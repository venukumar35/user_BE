
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions

export type PrismaPromise<T> = $Public.PrismaPromise<T>


export type RolesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Roles"
  objects: {
    user: UserPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    name: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
  }, ExtArgs["result"]["roles"]>
  composites: {}
}

/**
 * Model Roles
 * 
 */
export type Roles = runtime.Types.DefaultSelection<RolesPayload>
export type SyncDataLastIdPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "SyncDataLastId"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: number
    lastId: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
  }, ExtArgs["result"]["syncDataLastId"]>
  composites: {}
}

/**
 * Model SyncDataLastId
 * 
 */
export type SyncDataLastId = runtime.Types.DefaultSelection<SyncDataLastIdPayload>
export type ProductCategoryPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "ProductCategory"
  objects: {
    gender: GenderPayload<ExtArgs>
    productType: ProductTypePayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    name: string
    genderId: number
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
  }, ExtArgs["result"]["productCategory"]>
  composites: {}
}

/**
 * Model ProductCategory
 * 
 */
export type ProductCategory = runtime.Types.DefaultSelection<ProductCategoryPayload>
export type ProductTypePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "ProductType"
  objects: {
    ProductCategory: ProductCategoryPayload<ExtArgs>
    sizes: ProductTypeSizePayload<ExtArgs>[]
    product: ProductPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    itemsName: string
    productCategoryId: number
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
  }, ExtArgs["result"]["productType"]>
  composites: {}
}

/**
 * Model ProductType
 * 
 */
export type ProductType = runtime.Types.DefaultSelection<ProductTypePayload>
export type ProductTypeSizePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "ProductTypeSize"
  objects: {
    aviableSizes: ProductAviableSizesPayload<ExtArgs>[]
    productType: ProductTypePayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    size: string
    ietmsId: number
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
  }, ExtArgs["result"]["productTypeSize"]>
  composites: {}
}

/**
 * Model ProductTypeSize
 * 
 */
export type ProductTypeSize = runtime.Types.DefaultSelection<ProductTypeSizePayload>
export type GenderPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Gender"
  objects: {
    productCategory: ProductCategoryPayload<ExtArgs>[]
    user: UserPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    name: string
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
  }, ExtArgs["result"]["gender"]>
  composites: {}
}

/**
 * Model Gender
 * 
 */
export type Gender = runtime.Types.DefaultSelection<GenderPayload>
export type CountryPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Country"
  objects: {
    state: StatePayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    name: string
    timezoneOffset: number
    dialCode: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
  }, ExtArgs["result"]["country"]>
  composites: {}
}

/**
 * Model Country
 * 
 */
export type Country = runtime.Types.DefaultSelection<CountryPayload>
export type StatePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "State"
  objects: {
    country: CountryPayload<ExtArgs>
    district: AddressPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    name: string
    countryId: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
  }, ExtArgs["result"]["state"]>
  composites: {}
}

/**
 * Model State
 * 
 */
export type State = runtime.Types.DefaultSelection<StatePayload>
export type AddressPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Address"
  objects: {
    state: StatePayload<ExtArgs>
    userAddress: UserAddressPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    doorNumber: string
    streetName: string
    pinCode: string
    stateId: number
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
  }, ExtArgs["result"]["address"]>
  composites: {}
}

/**
 * Model Address
 * 
 */
export type Address = runtime.Types.DefaultSelection<AddressPayload>
export type UserAddressPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "UserAddress"
  objects: {
    address: AddressPayload<ExtArgs>
    user: UserPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    addressId: number
    userId: number
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
  }, ExtArgs["result"]["userAddress"]>
  composites: {}
}

/**
 * Model UserAddress
 * 
 */
export type UserAddress = runtime.Types.DefaultSelection<UserAddressPayload>
export type UserPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "User"
  objects: {
    userProduct: ProductPayload<ExtArgs>[]
    userAddress: UserAddressPayload<ExtArgs>[]
    addCart: CartPayload<ExtArgs>[]
    wishlist: WishlistPayload<ExtArgs>[]
    loginRequests: UserLoginRequestPayload<ExtArgs>[]
    ProductReview: ProductReviewPayload<ExtArgs>[]
    order: OrderPayload<ExtArgs>[]
    userSearchItems: SearchItemsPayload<ExtArgs>[]
    password: UserPasswordPayload<ExtArgs>[]
    roles: RolesPayload<ExtArgs>
    gender: GenderPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    username: string
    email: string
    mobile: string
    token: string | null
    roleId: number
    genderId: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
  }, ExtArgs["result"]["user"]>
  composites: {}
}

/**
 * Model User
 * 
 */
export type User = runtime.Types.DefaultSelection<UserPayload>
export type ProductOwnerPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "ProductOwner"
  objects: {
    product: ProductPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    syncUserId: number
    ownerName: string
    ownerEmail: string
    ownerMobile: string
    storeName: string
    storeAddress: string
    storeCity: string
    storePincode: string
    storeState: string
    customerCareEmail: string
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
  }, ExtArgs["result"]["productOwner"]>
  composites: {}
}

/**
 * Model ProductOwner
 * 
 */
export type ProductOwner = runtime.Types.DefaultSelection<ProductOwnerPayload>
export type UserPasswordPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "UserPassword"
  objects: {
    user: UserPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    password: string
    userId: number
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
  }, ExtArgs["result"]["userPassword"]>
  composites: {}
}

/**
 * Model UserPassword
 * 
 */
export type UserPassword = runtime.Types.DefaultSelection<UserPasswordPayload>
export type SearchItemsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "SearchItems"
  objects: {
    User: UserPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    searchName: string
    userId: number
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
  }, ExtArgs["result"]["searchItems"]>
  composites: {}
}

/**
 * Model SearchItems
 * 
 */
export type SearchItems = runtime.Types.DefaultSelection<SearchItemsPayload>
export type OrderPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Order"
  objects: {
    user: UserPayload<ExtArgs>
    product: ProductPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    userId: number
    productId: number
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
  }, ExtArgs["result"]["order"]>
  composites: {}
}

/**
 * Model Order
 * 
 */
export type Order = runtime.Types.DefaultSelection<OrderPayload>
export type UserLoginRequestPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "UserLoginRequest"
  objects: {
    user: UserPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    userId: number
    email: string
    mobile: string | null
    otp: string
    isUsed: boolean
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
  }, ExtArgs["result"]["userLoginRequest"]>
  composites: {}
}

/**
 * Model UserLoginRequest
 * 
 */
export type UserLoginRequest = runtime.Types.DefaultSelection<UserLoginRequestPayload>
export type ProductPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Product"
  objects: {
    color: ProductColorPayload<ExtArgs>[]
    offer: OfferPayload<ExtArgs>[]
    seasonalDresses: SeasonalDressesPayload<ExtArgs>[]
    productType: ProductTypePayload<ExtArgs>
    user: UserPayload<ExtArgs> | null
    priceHistory: PriceHistoryPayload<ExtArgs>[]
    commonDescription: CommonDescriptionPayload<ExtArgs>[]
    delivery: DeleveryPeriodPayload<ExtArgs>[]
    returns: ReturnedProductPayload<ExtArgs>[]
    cart: CartPayload<ExtArgs>[]
    wishlistItem: WishlistItemPayload<ExtArgs>[]
    productReviews: ProductReviewPayload<ExtArgs>[]
    order: OrderPayload<ExtArgs>[]
    productOwner: ProductOwnerPayload<ExtArgs> | null
  }
  scalars: $Extensions.GetResult<{
    id: number
    syncId: number
    title: string
    price: number
    productTypeId: number
    productOwnerId: number | null
    userId: number | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    isActive: boolean
  }, ExtArgs["result"]["product"]>
  composites: {}
}

/**
 * Model Product
 * 
 */
export type Product = runtime.Types.DefaultSelection<ProductPayload>
export type ProductReviewPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "ProductReview"
  objects: {
    product: ProductPayload<ExtArgs>
    user: UserPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    productId: number
    userId: number
    review: string
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
  }, ExtArgs["result"]["productReview"]>
  composites: {}
}

/**
 * Model ProductReview
 * 
 */
export type ProductReview = runtime.Types.DefaultSelection<ProductReviewPayload>
export type ReturnedProductPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "ReturnedProduct"
  objects: {
    product: ProductPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    productId: number
    returns: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
  }, ExtArgs["result"]["returnedProduct"]>
  composites: {}
}

/**
 * Model ReturnedProduct
 * 
 */
export type ReturnedProduct = runtime.Types.DefaultSelection<ReturnedProductPayload>
export type DeleveryPeriodPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "DeleveryPeriod"
  objects: {
    product: ProductPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    productId: number
    deliveryForMetroCitys: number
    deliveryForOtherCitys: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
  }, ExtArgs["result"]["deleveryPeriod"]>
  composites: {}
}

/**
 * Model DeleveryPeriod
 * 
 */
export type DeleveryPeriod = runtime.Types.DefaultSelection<DeleveryPeriodPayload>
export type ProductColorPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "ProductColor"
  objects: {
    product: ProductPayload<ExtArgs>
    colorSize: ProductAviableSizesPayload<ExtArgs>[]
    productImages: ProductImagesPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    productId: number
    colors: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
  }, ExtArgs["result"]["productColor"]>
  composites: {}
}

/**
 * Model ProductColor
 * 
 */
export type ProductColor = runtime.Types.DefaultSelection<ProductColorPayload>
export type PriceHistoryPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "PriceHistory"
  objects: {
    Product: ProductPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    price: number
    productId: number
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
  }, ExtArgs["result"]["priceHistory"]>
  composites: {}
}

/**
 * Model PriceHistory
 * 
 */
export type PriceHistory = runtime.Types.DefaultSelection<PriceHistoryPayload>
export type ProductAviableSizesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "ProductAviableSizes"
  objects: {
    history: QuantityHistoryPayload<ExtArgs>[]
    productColor: ProductColorPayload<ExtArgs>
    productTypeSize: ProductTypeSizePayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    quantity: number
    productColorId: number
    productTypeSizeId: number
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
  }, ExtArgs["result"]["productAviableSizes"]>
  composites: {}
}

/**
 * Model ProductAviableSizes
 * 
 */
export type ProductAviableSizes = runtime.Types.DefaultSelection<ProductAviableSizesPayload>
export type SeasonalDressesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "SeasonalDresses"
  objects: {
    product: ProductPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    seasonal: string
    productId: number
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
  }, ExtArgs["result"]["seasonalDresses"]>
  composites: {}
}

/**
 * Model SeasonalDresses
 * 
 */
export type SeasonalDresses = runtime.Types.DefaultSelection<SeasonalDressesPayload>
export type ProductImagesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "ProductImages"
  objects: {
    productColor: ProductColorPayload<ExtArgs> | null
  }
  scalars: $Extensions.GetResult<{
    id: number
    imageUrl: string
    productColorId: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
  }, ExtArgs["result"]["productImages"]>
  composites: {}
}

/**
 * Model ProductImages
 * 
 */
export type ProductImages = runtime.Types.DefaultSelection<ProductImagesPayload>
export type CommonDescriptionPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "CommonDescription"
  objects: {
    product: ProductPayload<ExtArgs>
    topDescription: TopDescriptionPayload<ExtArgs>[]
    pantDescription: BottomDescriptionPayload<ExtArgs>[]
    kurtasDescription: KurtasDescriptionPayload<ExtArgs>[]
    shoesDescription: ShoesDescriptionPayload<ExtArgs>[]
    innerDescription: InnersDescriptionPayload<ExtArgs>[]
    watchesDescription: WatchesDescriptionPayload<ExtArgs>[]
    perfumesDescription: PerfumesDescriptionPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    fit: string | null
    materail: string
    care: string
    brandName: string
    origin: string
    productId: number
    occasion: string
    specialFeature: string | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
  }, ExtArgs["result"]["commonDescription"]>
  composites: {}
}

/**
 * Model CommonDescription
 * 
 */
export type CommonDescription = runtime.Types.DefaultSelection<CommonDescriptionPayload>
export type TopDescriptionPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "TopDescription"
  objects: {
    commonDescription: CommonDescriptionPayload<ExtArgs> | null
    sleeveType: SleeveTypePayload<ExtArgs>
    neckType: NeckTypePayload<ExtArgs>
    bottomDescription: BottomDescriptionPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    productDescription: string | null
    sleeveTypeId: number
    weight: number | null
    chest: number
    shoulder: number
    neckTypeId: number
    type: string | null
    colorFamily: string | null
    printAndPattern: string | null
    length: number
    pocket: string
    commonDescriptionId: number
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
  }, ExtArgs["result"]["topDescription"]>
  composites: {}
}

/**
 * Model TopDescription
 * 
 */
export type TopDescription = runtime.Types.DefaultSelection<TopDescriptionPayload>
export type BottomDescriptionPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "BottomDescription"
  objects: {
    typesOfPants: TypesOfBottomPayload<ExtArgs>
    typesOfPleats: TypesOfPleatsPayload<ExtArgs>
    typesOfLength: TypesOfLengthBottomPayload<ExtArgs>
    commonDescription: CommonDescriptionPayload<ExtArgs>
    kurtasDescription: KurtasDescriptionPayload<ExtArgs> | null
    topDescription: TopDescriptionPayload<ExtArgs> | null
  }
  scalars: $Extensions.GetResult<{
    id: number
    productDescription: string | null
    weight: number | null
    printAndPattern: string
    length: number
    waist: number
    hip: number
    commonDescriptionId: number
    type: string | null
    colorFamily: string | null
    pocket: string | null
    kurtasDescriptionId: number | null
    topDescriptionId: number | null
    beltLoop: boolean
    typeOfPantId: number
    typesOfPleatsId: number
    typesOfLengthId: number
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
  }, ExtArgs["result"]["bottomDescription"]>
  composites: {}
}

/**
 * Model BottomDescription
 * 
 */
export type BottomDescription = runtime.Types.DefaultSelection<BottomDescriptionPayload>
export type KurtasDescriptionPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "KurtasDescription"
  objects: {
    kurtasLengthType: KurtasLengthTypePayload<ExtArgs>
    neckType: NeckTypePayload<ExtArgs>
    sleeveType: SleeveTypePayload<ExtArgs>
    commonDescription: CommonDescriptionPayload<ExtArgs>
    bottomDescription: BottomDescriptionPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    work: string | null
    productDescription: string
    chest: number
    shoulder: number
    transparencyOfTheFabric: boolean
    kurtasLengthTypeId: number
    weight: number | null
    colorFamily: string | null
    pocket: string
    type: string
    printAndpattern: string | null
    kurtasNeckTypeId: number
    kurtasSleeveTypeId: number
    commonDescriptionId: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
  }, ExtArgs["result"]["kurtasDescription"]>
  composites: {}
}

/**
 * Model KurtasDescription
 * 
 */
export type KurtasDescription = runtime.Types.DefaultSelection<KurtasDescriptionPayload>
export type ShoesDescriptionPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "ShoesDescription"
  objects: {
    warranty: WarrantyPayload<ExtArgs>[]
    commonDescription: CommonDescriptionPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    pattern: string | null
    footLength: string
    type: string
    soleMaterial: string | null
    printAndPattern: string | null
    upperMaterial: string | null
    closure: string | null
    toeType: string
    weight: number | null
    colorFamily: string | null
    productDescription: string | null
    packageContains: number | null
    commonDescriptionId: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
  }, ExtArgs["result"]["shoesDescription"]>
  composites: {}
}

/**
 * Model ShoesDescription
 * 
 */
export type ShoesDescription = runtime.Types.DefaultSelection<ShoesDescriptionPayload>
export type WatchesDescriptionPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "WatchesDescription"
  objects: {
    warranty: WarrantyPayload<ExtArgs>[]
    commonDescription: CommonDescriptionPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    type: string | null
    weight: number
    model: string
    dialShape: string
    printAndPattern: string | null
    dialDiameter: string
    dialColor: string
    strapColor: string
    colorFamily: string | null
    productDescription: string | null
    commonDescriptionId: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
  }, ExtArgs["result"]["watchesDescription"]>
  composites: {}
}

/**
 * Model WatchesDescription
 * 
 */
export type WatchesDescription = runtime.Types.DefaultSelection<WatchesDescriptionPayload>
export type PerfumesDescriptionPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "PerfumesDescription"
  objects: {
    commonDescription: CommonDescriptionPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    productDescription: string
    type: string | null
    materialDescription: string
    weight: number
    commonDescriptionId: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
  }, ExtArgs["result"]["perfumesDescription"]>
  composites: {}
}

/**
 * Model PerfumesDescription
 * 
 */
export type PerfumesDescription = runtime.Types.DefaultSelection<PerfumesDescriptionPayload>
export type InnersDescriptionPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "InnersDescription"
  objects: {
    sleeveType: SleeveTypePayload<ExtArgs> | null
    neckType: NeckTypePayload<ExtArgs> | null
    commonDescription: CommonDescriptionPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    type: string
    productDescription: string
    weight: number | null
    length: number
    waistRise: number
    printAndPattern: string | null
    packageContains: number
    lookAndFeel: string
    colorFamily: string | null
    vestsSleeveTypeId: number | null
    vestsNeckTypeId: number | null
    commonDescriptionId: number
    multiColors: boolean
  }, ExtArgs["result"]["innersDescription"]>
  composites: {}
}

/**
 * Model InnersDescription
 * 
 */
export type InnersDescription = runtime.Types.DefaultSelection<InnersDescriptionPayload>
export type WarrantyPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Warranty"
  objects: {
    shoesDescription: ShoesDescriptionPayload<ExtArgs> | null
    watches: WatchesDescriptionPayload<ExtArgs> | null
  }
  scalars: $Extensions.GetResult<{
    id: number
    shoesDescriptionId: number | null
    watchsId: number | null
    warrantyPeriod: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
  }, ExtArgs["result"]["warranty"]>
  composites: {}
}

/**
 * Model Warranty
 * 
 */
export type Warranty = runtime.Types.DefaultSelection<WarrantyPayload>
export type SleeveTypePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "SleeveType"
  objects: {
    kurtasDescription: KurtasDescriptionPayload<ExtArgs>[]
    innersDescription: InnersDescriptionPayload<ExtArgs>[]
    topDescription: TopDescriptionPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    name: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
  }, ExtArgs["result"]["sleeveType"]>
  composites: {}
}

/**
 * Model SleeveType
 * 
 */
export type SleeveType = runtime.Types.DefaultSelection<SleeveTypePayload>
export type NeckTypePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "NeckType"
  objects: {
    kurtasDescription: KurtasDescriptionPayload<ExtArgs>[]
    innersDescription: InnersDescriptionPayload<ExtArgs>[]
    topDescription: TopDescriptionPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    name: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
  }, ExtArgs["result"]["neckType"]>
  composites: {}
}

/**
 * Model NeckType
 * 
 */
export type NeckType = runtime.Types.DefaultSelection<NeckTypePayload>
export type KurtasLengthTypePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "KurtasLengthType"
  objects: {
    kurtasDescription: KurtasDescriptionPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    name: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
  }, ExtArgs["result"]["kurtasLengthType"]>
  composites: {}
}

/**
 * Model KurtasLengthType
 * 
 */
export type KurtasLengthType = runtime.Types.DefaultSelection<KurtasLengthTypePayload>
export type TypesOfBottomPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "TypesOfBottom"
  objects: {
    description: BottomDescriptionPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    name: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
  }, ExtArgs["result"]["typesOfBottom"]>
  composites: {}
}

/**
 * Model TypesOfBottom
 * 
 */
export type TypesOfBottom = runtime.Types.DefaultSelection<TypesOfBottomPayload>
export type TypesOfPleatsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "TypesOfPleats"
  objects: {
    description: BottomDescriptionPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    name: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
  }, ExtArgs["result"]["typesOfPleats"]>
  composites: {}
}

/**
 * Model TypesOfPleats
 * 
 */
export type TypesOfPleats = runtime.Types.DefaultSelection<TypesOfPleatsPayload>
export type TypesOfLengthBottomPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "TypesOfLengthBottom"
  objects: {
    description: BottomDescriptionPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    name: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
  }, ExtArgs["result"]["typesOfLengthBottom"]>
  composites: {}
}

/**
 * Model TypesOfLengthBottom
 * 
 */
export type TypesOfLengthBottom = runtime.Types.DefaultSelection<TypesOfLengthBottomPayload>
export type QuantityHistoryPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "QuantityHistory"
  objects: {
    productAviableSizes: ProductAviableSizesPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    quantity: number
    productAviableSizesId: number
    timestamp: Date
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
  }, ExtArgs["result"]["quantityHistory"]>
  composites: {}
}

/**
 * Model QuantityHistory
 * 
 */
export type QuantityHistory = runtime.Types.DefaultSelection<QuantityHistoryPayload>
export type OfferPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Offer"
  objects: {
    product: ProductPayload<ExtArgs>
    offerValidity: OfferValidityPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    productId: number
    offerPercntage: number
    offerPrice: number
    currentPrice: number
    offerQuantity: number
    currentQuantity: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
  }, ExtArgs["result"]["offer"]>
  composites: {}
}

/**
 * Model Offer
 * 
 */
export type Offer = runtime.Types.DefaultSelection<OfferPayload>
export type OfferValidityPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "OfferValidity"
  objects: {
    offer: OfferPayload<ExtArgs> | null
    offerPromotionPeriod: OfferPromotionPeriodsPayload<ExtArgs> | null
  }
  scalars: $Extensions.GetResult<{
    id: number
    fromDate: Date
    toDate: Date
    fromTime: Date
    toTime: Date
    monday: boolean
    tuesday: boolean
    wednesday: boolean
    thursday: boolean
    friday: boolean
    saturday: boolean
    sunday: boolean
    offerId: number
    offerPromotionPeriodId: number | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
  }, ExtArgs["result"]["offerValidity"]>
  composites: {}
}

/**
 * Model OfferValidity
 * 
 */
export type OfferValidity = runtime.Types.DefaultSelection<OfferValidityPayload>
export type OfferPromotionPeriodsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "OfferPromotionPeriods"
  objects: {
    offerValidity: OfferValidityPayload<ExtArgs> | null
  }
  scalars: $Extensions.GetResult<{
    id: number
    name: string
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
  }, ExtArgs["result"]["offerPromotionPeriods"]>
  composites: {}
}

/**
 * Model OfferPromotionPeriods
 * 
 */
export type OfferPromotionPeriods = runtime.Types.DefaultSelection<OfferPromotionPeriodsPayload>
export type CartPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Cart"
  objects: {
    user: UserPayload<ExtArgs>
    product: ProductPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    userId: number
    productId: number
    isCheckedOut: boolean
    isRemoved: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
  }, ExtArgs["result"]["cart"]>
  composites: {}
}

/**
 * Model Cart
 * 
 */
export type Cart = runtime.Types.DefaultSelection<CartPayload>
export type WishlistPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Wishlist"
  objects: {
    items: WishlistItemPayload<ExtArgs>[]
    user: UserPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    userId: number
  }, ExtArgs["result"]["wishlist"]>
  composites: {}
}

/**
 * Model Wishlist
 * 
 */
export type Wishlist = runtime.Types.DefaultSelection<WishlistPayload>
export type WishlistItemPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "WishlistItem"
  objects: {
    wishlist: WishlistPayload<ExtArgs>
    product: ProductPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    wishlistId: number
    productId: number
  }, ExtArgs["result"]["wishlistItem"]>
  composites: {}
}

/**
 * Model WishlistItem
 * 
 */
export type WishlistItem = runtime.Types.DefaultSelection<WishlistItemPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Roles
 * const roles = await prisma.roles.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false,
  ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Roles
   * const roles = await prisma.roles.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.roles`: Exposes CRUD operations for the **Roles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.roles.findMany()
    * ```
    */
  get roles(): Prisma.RolesDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.syncDataLastId`: Exposes CRUD operations for the **SyncDataLastId** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SyncDataLastIds
    * const syncDataLastIds = await prisma.syncDataLastId.findMany()
    * ```
    */
  get syncDataLastId(): Prisma.SyncDataLastIdDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.productCategory`: Exposes CRUD operations for the **ProductCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductCategories
    * const productCategories = await prisma.productCategory.findMany()
    * ```
    */
  get productCategory(): Prisma.ProductCategoryDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.productType`: Exposes CRUD operations for the **ProductType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductTypes
    * const productTypes = await prisma.productType.findMany()
    * ```
    */
  get productType(): Prisma.ProductTypeDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.productTypeSize`: Exposes CRUD operations for the **ProductTypeSize** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductTypeSizes
    * const productTypeSizes = await prisma.productTypeSize.findMany()
    * ```
    */
  get productTypeSize(): Prisma.ProductTypeSizeDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.gender`: Exposes CRUD operations for the **Gender** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Genders
    * const genders = await prisma.gender.findMany()
    * ```
    */
  get gender(): Prisma.GenderDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.country`: Exposes CRUD operations for the **Country** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Countries
    * const countries = await prisma.country.findMany()
    * ```
    */
  get country(): Prisma.CountryDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.state`: Exposes CRUD operations for the **State** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more States
    * const states = await prisma.state.findMany()
    * ```
    */
  get state(): Prisma.StateDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.address`: Exposes CRUD operations for the **Address** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Addresses
    * const addresses = await prisma.address.findMany()
    * ```
    */
  get address(): Prisma.AddressDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.userAddress`: Exposes CRUD operations for the **UserAddress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserAddresses
    * const userAddresses = await prisma.userAddress.findMany()
    * ```
    */
  get userAddress(): Prisma.UserAddressDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.productOwner`: Exposes CRUD operations for the **ProductOwner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductOwners
    * const productOwners = await prisma.productOwner.findMany()
    * ```
    */
  get productOwner(): Prisma.ProductOwnerDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.userPassword`: Exposes CRUD operations for the **UserPassword** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserPasswords
    * const userPasswords = await prisma.userPassword.findMany()
    * ```
    */
  get userPassword(): Prisma.UserPasswordDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.searchItems`: Exposes CRUD operations for the **SearchItems** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SearchItems
    * const searchItems = await prisma.searchItems.findMany()
    * ```
    */
  get searchItems(): Prisma.SearchItemsDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.userLoginRequest`: Exposes CRUD operations for the **UserLoginRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserLoginRequests
    * const userLoginRequests = await prisma.userLoginRequest.findMany()
    * ```
    */
  get userLoginRequest(): Prisma.UserLoginRequestDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.productReview`: Exposes CRUD operations for the **ProductReview** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductReviews
    * const productReviews = await prisma.productReview.findMany()
    * ```
    */
  get productReview(): Prisma.ProductReviewDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.returnedProduct`: Exposes CRUD operations for the **ReturnedProduct** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReturnedProducts
    * const returnedProducts = await prisma.returnedProduct.findMany()
    * ```
    */
  get returnedProduct(): Prisma.ReturnedProductDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.deleveryPeriod`: Exposes CRUD operations for the **DeleveryPeriod** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeleveryPeriods
    * const deleveryPeriods = await prisma.deleveryPeriod.findMany()
    * ```
    */
  get deleveryPeriod(): Prisma.DeleveryPeriodDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.productColor`: Exposes CRUD operations for the **ProductColor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductColors
    * const productColors = await prisma.productColor.findMany()
    * ```
    */
  get productColor(): Prisma.ProductColorDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.priceHistory`: Exposes CRUD operations for the **PriceHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PriceHistories
    * const priceHistories = await prisma.priceHistory.findMany()
    * ```
    */
  get priceHistory(): Prisma.PriceHistoryDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.productAviableSizes`: Exposes CRUD operations for the **ProductAviableSizes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductAviableSizes
    * const productAviableSizes = await prisma.productAviableSizes.findMany()
    * ```
    */
  get productAviableSizes(): Prisma.ProductAviableSizesDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.seasonalDresses`: Exposes CRUD operations for the **SeasonalDresses** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SeasonalDresses
    * const seasonalDresses = await prisma.seasonalDresses.findMany()
    * ```
    */
  get seasonalDresses(): Prisma.SeasonalDressesDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.productImages`: Exposes CRUD operations for the **ProductImages** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductImages
    * const productImages = await prisma.productImages.findMany()
    * ```
    */
  get productImages(): Prisma.ProductImagesDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.commonDescription`: Exposes CRUD operations for the **CommonDescription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommonDescriptions
    * const commonDescriptions = await prisma.commonDescription.findMany()
    * ```
    */
  get commonDescription(): Prisma.CommonDescriptionDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.topDescription`: Exposes CRUD operations for the **TopDescription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TopDescriptions
    * const topDescriptions = await prisma.topDescription.findMany()
    * ```
    */
  get topDescription(): Prisma.TopDescriptionDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.bottomDescription`: Exposes CRUD operations for the **BottomDescription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BottomDescriptions
    * const bottomDescriptions = await prisma.bottomDescription.findMany()
    * ```
    */
  get bottomDescription(): Prisma.BottomDescriptionDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.kurtasDescription`: Exposes CRUD operations for the **KurtasDescription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KurtasDescriptions
    * const kurtasDescriptions = await prisma.kurtasDescription.findMany()
    * ```
    */
  get kurtasDescription(): Prisma.KurtasDescriptionDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.shoesDescription`: Exposes CRUD operations for the **ShoesDescription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShoesDescriptions
    * const shoesDescriptions = await prisma.shoesDescription.findMany()
    * ```
    */
  get shoesDescription(): Prisma.ShoesDescriptionDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.watchesDescription`: Exposes CRUD operations for the **WatchesDescription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WatchesDescriptions
    * const watchesDescriptions = await prisma.watchesDescription.findMany()
    * ```
    */
  get watchesDescription(): Prisma.WatchesDescriptionDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.perfumesDescription`: Exposes CRUD operations for the **PerfumesDescription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PerfumesDescriptions
    * const perfumesDescriptions = await prisma.perfumesDescription.findMany()
    * ```
    */
  get perfumesDescription(): Prisma.PerfumesDescriptionDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.innersDescription`: Exposes CRUD operations for the **InnersDescription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InnersDescriptions
    * const innersDescriptions = await prisma.innersDescription.findMany()
    * ```
    */
  get innersDescription(): Prisma.InnersDescriptionDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.warranty`: Exposes CRUD operations for the **Warranty** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Warranties
    * const warranties = await prisma.warranty.findMany()
    * ```
    */
  get warranty(): Prisma.WarrantyDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.sleeveType`: Exposes CRUD operations for the **SleeveType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SleeveTypes
    * const sleeveTypes = await prisma.sleeveType.findMany()
    * ```
    */
  get sleeveType(): Prisma.SleeveTypeDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.neckType`: Exposes CRUD operations for the **NeckType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NeckTypes
    * const neckTypes = await prisma.neckType.findMany()
    * ```
    */
  get neckType(): Prisma.NeckTypeDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.kurtasLengthType`: Exposes CRUD operations for the **KurtasLengthType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KurtasLengthTypes
    * const kurtasLengthTypes = await prisma.kurtasLengthType.findMany()
    * ```
    */
  get kurtasLengthType(): Prisma.KurtasLengthTypeDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.typesOfBottom`: Exposes CRUD operations for the **TypesOfBottom** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TypesOfBottoms
    * const typesOfBottoms = await prisma.typesOfBottom.findMany()
    * ```
    */
  get typesOfBottom(): Prisma.TypesOfBottomDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.typesOfPleats`: Exposes CRUD operations for the **TypesOfPleats** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TypesOfPleats
    * const typesOfPleats = await prisma.typesOfPleats.findMany()
    * ```
    */
  get typesOfPleats(): Prisma.TypesOfPleatsDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.typesOfLengthBottom`: Exposes CRUD operations for the **TypesOfLengthBottom** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TypesOfLengthBottoms
    * const typesOfLengthBottoms = await prisma.typesOfLengthBottom.findMany()
    * ```
    */
  get typesOfLengthBottom(): Prisma.TypesOfLengthBottomDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.quantityHistory`: Exposes CRUD operations for the **QuantityHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuantityHistories
    * const quantityHistories = await prisma.quantityHistory.findMany()
    * ```
    */
  get quantityHistory(): Prisma.QuantityHistoryDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.offer`: Exposes CRUD operations for the **Offer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Offers
    * const offers = await prisma.offer.findMany()
    * ```
    */
  get offer(): Prisma.OfferDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.offerValidity`: Exposes CRUD operations for the **OfferValidity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OfferValidities
    * const offerValidities = await prisma.offerValidity.findMany()
    * ```
    */
  get offerValidity(): Prisma.OfferValidityDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.offerPromotionPeriods`: Exposes CRUD operations for the **OfferPromotionPeriods** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OfferPromotionPeriods
    * const offerPromotionPeriods = await prisma.offerPromotionPeriods.findMany()
    * ```
    */
  get offerPromotionPeriods(): Prisma.OfferPromotionPeriodsDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.cart`: Exposes CRUD operations for the **Cart** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Carts
    * const carts = await prisma.cart.findMany()
    * ```
    */
  get cart(): Prisma.CartDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.wishlist`: Exposes CRUD operations for the **Wishlist** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Wishlists
    * const wishlists = await prisma.wishlist.findMany()
    * ```
    */
  get wishlist(): Prisma.WishlistDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.wishlistItem`: Exposes CRUD operations for the **WishlistItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WishlistItems
    * const wishlistItems = await prisma.wishlistItem.findMany()
    * ```
    */
  get wishlistItem(): Prisma.WishlistItemDelegate<GlobalReject, ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export type Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export type Args<T, F extends $Public.Operation> = $Public.Args<T, F>
  export type Payload<T, F extends $Public.Operation> = $Public.Payload<T, F>
  export type Result<T, A, F extends $Public.Operation> = $Public.Result<T, A, F>
  export type Exact<T, W> = $Public.Exact<T, W>

  /**
   * Prisma Client JS version: 4.16.2
   * Query Engine version: 4bc8b6e1b66cb932731fb1bdbbc550d1e010de81
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Roles: 'Roles',
    SyncDataLastId: 'SyncDataLastId',
    ProductCategory: 'ProductCategory',
    ProductType: 'ProductType',
    ProductTypeSize: 'ProductTypeSize',
    Gender: 'Gender',
    Country: 'Country',
    State: 'State',
    Address: 'Address',
    UserAddress: 'UserAddress',
    User: 'User',
    ProductOwner: 'ProductOwner',
    UserPassword: 'UserPassword',
    SearchItems: 'SearchItems',
    Order: 'Order',
    UserLoginRequest: 'UserLoginRequest',
    Product: 'Product',
    ProductReview: 'ProductReview',
    ReturnedProduct: 'ReturnedProduct',
    DeleveryPeriod: 'DeleveryPeriod',
    ProductColor: 'ProductColor',
    PriceHistory: 'PriceHistory',
    ProductAviableSizes: 'ProductAviableSizes',
    SeasonalDresses: 'SeasonalDresses',
    ProductImages: 'ProductImages',
    CommonDescription: 'CommonDescription',
    TopDescription: 'TopDescription',
    BottomDescription: 'BottomDescription',
    KurtasDescription: 'KurtasDescription',
    ShoesDescription: 'ShoesDescription',
    WatchesDescription: 'WatchesDescription',
    PerfumesDescription: 'PerfumesDescription',
    InnersDescription: 'InnersDescription',
    Warranty: 'Warranty',
    SleeveType: 'SleeveType',
    NeckType: 'NeckType',
    KurtasLengthType: 'KurtasLengthType',
    TypesOfBottom: 'TypesOfBottom',
    TypesOfPleats: 'TypesOfPleats',
    TypesOfLengthBottom: 'TypesOfLengthBottom',
    QuantityHistory: 'QuantityHistory',
    Offer: 'Offer',
    OfferValidity: 'OfferValidity',
    OfferPromotionPeriods: 'OfferPromotionPeriods',
    Cart: 'Cart',
    Wishlist: 'Wishlist',
    WishlistItem: 'WishlistItem'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.Args}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'roles' | 'syncDataLastId' | 'productCategory' | 'productType' | 'productTypeSize' | 'gender' | 'country' | 'state' | 'address' | 'userAddress' | 'user' | 'productOwner' | 'userPassword' | 'searchItems' | 'order' | 'userLoginRequest' | 'product' | 'productReview' | 'returnedProduct' | 'deleveryPeriod' | 'productColor' | 'priceHistory' | 'productAviableSizes' | 'seasonalDresses' | 'productImages' | 'commonDescription' | 'topDescription' | 'bottomDescription' | 'kurtasDescription' | 'shoesDescription' | 'watchesDescription' | 'perfumesDescription' | 'innersDescription' | 'warranty' | 'sleeveType' | 'neckType' | 'kurtasLengthType' | 'typesOfBottom' | 'typesOfPleats' | 'typesOfLengthBottom' | 'quantityHistory' | 'offer' | 'offerValidity' | 'offerPromotionPeriods' | 'cart' | 'wishlist' | 'wishlistItem'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      Roles: {
        payload: RolesPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.RolesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RolesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RolesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RolesPayload>
          }
          findFirst: {
            args: Prisma.RolesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RolesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RolesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RolesPayload>
          }
          findMany: {
            args: Prisma.RolesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RolesPayload>[]
          }
          create: {
            args: Prisma.RolesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RolesPayload>
          }
          createMany: {
            args: Prisma.RolesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RolesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RolesPayload>
          }
          update: {
            args: Prisma.RolesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RolesPayload>
          }
          deleteMany: {
            args: Prisma.RolesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RolesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RolesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<RolesPayload>
          }
          aggregate: {
            args: Prisma.RolesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRoles>
          }
          groupBy: {
            args: Prisma.RolesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RolesGroupByOutputType>[]
          }
          count: {
            args: Prisma.RolesCountArgs<ExtArgs>,
            result: $Utils.Optional<RolesCountAggregateOutputType> | number
          }
        }
      }
      SyncDataLastId: {
        payload: SyncDataLastIdPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.SyncDataLastIdFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SyncDataLastIdPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SyncDataLastIdFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SyncDataLastIdPayload>
          }
          findFirst: {
            args: Prisma.SyncDataLastIdFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SyncDataLastIdPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SyncDataLastIdFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SyncDataLastIdPayload>
          }
          findMany: {
            args: Prisma.SyncDataLastIdFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SyncDataLastIdPayload>[]
          }
          create: {
            args: Prisma.SyncDataLastIdCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SyncDataLastIdPayload>
          }
          createMany: {
            args: Prisma.SyncDataLastIdCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SyncDataLastIdDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SyncDataLastIdPayload>
          }
          update: {
            args: Prisma.SyncDataLastIdUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SyncDataLastIdPayload>
          }
          deleteMany: {
            args: Prisma.SyncDataLastIdDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SyncDataLastIdUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SyncDataLastIdUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SyncDataLastIdPayload>
          }
          aggregate: {
            args: Prisma.SyncDataLastIdAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSyncDataLastId>
          }
          groupBy: {
            args: Prisma.SyncDataLastIdGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SyncDataLastIdGroupByOutputType>[]
          }
          count: {
            args: Prisma.SyncDataLastIdCountArgs<ExtArgs>,
            result: $Utils.Optional<SyncDataLastIdCountAggregateOutputType> | number
          }
        }
      }
      ProductCategory: {
        payload: ProductCategoryPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.ProductCategoryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductCategoryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductCategoryPayload>
          }
          findFirst: {
            args: Prisma.ProductCategoryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductCategoryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductCategoryPayload>
          }
          findMany: {
            args: Prisma.ProductCategoryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductCategoryPayload>[]
          }
          create: {
            args: Prisma.ProductCategoryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductCategoryPayload>
          }
          createMany: {
            args: Prisma.ProductCategoryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ProductCategoryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductCategoryPayload>
          }
          update: {
            args: Prisma.ProductCategoryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductCategoryPayload>
          }
          deleteMany: {
            args: Prisma.ProductCategoryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ProductCategoryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ProductCategoryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductCategoryPayload>
          }
          aggregate: {
            args: Prisma.ProductCategoryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProductCategory>
          }
          groupBy: {
            args: Prisma.ProductCategoryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProductCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCategoryCountArgs<ExtArgs>,
            result: $Utils.Optional<ProductCategoryCountAggregateOutputType> | number
          }
        }
      }
      ProductType: {
        payload: ProductTypePayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.ProductTypeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductTypeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductTypePayload>
          }
          findFirst: {
            args: Prisma.ProductTypeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductTypeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductTypePayload>
          }
          findMany: {
            args: Prisma.ProductTypeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductTypePayload>[]
          }
          create: {
            args: Prisma.ProductTypeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductTypePayload>
          }
          createMany: {
            args: Prisma.ProductTypeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ProductTypeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductTypePayload>
          }
          update: {
            args: Prisma.ProductTypeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductTypePayload>
          }
          deleteMany: {
            args: Prisma.ProductTypeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ProductTypeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ProductTypeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductTypePayload>
          }
          aggregate: {
            args: Prisma.ProductTypeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProductType>
          }
          groupBy: {
            args: Prisma.ProductTypeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProductTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductTypeCountArgs<ExtArgs>,
            result: $Utils.Optional<ProductTypeCountAggregateOutputType> | number
          }
        }
      }
      ProductTypeSize: {
        payload: ProductTypeSizePayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.ProductTypeSizeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductTypeSizePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductTypeSizeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductTypeSizePayload>
          }
          findFirst: {
            args: Prisma.ProductTypeSizeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductTypeSizePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductTypeSizeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductTypeSizePayload>
          }
          findMany: {
            args: Prisma.ProductTypeSizeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductTypeSizePayload>[]
          }
          create: {
            args: Prisma.ProductTypeSizeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductTypeSizePayload>
          }
          createMany: {
            args: Prisma.ProductTypeSizeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ProductTypeSizeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductTypeSizePayload>
          }
          update: {
            args: Prisma.ProductTypeSizeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductTypeSizePayload>
          }
          deleteMany: {
            args: Prisma.ProductTypeSizeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ProductTypeSizeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ProductTypeSizeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductTypeSizePayload>
          }
          aggregate: {
            args: Prisma.ProductTypeSizeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProductTypeSize>
          }
          groupBy: {
            args: Prisma.ProductTypeSizeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProductTypeSizeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductTypeSizeCountArgs<ExtArgs>,
            result: $Utils.Optional<ProductTypeSizeCountAggregateOutputType> | number
          }
        }
      }
      Gender: {
        payload: GenderPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.GenderFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<GenderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GenderFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<GenderPayload>
          }
          findFirst: {
            args: Prisma.GenderFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<GenderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GenderFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<GenderPayload>
          }
          findMany: {
            args: Prisma.GenderFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<GenderPayload>[]
          }
          create: {
            args: Prisma.GenderCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<GenderPayload>
          }
          createMany: {
            args: Prisma.GenderCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.GenderDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<GenderPayload>
          }
          update: {
            args: Prisma.GenderUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<GenderPayload>
          }
          deleteMany: {
            args: Prisma.GenderDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.GenderUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.GenderUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<GenderPayload>
          }
          aggregate: {
            args: Prisma.GenderAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateGender>
          }
          groupBy: {
            args: Prisma.GenderGroupByArgs<ExtArgs>,
            result: $Utils.Optional<GenderGroupByOutputType>[]
          }
          count: {
            args: Prisma.GenderCountArgs<ExtArgs>,
            result: $Utils.Optional<GenderCountAggregateOutputType> | number
          }
        }
      }
      Country: {
        payload: CountryPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.CountryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CountryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CountryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CountryPayload>
          }
          findFirst: {
            args: Prisma.CountryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CountryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CountryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CountryPayload>
          }
          findMany: {
            args: Prisma.CountryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CountryPayload>[]
          }
          create: {
            args: Prisma.CountryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CountryPayload>
          }
          createMany: {
            args: Prisma.CountryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CountryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CountryPayload>
          }
          update: {
            args: Prisma.CountryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CountryPayload>
          }
          deleteMany: {
            args: Prisma.CountryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CountryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CountryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CountryPayload>
          }
          aggregate: {
            args: Prisma.CountryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCountry>
          }
          groupBy: {
            args: Prisma.CountryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CountryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CountryCountArgs<ExtArgs>,
            result: $Utils.Optional<CountryCountAggregateOutputType> | number
          }
        }
      }
      State: {
        payload: StatePayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.StateFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<StatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StateFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<StatePayload>
          }
          findFirst: {
            args: Prisma.StateFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<StatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StateFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<StatePayload>
          }
          findMany: {
            args: Prisma.StateFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<StatePayload>[]
          }
          create: {
            args: Prisma.StateCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<StatePayload>
          }
          createMany: {
            args: Prisma.StateCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.StateDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<StatePayload>
          }
          update: {
            args: Prisma.StateUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<StatePayload>
          }
          deleteMany: {
            args: Prisma.StateDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.StateUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.StateUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<StatePayload>
          }
          aggregate: {
            args: Prisma.StateAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateState>
          }
          groupBy: {
            args: Prisma.StateGroupByArgs<ExtArgs>,
            result: $Utils.Optional<StateGroupByOutputType>[]
          }
          count: {
            args: Prisma.StateCountArgs<ExtArgs>,
            result: $Utils.Optional<StateCountAggregateOutputType> | number
          }
        }
      }
      Address: {
        payload: AddressPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.AddressFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AddressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AddressFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AddressPayload>
          }
          findFirst: {
            args: Prisma.AddressFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AddressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AddressFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AddressPayload>
          }
          findMany: {
            args: Prisma.AddressFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AddressPayload>[]
          }
          create: {
            args: Prisma.AddressCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AddressPayload>
          }
          createMany: {
            args: Prisma.AddressCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AddressDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AddressPayload>
          }
          update: {
            args: Prisma.AddressUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AddressPayload>
          }
          deleteMany: {
            args: Prisma.AddressDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AddressUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AddressUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AddressPayload>
          }
          aggregate: {
            args: Prisma.AddressAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAddress>
          }
          groupBy: {
            args: Prisma.AddressGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AddressGroupByOutputType>[]
          }
          count: {
            args: Prisma.AddressCountArgs<ExtArgs>,
            result: $Utils.Optional<AddressCountAggregateOutputType> | number
          }
        }
      }
      UserAddress: {
        payload: UserAddressPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.UserAddressFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserAddressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserAddressFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserAddressPayload>
          }
          findFirst: {
            args: Prisma.UserAddressFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserAddressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserAddressFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserAddressPayload>
          }
          findMany: {
            args: Prisma.UserAddressFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserAddressPayload>[]
          }
          create: {
            args: Prisma.UserAddressCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserAddressPayload>
          }
          createMany: {
            args: Prisma.UserAddressCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserAddressDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserAddressPayload>
          }
          update: {
            args: Prisma.UserAddressUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserAddressPayload>
          }
          deleteMany: {
            args: Prisma.UserAddressDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserAddressUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserAddressUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserAddressPayload>
          }
          aggregate: {
            args: Prisma.UserAddressAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUserAddress>
          }
          groupBy: {
            args: Prisma.UserAddressGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserAddressGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserAddressCountArgs<ExtArgs>,
            result: $Utils.Optional<UserAddressCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: UserPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      ProductOwner: {
        payload: ProductOwnerPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.ProductOwnerFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductOwnerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductOwnerFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductOwnerPayload>
          }
          findFirst: {
            args: Prisma.ProductOwnerFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductOwnerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductOwnerFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductOwnerPayload>
          }
          findMany: {
            args: Prisma.ProductOwnerFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductOwnerPayload>[]
          }
          create: {
            args: Prisma.ProductOwnerCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductOwnerPayload>
          }
          createMany: {
            args: Prisma.ProductOwnerCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ProductOwnerDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductOwnerPayload>
          }
          update: {
            args: Prisma.ProductOwnerUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductOwnerPayload>
          }
          deleteMany: {
            args: Prisma.ProductOwnerDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ProductOwnerUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ProductOwnerUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductOwnerPayload>
          }
          aggregate: {
            args: Prisma.ProductOwnerAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProductOwner>
          }
          groupBy: {
            args: Prisma.ProductOwnerGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProductOwnerGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductOwnerCountArgs<ExtArgs>,
            result: $Utils.Optional<ProductOwnerCountAggregateOutputType> | number
          }
        }
      }
      UserPassword: {
        payload: UserPasswordPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.UserPasswordFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPasswordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserPasswordFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPasswordPayload>
          }
          findFirst: {
            args: Prisma.UserPasswordFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPasswordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserPasswordFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPasswordPayload>
          }
          findMany: {
            args: Prisma.UserPasswordFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPasswordPayload>[]
          }
          create: {
            args: Prisma.UserPasswordCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPasswordPayload>
          }
          createMany: {
            args: Prisma.UserPasswordCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserPasswordDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPasswordPayload>
          }
          update: {
            args: Prisma.UserPasswordUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPasswordPayload>
          }
          deleteMany: {
            args: Prisma.UserPasswordDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserPasswordUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserPasswordUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPasswordPayload>
          }
          aggregate: {
            args: Prisma.UserPasswordAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUserPassword>
          }
          groupBy: {
            args: Prisma.UserPasswordGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserPasswordGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserPasswordCountArgs<ExtArgs>,
            result: $Utils.Optional<UserPasswordCountAggregateOutputType> | number
          }
        }
      }
      SearchItems: {
        payload: SearchItemsPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.SearchItemsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SearchItemsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SearchItemsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SearchItemsPayload>
          }
          findFirst: {
            args: Prisma.SearchItemsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SearchItemsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SearchItemsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SearchItemsPayload>
          }
          findMany: {
            args: Prisma.SearchItemsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SearchItemsPayload>[]
          }
          create: {
            args: Prisma.SearchItemsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SearchItemsPayload>
          }
          createMany: {
            args: Prisma.SearchItemsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SearchItemsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SearchItemsPayload>
          }
          update: {
            args: Prisma.SearchItemsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SearchItemsPayload>
          }
          deleteMany: {
            args: Prisma.SearchItemsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SearchItemsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SearchItemsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SearchItemsPayload>
          }
          aggregate: {
            args: Prisma.SearchItemsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSearchItems>
          }
          groupBy: {
            args: Prisma.SearchItemsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SearchItemsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SearchItemsCountArgs<ExtArgs>,
            result: $Utils.Optional<SearchItemsCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: OrderPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>,
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      UserLoginRequest: {
        payload: UserLoginRequestPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.UserLoginRequestFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserLoginRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserLoginRequestFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserLoginRequestPayload>
          }
          findFirst: {
            args: Prisma.UserLoginRequestFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserLoginRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserLoginRequestFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserLoginRequestPayload>
          }
          findMany: {
            args: Prisma.UserLoginRequestFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserLoginRequestPayload>[]
          }
          create: {
            args: Prisma.UserLoginRequestCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserLoginRequestPayload>
          }
          createMany: {
            args: Prisma.UserLoginRequestCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserLoginRequestDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserLoginRequestPayload>
          }
          update: {
            args: Prisma.UserLoginRequestUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserLoginRequestPayload>
          }
          deleteMany: {
            args: Prisma.UserLoginRequestDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserLoginRequestUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserLoginRequestUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserLoginRequestPayload>
          }
          aggregate: {
            args: Prisma.UserLoginRequestAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUserLoginRequest>
          }
          groupBy: {
            args: Prisma.UserLoginRequestGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserLoginRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserLoginRequestCountArgs<ExtArgs>,
            result: $Utils.Optional<UserLoginRequestCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: ProductPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>,
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      ProductReview: {
        payload: ProductReviewPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.ProductReviewFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductReviewFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductReviewPayload>
          }
          findFirst: {
            args: Prisma.ProductReviewFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductReviewFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductReviewPayload>
          }
          findMany: {
            args: Prisma.ProductReviewFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductReviewPayload>[]
          }
          create: {
            args: Prisma.ProductReviewCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductReviewPayload>
          }
          createMany: {
            args: Prisma.ProductReviewCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ProductReviewDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductReviewPayload>
          }
          update: {
            args: Prisma.ProductReviewUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductReviewPayload>
          }
          deleteMany: {
            args: Prisma.ProductReviewDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ProductReviewUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ProductReviewUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductReviewPayload>
          }
          aggregate: {
            args: Prisma.ProductReviewAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProductReview>
          }
          groupBy: {
            args: Prisma.ProductReviewGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProductReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductReviewCountArgs<ExtArgs>,
            result: $Utils.Optional<ProductReviewCountAggregateOutputType> | number
          }
        }
      }
      ReturnedProduct: {
        payload: ReturnedProductPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.ReturnedProductFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ReturnedProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReturnedProductFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ReturnedProductPayload>
          }
          findFirst: {
            args: Prisma.ReturnedProductFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ReturnedProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReturnedProductFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ReturnedProductPayload>
          }
          findMany: {
            args: Prisma.ReturnedProductFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ReturnedProductPayload>[]
          }
          create: {
            args: Prisma.ReturnedProductCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ReturnedProductPayload>
          }
          createMany: {
            args: Prisma.ReturnedProductCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ReturnedProductDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ReturnedProductPayload>
          }
          update: {
            args: Prisma.ReturnedProductUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ReturnedProductPayload>
          }
          deleteMany: {
            args: Prisma.ReturnedProductDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ReturnedProductUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ReturnedProductUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ReturnedProductPayload>
          }
          aggregate: {
            args: Prisma.ReturnedProductAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateReturnedProduct>
          }
          groupBy: {
            args: Prisma.ReturnedProductGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ReturnedProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReturnedProductCountArgs<ExtArgs>,
            result: $Utils.Optional<ReturnedProductCountAggregateOutputType> | number
          }
        }
      }
      DeleveryPeriod: {
        payload: DeleveryPeriodPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.DeleveryPeriodFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DeleveryPeriodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeleveryPeriodFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DeleveryPeriodPayload>
          }
          findFirst: {
            args: Prisma.DeleveryPeriodFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DeleveryPeriodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeleveryPeriodFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DeleveryPeriodPayload>
          }
          findMany: {
            args: Prisma.DeleveryPeriodFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DeleveryPeriodPayload>[]
          }
          create: {
            args: Prisma.DeleveryPeriodCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DeleveryPeriodPayload>
          }
          createMany: {
            args: Prisma.DeleveryPeriodCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DeleveryPeriodDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DeleveryPeriodPayload>
          }
          update: {
            args: Prisma.DeleveryPeriodUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DeleveryPeriodPayload>
          }
          deleteMany: {
            args: Prisma.DeleveryPeriodDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DeleveryPeriodUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DeleveryPeriodUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DeleveryPeriodPayload>
          }
          aggregate: {
            args: Prisma.DeleveryPeriodAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDeleveryPeriod>
          }
          groupBy: {
            args: Prisma.DeleveryPeriodGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DeleveryPeriodGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeleveryPeriodCountArgs<ExtArgs>,
            result: $Utils.Optional<DeleveryPeriodCountAggregateOutputType> | number
          }
        }
      }
      ProductColor: {
        payload: ProductColorPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.ProductColorFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductColorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductColorFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductColorPayload>
          }
          findFirst: {
            args: Prisma.ProductColorFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductColorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductColorFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductColorPayload>
          }
          findMany: {
            args: Prisma.ProductColorFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductColorPayload>[]
          }
          create: {
            args: Prisma.ProductColorCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductColorPayload>
          }
          createMany: {
            args: Prisma.ProductColorCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ProductColorDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductColorPayload>
          }
          update: {
            args: Prisma.ProductColorUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductColorPayload>
          }
          deleteMany: {
            args: Prisma.ProductColorDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ProductColorUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ProductColorUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductColorPayload>
          }
          aggregate: {
            args: Prisma.ProductColorAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProductColor>
          }
          groupBy: {
            args: Prisma.ProductColorGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProductColorGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductColorCountArgs<ExtArgs>,
            result: $Utils.Optional<ProductColorCountAggregateOutputType> | number
          }
        }
      }
      PriceHistory: {
        payload: PriceHistoryPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.PriceHistoryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PriceHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PriceHistoryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PriceHistoryPayload>
          }
          findFirst: {
            args: Prisma.PriceHistoryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PriceHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PriceHistoryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PriceHistoryPayload>
          }
          findMany: {
            args: Prisma.PriceHistoryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PriceHistoryPayload>[]
          }
          create: {
            args: Prisma.PriceHistoryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PriceHistoryPayload>
          }
          createMany: {
            args: Prisma.PriceHistoryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PriceHistoryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PriceHistoryPayload>
          }
          update: {
            args: Prisma.PriceHistoryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PriceHistoryPayload>
          }
          deleteMany: {
            args: Prisma.PriceHistoryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PriceHistoryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PriceHistoryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PriceHistoryPayload>
          }
          aggregate: {
            args: Prisma.PriceHistoryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePriceHistory>
          }
          groupBy: {
            args: Prisma.PriceHistoryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PriceHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.PriceHistoryCountArgs<ExtArgs>,
            result: $Utils.Optional<PriceHistoryCountAggregateOutputType> | number
          }
        }
      }
      ProductAviableSizes: {
        payload: ProductAviableSizesPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.ProductAviableSizesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductAviableSizesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductAviableSizesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductAviableSizesPayload>
          }
          findFirst: {
            args: Prisma.ProductAviableSizesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductAviableSizesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductAviableSizesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductAviableSizesPayload>
          }
          findMany: {
            args: Prisma.ProductAviableSizesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductAviableSizesPayload>[]
          }
          create: {
            args: Prisma.ProductAviableSizesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductAviableSizesPayload>
          }
          createMany: {
            args: Prisma.ProductAviableSizesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ProductAviableSizesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductAviableSizesPayload>
          }
          update: {
            args: Prisma.ProductAviableSizesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductAviableSizesPayload>
          }
          deleteMany: {
            args: Prisma.ProductAviableSizesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ProductAviableSizesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ProductAviableSizesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductAviableSizesPayload>
          }
          aggregate: {
            args: Prisma.ProductAviableSizesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProductAviableSizes>
          }
          groupBy: {
            args: Prisma.ProductAviableSizesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProductAviableSizesGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductAviableSizesCountArgs<ExtArgs>,
            result: $Utils.Optional<ProductAviableSizesCountAggregateOutputType> | number
          }
        }
      }
      SeasonalDresses: {
        payload: SeasonalDressesPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.SeasonalDressesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SeasonalDressesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SeasonalDressesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SeasonalDressesPayload>
          }
          findFirst: {
            args: Prisma.SeasonalDressesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SeasonalDressesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SeasonalDressesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SeasonalDressesPayload>
          }
          findMany: {
            args: Prisma.SeasonalDressesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SeasonalDressesPayload>[]
          }
          create: {
            args: Prisma.SeasonalDressesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SeasonalDressesPayload>
          }
          createMany: {
            args: Prisma.SeasonalDressesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SeasonalDressesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SeasonalDressesPayload>
          }
          update: {
            args: Prisma.SeasonalDressesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SeasonalDressesPayload>
          }
          deleteMany: {
            args: Prisma.SeasonalDressesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SeasonalDressesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SeasonalDressesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SeasonalDressesPayload>
          }
          aggregate: {
            args: Prisma.SeasonalDressesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSeasonalDresses>
          }
          groupBy: {
            args: Prisma.SeasonalDressesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SeasonalDressesGroupByOutputType>[]
          }
          count: {
            args: Prisma.SeasonalDressesCountArgs<ExtArgs>,
            result: $Utils.Optional<SeasonalDressesCountAggregateOutputType> | number
          }
        }
      }
      ProductImages: {
        payload: ProductImagesPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.ProductImagesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductImagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductImagesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductImagesPayload>
          }
          findFirst: {
            args: Prisma.ProductImagesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductImagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductImagesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductImagesPayload>
          }
          findMany: {
            args: Prisma.ProductImagesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductImagesPayload>[]
          }
          create: {
            args: Prisma.ProductImagesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductImagesPayload>
          }
          createMany: {
            args: Prisma.ProductImagesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ProductImagesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductImagesPayload>
          }
          update: {
            args: Prisma.ProductImagesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductImagesPayload>
          }
          deleteMany: {
            args: Prisma.ProductImagesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ProductImagesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ProductImagesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProductImagesPayload>
          }
          aggregate: {
            args: Prisma.ProductImagesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProductImages>
          }
          groupBy: {
            args: Prisma.ProductImagesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProductImagesGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductImagesCountArgs<ExtArgs>,
            result: $Utils.Optional<ProductImagesCountAggregateOutputType> | number
          }
        }
      }
      CommonDescription: {
        payload: CommonDescriptionPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.CommonDescriptionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CommonDescriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommonDescriptionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CommonDescriptionPayload>
          }
          findFirst: {
            args: Prisma.CommonDescriptionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CommonDescriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommonDescriptionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CommonDescriptionPayload>
          }
          findMany: {
            args: Prisma.CommonDescriptionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CommonDescriptionPayload>[]
          }
          create: {
            args: Prisma.CommonDescriptionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CommonDescriptionPayload>
          }
          createMany: {
            args: Prisma.CommonDescriptionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CommonDescriptionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CommonDescriptionPayload>
          }
          update: {
            args: Prisma.CommonDescriptionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CommonDescriptionPayload>
          }
          deleteMany: {
            args: Prisma.CommonDescriptionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CommonDescriptionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CommonDescriptionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CommonDescriptionPayload>
          }
          aggregate: {
            args: Prisma.CommonDescriptionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCommonDescription>
          }
          groupBy: {
            args: Prisma.CommonDescriptionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CommonDescriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommonDescriptionCountArgs<ExtArgs>,
            result: $Utils.Optional<CommonDescriptionCountAggregateOutputType> | number
          }
        }
      }
      TopDescription: {
        payload: TopDescriptionPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.TopDescriptionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TopDescriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TopDescriptionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TopDescriptionPayload>
          }
          findFirst: {
            args: Prisma.TopDescriptionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TopDescriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TopDescriptionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TopDescriptionPayload>
          }
          findMany: {
            args: Prisma.TopDescriptionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TopDescriptionPayload>[]
          }
          create: {
            args: Prisma.TopDescriptionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TopDescriptionPayload>
          }
          createMany: {
            args: Prisma.TopDescriptionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TopDescriptionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TopDescriptionPayload>
          }
          update: {
            args: Prisma.TopDescriptionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TopDescriptionPayload>
          }
          deleteMany: {
            args: Prisma.TopDescriptionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TopDescriptionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TopDescriptionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TopDescriptionPayload>
          }
          aggregate: {
            args: Prisma.TopDescriptionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTopDescription>
          }
          groupBy: {
            args: Prisma.TopDescriptionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TopDescriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TopDescriptionCountArgs<ExtArgs>,
            result: $Utils.Optional<TopDescriptionCountAggregateOutputType> | number
          }
        }
      }
      BottomDescription: {
        payload: BottomDescriptionPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.BottomDescriptionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BottomDescriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BottomDescriptionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BottomDescriptionPayload>
          }
          findFirst: {
            args: Prisma.BottomDescriptionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BottomDescriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BottomDescriptionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BottomDescriptionPayload>
          }
          findMany: {
            args: Prisma.BottomDescriptionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BottomDescriptionPayload>[]
          }
          create: {
            args: Prisma.BottomDescriptionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BottomDescriptionPayload>
          }
          createMany: {
            args: Prisma.BottomDescriptionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BottomDescriptionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BottomDescriptionPayload>
          }
          update: {
            args: Prisma.BottomDescriptionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BottomDescriptionPayload>
          }
          deleteMany: {
            args: Prisma.BottomDescriptionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BottomDescriptionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BottomDescriptionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BottomDescriptionPayload>
          }
          aggregate: {
            args: Prisma.BottomDescriptionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBottomDescription>
          }
          groupBy: {
            args: Prisma.BottomDescriptionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BottomDescriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.BottomDescriptionCountArgs<ExtArgs>,
            result: $Utils.Optional<BottomDescriptionCountAggregateOutputType> | number
          }
        }
      }
      KurtasDescription: {
        payload: KurtasDescriptionPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.KurtasDescriptionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<KurtasDescriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KurtasDescriptionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<KurtasDescriptionPayload>
          }
          findFirst: {
            args: Prisma.KurtasDescriptionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<KurtasDescriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KurtasDescriptionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<KurtasDescriptionPayload>
          }
          findMany: {
            args: Prisma.KurtasDescriptionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<KurtasDescriptionPayload>[]
          }
          create: {
            args: Prisma.KurtasDescriptionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<KurtasDescriptionPayload>
          }
          createMany: {
            args: Prisma.KurtasDescriptionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.KurtasDescriptionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<KurtasDescriptionPayload>
          }
          update: {
            args: Prisma.KurtasDescriptionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<KurtasDescriptionPayload>
          }
          deleteMany: {
            args: Prisma.KurtasDescriptionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.KurtasDescriptionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.KurtasDescriptionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<KurtasDescriptionPayload>
          }
          aggregate: {
            args: Prisma.KurtasDescriptionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateKurtasDescription>
          }
          groupBy: {
            args: Prisma.KurtasDescriptionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<KurtasDescriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.KurtasDescriptionCountArgs<ExtArgs>,
            result: $Utils.Optional<KurtasDescriptionCountAggregateOutputType> | number
          }
        }
      }
      ShoesDescription: {
        payload: ShoesDescriptionPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.ShoesDescriptionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ShoesDescriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShoesDescriptionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ShoesDescriptionPayload>
          }
          findFirst: {
            args: Prisma.ShoesDescriptionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ShoesDescriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShoesDescriptionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ShoesDescriptionPayload>
          }
          findMany: {
            args: Prisma.ShoesDescriptionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ShoesDescriptionPayload>[]
          }
          create: {
            args: Prisma.ShoesDescriptionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ShoesDescriptionPayload>
          }
          createMany: {
            args: Prisma.ShoesDescriptionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ShoesDescriptionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ShoesDescriptionPayload>
          }
          update: {
            args: Prisma.ShoesDescriptionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ShoesDescriptionPayload>
          }
          deleteMany: {
            args: Prisma.ShoesDescriptionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ShoesDescriptionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ShoesDescriptionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ShoesDescriptionPayload>
          }
          aggregate: {
            args: Prisma.ShoesDescriptionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateShoesDescription>
          }
          groupBy: {
            args: Prisma.ShoesDescriptionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ShoesDescriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShoesDescriptionCountArgs<ExtArgs>,
            result: $Utils.Optional<ShoesDescriptionCountAggregateOutputType> | number
          }
        }
      }
      WatchesDescription: {
        payload: WatchesDescriptionPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.WatchesDescriptionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<WatchesDescriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WatchesDescriptionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<WatchesDescriptionPayload>
          }
          findFirst: {
            args: Prisma.WatchesDescriptionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<WatchesDescriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WatchesDescriptionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<WatchesDescriptionPayload>
          }
          findMany: {
            args: Prisma.WatchesDescriptionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<WatchesDescriptionPayload>[]
          }
          create: {
            args: Prisma.WatchesDescriptionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<WatchesDescriptionPayload>
          }
          createMany: {
            args: Prisma.WatchesDescriptionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.WatchesDescriptionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<WatchesDescriptionPayload>
          }
          update: {
            args: Prisma.WatchesDescriptionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<WatchesDescriptionPayload>
          }
          deleteMany: {
            args: Prisma.WatchesDescriptionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.WatchesDescriptionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.WatchesDescriptionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<WatchesDescriptionPayload>
          }
          aggregate: {
            args: Prisma.WatchesDescriptionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateWatchesDescription>
          }
          groupBy: {
            args: Prisma.WatchesDescriptionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<WatchesDescriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.WatchesDescriptionCountArgs<ExtArgs>,
            result: $Utils.Optional<WatchesDescriptionCountAggregateOutputType> | number
          }
        }
      }
      PerfumesDescription: {
        payload: PerfumesDescriptionPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.PerfumesDescriptionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PerfumesDescriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PerfumesDescriptionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PerfumesDescriptionPayload>
          }
          findFirst: {
            args: Prisma.PerfumesDescriptionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PerfumesDescriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PerfumesDescriptionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PerfumesDescriptionPayload>
          }
          findMany: {
            args: Prisma.PerfumesDescriptionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PerfumesDescriptionPayload>[]
          }
          create: {
            args: Prisma.PerfumesDescriptionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PerfumesDescriptionPayload>
          }
          createMany: {
            args: Prisma.PerfumesDescriptionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PerfumesDescriptionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PerfumesDescriptionPayload>
          }
          update: {
            args: Prisma.PerfumesDescriptionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PerfumesDescriptionPayload>
          }
          deleteMany: {
            args: Prisma.PerfumesDescriptionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PerfumesDescriptionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PerfumesDescriptionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PerfumesDescriptionPayload>
          }
          aggregate: {
            args: Prisma.PerfumesDescriptionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePerfumesDescription>
          }
          groupBy: {
            args: Prisma.PerfumesDescriptionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PerfumesDescriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PerfumesDescriptionCountArgs<ExtArgs>,
            result: $Utils.Optional<PerfumesDescriptionCountAggregateOutputType> | number
          }
        }
      }
      InnersDescription: {
        payload: InnersDescriptionPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.InnersDescriptionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InnersDescriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InnersDescriptionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InnersDescriptionPayload>
          }
          findFirst: {
            args: Prisma.InnersDescriptionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InnersDescriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InnersDescriptionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InnersDescriptionPayload>
          }
          findMany: {
            args: Prisma.InnersDescriptionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InnersDescriptionPayload>[]
          }
          create: {
            args: Prisma.InnersDescriptionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InnersDescriptionPayload>
          }
          createMany: {
            args: Prisma.InnersDescriptionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.InnersDescriptionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InnersDescriptionPayload>
          }
          update: {
            args: Prisma.InnersDescriptionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InnersDescriptionPayload>
          }
          deleteMany: {
            args: Prisma.InnersDescriptionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.InnersDescriptionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.InnersDescriptionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InnersDescriptionPayload>
          }
          aggregate: {
            args: Prisma.InnersDescriptionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInnersDescription>
          }
          groupBy: {
            args: Prisma.InnersDescriptionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<InnersDescriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.InnersDescriptionCountArgs<ExtArgs>,
            result: $Utils.Optional<InnersDescriptionCountAggregateOutputType> | number
          }
        }
      }
      Warranty: {
        payload: WarrantyPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.WarrantyFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<WarrantyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WarrantyFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<WarrantyPayload>
          }
          findFirst: {
            args: Prisma.WarrantyFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<WarrantyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WarrantyFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<WarrantyPayload>
          }
          findMany: {
            args: Prisma.WarrantyFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<WarrantyPayload>[]
          }
          create: {
            args: Prisma.WarrantyCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<WarrantyPayload>
          }
          createMany: {
            args: Prisma.WarrantyCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.WarrantyDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<WarrantyPayload>
          }
          update: {
            args: Prisma.WarrantyUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<WarrantyPayload>
          }
          deleteMany: {
            args: Prisma.WarrantyDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.WarrantyUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.WarrantyUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<WarrantyPayload>
          }
          aggregate: {
            args: Prisma.WarrantyAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateWarranty>
          }
          groupBy: {
            args: Prisma.WarrantyGroupByArgs<ExtArgs>,
            result: $Utils.Optional<WarrantyGroupByOutputType>[]
          }
          count: {
            args: Prisma.WarrantyCountArgs<ExtArgs>,
            result: $Utils.Optional<WarrantyCountAggregateOutputType> | number
          }
        }
      }
      SleeveType: {
        payload: SleeveTypePayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.SleeveTypeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SleeveTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SleeveTypeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SleeveTypePayload>
          }
          findFirst: {
            args: Prisma.SleeveTypeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SleeveTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SleeveTypeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SleeveTypePayload>
          }
          findMany: {
            args: Prisma.SleeveTypeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SleeveTypePayload>[]
          }
          create: {
            args: Prisma.SleeveTypeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SleeveTypePayload>
          }
          createMany: {
            args: Prisma.SleeveTypeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SleeveTypeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SleeveTypePayload>
          }
          update: {
            args: Prisma.SleeveTypeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SleeveTypePayload>
          }
          deleteMany: {
            args: Prisma.SleeveTypeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SleeveTypeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SleeveTypeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SleeveTypePayload>
          }
          aggregate: {
            args: Prisma.SleeveTypeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSleeveType>
          }
          groupBy: {
            args: Prisma.SleeveTypeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SleeveTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.SleeveTypeCountArgs<ExtArgs>,
            result: $Utils.Optional<SleeveTypeCountAggregateOutputType> | number
          }
        }
      }
      NeckType: {
        payload: NeckTypePayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.NeckTypeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NeckTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NeckTypeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NeckTypePayload>
          }
          findFirst: {
            args: Prisma.NeckTypeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NeckTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NeckTypeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NeckTypePayload>
          }
          findMany: {
            args: Prisma.NeckTypeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NeckTypePayload>[]
          }
          create: {
            args: Prisma.NeckTypeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NeckTypePayload>
          }
          createMany: {
            args: Prisma.NeckTypeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.NeckTypeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NeckTypePayload>
          }
          update: {
            args: Prisma.NeckTypeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NeckTypePayload>
          }
          deleteMany: {
            args: Prisma.NeckTypeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.NeckTypeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.NeckTypeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NeckTypePayload>
          }
          aggregate: {
            args: Prisma.NeckTypeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateNeckType>
          }
          groupBy: {
            args: Prisma.NeckTypeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<NeckTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.NeckTypeCountArgs<ExtArgs>,
            result: $Utils.Optional<NeckTypeCountAggregateOutputType> | number
          }
        }
      }
      KurtasLengthType: {
        payload: KurtasLengthTypePayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.KurtasLengthTypeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<KurtasLengthTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KurtasLengthTypeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<KurtasLengthTypePayload>
          }
          findFirst: {
            args: Prisma.KurtasLengthTypeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<KurtasLengthTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KurtasLengthTypeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<KurtasLengthTypePayload>
          }
          findMany: {
            args: Prisma.KurtasLengthTypeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<KurtasLengthTypePayload>[]
          }
          create: {
            args: Prisma.KurtasLengthTypeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<KurtasLengthTypePayload>
          }
          createMany: {
            args: Prisma.KurtasLengthTypeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.KurtasLengthTypeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<KurtasLengthTypePayload>
          }
          update: {
            args: Prisma.KurtasLengthTypeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<KurtasLengthTypePayload>
          }
          deleteMany: {
            args: Prisma.KurtasLengthTypeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.KurtasLengthTypeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.KurtasLengthTypeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<KurtasLengthTypePayload>
          }
          aggregate: {
            args: Prisma.KurtasLengthTypeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateKurtasLengthType>
          }
          groupBy: {
            args: Prisma.KurtasLengthTypeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<KurtasLengthTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.KurtasLengthTypeCountArgs<ExtArgs>,
            result: $Utils.Optional<KurtasLengthTypeCountAggregateOutputType> | number
          }
        }
      }
      TypesOfBottom: {
        payload: TypesOfBottomPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.TypesOfBottomFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TypesOfBottomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TypesOfBottomFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TypesOfBottomPayload>
          }
          findFirst: {
            args: Prisma.TypesOfBottomFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TypesOfBottomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TypesOfBottomFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TypesOfBottomPayload>
          }
          findMany: {
            args: Prisma.TypesOfBottomFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TypesOfBottomPayload>[]
          }
          create: {
            args: Prisma.TypesOfBottomCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TypesOfBottomPayload>
          }
          createMany: {
            args: Prisma.TypesOfBottomCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TypesOfBottomDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TypesOfBottomPayload>
          }
          update: {
            args: Prisma.TypesOfBottomUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TypesOfBottomPayload>
          }
          deleteMany: {
            args: Prisma.TypesOfBottomDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TypesOfBottomUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TypesOfBottomUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TypesOfBottomPayload>
          }
          aggregate: {
            args: Prisma.TypesOfBottomAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTypesOfBottom>
          }
          groupBy: {
            args: Prisma.TypesOfBottomGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TypesOfBottomGroupByOutputType>[]
          }
          count: {
            args: Prisma.TypesOfBottomCountArgs<ExtArgs>,
            result: $Utils.Optional<TypesOfBottomCountAggregateOutputType> | number
          }
        }
      }
      TypesOfPleats: {
        payload: TypesOfPleatsPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.TypesOfPleatsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TypesOfPleatsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TypesOfPleatsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TypesOfPleatsPayload>
          }
          findFirst: {
            args: Prisma.TypesOfPleatsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TypesOfPleatsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TypesOfPleatsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TypesOfPleatsPayload>
          }
          findMany: {
            args: Prisma.TypesOfPleatsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TypesOfPleatsPayload>[]
          }
          create: {
            args: Prisma.TypesOfPleatsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TypesOfPleatsPayload>
          }
          createMany: {
            args: Prisma.TypesOfPleatsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TypesOfPleatsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TypesOfPleatsPayload>
          }
          update: {
            args: Prisma.TypesOfPleatsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TypesOfPleatsPayload>
          }
          deleteMany: {
            args: Prisma.TypesOfPleatsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TypesOfPleatsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TypesOfPleatsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TypesOfPleatsPayload>
          }
          aggregate: {
            args: Prisma.TypesOfPleatsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTypesOfPleats>
          }
          groupBy: {
            args: Prisma.TypesOfPleatsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TypesOfPleatsGroupByOutputType>[]
          }
          count: {
            args: Prisma.TypesOfPleatsCountArgs<ExtArgs>,
            result: $Utils.Optional<TypesOfPleatsCountAggregateOutputType> | number
          }
        }
      }
      TypesOfLengthBottom: {
        payload: TypesOfLengthBottomPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.TypesOfLengthBottomFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TypesOfLengthBottomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TypesOfLengthBottomFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TypesOfLengthBottomPayload>
          }
          findFirst: {
            args: Prisma.TypesOfLengthBottomFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TypesOfLengthBottomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TypesOfLengthBottomFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TypesOfLengthBottomPayload>
          }
          findMany: {
            args: Prisma.TypesOfLengthBottomFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TypesOfLengthBottomPayload>[]
          }
          create: {
            args: Prisma.TypesOfLengthBottomCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TypesOfLengthBottomPayload>
          }
          createMany: {
            args: Prisma.TypesOfLengthBottomCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TypesOfLengthBottomDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TypesOfLengthBottomPayload>
          }
          update: {
            args: Prisma.TypesOfLengthBottomUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TypesOfLengthBottomPayload>
          }
          deleteMany: {
            args: Prisma.TypesOfLengthBottomDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TypesOfLengthBottomUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TypesOfLengthBottomUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TypesOfLengthBottomPayload>
          }
          aggregate: {
            args: Prisma.TypesOfLengthBottomAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTypesOfLengthBottom>
          }
          groupBy: {
            args: Prisma.TypesOfLengthBottomGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TypesOfLengthBottomGroupByOutputType>[]
          }
          count: {
            args: Prisma.TypesOfLengthBottomCountArgs<ExtArgs>,
            result: $Utils.Optional<TypesOfLengthBottomCountAggregateOutputType> | number
          }
        }
      }
      QuantityHistory: {
        payload: QuantityHistoryPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.QuantityHistoryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<QuantityHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuantityHistoryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<QuantityHistoryPayload>
          }
          findFirst: {
            args: Prisma.QuantityHistoryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<QuantityHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuantityHistoryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<QuantityHistoryPayload>
          }
          findMany: {
            args: Prisma.QuantityHistoryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<QuantityHistoryPayload>[]
          }
          create: {
            args: Prisma.QuantityHistoryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<QuantityHistoryPayload>
          }
          createMany: {
            args: Prisma.QuantityHistoryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.QuantityHistoryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<QuantityHistoryPayload>
          }
          update: {
            args: Prisma.QuantityHistoryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<QuantityHistoryPayload>
          }
          deleteMany: {
            args: Prisma.QuantityHistoryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.QuantityHistoryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.QuantityHistoryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<QuantityHistoryPayload>
          }
          aggregate: {
            args: Prisma.QuantityHistoryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateQuantityHistory>
          }
          groupBy: {
            args: Prisma.QuantityHistoryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<QuantityHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuantityHistoryCountArgs<ExtArgs>,
            result: $Utils.Optional<QuantityHistoryCountAggregateOutputType> | number
          }
        }
      }
      Offer: {
        payload: OfferPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.OfferFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OfferPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OfferFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OfferPayload>
          }
          findFirst: {
            args: Prisma.OfferFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OfferPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OfferFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OfferPayload>
          }
          findMany: {
            args: Prisma.OfferFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OfferPayload>[]
          }
          create: {
            args: Prisma.OfferCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OfferPayload>
          }
          createMany: {
            args: Prisma.OfferCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.OfferDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OfferPayload>
          }
          update: {
            args: Prisma.OfferUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OfferPayload>
          }
          deleteMany: {
            args: Prisma.OfferDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.OfferUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.OfferUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OfferPayload>
          }
          aggregate: {
            args: Prisma.OfferAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOffer>
          }
          groupBy: {
            args: Prisma.OfferGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OfferGroupByOutputType>[]
          }
          count: {
            args: Prisma.OfferCountArgs<ExtArgs>,
            result: $Utils.Optional<OfferCountAggregateOutputType> | number
          }
        }
      }
      OfferValidity: {
        payload: OfferValidityPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.OfferValidityFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OfferValidityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OfferValidityFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OfferValidityPayload>
          }
          findFirst: {
            args: Prisma.OfferValidityFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OfferValidityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OfferValidityFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OfferValidityPayload>
          }
          findMany: {
            args: Prisma.OfferValidityFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OfferValidityPayload>[]
          }
          create: {
            args: Prisma.OfferValidityCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OfferValidityPayload>
          }
          createMany: {
            args: Prisma.OfferValidityCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.OfferValidityDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OfferValidityPayload>
          }
          update: {
            args: Prisma.OfferValidityUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OfferValidityPayload>
          }
          deleteMany: {
            args: Prisma.OfferValidityDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.OfferValidityUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.OfferValidityUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OfferValidityPayload>
          }
          aggregate: {
            args: Prisma.OfferValidityAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOfferValidity>
          }
          groupBy: {
            args: Prisma.OfferValidityGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OfferValidityGroupByOutputType>[]
          }
          count: {
            args: Prisma.OfferValidityCountArgs<ExtArgs>,
            result: $Utils.Optional<OfferValidityCountAggregateOutputType> | number
          }
        }
      }
      OfferPromotionPeriods: {
        payload: OfferPromotionPeriodsPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.OfferPromotionPeriodsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OfferPromotionPeriodsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OfferPromotionPeriodsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OfferPromotionPeriodsPayload>
          }
          findFirst: {
            args: Prisma.OfferPromotionPeriodsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OfferPromotionPeriodsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OfferPromotionPeriodsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OfferPromotionPeriodsPayload>
          }
          findMany: {
            args: Prisma.OfferPromotionPeriodsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OfferPromotionPeriodsPayload>[]
          }
          create: {
            args: Prisma.OfferPromotionPeriodsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OfferPromotionPeriodsPayload>
          }
          createMany: {
            args: Prisma.OfferPromotionPeriodsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.OfferPromotionPeriodsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OfferPromotionPeriodsPayload>
          }
          update: {
            args: Prisma.OfferPromotionPeriodsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OfferPromotionPeriodsPayload>
          }
          deleteMany: {
            args: Prisma.OfferPromotionPeriodsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.OfferPromotionPeriodsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.OfferPromotionPeriodsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OfferPromotionPeriodsPayload>
          }
          aggregate: {
            args: Prisma.OfferPromotionPeriodsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOfferPromotionPeriods>
          }
          groupBy: {
            args: Prisma.OfferPromotionPeriodsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OfferPromotionPeriodsGroupByOutputType>[]
          }
          count: {
            args: Prisma.OfferPromotionPeriodsCountArgs<ExtArgs>,
            result: $Utils.Optional<OfferPromotionPeriodsCountAggregateOutputType> | number
          }
        }
      }
      Cart: {
        payload: CartPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.CartFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CartPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CartFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CartPayload>
          }
          findFirst: {
            args: Prisma.CartFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CartPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CartFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CartPayload>
          }
          findMany: {
            args: Prisma.CartFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CartPayload>[]
          }
          create: {
            args: Prisma.CartCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CartPayload>
          }
          createMany: {
            args: Prisma.CartCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CartDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CartPayload>
          }
          update: {
            args: Prisma.CartUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CartPayload>
          }
          deleteMany: {
            args: Prisma.CartDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CartUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CartUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CartPayload>
          }
          aggregate: {
            args: Prisma.CartAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCart>
          }
          groupBy: {
            args: Prisma.CartGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CartGroupByOutputType>[]
          }
          count: {
            args: Prisma.CartCountArgs<ExtArgs>,
            result: $Utils.Optional<CartCountAggregateOutputType> | number
          }
        }
      }
      Wishlist: {
        payload: WishlistPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.WishlistFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<WishlistPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WishlistFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<WishlistPayload>
          }
          findFirst: {
            args: Prisma.WishlistFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<WishlistPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WishlistFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<WishlistPayload>
          }
          findMany: {
            args: Prisma.WishlistFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<WishlistPayload>[]
          }
          create: {
            args: Prisma.WishlistCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<WishlistPayload>
          }
          createMany: {
            args: Prisma.WishlistCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.WishlistDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<WishlistPayload>
          }
          update: {
            args: Prisma.WishlistUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<WishlistPayload>
          }
          deleteMany: {
            args: Prisma.WishlistDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.WishlistUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.WishlistUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<WishlistPayload>
          }
          aggregate: {
            args: Prisma.WishlistAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateWishlist>
          }
          groupBy: {
            args: Prisma.WishlistGroupByArgs<ExtArgs>,
            result: $Utils.Optional<WishlistGroupByOutputType>[]
          }
          count: {
            args: Prisma.WishlistCountArgs<ExtArgs>,
            result: $Utils.Optional<WishlistCountAggregateOutputType> | number
          }
        }
      }
      WishlistItem: {
        payload: WishlistItemPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.WishlistItemFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<WishlistItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WishlistItemFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<WishlistItemPayload>
          }
          findFirst: {
            args: Prisma.WishlistItemFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<WishlistItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WishlistItemFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<WishlistItemPayload>
          }
          findMany: {
            args: Prisma.WishlistItemFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<WishlistItemPayload>[]
          }
          create: {
            args: Prisma.WishlistItemCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<WishlistItemPayload>
          }
          createMany: {
            args: Prisma.WishlistItemCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.WishlistItemDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<WishlistItemPayload>
          }
          update: {
            args: Prisma.WishlistItemUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<WishlistItemPayload>
          }
          deleteMany: {
            args: Prisma.WishlistItemDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.WishlistItemUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.WishlistItemUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<WishlistItemPayload>
          }
          aggregate: {
            args: Prisma.WishlistItemAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateWishlistItem>
          }
          groupBy: {
            args: Prisma.WishlistItemGroupByArgs<ExtArgs>,
            result: $Utils.Optional<WishlistItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.WishlistItemCountArgs<ExtArgs>,
            result: $Utils.Optional<WishlistItemCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type RolesCountOutputType
   */


  export type RolesCountOutputType = {
    user: number
  }

  export type RolesCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | RolesCountOutputTypeCountUserArgs
  }

  // Custom InputTypes

  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolesCountOutputType
     */
    select?: RolesCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeCountUserArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }



  /**
   * Count Type ProductCategoryCountOutputType
   */


  export type ProductCategoryCountOutputType = {
    productType: number
  }

  export type ProductCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    productType?: boolean | ProductCategoryCountOutputTypeCountProductTypeArgs
  }

  // Custom InputTypes

  /**
   * ProductCategoryCountOutputType without action
   */
  export type ProductCategoryCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategoryCountOutputType
     */
    select?: ProductCategoryCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ProductCategoryCountOutputType without action
   */
  export type ProductCategoryCountOutputTypeCountProductTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ProductTypeWhereInput
  }



  /**
   * Count Type ProductTypeCountOutputType
   */


  export type ProductTypeCountOutputType = {
    sizes: number
    product: number
  }

  export type ProductTypeCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    sizes?: boolean | ProductTypeCountOutputTypeCountSizesArgs
    product?: boolean | ProductTypeCountOutputTypeCountProductArgs
  }

  // Custom InputTypes

  /**
   * ProductTypeCountOutputType without action
   */
  export type ProductTypeCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTypeCountOutputType
     */
    select?: ProductTypeCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ProductTypeCountOutputType without action
   */
  export type ProductTypeCountOutputTypeCountSizesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ProductTypeSizeWhereInput
  }


  /**
   * ProductTypeCountOutputType without action
   */
  export type ProductTypeCountOutputTypeCountProductArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }



  /**
   * Count Type ProductTypeSizeCountOutputType
   */


  export type ProductTypeSizeCountOutputType = {
    aviableSizes: number
  }

  export type ProductTypeSizeCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    aviableSizes?: boolean | ProductTypeSizeCountOutputTypeCountAviableSizesArgs
  }

  // Custom InputTypes

  /**
   * ProductTypeSizeCountOutputType without action
   */
  export type ProductTypeSizeCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTypeSizeCountOutputType
     */
    select?: ProductTypeSizeCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ProductTypeSizeCountOutputType without action
   */
  export type ProductTypeSizeCountOutputTypeCountAviableSizesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ProductAviableSizesWhereInput
  }



  /**
   * Count Type GenderCountOutputType
   */


  export type GenderCountOutputType = {
    productCategory: number
    user: number
  }

  export type GenderCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    productCategory?: boolean | GenderCountOutputTypeCountProductCategoryArgs
    user?: boolean | GenderCountOutputTypeCountUserArgs
  }

  // Custom InputTypes

  /**
   * GenderCountOutputType without action
   */
  export type GenderCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenderCountOutputType
     */
    select?: GenderCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * GenderCountOutputType without action
   */
  export type GenderCountOutputTypeCountProductCategoryArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ProductCategoryWhereInput
  }


  /**
   * GenderCountOutputType without action
   */
  export type GenderCountOutputTypeCountUserArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }



  /**
   * Count Type CountryCountOutputType
   */


  export type CountryCountOutputType = {
    state: number
  }

  export type CountryCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    state?: boolean | CountryCountOutputTypeCountStateArgs
  }

  // Custom InputTypes

  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCountOutputType
     */
    select?: CountryCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeCountStateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: StateWhereInput
  }



  /**
   * Count Type StateCountOutputType
   */


  export type StateCountOutputType = {
    district: number
  }

  export type StateCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    district?: boolean | StateCountOutputTypeCountDistrictArgs
  }

  // Custom InputTypes

  /**
   * StateCountOutputType without action
   */
  export type StateCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StateCountOutputType
     */
    select?: StateCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * StateCountOutputType without action
   */
  export type StateCountOutputTypeCountDistrictArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AddressWhereInput
  }



  /**
   * Count Type AddressCountOutputType
   */


  export type AddressCountOutputType = {
    userAddress: number
  }

  export type AddressCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    userAddress?: boolean | AddressCountOutputTypeCountUserAddressArgs
  }

  // Custom InputTypes

  /**
   * AddressCountOutputType without action
   */
  export type AddressCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressCountOutputType
     */
    select?: AddressCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * AddressCountOutputType without action
   */
  export type AddressCountOutputTypeCountUserAddressArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserAddressWhereInput
  }



  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    userProduct: number
    userAddress: number
    addCart: number
    wishlist: number
    loginRequests: number
    ProductReview: number
    order: number
    userSearchItems: number
    password: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    userProduct?: boolean | UserCountOutputTypeCountUserProductArgs
    userAddress?: boolean | UserCountOutputTypeCountUserAddressArgs
    addCart?: boolean | UserCountOutputTypeCountAddCartArgs
    wishlist?: boolean | UserCountOutputTypeCountWishlistArgs
    loginRequests?: boolean | UserCountOutputTypeCountLoginRequestsArgs
    ProductReview?: boolean | UserCountOutputTypeCountProductReviewArgs
    order?: boolean | UserCountOutputTypeCountOrderArgs
    userSearchItems?: boolean | UserCountOutputTypeCountUserSearchItemsArgs
    password?: boolean | UserCountOutputTypeCountPasswordArgs
  }

  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserProductArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserAddressArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserAddressWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAddCartArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CartWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWishlistArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: WishlistWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLoginRequestsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserLoginRequestWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProductReviewArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ProductReviewWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrderArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserSearchItemsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: SearchItemsWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPasswordArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserPasswordWhereInput
  }



  /**
   * Count Type ProductOwnerCountOutputType
   */


  export type ProductOwnerCountOutputType = {
    product: number
  }

  export type ProductOwnerCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    product?: boolean | ProductOwnerCountOutputTypeCountProductArgs
  }

  // Custom InputTypes

  /**
   * ProductOwnerCountOutputType without action
   */
  export type ProductOwnerCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductOwnerCountOutputType
     */
    select?: ProductOwnerCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ProductOwnerCountOutputType without action
   */
  export type ProductOwnerCountOutputTypeCountProductArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }



  /**
   * Count Type ProductCountOutputType
   */


  export type ProductCountOutputType = {
    color: number
    offer: number
    seasonalDresses: number
    priceHistory: number
    commonDescription: number
    delivery: number
    returns: number
    cart: number
    wishlistItem: number
    productReviews: number
    order: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    color?: boolean | ProductCountOutputTypeCountColorArgs
    offer?: boolean | ProductCountOutputTypeCountOfferArgs
    seasonalDresses?: boolean | ProductCountOutputTypeCountSeasonalDressesArgs
    priceHistory?: boolean | ProductCountOutputTypeCountPriceHistoryArgs
    commonDescription?: boolean | ProductCountOutputTypeCountCommonDescriptionArgs
    delivery?: boolean | ProductCountOutputTypeCountDeliveryArgs
    returns?: boolean | ProductCountOutputTypeCountReturnsArgs
    cart?: boolean | ProductCountOutputTypeCountCartArgs
    wishlistItem?: boolean | ProductCountOutputTypeCountWishlistItemArgs
    productReviews?: boolean | ProductCountOutputTypeCountProductReviewsArgs
    order?: boolean | ProductCountOutputTypeCountOrderArgs
  }

  // Custom InputTypes

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountColorArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ProductColorWhereInput
  }


  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountOfferArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OfferWhereInput
  }


  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountSeasonalDressesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: SeasonalDressesWhereInput
  }


  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountPriceHistoryArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PriceHistoryWhereInput
  }


  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountCommonDescriptionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CommonDescriptionWhereInput
  }


  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountDeliveryArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DeleveryPeriodWhereInput
  }


  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountReturnsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ReturnedProductWhereInput
  }


  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountCartArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CartWhereInput
  }


  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountWishlistItemArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: WishlistItemWhereInput
  }


  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountProductReviewsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ProductReviewWhereInput
  }


  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountOrderArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }



  /**
   * Count Type ProductColorCountOutputType
   */


  export type ProductColorCountOutputType = {
    colorSize: number
    productImages: number
  }

  export type ProductColorCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    colorSize?: boolean | ProductColorCountOutputTypeCountColorSizeArgs
    productImages?: boolean | ProductColorCountOutputTypeCountProductImagesArgs
  }

  // Custom InputTypes

  /**
   * ProductColorCountOutputType without action
   */
  export type ProductColorCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductColorCountOutputType
     */
    select?: ProductColorCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ProductColorCountOutputType without action
   */
  export type ProductColorCountOutputTypeCountColorSizeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ProductAviableSizesWhereInput
  }


  /**
   * ProductColorCountOutputType without action
   */
  export type ProductColorCountOutputTypeCountProductImagesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ProductImagesWhereInput
  }



  /**
   * Count Type ProductAviableSizesCountOutputType
   */


  export type ProductAviableSizesCountOutputType = {
    history: number
  }

  export type ProductAviableSizesCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    history?: boolean | ProductAviableSizesCountOutputTypeCountHistoryArgs
  }

  // Custom InputTypes

  /**
   * ProductAviableSizesCountOutputType without action
   */
  export type ProductAviableSizesCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductAviableSizesCountOutputType
     */
    select?: ProductAviableSizesCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ProductAviableSizesCountOutputType without action
   */
  export type ProductAviableSizesCountOutputTypeCountHistoryArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: QuantityHistoryWhereInput
  }



  /**
   * Count Type CommonDescriptionCountOutputType
   */


  export type CommonDescriptionCountOutputType = {
    topDescription: number
    pantDescription: number
    kurtasDescription: number
    shoesDescription: number
    innerDescription: number
    watchesDescription: number
    perfumesDescription: number
  }

  export type CommonDescriptionCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    topDescription?: boolean | CommonDescriptionCountOutputTypeCountTopDescriptionArgs
    pantDescription?: boolean | CommonDescriptionCountOutputTypeCountPantDescriptionArgs
    kurtasDescription?: boolean | CommonDescriptionCountOutputTypeCountKurtasDescriptionArgs
    shoesDescription?: boolean | CommonDescriptionCountOutputTypeCountShoesDescriptionArgs
    innerDescription?: boolean | CommonDescriptionCountOutputTypeCountInnerDescriptionArgs
    watchesDescription?: boolean | CommonDescriptionCountOutputTypeCountWatchesDescriptionArgs
    perfumesDescription?: boolean | CommonDescriptionCountOutputTypeCountPerfumesDescriptionArgs
  }

  // Custom InputTypes

  /**
   * CommonDescriptionCountOutputType without action
   */
  export type CommonDescriptionCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommonDescriptionCountOutputType
     */
    select?: CommonDescriptionCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CommonDescriptionCountOutputType without action
   */
  export type CommonDescriptionCountOutputTypeCountTopDescriptionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: TopDescriptionWhereInput
  }


  /**
   * CommonDescriptionCountOutputType without action
   */
  export type CommonDescriptionCountOutputTypeCountPantDescriptionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: BottomDescriptionWhereInput
  }


  /**
   * CommonDescriptionCountOutputType without action
   */
  export type CommonDescriptionCountOutputTypeCountKurtasDescriptionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: KurtasDescriptionWhereInput
  }


  /**
   * CommonDescriptionCountOutputType without action
   */
  export type CommonDescriptionCountOutputTypeCountShoesDescriptionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ShoesDescriptionWhereInput
  }


  /**
   * CommonDescriptionCountOutputType without action
   */
  export type CommonDescriptionCountOutputTypeCountInnerDescriptionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: InnersDescriptionWhereInput
  }


  /**
   * CommonDescriptionCountOutputType without action
   */
  export type CommonDescriptionCountOutputTypeCountWatchesDescriptionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: WatchesDescriptionWhereInput
  }


  /**
   * CommonDescriptionCountOutputType without action
   */
  export type CommonDescriptionCountOutputTypeCountPerfumesDescriptionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PerfumesDescriptionWhereInput
  }



  /**
   * Count Type TopDescriptionCountOutputType
   */


  export type TopDescriptionCountOutputType = {
    bottomDescription: number
  }

  export type TopDescriptionCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    bottomDescription?: boolean | TopDescriptionCountOutputTypeCountBottomDescriptionArgs
  }

  // Custom InputTypes

  /**
   * TopDescriptionCountOutputType without action
   */
  export type TopDescriptionCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopDescriptionCountOutputType
     */
    select?: TopDescriptionCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * TopDescriptionCountOutputType without action
   */
  export type TopDescriptionCountOutputTypeCountBottomDescriptionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: BottomDescriptionWhereInput
  }



  /**
   * Count Type KurtasDescriptionCountOutputType
   */


  export type KurtasDescriptionCountOutputType = {
    bottomDescription: number
  }

  export type KurtasDescriptionCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    bottomDescription?: boolean | KurtasDescriptionCountOutputTypeCountBottomDescriptionArgs
  }

  // Custom InputTypes

  /**
   * KurtasDescriptionCountOutputType without action
   */
  export type KurtasDescriptionCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KurtasDescriptionCountOutputType
     */
    select?: KurtasDescriptionCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * KurtasDescriptionCountOutputType without action
   */
  export type KurtasDescriptionCountOutputTypeCountBottomDescriptionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: BottomDescriptionWhereInput
  }



  /**
   * Count Type ShoesDescriptionCountOutputType
   */


  export type ShoesDescriptionCountOutputType = {
    warranty: number
  }

  export type ShoesDescriptionCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    warranty?: boolean | ShoesDescriptionCountOutputTypeCountWarrantyArgs
  }

  // Custom InputTypes

  /**
   * ShoesDescriptionCountOutputType without action
   */
  export type ShoesDescriptionCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShoesDescriptionCountOutputType
     */
    select?: ShoesDescriptionCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ShoesDescriptionCountOutputType without action
   */
  export type ShoesDescriptionCountOutputTypeCountWarrantyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: WarrantyWhereInput
  }



  /**
   * Count Type WatchesDescriptionCountOutputType
   */


  export type WatchesDescriptionCountOutputType = {
    warranty: number
  }

  export type WatchesDescriptionCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    warranty?: boolean | WatchesDescriptionCountOutputTypeCountWarrantyArgs
  }

  // Custom InputTypes

  /**
   * WatchesDescriptionCountOutputType without action
   */
  export type WatchesDescriptionCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchesDescriptionCountOutputType
     */
    select?: WatchesDescriptionCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * WatchesDescriptionCountOutputType without action
   */
  export type WatchesDescriptionCountOutputTypeCountWarrantyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: WarrantyWhereInput
  }



  /**
   * Count Type SleeveTypeCountOutputType
   */


  export type SleeveTypeCountOutputType = {
    kurtasDescription: number
    innersDescription: number
    topDescription: number
  }

  export type SleeveTypeCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    kurtasDescription?: boolean | SleeveTypeCountOutputTypeCountKurtasDescriptionArgs
    innersDescription?: boolean | SleeveTypeCountOutputTypeCountInnersDescriptionArgs
    topDescription?: boolean | SleeveTypeCountOutputTypeCountTopDescriptionArgs
  }

  // Custom InputTypes

  /**
   * SleeveTypeCountOutputType without action
   */
  export type SleeveTypeCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SleeveTypeCountOutputType
     */
    select?: SleeveTypeCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * SleeveTypeCountOutputType without action
   */
  export type SleeveTypeCountOutputTypeCountKurtasDescriptionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: KurtasDescriptionWhereInput
  }


  /**
   * SleeveTypeCountOutputType without action
   */
  export type SleeveTypeCountOutputTypeCountInnersDescriptionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: InnersDescriptionWhereInput
  }


  /**
   * SleeveTypeCountOutputType without action
   */
  export type SleeveTypeCountOutputTypeCountTopDescriptionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: TopDescriptionWhereInput
  }



  /**
   * Count Type NeckTypeCountOutputType
   */


  export type NeckTypeCountOutputType = {
    kurtasDescription: number
    innersDescription: number
    topDescription: number
  }

  export type NeckTypeCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    kurtasDescription?: boolean | NeckTypeCountOutputTypeCountKurtasDescriptionArgs
    innersDescription?: boolean | NeckTypeCountOutputTypeCountInnersDescriptionArgs
    topDescription?: boolean | NeckTypeCountOutputTypeCountTopDescriptionArgs
  }

  // Custom InputTypes

  /**
   * NeckTypeCountOutputType without action
   */
  export type NeckTypeCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NeckTypeCountOutputType
     */
    select?: NeckTypeCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * NeckTypeCountOutputType without action
   */
  export type NeckTypeCountOutputTypeCountKurtasDescriptionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: KurtasDescriptionWhereInput
  }


  /**
   * NeckTypeCountOutputType without action
   */
  export type NeckTypeCountOutputTypeCountInnersDescriptionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: InnersDescriptionWhereInput
  }


  /**
   * NeckTypeCountOutputType without action
   */
  export type NeckTypeCountOutputTypeCountTopDescriptionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: TopDescriptionWhereInput
  }



  /**
   * Count Type KurtasLengthTypeCountOutputType
   */


  export type KurtasLengthTypeCountOutputType = {
    kurtasDescription: number
  }

  export type KurtasLengthTypeCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    kurtasDescription?: boolean | KurtasLengthTypeCountOutputTypeCountKurtasDescriptionArgs
  }

  // Custom InputTypes

  /**
   * KurtasLengthTypeCountOutputType without action
   */
  export type KurtasLengthTypeCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KurtasLengthTypeCountOutputType
     */
    select?: KurtasLengthTypeCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * KurtasLengthTypeCountOutputType without action
   */
  export type KurtasLengthTypeCountOutputTypeCountKurtasDescriptionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: KurtasDescriptionWhereInput
  }



  /**
   * Count Type TypesOfBottomCountOutputType
   */


  export type TypesOfBottomCountOutputType = {
    description: number
  }

  export type TypesOfBottomCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    description?: boolean | TypesOfBottomCountOutputTypeCountDescriptionArgs
  }

  // Custom InputTypes

  /**
   * TypesOfBottomCountOutputType without action
   */
  export type TypesOfBottomCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypesOfBottomCountOutputType
     */
    select?: TypesOfBottomCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * TypesOfBottomCountOutputType without action
   */
  export type TypesOfBottomCountOutputTypeCountDescriptionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: BottomDescriptionWhereInput
  }



  /**
   * Count Type TypesOfPleatsCountOutputType
   */


  export type TypesOfPleatsCountOutputType = {
    description: number
  }

  export type TypesOfPleatsCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    description?: boolean | TypesOfPleatsCountOutputTypeCountDescriptionArgs
  }

  // Custom InputTypes

  /**
   * TypesOfPleatsCountOutputType without action
   */
  export type TypesOfPleatsCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypesOfPleatsCountOutputType
     */
    select?: TypesOfPleatsCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * TypesOfPleatsCountOutputType without action
   */
  export type TypesOfPleatsCountOutputTypeCountDescriptionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: BottomDescriptionWhereInput
  }



  /**
   * Count Type TypesOfLengthBottomCountOutputType
   */


  export type TypesOfLengthBottomCountOutputType = {
    description: number
  }

  export type TypesOfLengthBottomCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    description?: boolean | TypesOfLengthBottomCountOutputTypeCountDescriptionArgs
  }

  // Custom InputTypes

  /**
   * TypesOfLengthBottomCountOutputType without action
   */
  export type TypesOfLengthBottomCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypesOfLengthBottomCountOutputType
     */
    select?: TypesOfLengthBottomCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * TypesOfLengthBottomCountOutputType without action
   */
  export type TypesOfLengthBottomCountOutputTypeCountDescriptionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: BottomDescriptionWhereInput
  }



  /**
   * Count Type OfferCountOutputType
   */


  export type OfferCountOutputType = {
    offerValidity: number
  }

  export type OfferCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    offerValidity?: boolean | OfferCountOutputTypeCountOfferValidityArgs
  }

  // Custom InputTypes

  /**
   * OfferCountOutputType without action
   */
  export type OfferCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferCountOutputType
     */
    select?: OfferCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * OfferCountOutputType without action
   */
  export type OfferCountOutputTypeCountOfferValidityArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OfferValidityWhereInput
  }



  /**
   * Count Type WishlistCountOutputType
   */


  export type WishlistCountOutputType = {
    items: number
  }

  export type WishlistCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    items?: boolean | WishlistCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes

  /**
   * WishlistCountOutputType without action
   */
  export type WishlistCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistCountOutputType
     */
    select?: WishlistCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * WishlistCountOutputType without action
   */
  export type WishlistCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: WishlistItemWhereInput
  }



  /**
   * Models
   */

  /**
   * Model Roles
   */


  export type AggregateRoles = {
    _count: RolesCountAggregateOutputType | null
    _avg: RolesAvgAggregateOutputType | null
    _sum: RolesSumAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  export type RolesAvgAggregateOutputType = {
    id: number | null
  }

  export type RolesSumAggregateOutputType = {
    id: number | null
  }

  export type RolesMinAggregateOutputType = {
    id: number | null
    name: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type RolesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type RolesCountAggregateOutputType = {
    id: number
    name: number
    isActive: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type RolesAvgAggregateInputType = {
    id?: true
  }

  export type RolesSumAggregateInputType = {
    id?: true
  }

  export type RolesMinAggregateInputType = {
    id?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type RolesMaxAggregateInputType = {
    id?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type RolesCountAggregateInputType = {
    id?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type RolesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to aggregate.
     */
    where?: RolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: Enumerable<RolesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolesMaxAggregateInputType
  }

  export type GetRolesAggregateType<T extends RolesAggregateArgs> = {
        [P in keyof T & keyof AggregateRoles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoles[P]>
      : GetScalarType<T[P], AggregateRoles[P]>
  }




  export type RolesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: RolesWhereInput
    orderBy?: Enumerable<RolesOrderByWithAggregationInput>
    by: RolesScalarFieldEnum[]
    having?: RolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolesCountAggregateInputType | true
    _avg?: RolesAvgAggregateInputType
    _sum?: RolesSumAggregateInputType
    _min?: RolesMinAggregateInputType
    _max?: RolesMaxAggregateInputType
  }


  export type RolesGroupByOutputType = {
    id: number
    name: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: RolesCountAggregateOutputType | null
    _avg: RolesAvgAggregateOutputType | null
    _sum: RolesSumAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  type GetRolesGroupByPayload<T extends RolesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<RolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolesGroupByOutputType[P]>
            : GetScalarType<T[P], RolesGroupByOutputType[P]>
        }
      >
    >


  export type RolesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | Roles$userArgs<ExtArgs>
    _count?: boolean | RolesCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["roles"]>

  export type RolesSelectScalar = {
    id?: boolean
    name?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type RolesInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | Roles$userArgs<ExtArgs>
    _count?: boolean | RolesCountOutputTypeArgs<ExtArgs>
  }


  type RolesGetPayload<S extends boolean | null | undefined | RolesArgs> = $Types.GetResult<RolesPayload, S>

  type RolesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<RolesFindManyArgs, 'select' | 'include'> & {
      select?: RolesCountAggregateInputType | true
    }

  export interface RolesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Roles'], meta: { name: 'Roles' } }
    /**
     * Find zero or one Roles that matches the filter.
     * @param {RolesFindUniqueArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RolesFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RolesFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Roles'> extends True ? Prisma__RolesClient<$Types.GetResult<RolesPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__RolesClient<$Types.GetResult<RolesPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Roles that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RolesFindUniqueOrThrowArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RolesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RolesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RolesClient<$Types.GetResult<RolesPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesFindFirstArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RolesFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RolesFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Roles'> extends True ? Prisma__RolesClient<$Types.GetResult<RolesPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__RolesClient<$Types.GetResult<RolesPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Roles that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesFindFirstOrThrowArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RolesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RolesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RolesClient<$Types.GetResult<RolesPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.roles.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.roles.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolesWithIdOnly = await prisma.roles.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RolesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RolesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<RolesPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Roles.
     * @param {RolesCreateArgs} args - Arguments to create a Roles.
     * @example
     * // Create one Roles
     * const Roles = await prisma.roles.create({
     *   data: {
     *     // ... data to create a Roles
     *   }
     * })
     * 
    **/
    create<T extends RolesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RolesCreateArgs<ExtArgs>>
    ): Prisma__RolesClient<$Types.GetResult<RolesPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Roles.
     *     @param {RolesCreateManyArgs} args - Arguments to create many Roles.
     *     @example
     *     // Create many Roles
     *     const roles = await prisma.roles.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RolesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RolesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Roles.
     * @param {RolesDeleteArgs} args - Arguments to delete one Roles.
     * @example
     * // Delete one Roles
     * const Roles = await prisma.roles.delete({
     *   where: {
     *     // ... filter to delete one Roles
     *   }
     * })
     * 
    **/
    delete<T extends RolesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RolesDeleteArgs<ExtArgs>>
    ): Prisma__RolesClient<$Types.GetResult<RolesPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Roles.
     * @param {RolesUpdateArgs} args - Arguments to update one Roles.
     * @example
     * // Update one Roles
     * const roles = await prisma.roles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RolesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RolesUpdateArgs<ExtArgs>>
    ): Prisma__RolesClient<$Types.GetResult<RolesPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Roles.
     * @param {RolesDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.roles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RolesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RolesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const roles = await prisma.roles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RolesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RolesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Roles.
     * @param {RolesUpsertArgs} args - Arguments to update or create a Roles.
     * @example
     * // Update or create a Roles
     * const roles = await prisma.roles.upsert({
     *   create: {
     *     // ... data to create a Roles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Roles we want to update
     *   }
     * })
    **/
    upsert<T extends RolesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RolesUpsertArgs<ExtArgs>>
    ): Prisma__RolesClient<$Types.GetResult<RolesPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.roles.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RolesCountArgs>(
      args?: Subset<T, RolesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolesAggregateArgs>(args: Subset<T, RolesAggregateArgs>): Prisma.PrismaPromise<GetRolesAggregateType<T>>

    /**
     * Group by Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolesGroupByArgs['orderBy'] }
        : { orderBy?: RolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Roles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RolesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends Roles$userArgs<ExtArgs> = {}>(args?: Subset<T, Roles$userArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<UserPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Roles base type for findUnique actions
   */
  export type RolesFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where: RolesWhereUniqueInput
  }

  /**
   * Roles findUnique
   */
  export interface RolesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends RolesFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Roles findUniqueOrThrow
   */
  export type RolesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where: RolesWhereUniqueInput
  }


  /**
   * Roles base type for findFirst actions
   */
  export type RolesFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: Enumerable<RolesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: Enumerable<RolesScalarFieldEnum>
  }

  /**
   * Roles findFirst
   */
  export interface RolesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends RolesFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Roles findFirstOrThrow
   */
  export type RolesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: Enumerable<RolesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: Enumerable<RolesScalarFieldEnum>
  }


  /**
   * Roles findMany
   */
  export type RolesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: Enumerable<RolesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: Enumerable<RolesScalarFieldEnum>
  }


  /**
   * Roles create
   */
  export type RolesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * The data needed to create a Roles.
     */
    data: XOR<RolesCreateInput, RolesUncheckedCreateInput>
  }


  /**
   * Roles createMany
   */
  export type RolesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: Enumerable<RolesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Roles update
   */
  export type RolesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * The data needed to update a Roles.
     */
    data: XOR<RolesUpdateInput, RolesUncheckedUpdateInput>
    /**
     * Choose, which Roles to update.
     */
    where: RolesWhereUniqueInput
  }


  /**
   * Roles updateMany
   */
  export type RolesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RolesUpdateManyMutationInput, RolesUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RolesWhereInput
  }


  /**
   * Roles upsert
   */
  export type RolesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * The filter to search for the Roles to update in case it exists.
     */
    where: RolesWhereUniqueInput
    /**
     * In case the Roles found by the `where` argument doesn't exist, create a new Roles with this data.
     */
    create: XOR<RolesCreateInput, RolesUncheckedCreateInput>
    /**
     * In case the Roles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RolesUpdateInput, RolesUncheckedUpdateInput>
  }


  /**
   * Roles delete
   */
  export type RolesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * Filter which Roles to delete.
     */
    where: RolesWhereUniqueInput
  }


  /**
   * Roles deleteMany
   */
  export type RolesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RolesWhereInput
  }


  /**
   * Roles.user
   */
  export type Roles$userArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * Roles without action
   */
  export type RolesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RolesInclude<ExtArgs> | null
  }



  /**
   * Model SyncDataLastId
   */


  export type AggregateSyncDataLastId = {
    _count: SyncDataLastIdCountAggregateOutputType | null
    _avg: SyncDataLastIdAvgAggregateOutputType | null
    _sum: SyncDataLastIdSumAggregateOutputType | null
    _min: SyncDataLastIdMinAggregateOutputType | null
    _max: SyncDataLastIdMaxAggregateOutputType | null
  }

  export type SyncDataLastIdAvgAggregateOutputType = {
    id: number | null
    lastId: number | null
  }

  export type SyncDataLastIdSumAggregateOutputType = {
    id: number | null
    lastId: number | null
  }

  export type SyncDataLastIdMinAggregateOutputType = {
    id: number | null
    lastId: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type SyncDataLastIdMaxAggregateOutputType = {
    id: number | null
    lastId: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type SyncDataLastIdCountAggregateOutputType = {
    id: number
    lastId: number
    isActive: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type SyncDataLastIdAvgAggregateInputType = {
    id?: true
    lastId?: true
  }

  export type SyncDataLastIdSumAggregateInputType = {
    id?: true
    lastId?: true
  }

  export type SyncDataLastIdMinAggregateInputType = {
    id?: true
    lastId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type SyncDataLastIdMaxAggregateInputType = {
    id?: true
    lastId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type SyncDataLastIdCountAggregateInputType = {
    id?: true
    lastId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type SyncDataLastIdAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which SyncDataLastId to aggregate.
     */
    where?: SyncDataLastIdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncDataLastIds to fetch.
     */
    orderBy?: Enumerable<SyncDataLastIdOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SyncDataLastIdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncDataLastIds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncDataLastIds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SyncDataLastIds
    **/
    _count?: true | SyncDataLastIdCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SyncDataLastIdAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SyncDataLastIdSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SyncDataLastIdMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SyncDataLastIdMaxAggregateInputType
  }

  export type GetSyncDataLastIdAggregateType<T extends SyncDataLastIdAggregateArgs> = {
        [P in keyof T & keyof AggregateSyncDataLastId]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSyncDataLastId[P]>
      : GetScalarType<T[P], AggregateSyncDataLastId[P]>
  }




  export type SyncDataLastIdGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: SyncDataLastIdWhereInput
    orderBy?: Enumerable<SyncDataLastIdOrderByWithAggregationInput>
    by: SyncDataLastIdScalarFieldEnum[]
    having?: SyncDataLastIdScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SyncDataLastIdCountAggregateInputType | true
    _avg?: SyncDataLastIdAvgAggregateInputType
    _sum?: SyncDataLastIdSumAggregateInputType
    _min?: SyncDataLastIdMinAggregateInputType
    _max?: SyncDataLastIdMaxAggregateInputType
  }


  export type SyncDataLastIdGroupByOutputType = {
    id: number
    lastId: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: SyncDataLastIdCountAggregateOutputType | null
    _avg: SyncDataLastIdAvgAggregateOutputType | null
    _sum: SyncDataLastIdSumAggregateOutputType | null
    _min: SyncDataLastIdMinAggregateOutputType | null
    _max: SyncDataLastIdMaxAggregateOutputType | null
  }

  type GetSyncDataLastIdGroupByPayload<T extends SyncDataLastIdGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<SyncDataLastIdGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SyncDataLastIdGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SyncDataLastIdGroupByOutputType[P]>
            : GetScalarType<T[P], SyncDataLastIdGroupByOutputType[P]>
        }
      >
    >


  export type SyncDataLastIdSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lastId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["syncDataLastId"]>

  export type SyncDataLastIdSelectScalar = {
    id?: boolean
    lastId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }


  type SyncDataLastIdGetPayload<S extends boolean | null | undefined | SyncDataLastIdArgs> = $Types.GetResult<SyncDataLastIdPayload, S>

  type SyncDataLastIdCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<SyncDataLastIdFindManyArgs, 'select' | 'include'> & {
      select?: SyncDataLastIdCountAggregateInputType | true
    }

  export interface SyncDataLastIdDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SyncDataLastId'], meta: { name: 'SyncDataLastId' } }
    /**
     * Find zero or one SyncDataLastId that matches the filter.
     * @param {SyncDataLastIdFindUniqueArgs} args - Arguments to find a SyncDataLastId
     * @example
     * // Get one SyncDataLastId
     * const syncDataLastId = await prisma.syncDataLastId.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SyncDataLastIdFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SyncDataLastIdFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SyncDataLastId'> extends True ? Prisma__SyncDataLastIdClient<$Types.GetResult<SyncDataLastIdPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__SyncDataLastIdClient<$Types.GetResult<SyncDataLastIdPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one SyncDataLastId that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SyncDataLastIdFindUniqueOrThrowArgs} args - Arguments to find a SyncDataLastId
     * @example
     * // Get one SyncDataLastId
     * const syncDataLastId = await prisma.syncDataLastId.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SyncDataLastIdFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SyncDataLastIdFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SyncDataLastIdClient<$Types.GetResult<SyncDataLastIdPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first SyncDataLastId that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncDataLastIdFindFirstArgs} args - Arguments to find a SyncDataLastId
     * @example
     * // Get one SyncDataLastId
     * const syncDataLastId = await prisma.syncDataLastId.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SyncDataLastIdFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SyncDataLastIdFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SyncDataLastId'> extends True ? Prisma__SyncDataLastIdClient<$Types.GetResult<SyncDataLastIdPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__SyncDataLastIdClient<$Types.GetResult<SyncDataLastIdPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first SyncDataLastId that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncDataLastIdFindFirstOrThrowArgs} args - Arguments to find a SyncDataLastId
     * @example
     * // Get one SyncDataLastId
     * const syncDataLastId = await prisma.syncDataLastId.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SyncDataLastIdFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SyncDataLastIdFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SyncDataLastIdClient<$Types.GetResult<SyncDataLastIdPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more SyncDataLastIds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncDataLastIdFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SyncDataLastIds
     * const syncDataLastIds = await prisma.syncDataLastId.findMany()
     * 
     * // Get first 10 SyncDataLastIds
     * const syncDataLastIds = await prisma.syncDataLastId.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const syncDataLastIdWithIdOnly = await prisma.syncDataLastId.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SyncDataLastIdFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SyncDataLastIdFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<SyncDataLastIdPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a SyncDataLastId.
     * @param {SyncDataLastIdCreateArgs} args - Arguments to create a SyncDataLastId.
     * @example
     * // Create one SyncDataLastId
     * const SyncDataLastId = await prisma.syncDataLastId.create({
     *   data: {
     *     // ... data to create a SyncDataLastId
     *   }
     * })
     * 
    **/
    create<T extends SyncDataLastIdCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SyncDataLastIdCreateArgs<ExtArgs>>
    ): Prisma__SyncDataLastIdClient<$Types.GetResult<SyncDataLastIdPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many SyncDataLastIds.
     *     @param {SyncDataLastIdCreateManyArgs} args - Arguments to create many SyncDataLastIds.
     *     @example
     *     // Create many SyncDataLastIds
     *     const syncDataLastId = await prisma.syncDataLastId.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SyncDataLastIdCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SyncDataLastIdCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SyncDataLastId.
     * @param {SyncDataLastIdDeleteArgs} args - Arguments to delete one SyncDataLastId.
     * @example
     * // Delete one SyncDataLastId
     * const SyncDataLastId = await prisma.syncDataLastId.delete({
     *   where: {
     *     // ... filter to delete one SyncDataLastId
     *   }
     * })
     * 
    **/
    delete<T extends SyncDataLastIdDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SyncDataLastIdDeleteArgs<ExtArgs>>
    ): Prisma__SyncDataLastIdClient<$Types.GetResult<SyncDataLastIdPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one SyncDataLastId.
     * @param {SyncDataLastIdUpdateArgs} args - Arguments to update one SyncDataLastId.
     * @example
     * // Update one SyncDataLastId
     * const syncDataLastId = await prisma.syncDataLastId.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SyncDataLastIdUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SyncDataLastIdUpdateArgs<ExtArgs>>
    ): Prisma__SyncDataLastIdClient<$Types.GetResult<SyncDataLastIdPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more SyncDataLastIds.
     * @param {SyncDataLastIdDeleteManyArgs} args - Arguments to filter SyncDataLastIds to delete.
     * @example
     * // Delete a few SyncDataLastIds
     * const { count } = await prisma.syncDataLastId.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SyncDataLastIdDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SyncDataLastIdDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SyncDataLastIds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncDataLastIdUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SyncDataLastIds
     * const syncDataLastId = await prisma.syncDataLastId.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SyncDataLastIdUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SyncDataLastIdUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SyncDataLastId.
     * @param {SyncDataLastIdUpsertArgs} args - Arguments to update or create a SyncDataLastId.
     * @example
     * // Update or create a SyncDataLastId
     * const syncDataLastId = await prisma.syncDataLastId.upsert({
     *   create: {
     *     // ... data to create a SyncDataLastId
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SyncDataLastId we want to update
     *   }
     * })
    **/
    upsert<T extends SyncDataLastIdUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SyncDataLastIdUpsertArgs<ExtArgs>>
    ): Prisma__SyncDataLastIdClient<$Types.GetResult<SyncDataLastIdPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of SyncDataLastIds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncDataLastIdCountArgs} args - Arguments to filter SyncDataLastIds to count.
     * @example
     * // Count the number of SyncDataLastIds
     * const count = await prisma.syncDataLastId.count({
     *   where: {
     *     // ... the filter for the SyncDataLastIds we want to count
     *   }
     * })
    **/
    count<T extends SyncDataLastIdCountArgs>(
      args?: Subset<T, SyncDataLastIdCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SyncDataLastIdCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SyncDataLastId.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncDataLastIdAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SyncDataLastIdAggregateArgs>(args: Subset<T, SyncDataLastIdAggregateArgs>): Prisma.PrismaPromise<GetSyncDataLastIdAggregateType<T>>

    /**
     * Group by SyncDataLastId.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncDataLastIdGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SyncDataLastIdGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SyncDataLastIdGroupByArgs['orderBy'] }
        : { orderBy?: SyncDataLastIdGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SyncDataLastIdGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSyncDataLastIdGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for SyncDataLastId.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SyncDataLastIdClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * SyncDataLastId base type for findUnique actions
   */
  export type SyncDataLastIdFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncDataLastId
     */
    select?: SyncDataLastIdSelect<ExtArgs> | null
    /**
     * Filter, which SyncDataLastId to fetch.
     */
    where: SyncDataLastIdWhereUniqueInput
  }

  /**
   * SyncDataLastId findUnique
   */
  export interface SyncDataLastIdFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends SyncDataLastIdFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SyncDataLastId findUniqueOrThrow
   */
  export type SyncDataLastIdFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncDataLastId
     */
    select?: SyncDataLastIdSelect<ExtArgs> | null
    /**
     * Filter, which SyncDataLastId to fetch.
     */
    where: SyncDataLastIdWhereUniqueInput
  }


  /**
   * SyncDataLastId base type for findFirst actions
   */
  export type SyncDataLastIdFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncDataLastId
     */
    select?: SyncDataLastIdSelect<ExtArgs> | null
    /**
     * Filter, which SyncDataLastId to fetch.
     */
    where?: SyncDataLastIdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncDataLastIds to fetch.
     */
    orderBy?: Enumerable<SyncDataLastIdOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SyncDataLastIds.
     */
    cursor?: SyncDataLastIdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncDataLastIds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncDataLastIds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SyncDataLastIds.
     */
    distinct?: Enumerable<SyncDataLastIdScalarFieldEnum>
  }

  /**
   * SyncDataLastId findFirst
   */
  export interface SyncDataLastIdFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends SyncDataLastIdFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SyncDataLastId findFirstOrThrow
   */
  export type SyncDataLastIdFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncDataLastId
     */
    select?: SyncDataLastIdSelect<ExtArgs> | null
    /**
     * Filter, which SyncDataLastId to fetch.
     */
    where?: SyncDataLastIdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncDataLastIds to fetch.
     */
    orderBy?: Enumerable<SyncDataLastIdOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SyncDataLastIds.
     */
    cursor?: SyncDataLastIdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncDataLastIds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncDataLastIds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SyncDataLastIds.
     */
    distinct?: Enumerable<SyncDataLastIdScalarFieldEnum>
  }


  /**
   * SyncDataLastId findMany
   */
  export type SyncDataLastIdFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncDataLastId
     */
    select?: SyncDataLastIdSelect<ExtArgs> | null
    /**
     * Filter, which SyncDataLastIds to fetch.
     */
    where?: SyncDataLastIdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncDataLastIds to fetch.
     */
    orderBy?: Enumerable<SyncDataLastIdOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SyncDataLastIds.
     */
    cursor?: SyncDataLastIdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncDataLastIds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncDataLastIds.
     */
    skip?: number
    distinct?: Enumerable<SyncDataLastIdScalarFieldEnum>
  }


  /**
   * SyncDataLastId create
   */
  export type SyncDataLastIdCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncDataLastId
     */
    select?: SyncDataLastIdSelect<ExtArgs> | null
    /**
     * The data needed to create a SyncDataLastId.
     */
    data: XOR<SyncDataLastIdCreateInput, SyncDataLastIdUncheckedCreateInput>
  }


  /**
   * SyncDataLastId createMany
   */
  export type SyncDataLastIdCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SyncDataLastIds.
     */
    data: Enumerable<SyncDataLastIdCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SyncDataLastId update
   */
  export type SyncDataLastIdUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncDataLastId
     */
    select?: SyncDataLastIdSelect<ExtArgs> | null
    /**
     * The data needed to update a SyncDataLastId.
     */
    data: XOR<SyncDataLastIdUpdateInput, SyncDataLastIdUncheckedUpdateInput>
    /**
     * Choose, which SyncDataLastId to update.
     */
    where: SyncDataLastIdWhereUniqueInput
  }


  /**
   * SyncDataLastId updateMany
   */
  export type SyncDataLastIdUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SyncDataLastIds.
     */
    data: XOR<SyncDataLastIdUpdateManyMutationInput, SyncDataLastIdUncheckedUpdateManyInput>
    /**
     * Filter which SyncDataLastIds to update
     */
    where?: SyncDataLastIdWhereInput
  }


  /**
   * SyncDataLastId upsert
   */
  export type SyncDataLastIdUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncDataLastId
     */
    select?: SyncDataLastIdSelect<ExtArgs> | null
    /**
     * The filter to search for the SyncDataLastId to update in case it exists.
     */
    where: SyncDataLastIdWhereUniqueInput
    /**
     * In case the SyncDataLastId found by the `where` argument doesn't exist, create a new SyncDataLastId with this data.
     */
    create: XOR<SyncDataLastIdCreateInput, SyncDataLastIdUncheckedCreateInput>
    /**
     * In case the SyncDataLastId was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SyncDataLastIdUpdateInput, SyncDataLastIdUncheckedUpdateInput>
  }


  /**
   * SyncDataLastId delete
   */
  export type SyncDataLastIdDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncDataLastId
     */
    select?: SyncDataLastIdSelect<ExtArgs> | null
    /**
     * Filter which SyncDataLastId to delete.
     */
    where: SyncDataLastIdWhereUniqueInput
  }


  /**
   * SyncDataLastId deleteMany
   */
  export type SyncDataLastIdDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which SyncDataLastIds to delete
     */
    where?: SyncDataLastIdWhereInput
  }


  /**
   * SyncDataLastId without action
   */
  export type SyncDataLastIdArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncDataLastId
     */
    select?: SyncDataLastIdSelect<ExtArgs> | null
  }



  /**
   * Model ProductCategory
   */


  export type AggregateProductCategory = {
    _count: ProductCategoryCountAggregateOutputType | null
    _avg: ProductCategoryAvgAggregateOutputType | null
    _sum: ProductCategorySumAggregateOutputType | null
    _min: ProductCategoryMinAggregateOutputType | null
    _max: ProductCategoryMaxAggregateOutputType | null
  }

  export type ProductCategoryAvgAggregateOutputType = {
    id: number | null
    genderId: number | null
  }

  export type ProductCategorySumAggregateOutputType = {
    id: number | null
    genderId: number | null
  }

  export type ProductCategoryMinAggregateOutputType = {
    id: number | null
    name: string | null
    genderId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ProductCategoryMaxAggregateOutputType = {
    id: number | null
    name: string | null
    genderId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ProductCategoryCountAggregateOutputType = {
    id: number
    name: number
    genderId: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type ProductCategoryAvgAggregateInputType = {
    id?: true
    genderId?: true
  }

  export type ProductCategorySumAggregateInputType = {
    id?: true
    genderId?: true
  }

  export type ProductCategoryMinAggregateInputType = {
    id?: true
    name?: true
    genderId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ProductCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    genderId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ProductCategoryCountAggregateInputType = {
    id?: true
    name?: true
    genderId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type ProductCategoryAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductCategory to aggregate.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: Enumerable<ProductCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductCategories
    **/
    _count?: true | ProductCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductCategoryMaxAggregateInputType
  }

  export type GetProductCategoryAggregateType<T extends ProductCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateProductCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductCategory[P]>
      : GetScalarType<T[P], AggregateProductCategory[P]>
  }




  export type ProductCategoryGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ProductCategoryWhereInput
    orderBy?: Enumerable<ProductCategoryOrderByWithAggregationInput>
    by: ProductCategoryScalarFieldEnum[]
    having?: ProductCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCategoryCountAggregateInputType | true
    _avg?: ProductCategoryAvgAggregateInputType
    _sum?: ProductCategorySumAggregateInputType
    _min?: ProductCategoryMinAggregateInputType
    _max?: ProductCategoryMaxAggregateInputType
  }


  export type ProductCategoryGroupByOutputType = {
    id: number
    name: string
    genderId: number
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: ProductCategoryCountAggregateOutputType | null
    _avg: ProductCategoryAvgAggregateOutputType | null
    _sum: ProductCategorySumAggregateOutputType | null
    _min: ProductCategoryMinAggregateOutputType | null
    _max: ProductCategoryMaxAggregateOutputType | null
  }

  type GetProductCategoryGroupByPayload<T extends ProductCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ProductCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ProductCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ProductCategorySelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    genderId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    gender?: boolean | GenderArgs<ExtArgs>
    productType?: boolean | ProductCategory$productTypeArgs<ExtArgs>
    _count?: boolean | ProductCategoryCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["productCategory"]>

  export type ProductCategorySelectScalar = {
    id?: boolean
    name?: boolean
    genderId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type ProductCategoryInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    gender?: boolean | GenderArgs<ExtArgs>
    productType?: boolean | ProductCategory$productTypeArgs<ExtArgs>
    _count?: boolean | ProductCategoryCountOutputTypeArgs<ExtArgs>
  }


  type ProductCategoryGetPayload<S extends boolean | null | undefined | ProductCategoryArgs> = $Types.GetResult<ProductCategoryPayload, S>

  type ProductCategoryCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ProductCategoryFindManyArgs, 'select' | 'include'> & {
      select?: ProductCategoryCountAggregateInputType | true
    }

  export interface ProductCategoryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductCategory'], meta: { name: 'ProductCategory' } }
    /**
     * Find zero or one ProductCategory that matches the filter.
     * @param {ProductCategoryFindUniqueArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductCategoryFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductCategoryFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ProductCategory'> extends True ? Prisma__ProductCategoryClient<$Types.GetResult<ProductCategoryPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ProductCategoryClient<$Types.GetResult<ProductCategoryPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one ProductCategory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProductCategoryFindUniqueOrThrowArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProductCategoryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductCategoryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProductCategoryClient<$Types.GetResult<ProductCategoryPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first ProductCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryFindFirstArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductCategoryFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductCategoryFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ProductCategory'> extends True ? Prisma__ProductCategoryClient<$Types.GetResult<ProductCategoryPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ProductCategoryClient<$Types.GetResult<ProductCategoryPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first ProductCategory that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryFindFirstOrThrowArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProductCategoryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductCategoryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProductCategoryClient<$Types.GetResult<ProductCategoryPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more ProductCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductCategories
     * const productCategories = await prisma.productCategory.findMany()
     * 
     * // Get first 10 ProductCategories
     * const productCategories = await prisma.productCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productCategoryWithIdOnly = await prisma.productCategory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductCategoryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductCategoryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ProductCategoryPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a ProductCategory.
     * @param {ProductCategoryCreateArgs} args - Arguments to create a ProductCategory.
     * @example
     * // Create one ProductCategory
     * const ProductCategory = await prisma.productCategory.create({
     *   data: {
     *     // ... data to create a ProductCategory
     *   }
     * })
     * 
    **/
    create<T extends ProductCategoryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductCategoryCreateArgs<ExtArgs>>
    ): Prisma__ProductCategoryClient<$Types.GetResult<ProductCategoryPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many ProductCategories.
     *     @param {ProductCategoryCreateManyArgs} args - Arguments to create many ProductCategories.
     *     @example
     *     // Create many ProductCategories
     *     const productCategory = await prisma.productCategory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductCategoryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductCategoryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProductCategory.
     * @param {ProductCategoryDeleteArgs} args - Arguments to delete one ProductCategory.
     * @example
     * // Delete one ProductCategory
     * const ProductCategory = await prisma.productCategory.delete({
     *   where: {
     *     // ... filter to delete one ProductCategory
     *   }
     * })
     * 
    **/
    delete<T extends ProductCategoryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ProductCategoryDeleteArgs<ExtArgs>>
    ): Prisma__ProductCategoryClient<$Types.GetResult<ProductCategoryPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one ProductCategory.
     * @param {ProductCategoryUpdateArgs} args - Arguments to update one ProductCategory.
     * @example
     * // Update one ProductCategory
     * const productCategory = await prisma.productCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductCategoryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductCategoryUpdateArgs<ExtArgs>>
    ): Prisma__ProductCategoryClient<$Types.GetResult<ProductCategoryPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more ProductCategories.
     * @param {ProductCategoryDeleteManyArgs} args - Arguments to filter ProductCategories to delete.
     * @example
     * // Delete a few ProductCategories
     * const { count } = await prisma.productCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductCategoryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductCategoryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductCategories
     * const productCategory = await prisma.productCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductCategoryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ProductCategoryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductCategory.
     * @param {ProductCategoryUpsertArgs} args - Arguments to update or create a ProductCategory.
     * @example
     * // Update or create a ProductCategory
     * const productCategory = await prisma.productCategory.upsert({
     *   create: {
     *     // ... data to create a ProductCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductCategory we want to update
     *   }
     * })
    **/
    upsert<T extends ProductCategoryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ProductCategoryUpsertArgs<ExtArgs>>
    ): Prisma__ProductCategoryClient<$Types.GetResult<ProductCategoryPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of ProductCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryCountArgs} args - Arguments to filter ProductCategories to count.
     * @example
     * // Count the number of ProductCategories
     * const count = await prisma.productCategory.count({
     *   where: {
     *     // ... the filter for the ProductCategories we want to count
     *   }
     * })
    **/
    count<T extends ProductCategoryCountArgs>(
      args?: Subset<T, ProductCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductCategoryAggregateArgs>(args: Subset<T, ProductCategoryAggregateArgs>): Prisma.PrismaPromise<GetProductCategoryAggregateType<T>>

    /**
     * Group by ProductCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ProductCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductCategoryClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    gender<T extends GenderArgs<ExtArgs> = {}>(args?: Subset<T, GenderArgs<ExtArgs>>): Prisma__GenderClient<$Types.GetResult<GenderPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    productType<T extends ProductCategory$productTypeArgs<ExtArgs> = {}>(args?: Subset<T, ProductCategory$productTypeArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ProductTypePayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ProductCategory base type for findUnique actions
   */
  export type ProductCategoryFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory findUnique
   */
  export interface ProductCategoryFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ProductCategoryFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProductCategory findUniqueOrThrow
   */
  export type ProductCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where: ProductCategoryWhereUniqueInput
  }


  /**
   * ProductCategory base type for findFirst actions
   */
  export type ProductCategoryFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: Enumerable<ProductCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductCategories.
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductCategories.
     */
    distinct?: Enumerable<ProductCategoryScalarFieldEnum>
  }

  /**
   * ProductCategory findFirst
   */
  export interface ProductCategoryFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ProductCategoryFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProductCategory findFirstOrThrow
   */
  export type ProductCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: Enumerable<ProductCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductCategories.
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductCategories.
     */
    distinct?: Enumerable<ProductCategoryScalarFieldEnum>
  }


  /**
   * ProductCategory findMany
   */
  export type ProductCategoryFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategories to fetch.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: Enumerable<ProductCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductCategories.
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    distinct?: Enumerable<ProductCategoryScalarFieldEnum>
  }


  /**
   * ProductCategory create
   */
  export type ProductCategoryCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductCategory.
     */
    data: XOR<ProductCategoryCreateInput, ProductCategoryUncheckedCreateInput>
  }


  /**
   * ProductCategory createMany
   */
  export type ProductCategoryCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductCategories.
     */
    data: Enumerable<ProductCategoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ProductCategory update
   */
  export type ProductCategoryUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductCategory.
     */
    data: XOR<ProductCategoryUpdateInput, ProductCategoryUncheckedUpdateInput>
    /**
     * Choose, which ProductCategory to update.
     */
    where: ProductCategoryWhereUniqueInput
  }


  /**
   * ProductCategory updateMany
   */
  export type ProductCategoryUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductCategories.
     */
    data: XOR<ProductCategoryUpdateManyMutationInput, ProductCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ProductCategories to update
     */
    where?: ProductCategoryWhereInput
  }


  /**
   * ProductCategory upsert
   */
  export type ProductCategoryUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductCategory to update in case it exists.
     */
    where: ProductCategoryWhereUniqueInput
    /**
     * In case the ProductCategory found by the `where` argument doesn't exist, create a new ProductCategory with this data.
     */
    create: XOR<ProductCategoryCreateInput, ProductCategoryUncheckedCreateInput>
    /**
     * In case the ProductCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductCategoryUpdateInput, ProductCategoryUncheckedUpdateInput>
  }


  /**
   * ProductCategory delete
   */
  export type ProductCategoryDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter which ProductCategory to delete.
     */
    where: ProductCategoryWhereUniqueInput
  }


  /**
   * ProductCategory deleteMany
   */
  export type ProductCategoryDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductCategories to delete
     */
    where?: ProductCategoryWhereInput
  }


  /**
   * ProductCategory.productType
   */
  export type ProductCategory$productTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductType
     */
    select?: ProductTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductTypeInclude<ExtArgs> | null
    where?: ProductTypeWhereInput
    orderBy?: Enumerable<ProductTypeOrderByWithRelationInput>
    cursor?: ProductTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ProductTypeScalarFieldEnum>
  }


  /**
   * ProductCategory without action
   */
  export type ProductCategoryArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductCategoryInclude<ExtArgs> | null
  }



  /**
   * Model ProductType
   */


  export type AggregateProductType = {
    _count: ProductTypeCountAggregateOutputType | null
    _avg: ProductTypeAvgAggregateOutputType | null
    _sum: ProductTypeSumAggregateOutputType | null
    _min: ProductTypeMinAggregateOutputType | null
    _max: ProductTypeMaxAggregateOutputType | null
  }

  export type ProductTypeAvgAggregateOutputType = {
    id: number | null
    productCategoryId: number | null
  }

  export type ProductTypeSumAggregateOutputType = {
    id: number | null
    productCategoryId: number | null
  }

  export type ProductTypeMinAggregateOutputType = {
    id: number | null
    itemsName: string | null
    productCategoryId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ProductTypeMaxAggregateOutputType = {
    id: number | null
    itemsName: string | null
    productCategoryId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ProductTypeCountAggregateOutputType = {
    id: number
    itemsName: number
    productCategoryId: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type ProductTypeAvgAggregateInputType = {
    id?: true
    productCategoryId?: true
  }

  export type ProductTypeSumAggregateInputType = {
    id?: true
    productCategoryId?: true
  }

  export type ProductTypeMinAggregateInputType = {
    id?: true
    itemsName?: true
    productCategoryId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ProductTypeMaxAggregateInputType = {
    id?: true
    itemsName?: true
    productCategoryId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ProductTypeCountAggregateInputType = {
    id?: true
    itemsName?: true
    productCategoryId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type ProductTypeAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductType to aggregate.
     */
    where?: ProductTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductTypes to fetch.
     */
    orderBy?: Enumerable<ProductTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductTypes
    **/
    _count?: true | ProductTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductTypeMaxAggregateInputType
  }

  export type GetProductTypeAggregateType<T extends ProductTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateProductType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductType[P]>
      : GetScalarType<T[P], AggregateProductType[P]>
  }




  export type ProductTypeGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ProductTypeWhereInput
    orderBy?: Enumerable<ProductTypeOrderByWithAggregationInput>
    by: ProductTypeScalarFieldEnum[]
    having?: ProductTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductTypeCountAggregateInputType | true
    _avg?: ProductTypeAvgAggregateInputType
    _sum?: ProductTypeSumAggregateInputType
    _min?: ProductTypeMinAggregateInputType
    _max?: ProductTypeMaxAggregateInputType
  }


  export type ProductTypeGroupByOutputType = {
    id: number
    itemsName: string
    productCategoryId: number
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: ProductTypeCountAggregateOutputType | null
    _avg: ProductTypeAvgAggregateOutputType | null
    _sum: ProductTypeSumAggregateOutputType | null
    _min: ProductTypeMinAggregateOutputType | null
    _max: ProductTypeMaxAggregateOutputType | null
  }

  type GetProductTypeGroupByPayload<T extends ProductTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ProductTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductTypeGroupByOutputType[P]>
            : GetScalarType<T[P], ProductTypeGroupByOutputType[P]>
        }
      >
    >


  export type ProductTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemsName?: boolean
    productCategoryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    ProductCategory?: boolean | ProductCategoryArgs<ExtArgs>
    sizes?: boolean | ProductType$sizesArgs<ExtArgs>
    product?: boolean | ProductType$productArgs<ExtArgs>
    _count?: boolean | ProductTypeCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["productType"]>

  export type ProductTypeSelectScalar = {
    id?: boolean
    itemsName?: boolean
    productCategoryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type ProductTypeInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    ProductCategory?: boolean | ProductCategoryArgs<ExtArgs>
    sizes?: boolean | ProductType$sizesArgs<ExtArgs>
    product?: boolean | ProductType$productArgs<ExtArgs>
    _count?: boolean | ProductTypeCountOutputTypeArgs<ExtArgs>
  }


  type ProductTypeGetPayload<S extends boolean | null | undefined | ProductTypeArgs> = $Types.GetResult<ProductTypePayload, S>

  type ProductTypeCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ProductTypeFindManyArgs, 'select' | 'include'> & {
      select?: ProductTypeCountAggregateInputType | true
    }

  export interface ProductTypeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductType'], meta: { name: 'ProductType' } }
    /**
     * Find zero or one ProductType that matches the filter.
     * @param {ProductTypeFindUniqueArgs} args - Arguments to find a ProductType
     * @example
     * // Get one ProductType
     * const productType = await prisma.productType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductTypeFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductTypeFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ProductType'> extends True ? Prisma__ProductTypeClient<$Types.GetResult<ProductTypePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ProductTypeClient<$Types.GetResult<ProductTypePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one ProductType that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProductTypeFindUniqueOrThrowArgs} args - Arguments to find a ProductType
     * @example
     * // Get one ProductType
     * const productType = await prisma.productType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProductTypeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductTypeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProductTypeClient<$Types.GetResult<ProductTypePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first ProductType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTypeFindFirstArgs} args - Arguments to find a ProductType
     * @example
     * // Get one ProductType
     * const productType = await prisma.productType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductTypeFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductTypeFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ProductType'> extends True ? Prisma__ProductTypeClient<$Types.GetResult<ProductTypePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ProductTypeClient<$Types.GetResult<ProductTypePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first ProductType that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTypeFindFirstOrThrowArgs} args - Arguments to find a ProductType
     * @example
     * // Get one ProductType
     * const productType = await prisma.productType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProductTypeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductTypeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProductTypeClient<$Types.GetResult<ProductTypePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more ProductTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTypeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductTypes
     * const productTypes = await prisma.productType.findMany()
     * 
     * // Get first 10 ProductTypes
     * const productTypes = await prisma.productType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productTypeWithIdOnly = await prisma.productType.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductTypeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductTypeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ProductTypePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a ProductType.
     * @param {ProductTypeCreateArgs} args - Arguments to create a ProductType.
     * @example
     * // Create one ProductType
     * const ProductType = await prisma.productType.create({
     *   data: {
     *     // ... data to create a ProductType
     *   }
     * })
     * 
    **/
    create<T extends ProductTypeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductTypeCreateArgs<ExtArgs>>
    ): Prisma__ProductTypeClient<$Types.GetResult<ProductTypePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many ProductTypes.
     *     @param {ProductTypeCreateManyArgs} args - Arguments to create many ProductTypes.
     *     @example
     *     // Create many ProductTypes
     *     const productType = await prisma.productType.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductTypeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductTypeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProductType.
     * @param {ProductTypeDeleteArgs} args - Arguments to delete one ProductType.
     * @example
     * // Delete one ProductType
     * const ProductType = await prisma.productType.delete({
     *   where: {
     *     // ... filter to delete one ProductType
     *   }
     * })
     * 
    **/
    delete<T extends ProductTypeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ProductTypeDeleteArgs<ExtArgs>>
    ): Prisma__ProductTypeClient<$Types.GetResult<ProductTypePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one ProductType.
     * @param {ProductTypeUpdateArgs} args - Arguments to update one ProductType.
     * @example
     * // Update one ProductType
     * const productType = await prisma.productType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductTypeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductTypeUpdateArgs<ExtArgs>>
    ): Prisma__ProductTypeClient<$Types.GetResult<ProductTypePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more ProductTypes.
     * @param {ProductTypeDeleteManyArgs} args - Arguments to filter ProductTypes to delete.
     * @example
     * // Delete a few ProductTypes
     * const { count } = await prisma.productType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductTypeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductTypeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductTypes
     * const productType = await prisma.productType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductTypeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ProductTypeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductType.
     * @param {ProductTypeUpsertArgs} args - Arguments to update or create a ProductType.
     * @example
     * // Update or create a ProductType
     * const productType = await prisma.productType.upsert({
     *   create: {
     *     // ... data to create a ProductType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductType we want to update
     *   }
     * })
    **/
    upsert<T extends ProductTypeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ProductTypeUpsertArgs<ExtArgs>>
    ): Prisma__ProductTypeClient<$Types.GetResult<ProductTypePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of ProductTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTypeCountArgs} args - Arguments to filter ProductTypes to count.
     * @example
     * // Count the number of ProductTypes
     * const count = await prisma.productType.count({
     *   where: {
     *     // ... the filter for the ProductTypes we want to count
     *   }
     * })
    **/
    count<T extends ProductTypeCountArgs>(
      args?: Subset<T, ProductTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductTypeAggregateArgs>(args: Subset<T, ProductTypeAggregateArgs>): Prisma.PrismaPromise<GetProductTypeAggregateType<T>>

    /**
     * Group by ProductType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductTypeGroupByArgs['orderBy'] }
        : { orderBy?: ProductTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductTypeClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    ProductCategory<T extends ProductCategoryArgs<ExtArgs> = {}>(args?: Subset<T, ProductCategoryArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Types.GetResult<ProductCategoryPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    sizes<T extends ProductType$sizesArgs<ExtArgs> = {}>(args?: Subset<T, ProductType$sizesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ProductTypeSizePayload<ExtArgs>, T, 'findMany', never>| Null>;

    product<T extends ProductType$productArgs<ExtArgs> = {}>(args?: Subset<T, ProductType$productArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ProductPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ProductType base type for findUnique actions
   */
  export type ProductTypeFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductType
     */
    select?: ProductTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductTypeInclude<ExtArgs> | null
    /**
     * Filter, which ProductType to fetch.
     */
    where: ProductTypeWhereUniqueInput
  }

  /**
   * ProductType findUnique
   */
  export interface ProductTypeFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ProductTypeFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProductType findUniqueOrThrow
   */
  export type ProductTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductType
     */
    select?: ProductTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductTypeInclude<ExtArgs> | null
    /**
     * Filter, which ProductType to fetch.
     */
    where: ProductTypeWhereUniqueInput
  }


  /**
   * ProductType base type for findFirst actions
   */
  export type ProductTypeFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductType
     */
    select?: ProductTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductTypeInclude<ExtArgs> | null
    /**
     * Filter, which ProductType to fetch.
     */
    where?: ProductTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductTypes to fetch.
     */
    orderBy?: Enumerable<ProductTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductTypes.
     */
    cursor?: ProductTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductTypes.
     */
    distinct?: Enumerable<ProductTypeScalarFieldEnum>
  }

  /**
   * ProductType findFirst
   */
  export interface ProductTypeFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ProductTypeFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProductType findFirstOrThrow
   */
  export type ProductTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductType
     */
    select?: ProductTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductTypeInclude<ExtArgs> | null
    /**
     * Filter, which ProductType to fetch.
     */
    where?: ProductTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductTypes to fetch.
     */
    orderBy?: Enumerable<ProductTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductTypes.
     */
    cursor?: ProductTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductTypes.
     */
    distinct?: Enumerable<ProductTypeScalarFieldEnum>
  }


  /**
   * ProductType findMany
   */
  export type ProductTypeFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductType
     */
    select?: ProductTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductTypeInclude<ExtArgs> | null
    /**
     * Filter, which ProductTypes to fetch.
     */
    where?: ProductTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductTypes to fetch.
     */
    orderBy?: Enumerable<ProductTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductTypes.
     */
    cursor?: ProductTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductTypes.
     */
    skip?: number
    distinct?: Enumerable<ProductTypeScalarFieldEnum>
  }


  /**
   * ProductType create
   */
  export type ProductTypeCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductType
     */
    select?: ProductTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductType.
     */
    data: XOR<ProductTypeCreateInput, ProductTypeUncheckedCreateInput>
  }


  /**
   * ProductType createMany
   */
  export type ProductTypeCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductTypes.
     */
    data: Enumerable<ProductTypeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ProductType update
   */
  export type ProductTypeUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductType
     */
    select?: ProductTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductType.
     */
    data: XOR<ProductTypeUpdateInput, ProductTypeUncheckedUpdateInput>
    /**
     * Choose, which ProductType to update.
     */
    where: ProductTypeWhereUniqueInput
  }


  /**
   * ProductType updateMany
   */
  export type ProductTypeUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductTypes.
     */
    data: XOR<ProductTypeUpdateManyMutationInput, ProductTypeUncheckedUpdateManyInput>
    /**
     * Filter which ProductTypes to update
     */
    where?: ProductTypeWhereInput
  }


  /**
   * ProductType upsert
   */
  export type ProductTypeUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductType
     */
    select?: ProductTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductType to update in case it exists.
     */
    where: ProductTypeWhereUniqueInput
    /**
     * In case the ProductType found by the `where` argument doesn't exist, create a new ProductType with this data.
     */
    create: XOR<ProductTypeCreateInput, ProductTypeUncheckedCreateInput>
    /**
     * In case the ProductType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductTypeUpdateInput, ProductTypeUncheckedUpdateInput>
  }


  /**
   * ProductType delete
   */
  export type ProductTypeDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductType
     */
    select?: ProductTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductTypeInclude<ExtArgs> | null
    /**
     * Filter which ProductType to delete.
     */
    where: ProductTypeWhereUniqueInput
  }


  /**
   * ProductType deleteMany
   */
  export type ProductTypeDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductTypes to delete
     */
    where?: ProductTypeWhereInput
  }


  /**
   * ProductType.sizes
   */
  export type ProductType$sizesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTypeSize
     */
    select?: ProductTypeSizeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductTypeSizeInclude<ExtArgs> | null
    where?: ProductTypeSizeWhereInput
    orderBy?: Enumerable<ProductTypeSizeOrderByWithRelationInput>
    cursor?: ProductTypeSizeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ProductTypeSizeScalarFieldEnum>
  }


  /**
   * ProductType.product
   */
  export type ProductType$productArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ProductScalarFieldEnum>
  }


  /**
   * ProductType without action
   */
  export type ProductTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductType
     */
    select?: ProductTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductTypeInclude<ExtArgs> | null
  }



  /**
   * Model ProductTypeSize
   */


  export type AggregateProductTypeSize = {
    _count: ProductTypeSizeCountAggregateOutputType | null
    _avg: ProductTypeSizeAvgAggregateOutputType | null
    _sum: ProductTypeSizeSumAggregateOutputType | null
    _min: ProductTypeSizeMinAggregateOutputType | null
    _max: ProductTypeSizeMaxAggregateOutputType | null
  }

  export type ProductTypeSizeAvgAggregateOutputType = {
    id: number | null
    ietmsId: number | null
  }

  export type ProductTypeSizeSumAggregateOutputType = {
    id: number | null
    ietmsId: number | null
  }

  export type ProductTypeSizeMinAggregateOutputType = {
    id: number | null
    size: string | null
    ietmsId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ProductTypeSizeMaxAggregateOutputType = {
    id: number | null
    size: string | null
    ietmsId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ProductTypeSizeCountAggregateOutputType = {
    id: number
    size: number
    ietmsId: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type ProductTypeSizeAvgAggregateInputType = {
    id?: true
    ietmsId?: true
  }

  export type ProductTypeSizeSumAggregateInputType = {
    id?: true
    ietmsId?: true
  }

  export type ProductTypeSizeMinAggregateInputType = {
    id?: true
    size?: true
    ietmsId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ProductTypeSizeMaxAggregateInputType = {
    id?: true
    size?: true
    ietmsId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ProductTypeSizeCountAggregateInputType = {
    id?: true
    size?: true
    ietmsId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type ProductTypeSizeAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductTypeSize to aggregate.
     */
    where?: ProductTypeSizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductTypeSizes to fetch.
     */
    orderBy?: Enumerable<ProductTypeSizeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductTypeSizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductTypeSizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductTypeSizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductTypeSizes
    **/
    _count?: true | ProductTypeSizeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductTypeSizeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductTypeSizeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductTypeSizeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductTypeSizeMaxAggregateInputType
  }

  export type GetProductTypeSizeAggregateType<T extends ProductTypeSizeAggregateArgs> = {
        [P in keyof T & keyof AggregateProductTypeSize]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductTypeSize[P]>
      : GetScalarType<T[P], AggregateProductTypeSize[P]>
  }




  export type ProductTypeSizeGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ProductTypeSizeWhereInput
    orderBy?: Enumerable<ProductTypeSizeOrderByWithAggregationInput>
    by: ProductTypeSizeScalarFieldEnum[]
    having?: ProductTypeSizeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductTypeSizeCountAggregateInputType | true
    _avg?: ProductTypeSizeAvgAggregateInputType
    _sum?: ProductTypeSizeSumAggregateInputType
    _min?: ProductTypeSizeMinAggregateInputType
    _max?: ProductTypeSizeMaxAggregateInputType
  }


  export type ProductTypeSizeGroupByOutputType = {
    id: number
    size: string
    ietmsId: number
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: ProductTypeSizeCountAggregateOutputType | null
    _avg: ProductTypeSizeAvgAggregateOutputType | null
    _sum: ProductTypeSizeSumAggregateOutputType | null
    _min: ProductTypeSizeMinAggregateOutputType | null
    _max: ProductTypeSizeMaxAggregateOutputType | null
  }

  type GetProductTypeSizeGroupByPayload<T extends ProductTypeSizeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ProductTypeSizeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductTypeSizeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductTypeSizeGroupByOutputType[P]>
            : GetScalarType<T[P], ProductTypeSizeGroupByOutputType[P]>
        }
      >
    >


  export type ProductTypeSizeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    size?: boolean
    ietmsId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    aviableSizes?: boolean | ProductTypeSize$aviableSizesArgs<ExtArgs>
    productType?: boolean | ProductTypeArgs<ExtArgs>
    _count?: boolean | ProductTypeSizeCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["productTypeSize"]>

  export type ProductTypeSizeSelectScalar = {
    id?: boolean
    size?: boolean
    ietmsId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type ProductTypeSizeInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    aviableSizes?: boolean | ProductTypeSize$aviableSizesArgs<ExtArgs>
    productType?: boolean | ProductTypeArgs<ExtArgs>
    _count?: boolean | ProductTypeSizeCountOutputTypeArgs<ExtArgs>
  }


  type ProductTypeSizeGetPayload<S extends boolean | null | undefined | ProductTypeSizeArgs> = $Types.GetResult<ProductTypeSizePayload, S>

  type ProductTypeSizeCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ProductTypeSizeFindManyArgs, 'select' | 'include'> & {
      select?: ProductTypeSizeCountAggregateInputType | true
    }

  export interface ProductTypeSizeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductTypeSize'], meta: { name: 'ProductTypeSize' } }
    /**
     * Find zero or one ProductTypeSize that matches the filter.
     * @param {ProductTypeSizeFindUniqueArgs} args - Arguments to find a ProductTypeSize
     * @example
     * // Get one ProductTypeSize
     * const productTypeSize = await prisma.productTypeSize.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductTypeSizeFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductTypeSizeFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ProductTypeSize'> extends True ? Prisma__ProductTypeSizeClient<$Types.GetResult<ProductTypeSizePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ProductTypeSizeClient<$Types.GetResult<ProductTypeSizePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one ProductTypeSize that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProductTypeSizeFindUniqueOrThrowArgs} args - Arguments to find a ProductTypeSize
     * @example
     * // Get one ProductTypeSize
     * const productTypeSize = await prisma.productTypeSize.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProductTypeSizeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductTypeSizeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProductTypeSizeClient<$Types.GetResult<ProductTypeSizePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first ProductTypeSize that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTypeSizeFindFirstArgs} args - Arguments to find a ProductTypeSize
     * @example
     * // Get one ProductTypeSize
     * const productTypeSize = await prisma.productTypeSize.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductTypeSizeFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductTypeSizeFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ProductTypeSize'> extends True ? Prisma__ProductTypeSizeClient<$Types.GetResult<ProductTypeSizePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ProductTypeSizeClient<$Types.GetResult<ProductTypeSizePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first ProductTypeSize that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTypeSizeFindFirstOrThrowArgs} args - Arguments to find a ProductTypeSize
     * @example
     * // Get one ProductTypeSize
     * const productTypeSize = await prisma.productTypeSize.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProductTypeSizeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductTypeSizeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProductTypeSizeClient<$Types.GetResult<ProductTypeSizePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more ProductTypeSizes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTypeSizeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductTypeSizes
     * const productTypeSizes = await prisma.productTypeSize.findMany()
     * 
     * // Get first 10 ProductTypeSizes
     * const productTypeSizes = await prisma.productTypeSize.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productTypeSizeWithIdOnly = await prisma.productTypeSize.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductTypeSizeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductTypeSizeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ProductTypeSizePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a ProductTypeSize.
     * @param {ProductTypeSizeCreateArgs} args - Arguments to create a ProductTypeSize.
     * @example
     * // Create one ProductTypeSize
     * const ProductTypeSize = await prisma.productTypeSize.create({
     *   data: {
     *     // ... data to create a ProductTypeSize
     *   }
     * })
     * 
    **/
    create<T extends ProductTypeSizeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductTypeSizeCreateArgs<ExtArgs>>
    ): Prisma__ProductTypeSizeClient<$Types.GetResult<ProductTypeSizePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many ProductTypeSizes.
     *     @param {ProductTypeSizeCreateManyArgs} args - Arguments to create many ProductTypeSizes.
     *     @example
     *     // Create many ProductTypeSizes
     *     const productTypeSize = await prisma.productTypeSize.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductTypeSizeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductTypeSizeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProductTypeSize.
     * @param {ProductTypeSizeDeleteArgs} args - Arguments to delete one ProductTypeSize.
     * @example
     * // Delete one ProductTypeSize
     * const ProductTypeSize = await prisma.productTypeSize.delete({
     *   where: {
     *     // ... filter to delete one ProductTypeSize
     *   }
     * })
     * 
    **/
    delete<T extends ProductTypeSizeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ProductTypeSizeDeleteArgs<ExtArgs>>
    ): Prisma__ProductTypeSizeClient<$Types.GetResult<ProductTypeSizePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one ProductTypeSize.
     * @param {ProductTypeSizeUpdateArgs} args - Arguments to update one ProductTypeSize.
     * @example
     * // Update one ProductTypeSize
     * const productTypeSize = await prisma.productTypeSize.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductTypeSizeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductTypeSizeUpdateArgs<ExtArgs>>
    ): Prisma__ProductTypeSizeClient<$Types.GetResult<ProductTypeSizePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more ProductTypeSizes.
     * @param {ProductTypeSizeDeleteManyArgs} args - Arguments to filter ProductTypeSizes to delete.
     * @example
     * // Delete a few ProductTypeSizes
     * const { count } = await prisma.productTypeSize.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductTypeSizeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductTypeSizeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductTypeSizes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTypeSizeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductTypeSizes
     * const productTypeSize = await prisma.productTypeSize.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductTypeSizeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ProductTypeSizeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductTypeSize.
     * @param {ProductTypeSizeUpsertArgs} args - Arguments to update or create a ProductTypeSize.
     * @example
     * // Update or create a ProductTypeSize
     * const productTypeSize = await prisma.productTypeSize.upsert({
     *   create: {
     *     // ... data to create a ProductTypeSize
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductTypeSize we want to update
     *   }
     * })
    **/
    upsert<T extends ProductTypeSizeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ProductTypeSizeUpsertArgs<ExtArgs>>
    ): Prisma__ProductTypeSizeClient<$Types.GetResult<ProductTypeSizePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of ProductTypeSizes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTypeSizeCountArgs} args - Arguments to filter ProductTypeSizes to count.
     * @example
     * // Count the number of ProductTypeSizes
     * const count = await prisma.productTypeSize.count({
     *   where: {
     *     // ... the filter for the ProductTypeSizes we want to count
     *   }
     * })
    **/
    count<T extends ProductTypeSizeCountArgs>(
      args?: Subset<T, ProductTypeSizeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductTypeSizeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductTypeSize.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTypeSizeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductTypeSizeAggregateArgs>(args: Subset<T, ProductTypeSizeAggregateArgs>): Prisma.PrismaPromise<GetProductTypeSizeAggregateType<T>>

    /**
     * Group by ProductTypeSize.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTypeSizeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductTypeSizeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductTypeSizeGroupByArgs['orderBy'] }
        : { orderBy?: ProductTypeSizeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductTypeSizeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductTypeSizeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductTypeSize.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductTypeSizeClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    aviableSizes<T extends ProductTypeSize$aviableSizesArgs<ExtArgs> = {}>(args?: Subset<T, ProductTypeSize$aviableSizesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ProductAviableSizesPayload<ExtArgs>, T, 'findMany', never>| Null>;

    productType<T extends ProductTypeArgs<ExtArgs> = {}>(args?: Subset<T, ProductTypeArgs<ExtArgs>>): Prisma__ProductTypeClient<$Types.GetResult<ProductTypePayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ProductTypeSize base type for findUnique actions
   */
  export type ProductTypeSizeFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTypeSize
     */
    select?: ProductTypeSizeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductTypeSizeInclude<ExtArgs> | null
    /**
     * Filter, which ProductTypeSize to fetch.
     */
    where: ProductTypeSizeWhereUniqueInput
  }

  /**
   * ProductTypeSize findUnique
   */
  export interface ProductTypeSizeFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ProductTypeSizeFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProductTypeSize findUniqueOrThrow
   */
  export type ProductTypeSizeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTypeSize
     */
    select?: ProductTypeSizeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductTypeSizeInclude<ExtArgs> | null
    /**
     * Filter, which ProductTypeSize to fetch.
     */
    where: ProductTypeSizeWhereUniqueInput
  }


  /**
   * ProductTypeSize base type for findFirst actions
   */
  export type ProductTypeSizeFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTypeSize
     */
    select?: ProductTypeSizeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductTypeSizeInclude<ExtArgs> | null
    /**
     * Filter, which ProductTypeSize to fetch.
     */
    where?: ProductTypeSizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductTypeSizes to fetch.
     */
    orderBy?: Enumerable<ProductTypeSizeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductTypeSizes.
     */
    cursor?: ProductTypeSizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductTypeSizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductTypeSizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductTypeSizes.
     */
    distinct?: Enumerable<ProductTypeSizeScalarFieldEnum>
  }

  /**
   * ProductTypeSize findFirst
   */
  export interface ProductTypeSizeFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ProductTypeSizeFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProductTypeSize findFirstOrThrow
   */
  export type ProductTypeSizeFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTypeSize
     */
    select?: ProductTypeSizeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductTypeSizeInclude<ExtArgs> | null
    /**
     * Filter, which ProductTypeSize to fetch.
     */
    where?: ProductTypeSizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductTypeSizes to fetch.
     */
    orderBy?: Enumerable<ProductTypeSizeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductTypeSizes.
     */
    cursor?: ProductTypeSizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductTypeSizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductTypeSizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductTypeSizes.
     */
    distinct?: Enumerable<ProductTypeSizeScalarFieldEnum>
  }


  /**
   * ProductTypeSize findMany
   */
  export type ProductTypeSizeFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTypeSize
     */
    select?: ProductTypeSizeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductTypeSizeInclude<ExtArgs> | null
    /**
     * Filter, which ProductTypeSizes to fetch.
     */
    where?: ProductTypeSizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductTypeSizes to fetch.
     */
    orderBy?: Enumerable<ProductTypeSizeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductTypeSizes.
     */
    cursor?: ProductTypeSizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductTypeSizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductTypeSizes.
     */
    skip?: number
    distinct?: Enumerable<ProductTypeSizeScalarFieldEnum>
  }


  /**
   * ProductTypeSize create
   */
  export type ProductTypeSizeCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTypeSize
     */
    select?: ProductTypeSizeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductTypeSizeInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductTypeSize.
     */
    data: XOR<ProductTypeSizeCreateInput, ProductTypeSizeUncheckedCreateInput>
  }


  /**
   * ProductTypeSize createMany
   */
  export type ProductTypeSizeCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductTypeSizes.
     */
    data: Enumerable<ProductTypeSizeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ProductTypeSize update
   */
  export type ProductTypeSizeUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTypeSize
     */
    select?: ProductTypeSizeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductTypeSizeInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductTypeSize.
     */
    data: XOR<ProductTypeSizeUpdateInput, ProductTypeSizeUncheckedUpdateInput>
    /**
     * Choose, which ProductTypeSize to update.
     */
    where: ProductTypeSizeWhereUniqueInput
  }


  /**
   * ProductTypeSize updateMany
   */
  export type ProductTypeSizeUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductTypeSizes.
     */
    data: XOR<ProductTypeSizeUpdateManyMutationInput, ProductTypeSizeUncheckedUpdateManyInput>
    /**
     * Filter which ProductTypeSizes to update
     */
    where?: ProductTypeSizeWhereInput
  }


  /**
   * ProductTypeSize upsert
   */
  export type ProductTypeSizeUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTypeSize
     */
    select?: ProductTypeSizeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductTypeSizeInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductTypeSize to update in case it exists.
     */
    where: ProductTypeSizeWhereUniqueInput
    /**
     * In case the ProductTypeSize found by the `where` argument doesn't exist, create a new ProductTypeSize with this data.
     */
    create: XOR<ProductTypeSizeCreateInput, ProductTypeSizeUncheckedCreateInput>
    /**
     * In case the ProductTypeSize was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductTypeSizeUpdateInput, ProductTypeSizeUncheckedUpdateInput>
  }


  /**
   * ProductTypeSize delete
   */
  export type ProductTypeSizeDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTypeSize
     */
    select?: ProductTypeSizeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductTypeSizeInclude<ExtArgs> | null
    /**
     * Filter which ProductTypeSize to delete.
     */
    where: ProductTypeSizeWhereUniqueInput
  }


  /**
   * ProductTypeSize deleteMany
   */
  export type ProductTypeSizeDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductTypeSizes to delete
     */
    where?: ProductTypeSizeWhereInput
  }


  /**
   * ProductTypeSize.aviableSizes
   */
  export type ProductTypeSize$aviableSizesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductAviableSizes
     */
    select?: ProductAviableSizesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductAviableSizesInclude<ExtArgs> | null
    where?: ProductAviableSizesWhereInput
    orderBy?: Enumerable<ProductAviableSizesOrderByWithRelationInput>
    cursor?: ProductAviableSizesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ProductAviableSizesScalarFieldEnum>
  }


  /**
   * ProductTypeSize without action
   */
  export type ProductTypeSizeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTypeSize
     */
    select?: ProductTypeSizeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductTypeSizeInclude<ExtArgs> | null
  }



  /**
   * Model Gender
   */


  export type AggregateGender = {
    _count: GenderCountAggregateOutputType | null
    _avg: GenderAvgAggregateOutputType | null
    _sum: GenderSumAggregateOutputType | null
    _min: GenderMinAggregateOutputType | null
    _max: GenderMaxAggregateOutputType | null
  }

  export type GenderAvgAggregateOutputType = {
    id: number | null
  }

  export type GenderSumAggregateOutputType = {
    id: number | null
  }

  export type GenderMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type GenderMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type GenderCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type GenderAvgAggregateInputType = {
    id?: true
  }

  export type GenderSumAggregateInputType = {
    id?: true
  }

  export type GenderMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type GenderMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type GenderCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type GenderAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Gender to aggregate.
     */
    where?: GenderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Genders to fetch.
     */
    orderBy?: Enumerable<GenderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GenderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Genders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Genders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Genders
    **/
    _count?: true | GenderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GenderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GenderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GenderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GenderMaxAggregateInputType
  }

  export type GetGenderAggregateType<T extends GenderAggregateArgs> = {
        [P in keyof T & keyof AggregateGender]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGender[P]>
      : GetScalarType<T[P], AggregateGender[P]>
  }




  export type GenderGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: GenderWhereInput
    orderBy?: Enumerable<GenderOrderByWithAggregationInput>
    by: GenderScalarFieldEnum[]
    having?: GenderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GenderCountAggregateInputType | true
    _avg?: GenderAvgAggregateInputType
    _sum?: GenderSumAggregateInputType
    _min?: GenderMinAggregateInputType
    _max?: GenderMaxAggregateInputType
  }


  export type GenderGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: GenderCountAggregateOutputType | null
    _avg: GenderAvgAggregateOutputType | null
    _sum: GenderSumAggregateOutputType | null
    _min: GenderMinAggregateOutputType | null
    _max: GenderMaxAggregateOutputType | null
  }

  type GetGenderGroupByPayload<T extends GenderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<GenderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GenderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GenderGroupByOutputType[P]>
            : GetScalarType<T[P], GenderGroupByOutputType[P]>
        }
      >
    >


  export type GenderSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    productCategory?: boolean | Gender$productCategoryArgs<ExtArgs>
    user?: boolean | Gender$userArgs<ExtArgs>
    _count?: boolean | GenderCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["gender"]>

  export type GenderSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type GenderInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    productCategory?: boolean | Gender$productCategoryArgs<ExtArgs>
    user?: boolean | Gender$userArgs<ExtArgs>
    _count?: boolean | GenderCountOutputTypeArgs<ExtArgs>
  }


  type GenderGetPayload<S extends boolean | null | undefined | GenderArgs> = $Types.GetResult<GenderPayload, S>

  type GenderCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<GenderFindManyArgs, 'select' | 'include'> & {
      select?: GenderCountAggregateInputType | true
    }

  export interface GenderDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Gender'], meta: { name: 'Gender' } }
    /**
     * Find zero or one Gender that matches the filter.
     * @param {GenderFindUniqueArgs} args - Arguments to find a Gender
     * @example
     * // Get one Gender
     * const gender = await prisma.gender.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends GenderFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, GenderFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Gender'> extends True ? Prisma__GenderClient<$Types.GetResult<GenderPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__GenderClient<$Types.GetResult<GenderPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Gender that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {GenderFindUniqueOrThrowArgs} args - Arguments to find a Gender
     * @example
     * // Get one Gender
     * const gender = await prisma.gender.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends GenderFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, GenderFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__GenderClient<$Types.GetResult<GenderPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Gender that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenderFindFirstArgs} args - Arguments to find a Gender
     * @example
     * // Get one Gender
     * const gender = await prisma.gender.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends GenderFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, GenderFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Gender'> extends True ? Prisma__GenderClient<$Types.GetResult<GenderPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__GenderClient<$Types.GetResult<GenderPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Gender that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenderFindFirstOrThrowArgs} args - Arguments to find a Gender
     * @example
     * // Get one Gender
     * const gender = await prisma.gender.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends GenderFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, GenderFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__GenderClient<$Types.GetResult<GenderPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Genders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenderFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Genders
     * const genders = await prisma.gender.findMany()
     * 
     * // Get first 10 Genders
     * const genders = await prisma.gender.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const genderWithIdOnly = await prisma.gender.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends GenderFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GenderFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<GenderPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Gender.
     * @param {GenderCreateArgs} args - Arguments to create a Gender.
     * @example
     * // Create one Gender
     * const Gender = await prisma.gender.create({
     *   data: {
     *     // ... data to create a Gender
     *   }
     * })
     * 
    **/
    create<T extends GenderCreateArgs<ExtArgs>>(
      args: SelectSubset<T, GenderCreateArgs<ExtArgs>>
    ): Prisma__GenderClient<$Types.GetResult<GenderPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Genders.
     *     @param {GenderCreateManyArgs} args - Arguments to create many Genders.
     *     @example
     *     // Create many Genders
     *     const gender = await prisma.gender.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends GenderCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GenderCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Gender.
     * @param {GenderDeleteArgs} args - Arguments to delete one Gender.
     * @example
     * // Delete one Gender
     * const Gender = await prisma.gender.delete({
     *   where: {
     *     // ... filter to delete one Gender
     *   }
     * })
     * 
    **/
    delete<T extends GenderDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, GenderDeleteArgs<ExtArgs>>
    ): Prisma__GenderClient<$Types.GetResult<GenderPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Gender.
     * @param {GenderUpdateArgs} args - Arguments to update one Gender.
     * @example
     * // Update one Gender
     * const gender = await prisma.gender.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends GenderUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, GenderUpdateArgs<ExtArgs>>
    ): Prisma__GenderClient<$Types.GetResult<GenderPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Genders.
     * @param {GenderDeleteManyArgs} args - Arguments to filter Genders to delete.
     * @example
     * // Delete a few Genders
     * const { count } = await prisma.gender.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends GenderDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GenderDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Genders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Genders
     * const gender = await prisma.gender.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends GenderUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, GenderUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Gender.
     * @param {GenderUpsertArgs} args - Arguments to update or create a Gender.
     * @example
     * // Update or create a Gender
     * const gender = await prisma.gender.upsert({
     *   create: {
     *     // ... data to create a Gender
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Gender we want to update
     *   }
     * })
    **/
    upsert<T extends GenderUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, GenderUpsertArgs<ExtArgs>>
    ): Prisma__GenderClient<$Types.GetResult<GenderPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Genders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenderCountArgs} args - Arguments to filter Genders to count.
     * @example
     * // Count the number of Genders
     * const count = await prisma.gender.count({
     *   where: {
     *     // ... the filter for the Genders we want to count
     *   }
     * })
    **/
    count<T extends GenderCountArgs>(
      args?: Subset<T, GenderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GenderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Gender.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GenderAggregateArgs>(args: Subset<T, GenderAggregateArgs>): Prisma.PrismaPromise<GetGenderAggregateType<T>>

    /**
     * Group by Gender.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GenderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GenderGroupByArgs['orderBy'] }
        : { orderBy?: GenderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GenderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGenderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Gender.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__GenderClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    productCategory<T extends Gender$productCategoryArgs<ExtArgs> = {}>(args?: Subset<T, Gender$productCategoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ProductCategoryPayload<ExtArgs>, T, 'findMany', never>| Null>;

    user<T extends Gender$userArgs<ExtArgs> = {}>(args?: Subset<T, Gender$userArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<UserPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Gender base type for findUnique actions
   */
  export type GenderFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gender
     */
    select?: GenderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GenderInclude<ExtArgs> | null
    /**
     * Filter, which Gender to fetch.
     */
    where: GenderWhereUniqueInput
  }

  /**
   * Gender findUnique
   */
  export interface GenderFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends GenderFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Gender findUniqueOrThrow
   */
  export type GenderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gender
     */
    select?: GenderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GenderInclude<ExtArgs> | null
    /**
     * Filter, which Gender to fetch.
     */
    where: GenderWhereUniqueInput
  }


  /**
   * Gender base type for findFirst actions
   */
  export type GenderFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gender
     */
    select?: GenderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GenderInclude<ExtArgs> | null
    /**
     * Filter, which Gender to fetch.
     */
    where?: GenderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Genders to fetch.
     */
    orderBy?: Enumerable<GenderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Genders.
     */
    cursor?: GenderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Genders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Genders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Genders.
     */
    distinct?: Enumerable<GenderScalarFieldEnum>
  }

  /**
   * Gender findFirst
   */
  export interface GenderFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends GenderFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Gender findFirstOrThrow
   */
  export type GenderFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gender
     */
    select?: GenderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GenderInclude<ExtArgs> | null
    /**
     * Filter, which Gender to fetch.
     */
    where?: GenderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Genders to fetch.
     */
    orderBy?: Enumerable<GenderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Genders.
     */
    cursor?: GenderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Genders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Genders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Genders.
     */
    distinct?: Enumerable<GenderScalarFieldEnum>
  }


  /**
   * Gender findMany
   */
  export type GenderFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gender
     */
    select?: GenderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GenderInclude<ExtArgs> | null
    /**
     * Filter, which Genders to fetch.
     */
    where?: GenderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Genders to fetch.
     */
    orderBy?: Enumerable<GenderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Genders.
     */
    cursor?: GenderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Genders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Genders.
     */
    skip?: number
    distinct?: Enumerable<GenderScalarFieldEnum>
  }


  /**
   * Gender create
   */
  export type GenderCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gender
     */
    select?: GenderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GenderInclude<ExtArgs> | null
    /**
     * The data needed to create a Gender.
     */
    data: XOR<GenderCreateInput, GenderUncheckedCreateInput>
  }


  /**
   * Gender createMany
   */
  export type GenderCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Genders.
     */
    data: Enumerable<GenderCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Gender update
   */
  export type GenderUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gender
     */
    select?: GenderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GenderInclude<ExtArgs> | null
    /**
     * The data needed to update a Gender.
     */
    data: XOR<GenderUpdateInput, GenderUncheckedUpdateInput>
    /**
     * Choose, which Gender to update.
     */
    where: GenderWhereUniqueInput
  }


  /**
   * Gender updateMany
   */
  export type GenderUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Genders.
     */
    data: XOR<GenderUpdateManyMutationInput, GenderUncheckedUpdateManyInput>
    /**
     * Filter which Genders to update
     */
    where?: GenderWhereInput
  }


  /**
   * Gender upsert
   */
  export type GenderUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gender
     */
    select?: GenderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GenderInclude<ExtArgs> | null
    /**
     * The filter to search for the Gender to update in case it exists.
     */
    where: GenderWhereUniqueInput
    /**
     * In case the Gender found by the `where` argument doesn't exist, create a new Gender with this data.
     */
    create: XOR<GenderCreateInput, GenderUncheckedCreateInput>
    /**
     * In case the Gender was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GenderUpdateInput, GenderUncheckedUpdateInput>
  }


  /**
   * Gender delete
   */
  export type GenderDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gender
     */
    select?: GenderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GenderInclude<ExtArgs> | null
    /**
     * Filter which Gender to delete.
     */
    where: GenderWhereUniqueInput
  }


  /**
   * Gender deleteMany
   */
  export type GenderDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Genders to delete
     */
    where?: GenderWhereInput
  }


  /**
   * Gender.productCategory
   */
  export type Gender$productCategoryArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    where?: ProductCategoryWhereInput
    orderBy?: Enumerable<ProductCategoryOrderByWithRelationInput>
    cursor?: ProductCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ProductCategoryScalarFieldEnum>
  }


  /**
   * Gender.user
   */
  export type Gender$userArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * Gender without action
   */
  export type GenderArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gender
     */
    select?: GenderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GenderInclude<ExtArgs> | null
  }



  /**
   * Model Country
   */


  export type AggregateCountry = {
    _count: CountryCountAggregateOutputType | null
    _avg: CountryAvgAggregateOutputType | null
    _sum: CountrySumAggregateOutputType | null
    _min: CountryMinAggregateOutputType | null
    _max: CountryMaxAggregateOutputType | null
  }

  export type CountryAvgAggregateOutputType = {
    id: number | null
    timezoneOffset: number | null
  }

  export type CountrySumAggregateOutputType = {
    id: number | null
    timezoneOffset: number | null
  }

  export type CountryMinAggregateOutputType = {
    id: number | null
    name: string | null
    timezoneOffset: number | null
    dialCode: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type CountryMaxAggregateOutputType = {
    id: number | null
    name: string | null
    timezoneOffset: number | null
    dialCode: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type CountryCountAggregateOutputType = {
    id: number
    name: number
    timezoneOffset: number
    dialCode: number
    isActive: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type CountryAvgAggregateInputType = {
    id?: true
    timezoneOffset?: true
  }

  export type CountrySumAggregateInputType = {
    id?: true
    timezoneOffset?: true
  }

  export type CountryMinAggregateInputType = {
    id?: true
    name?: true
    timezoneOffset?: true
    dialCode?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type CountryMaxAggregateInputType = {
    id?: true
    name?: true
    timezoneOffset?: true
    dialCode?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type CountryCountAggregateInputType = {
    id?: true
    name?: true
    timezoneOffset?: true
    dialCode?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type CountryAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Country to aggregate.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: Enumerable<CountryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Countries
    **/
    _count?: true | CountryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CountryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CountrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CountryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CountryMaxAggregateInputType
  }

  export type GetCountryAggregateType<T extends CountryAggregateArgs> = {
        [P in keyof T & keyof AggregateCountry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCountry[P]>
      : GetScalarType<T[P], AggregateCountry[P]>
  }




  export type CountryGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CountryWhereInput
    orderBy?: Enumerable<CountryOrderByWithAggregationInput>
    by: CountryScalarFieldEnum[]
    having?: CountryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CountryCountAggregateInputType | true
    _avg?: CountryAvgAggregateInputType
    _sum?: CountrySumAggregateInputType
    _min?: CountryMinAggregateInputType
    _max?: CountryMaxAggregateInputType
  }


  export type CountryGroupByOutputType = {
    id: number
    name: string
    timezoneOffset: number
    dialCode: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: CountryCountAggregateOutputType | null
    _avg: CountryAvgAggregateOutputType | null
    _sum: CountrySumAggregateOutputType | null
    _min: CountryMinAggregateOutputType | null
    _max: CountryMaxAggregateOutputType | null
  }

  type GetCountryGroupByPayload<T extends CountryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CountryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CountryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CountryGroupByOutputType[P]>
            : GetScalarType<T[P], CountryGroupByOutputType[P]>
        }
      >
    >


  export type CountrySelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    timezoneOffset?: boolean
    dialCode?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    state?: boolean | Country$stateArgs<ExtArgs>
    _count?: boolean | CountryCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["country"]>

  export type CountrySelectScalar = {
    id?: boolean
    name?: boolean
    timezoneOffset?: boolean
    dialCode?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type CountryInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    state?: boolean | Country$stateArgs<ExtArgs>
    _count?: boolean | CountryCountOutputTypeArgs<ExtArgs>
  }


  type CountryGetPayload<S extends boolean | null | undefined | CountryArgs> = $Types.GetResult<CountryPayload, S>

  type CountryCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<CountryFindManyArgs, 'select' | 'include'> & {
      select?: CountryCountAggregateInputType | true
    }

  export interface CountryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Country'], meta: { name: 'Country' } }
    /**
     * Find zero or one Country that matches the filter.
     * @param {CountryFindUniqueArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CountryFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CountryFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Country'> extends True ? Prisma__CountryClient<$Types.GetResult<CountryPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__CountryClient<$Types.GetResult<CountryPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Country that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CountryFindUniqueOrThrowArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CountryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CountryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CountryClient<$Types.GetResult<CountryPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Country that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindFirstArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CountryFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CountryFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Country'> extends True ? Prisma__CountryClient<$Types.GetResult<CountryPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__CountryClient<$Types.GetResult<CountryPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Country that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindFirstOrThrowArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CountryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CountryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CountryClient<$Types.GetResult<CountryPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Countries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Countries
     * const countries = await prisma.country.findMany()
     * 
     * // Get first 10 Countries
     * const countries = await prisma.country.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const countryWithIdOnly = await prisma.country.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CountryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CountryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<CountryPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Country.
     * @param {CountryCreateArgs} args - Arguments to create a Country.
     * @example
     * // Create one Country
     * const Country = await prisma.country.create({
     *   data: {
     *     // ... data to create a Country
     *   }
     * })
     * 
    **/
    create<T extends CountryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CountryCreateArgs<ExtArgs>>
    ): Prisma__CountryClient<$Types.GetResult<CountryPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Countries.
     *     @param {CountryCreateManyArgs} args - Arguments to create many Countries.
     *     @example
     *     // Create many Countries
     *     const country = await prisma.country.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CountryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CountryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Country.
     * @param {CountryDeleteArgs} args - Arguments to delete one Country.
     * @example
     * // Delete one Country
     * const Country = await prisma.country.delete({
     *   where: {
     *     // ... filter to delete one Country
     *   }
     * })
     * 
    **/
    delete<T extends CountryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CountryDeleteArgs<ExtArgs>>
    ): Prisma__CountryClient<$Types.GetResult<CountryPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Country.
     * @param {CountryUpdateArgs} args - Arguments to update one Country.
     * @example
     * // Update one Country
     * const country = await prisma.country.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CountryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CountryUpdateArgs<ExtArgs>>
    ): Prisma__CountryClient<$Types.GetResult<CountryPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Countries.
     * @param {CountryDeleteManyArgs} args - Arguments to filter Countries to delete.
     * @example
     * // Delete a few Countries
     * const { count } = await prisma.country.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CountryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CountryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Countries
     * const country = await prisma.country.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CountryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CountryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Country.
     * @param {CountryUpsertArgs} args - Arguments to update or create a Country.
     * @example
     * // Update or create a Country
     * const country = await prisma.country.upsert({
     *   create: {
     *     // ... data to create a Country
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Country we want to update
     *   }
     * })
    **/
    upsert<T extends CountryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CountryUpsertArgs<ExtArgs>>
    ): Prisma__CountryClient<$Types.GetResult<CountryPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryCountArgs} args - Arguments to filter Countries to count.
     * @example
     * // Count the number of Countries
     * const count = await prisma.country.count({
     *   where: {
     *     // ... the filter for the Countries we want to count
     *   }
     * })
    **/
    count<T extends CountryCountArgs>(
      args?: Subset<T, CountryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CountryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CountryAggregateArgs>(args: Subset<T, CountryAggregateArgs>): Prisma.PrismaPromise<GetCountryAggregateType<T>>

    /**
     * Group by Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CountryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CountryGroupByArgs['orderBy'] }
        : { orderBy?: CountryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CountryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCountryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Country.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CountryClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    state<T extends Country$stateArgs<ExtArgs> = {}>(args?: Subset<T, Country$stateArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<StatePayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Country base type for findUnique actions
   */
  export type CountryFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country findUnique
   */
  export interface CountryFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends CountryFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Country findUniqueOrThrow
   */
  export type CountryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where: CountryWhereUniqueInput
  }


  /**
   * Country base type for findFirst actions
   */
  export type CountryFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: Enumerable<CountryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Countries.
     */
    distinct?: Enumerable<CountryScalarFieldEnum>
  }

  /**
   * Country findFirst
   */
  export interface CountryFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends CountryFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Country findFirstOrThrow
   */
  export type CountryFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: Enumerable<CountryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Countries.
     */
    distinct?: Enumerable<CountryScalarFieldEnum>
  }


  /**
   * Country findMany
   */
  export type CountryFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Countries to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: Enumerable<CountryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    distinct?: Enumerable<CountryScalarFieldEnum>
  }


  /**
   * Country create
   */
  export type CountryCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * The data needed to create a Country.
     */
    data: XOR<CountryCreateInput, CountryUncheckedCreateInput>
  }


  /**
   * Country createMany
   */
  export type CountryCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Countries.
     */
    data: Enumerable<CountryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Country update
   */
  export type CountryUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * The data needed to update a Country.
     */
    data: XOR<CountryUpdateInput, CountryUncheckedUpdateInput>
    /**
     * Choose, which Country to update.
     */
    where: CountryWhereUniqueInput
  }


  /**
   * Country updateMany
   */
  export type CountryUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Countries.
     */
    data: XOR<CountryUpdateManyMutationInput, CountryUncheckedUpdateManyInput>
    /**
     * Filter which Countries to update
     */
    where?: CountryWhereInput
  }


  /**
   * Country upsert
   */
  export type CountryUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * The filter to search for the Country to update in case it exists.
     */
    where: CountryWhereUniqueInput
    /**
     * In case the Country found by the `where` argument doesn't exist, create a new Country with this data.
     */
    create: XOR<CountryCreateInput, CountryUncheckedCreateInput>
    /**
     * In case the Country was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CountryUpdateInput, CountryUncheckedUpdateInput>
  }


  /**
   * Country delete
   */
  export type CountryDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter which Country to delete.
     */
    where: CountryWhereUniqueInput
  }


  /**
   * Country deleteMany
   */
  export type CountryDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Countries to delete
     */
    where?: CountryWhereInput
  }


  /**
   * Country.state
   */
  export type Country$stateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the State
     */
    select?: StateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StateInclude<ExtArgs> | null
    where?: StateWhereInput
    orderBy?: Enumerable<StateOrderByWithRelationInput>
    cursor?: StateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<StateScalarFieldEnum>
  }


  /**
   * Country without action
   */
  export type CountryArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CountryInclude<ExtArgs> | null
  }



  /**
   * Model State
   */


  export type AggregateState = {
    _count: StateCountAggregateOutputType | null
    _avg: StateAvgAggregateOutputType | null
    _sum: StateSumAggregateOutputType | null
    _min: StateMinAggregateOutputType | null
    _max: StateMaxAggregateOutputType | null
  }

  export type StateAvgAggregateOutputType = {
    id: number | null
    countryId: number | null
  }

  export type StateSumAggregateOutputType = {
    id: number | null
    countryId: number | null
  }

  export type StateMinAggregateOutputType = {
    id: number | null
    name: string | null
    countryId: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type StateMaxAggregateOutputType = {
    id: number | null
    name: string | null
    countryId: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type StateCountAggregateOutputType = {
    id: number
    name: number
    countryId: number
    isActive: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type StateAvgAggregateInputType = {
    id?: true
    countryId?: true
  }

  export type StateSumAggregateInputType = {
    id?: true
    countryId?: true
  }

  export type StateMinAggregateInputType = {
    id?: true
    name?: true
    countryId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type StateMaxAggregateInputType = {
    id?: true
    name?: true
    countryId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type StateCountAggregateInputType = {
    id?: true
    name?: true
    countryId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type StateAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which State to aggregate.
     */
    where?: StateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of States to fetch.
     */
    orderBy?: Enumerable<StateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` States from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` States.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned States
    **/
    _count?: true | StateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StateMaxAggregateInputType
  }

  export type GetStateAggregateType<T extends StateAggregateArgs> = {
        [P in keyof T & keyof AggregateState]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateState[P]>
      : GetScalarType<T[P], AggregateState[P]>
  }




  export type StateGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: StateWhereInput
    orderBy?: Enumerable<StateOrderByWithAggregationInput>
    by: StateScalarFieldEnum[]
    having?: StateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StateCountAggregateInputType | true
    _avg?: StateAvgAggregateInputType
    _sum?: StateSumAggregateInputType
    _min?: StateMinAggregateInputType
    _max?: StateMaxAggregateInputType
  }


  export type StateGroupByOutputType = {
    id: number
    name: string
    countryId: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: StateCountAggregateOutputType | null
    _avg: StateAvgAggregateOutputType | null
    _sum: StateSumAggregateOutputType | null
    _min: StateMinAggregateOutputType | null
    _max: StateMaxAggregateOutputType | null
  }

  type GetStateGroupByPayload<T extends StateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<StateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StateGroupByOutputType[P]>
            : GetScalarType<T[P], StateGroupByOutputType[P]>
        }
      >
    >


  export type StateSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    countryId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    country?: boolean | CountryArgs<ExtArgs>
    district?: boolean | State$districtArgs<ExtArgs>
    _count?: boolean | StateCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["state"]>

  export type StateSelectScalar = {
    id?: boolean
    name?: boolean
    countryId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type StateInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    country?: boolean | CountryArgs<ExtArgs>
    district?: boolean | State$districtArgs<ExtArgs>
    _count?: boolean | StateCountOutputTypeArgs<ExtArgs>
  }


  type StateGetPayload<S extends boolean | null | undefined | StateArgs> = $Types.GetResult<StatePayload, S>

  type StateCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<StateFindManyArgs, 'select' | 'include'> & {
      select?: StateCountAggregateInputType | true
    }

  export interface StateDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['State'], meta: { name: 'State' } }
    /**
     * Find zero or one State that matches the filter.
     * @param {StateFindUniqueArgs} args - Arguments to find a State
     * @example
     * // Get one State
     * const state = await prisma.state.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StateFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, StateFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'State'> extends True ? Prisma__StateClient<$Types.GetResult<StatePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__StateClient<$Types.GetResult<StatePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one State that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {StateFindUniqueOrThrowArgs} args - Arguments to find a State
     * @example
     * // Get one State
     * const state = await prisma.state.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StateFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StateFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__StateClient<$Types.GetResult<StatePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first State that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateFindFirstArgs} args - Arguments to find a State
     * @example
     * // Get one State
     * const state = await prisma.state.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StateFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, StateFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'State'> extends True ? Prisma__StateClient<$Types.GetResult<StatePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__StateClient<$Types.GetResult<StatePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first State that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateFindFirstOrThrowArgs} args - Arguments to find a State
     * @example
     * // Get one State
     * const state = await prisma.state.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StateFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StateFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__StateClient<$Types.GetResult<StatePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more States that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all States
     * const states = await prisma.state.findMany()
     * 
     * // Get first 10 States
     * const states = await prisma.state.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stateWithIdOnly = await prisma.state.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StateFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StateFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<StatePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a State.
     * @param {StateCreateArgs} args - Arguments to create a State.
     * @example
     * // Create one State
     * const State = await prisma.state.create({
     *   data: {
     *     // ... data to create a State
     *   }
     * })
     * 
    **/
    create<T extends StateCreateArgs<ExtArgs>>(
      args: SelectSubset<T, StateCreateArgs<ExtArgs>>
    ): Prisma__StateClient<$Types.GetResult<StatePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many States.
     *     @param {StateCreateManyArgs} args - Arguments to create many States.
     *     @example
     *     // Create many States
     *     const state = await prisma.state.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StateCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StateCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a State.
     * @param {StateDeleteArgs} args - Arguments to delete one State.
     * @example
     * // Delete one State
     * const State = await prisma.state.delete({
     *   where: {
     *     // ... filter to delete one State
     *   }
     * })
     * 
    **/
    delete<T extends StateDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, StateDeleteArgs<ExtArgs>>
    ): Prisma__StateClient<$Types.GetResult<StatePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one State.
     * @param {StateUpdateArgs} args - Arguments to update one State.
     * @example
     * // Update one State
     * const state = await prisma.state.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StateUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, StateUpdateArgs<ExtArgs>>
    ): Prisma__StateClient<$Types.GetResult<StatePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more States.
     * @param {StateDeleteManyArgs} args - Arguments to filter States to delete.
     * @example
     * // Delete a few States
     * const { count } = await prisma.state.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StateDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StateDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more States.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many States
     * const state = await prisma.state.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StateUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, StateUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one State.
     * @param {StateUpsertArgs} args - Arguments to update or create a State.
     * @example
     * // Update or create a State
     * const state = await prisma.state.upsert({
     *   create: {
     *     // ... data to create a State
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the State we want to update
     *   }
     * })
    **/
    upsert<T extends StateUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, StateUpsertArgs<ExtArgs>>
    ): Prisma__StateClient<$Types.GetResult<StatePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of States.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateCountArgs} args - Arguments to filter States to count.
     * @example
     * // Count the number of States
     * const count = await prisma.state.count({
     *   where: {
     *     // ... the filter for the States we want to count
     *   }
     * })
    **/
    count<T extends StateCountArgs>(
      args?: Subset<T, StateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a State.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StateAggregateArgs>(args: Subset<T, StateAggregateArgs>): Prisma.PrismaPromise<GetStateAggregateType<T>>

    /**
     * Group by State.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StateGroupByArgs['orderBy'] }
        : { orderBy?: StateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for State.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__StateClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    country<T extends CountryArgs<ExtArgs> = {}>(args?: Subset<T, CountryArgs<ExtArgs>>): Prisma__CountryClient<$Types.GetResult<CountryPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    district<T extends State$districtArgs<ExtArgs> = {}>(args?: Subset<T, State$districtArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<AddressPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * State base type for findUnique actions
   */
  export type StateFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the State
     */
    select?: StateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StateInclude<ExtArgs> | null
    /**
     * Filter, which State to fetch.
     */
    where: StateWhereUniqueInput
  }

  /**
   * State findUnique
   */
  export interface StateFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends StateFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * State findUniqueOrThrow
   */
  export type StateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the State
     */
    select?: StateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StateInclude<ExtArgs> | null
    /**
     * Filter, which State to fetch.
     */
    where: StateWhereUniqueInput
  }


  /**
   * State base type for findFirst actions
   */
  export type StateFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the State
     */
    select?: StateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StateInclude<ExtArgs> | null
    /**
     * Filter, which State to fetch.
     */
    where?: StateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of States to fetch.
     */
    orderBy?: Enumerable<StateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for States.
     */
    cursor?: StateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` States from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` States.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of States.
     */
    distinct?: Enumerable<StateScalarFieldEnum>
  }

  /**
   * State findFirst
   */
  export interface StateFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends StateFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * State findFirstOrThrow
   */
  export type StateFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the State
     */
    select?: StateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StateInclude<ExtArgs> | null
    /**
     * Filter, which State to fetch.
     */
    where?: StateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of States to fetch.
     */
    orderBy?: Enumerable<StateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for States.
     */
    cursor?: StateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` States from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` States.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of States.
     */
    distinct?: Enumerable<StateScalarFieldEnum>
  }


  /**
   * State findMany
   */
  export type StateFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the State
     */
    select?: StateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StateInclude<ExtArgs> | null
    /**
     * Filter, which States to fetch.
     */
    where?: StateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of States to fetch.
     */
    orderBy?: Enumerable<StateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing States.
     */
    cursor?: StateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` States from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` States.
     */
    skip?: number
    distinct?: Enumerable<StateScalarFieldEnum>
  }


  /**
   * State create
   */
  export type StateCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the State
     */
    select?: StateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StateInclude<ExtArgs> | null
    /**
     * The data needed to create a State.
     */
    data: XOR<StateCreateInput, StateUncheckedCreateInput>
  }


  /**
   * State createMany
   */
  export type StateCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many States.
     */
    data: Enumerable<StateCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * State update
   */
  export type StateUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the State
     */
    select?: StateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StateInclude<ExtArgs> | null
    /**
     * The data needed to update a State.
     */
    data: XOR<StateUpdateInput, StateUncheckedUpdateInput>
    /**
     * Choose, which State to update.
     */
    where: StateWhereUniqueInput
  }


  /**
   * State updateMany
   */
  export type StateUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update States.
     */
    data: XOR<StateUpdateManyMutationInput, StateUncheckedUpdateManyInput>
    /**
     * Filter which States to update
     */
    where?: StateWhereInput
  }


  /**
   * State upsert
   */
  export type StateUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the State
     */
    select?: StateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StateInclude<ExtArgs> | null
    /**
     * The filter to search for the State to update in case it exists.
     */
    where: StateWhereUniqueInput
    /**
     * In case the State found by the `where` argument doesn't exist, create a new State with this data.
     */
    create: XOR<StateCreateInput, StateUncheckedCreateInput>
    /**
     * In case the State was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StateUpdateInput, StateUncheckedUpdateInput>
  }


  /**
   * State delete
   */
  export type StateDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the State
     */
    select?: StateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StateInclude<ExtArgs> | null
    /**
     * Filter which State to delete.
     */
    where: StateWhereUniqueInput
  }


  /**
   * State deleteMany
   */
  export type StateDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which States to delete
     */
    where?: StateWhereInput
  }


  /**
   * State.district
   */
  export type State$districtArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressInclude<ExtArgs> | null
    where?: AddressWhereInput
    orderBy?: Enumerable<AddressOrderByWithRelationInput>
    cursor?: AddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AddressScalarFieldEnum>
  }


  /**
   * State without action
   */
  export type StateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the State
     */
    select?: StateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StateInclude<ExtArgs> | null
  }



  /**
   * Model Address
   */


  export type AggregateAddress = {
    _count: AddressCountAggregateOutputType | null
    _avg: AddressAvgAggregateOutputType | null
    _sum: AddressSumAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  export type AddressAvgAggregateOutputType = {
    id: number | null
    stateId: number | null
  }

  export type AddressSumAggregateOutputType = {
    id: number | null
    stateId: number | null
  }

  export type AddressMinAggregateOutputType = {
    id: number | null
    doorNumber: string | null
    streetName: string | null
    pinCode: string | null
    stateId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type AddressMaxAggregateOutputType = {
    id: number | null
    doorNumber: string | null
    streetName: string | null
    pinCode: string | null
    stateId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type AddressCountAggregateOutputType = {
    id: number
    doorNumber: number
    streetName: number
    pinCode: number
    stateId: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type AddressAvgAggregateInputType = {
    id?: true
    stateId?: true
  }

  export type AddressSumAggregateInputType = {
    id?: true
    stateId?: true
  }

  export type AddressMinAggregateInputType = {
    id?: true
    doorNumber?: true
    streetName?: true
    pinCode?: true
    stateId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type AddressMaxAggregateInputType = {
    id?: true
    doorNumber?: true
    streetName?: true
    pinCode?: true
    stateId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type AddressCountAggregateInputType = {
    id?: true
    doorNumber?: true
    streetName?: true
    pinCode?: true
    stateId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type AddressAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Address to aggregate.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: Enumerable<AddressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Addresses
    **/
    _count?: true | AddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AddressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AddressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddressMaxAggregateInputType
  }

  export type GetAddressAggregateType<T extends AddressAggregateArgs> = {
        [P in keyof T & keyof AggregateAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddress[P]>
      : GetScalarType<T[P], AggregateAddress[P]>
  }




  export type AddressGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AddressWhereInput
    orderBy?: Enumerable<AddressOrderByWithAggregationInput>
    by: AddressScalarFieldEnum[]
    having?: AddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddressCountAggregateInputType | true
    _avg?: AddressAvgAggregateInputType
    _sum?: AddressSumAggregateInputType
    _min?: AddressMinAggregateInputType
    _max?: AddressMaxAggregateInputType
  }


  export type AddressGroupByOutputType = {
    id: number
    doorNumber: string
    streetName: string
    pinCode: string
    stateId: number
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: AddressCountAggregateOutputType | null
    _avg: AddressAvgAggregateOutputType | null
    _sum: AddressSumAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  type GetAddressGroupByPayload<T extends AddressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddressGroupByOutputType[P]>
            : GetScalarType<T[P], AddressGroupByOutputType[P]>
        }
      >
    >


  export type AddressSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    doorNumber?: boolean
    streetName?: boolean
    pinCode?: boolean
    stateId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    state?: boolean | StateArgs<ExtArgs>
    userAddress?: boolean | Address$userAddressArgs<ExtArgs>
    _count?: boolean | AddressCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>

  export type AddressSelectScalar = {
    id?: boolean
    doorNumber?: boolean
    streetName?: boolean
    pinCode?: boolean
    stateId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type AddressInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    state?: boolean | StateArgs<ExtArgs>
    userAddress?: boolean | Address$userAddressArgs<ExtArgs>
    _count?: boolean | AddressCountOutputTypeArgs<ExtArgs>
  }


  type AddressGetPayload<S extends boolean | null | undefined | AddressArgs> = $Types.GetResult<AddressPayload, S>

  type AddressCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<AddressFindManyArgs, 'select' | 'include'> & {
      select?: AddressCountAggregateInputType | true
    }

  export interface AddressDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Address'], meta: { name: 'Address' } }
    /**
     * Find zero or one Address that matches the filter.
     * @param {AddressFindUniqueArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AddressFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AddressFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Address'> extends True ? Prisma__AddressClient<$Types.GetResult<AddressPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__AddressClient<$Types.GetResult<AddressPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Address that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AddressFindUniqueOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AddressFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AddressFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AddressClient<$Types.GetResult<AddressPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Address that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AddressFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AddressFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Address'> extends True ? Prisma__AddressClient<$Types.GetResult<AddressPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__AddressClient<$Types.GetResult<AddressPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Address that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AddressFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AddressFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AddressClient<$Types.GetResult<AddressPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Addresses
     * const addresses = await prisma.address.findMany()
     * 
     * // Get first 10 Addresses
     * const addresses = await prisma.address.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addressWithIdOnly = await prisma.address.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AddressFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AddressFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<AddressPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Address.
     * @param {AddressCreateArgs} args - Arguments to create a Address.
     * @example
     * // Create one Address
     * const Address = await prisma.address.create({
     *   data: {
     *     // ... data to create a Address
     *   }
     * })
     * 
    **/
    create<T extends AddressCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AddressCreateArgs<ExtArgs>>
    ): Prisma__AddressClient<$Types.GetResult<AddressPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Addresses.
     *     @param {AddressCreateManyArgs} args - Arguments to create many Addresses.
     *     @example
     *     // Create many Addresses
     *     const address = await prisma.address.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AddressCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AddressCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Address.
     * @param {AddressDeleteArgs} args - Arguments to delete one Address.
     * @example
     * // Delete one Address
     * const Address = await prisma.address.delete({
     *   where: {
     *     // ... filter to delete one Address
     *   }
     * })
     * 
    **/
    delete<T extends AddressDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AddressDeleteArgs<ExtArgs>>
    ): Prisma__AddressClient<$Types.GetResult<AddressPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Address.
     * @param {AddressUpdateArgs} args - Arguments to update one Address.
     * @example
     * // Update one Address
     * const address = await prisma.address.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AddressUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AddressUpdateArgs<ExtArgs>>
    ): Prisma__AddressClient<$Types.GetResult<AddressPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Addresses.
     * @param {AddressDeleteManyArgs} args - Arguments to filter Addresses to delete.
     * @example
     * // Delete a few Addresses
     * const { count } = await prisma.address.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AddressDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AddressDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AddressUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AddressUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Address.
     * @param {AddressUpsertArgs} args - Arguments to update or create a Address.
     * @example
     * // Update or create a Address
     * const address = await prisma.address.upsert({
     *   create: {
     *     // ... data to create a Address
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Address we want to update
     *   }
     * })
    **/
    upsert<T extends AddressUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AddressUpsertArgs<ExtArgs>>
    ): Prisma__AddressClient<$Types.GetResult<AddressPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressCountArgs} args - Arguments to filter Addresses to count.
     * @example
     * // Count the number of Addresses
     * const count = await prisma.address.count({
     *   where: {
     *     // ... the filter for the Addresses we want to count
     *   }
     * })
    **/
    count<T extends AddressCountArgs>(
      args?: Subset<T, AddressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddressAggregateArgs>(args: Subset<T, AddressAggregateArgs>): Prisma.PrismaPromise<GetAddressAggregateType<T>>

    /**
     * Group by Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddressGroupByArgs['orderBy'] }
        : { orderBy?: AddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Address.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AddressClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    state<T extends StateArgs<ExtArgs> = {}>(args?: Subset<T, StateArgs<ExtArgs>>): Prisma__StateClient<$Types.GetResult<StatePayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    userAddress<T extends Address$userAddressArgs<ExtArgs> = {}>(args?: Subset<T, Address$userAddressArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<UserAddressPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Address base type for findUnique actions
   */
  export type AddressFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address findUnique
   */
  export interface AddressFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends AddressFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Address findUniqueOrThrow
   */
  export type AddressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput
  }


  /**
   * Address base type for findFirst actions
   */
  export type AddressFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: Enumerable<AddressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: Enumerable<AddressScalarFieldEnum>
  }

  /**
   * Address findFirst
   */
  export interface AddressFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends AddressFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Address findFirstOrThrow
   */
  export type AddressFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: Enumerable<AddressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: Enumerable<AddressScalarFieldEnum>
  }


  /**
   * Address findMany
   */
  export type AddressFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Addresses to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: Enumerable<AddressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    distinct?: Enumerable<AddressScalarFieldEnum>
  }


  /**
   * Address create
   */
  export type AddressCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The data needed to create a Address.
     */
    data: XOR<AddressCreateInput, AddressUncheckedCreateInput>
  }


  /**
   * Address createMany
   */
  export type AddressCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Addresses.
     */
    data: Enumerable<AddressCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Address update
   */
  export type AddressUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The data needed to update a Address.
     */
    data: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
    /**
     * Choose, which Address to update.
     */
    where: AddressWhereUniqueInput
  }


  /**
   * Address updateMany
   */
  export type AddressUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Addresses.
     */
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>
    /**
     * Filter which Addresses to update
     */
    where?: AddressWhereInput
  }


  /**
   * Address upsert
   */
  export type AddressUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The filter to search for the Address to update in case it exists.
     */
    where: AddressWhereUniqueInput
    /**
     * In case the Address found by the `where` argument doesn't exist, create a new Address with this data.
     */
    create: XOR<AddressCreateInput, AddressUncheckedCreateInput>
    /**
     * In case the Address was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
  }


  /**
   * Address delete
   */
  export type AddressDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter which Address to delete.
     */
    where: AddressWhereUniqueInput
  }


  /**
   * Address deleteMany
   */
  export type AddressDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Addresses to delete
     */
    where?: AddressWhereInput
  }


  /**
   * Address.userAddress
   */
  export type Address$userAddressArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserAddressInclude<ExtArgs> | null
    where?: UserAddressWhereInput
    orderBy?: Enumerable<UserAddressOrderByWithRelationInput>
    cursor?: UserAddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserAddressScalarFieldEnum>
  }


  /**
   * Address without action
   */
  export type AddressArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressInclude<ExtArgs> | null
  }



  /**
   * Model UserAddress
   */


  export type AggregateUserAddress = {
    _count: UserAddressCountAggregateOutputType | null
    _avg: UserAddressAvgAggregateOutputType | null
    _sum: UserAddressSumAggregateOutputType | null
    _min: UserAddressMinAggregateOutputType | null
    _max: UserAddressMaxAggregateOutputType | null
  }

  export type UserAddressAvgAggregateOutputType = {
    id: number | null
    addressId: number | null
    userId: number | null
  }

  export type UserAddressSumAggregateOutputType = {
    id: number | null
    addressId: number | null
    userId: number | null
  }

  export type UserAddressMinAggregateOutputType = {
    id: number | null
    addressId: number | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type UserAddressMaxAggregateOutputType = {
    id: number | null
    addressId: number | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type UserAddressCountAggregateOutputType = {
    id: number
    addressId: number
    userId: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type UserAddressAvgAggregateInputType = {
    id?: true
    addressId?: true
    userId?: true
  }

  export type UserAddressSumAggregateInputType = {
    id?: true
    addressId?: true
    userId?: true
  }

  export type UserAddressMinAggregateInputType = {
    id?: true
    addressId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type UserAddressMaxAggregateInputType = {
    id?: true
    addressId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type UserAddressCountAggregateInputType = {
    id?: true
    addressId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type UserAddressAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAddress to aggregate.
     */
    where?: UserAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAddresses to fetch.
     */
    orderBy?: Enumerable<UserAddressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserAddresses
    **/
    _count?: true | UserAddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAddressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserAddressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserAddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserAddressMaxAggregateInputType
  }

  export type GetUserAddressAggregateType<T extends UserAddressAggregateArgs> = {
        [P in keyof T & keyof AggregateUserAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserAddress[P]>
      : GetScalarType<T[P], AggregateUserAddress[P]>
  }




  export type UserAddressGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserAddressWhereInput
    orderBy?: Enumerable<UserAddressOrderByWithAggregationInput>
    by: UserAddressScalarFieldEnum[]
    having?: UserAddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserAddressCountAggregateInputType | true
    _avg?: UserAddressAvgAggregateInputType
    _sum?: UserAddressSumAggregateInputType
    _min?: UserAddressMinAggregateInputType
    _max?: UserAddressMaxAggregateInputType
  }


  export type UserAddressGroupByOutputType = {
    id: number
    addressId: number
    userId: number
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: UserAddressCountAggregateOutputType | null
    _avg: UserAddressAvgAggregateOutputType | null
    _sum: UserAddressSumAggregateOutputType | null
    _min: UserAddressMinAggregateOutputType | null
    _max: UserAddressMaxAggregateOutputType | null
  }

  type GetUserAddressGroupByPayload<T extends UserAddressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserAddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserAddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserAddressGroupByOutputType[P]>
            : GetScalarType<T[P], UserAddressGroupByOutputType[P]>
        }
      >
    >


  export type UserAddressSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    addressId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    address?: boolean | AddressArgs<ExtArgs>
    user?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["userAddress"]>

  export type UserAddressSelectScalar = {
    id?: boolean
    addressId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type UserAddressInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    address?: boolean | AddressArgs<ExtArgs>
    user?: boolean | UserArgs<ExtArgs>
  }


  type UserAddressGetPayload<S extends boolean | null | undefined | UserAddressArgs> = $Types.GetResult<UserAddressPayload, S>

  type UserAddressCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<UserAddressFindManyArgs, 'select' | 'include'> & {
      select?: UserAddressCountAggregateInputType | true
    }

  export interface UserAddressDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserAddress'], meta: { name: 'UserAddress' } }
    /**
     * Find zero or one UserAddress that matches the filter.
     * @param {UserAddressFindUniqueArgs} args - Arguments to find a UserAddress
     * @example
     * // Get one UserAddress
     * const userAddress = await prisma.userAddress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserAddressFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserAddressFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserAddress'> extends True ? Prisma__UserAddressClient<$Types.GetResult<UserAddressPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__UserAddressClient<$Types.GetResult<UserAddressPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one UserAddress that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserAddressFindUniqueOrThrowArgs} args - Arguments to find a UserAddress
     * @example
     * // Get one UserAddress
     * const userAddress = await prisma.userAddress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserAddressFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserAddressFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserAddressClient<$Types.GetResult<UserAddressPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first UserAddress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAddressFindFirstArgs} args - Arguments to find a UserAddress
     * @example
     * // Get one UserAddress
     * const userAddress = await prisma.userAddress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserAddressFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserAddressFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserAddress'> extends True ? Prisma__UserAddressClient<$Types.GetResult<UserAddressPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__UserAddressClient<$Types.GetResult<UserAddressPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first UserAddress that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAddressFindFirstOrThrowArgs} args - Arguments to find a UserAddress
     * @example
     * // Get one UserAddress
     * const userAddress = await prisma.userAddress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserAddressFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserAddressFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserAddressClient<$Types.GetResult<UserAddressPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more UserAddresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAddressFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserAddresses
     * const userAddresses = await prisma.userAddress.findMany()
     * 
     * // Get first 10 UserAddresses
     * const userAddresses = await prisma.userAddress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userAddressWithIdOnly = await prisma.userAddress.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserAddressFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserAddressFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<UserAddressPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a UserAddress.
     * @param {UserAddressCreateArgs} args - Arguments to create a UserAddress.
     * @example
     * // Create one UserAddress
     * const UserAddress = await prisma.userAddress.create({
     *   data: {
     *     // ... data to create a UserAddress
     *   }
     * })
     * 
    **/
    create<T extends UserAddressCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserAddressCreateArgs<ExtArgs>>
    ): Prisma__UserAddressClient<$Types.GetResult<UserAddressPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many UserAddresses.
     *     @param {UserAddressCreateManyArgs} args - Arguments to create many UserAddresses.
     *     @example
     *     // Create many UserAddresses
     *     const userAddress = await prisma.userAddress.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserAddressCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserAddressCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserAddress.
     * @param {UserAddressDeleteArgs} args - Arguments to delete one UserAddress.
     * @example
     * // Delete one UserAddress
     * const UserAddress = await prisma.userAddress.delete({
     *   where: {
     *     // ... filter to delete one UserAddress
     *   }
     * })
     * 
    **/
    delete<T extends UserAddressDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserAddressDeleteArgs<ExtArgs>>
    ): Prisma__UserAddressClient<$Types.GetResult<UserAddressPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one UserAddress.
     * @param {UserAddressUpdateArgs} args - Arguments to update one UserAddress.
     * @example
     * // Update one UserAddress
     * const userAddress = await prisma.userAddress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserAddressUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserAddressUpdateArgs<ExtArgs>>
    ): Prisma__UserAddressClient<$Types.GetResult<UserAddressPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more UserAddresses.
     * @param {UserAddressDeleteManyArgs} args - Arguments to filter UserAddresses to delete.
     * @example
     * // Delete a few UserAddresses
     * const { count } = await prisma.userAddress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserAddressDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserAddressDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserAddresses
     * const userAddress = await prisma.userAddress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserAddressUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserAddressUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserAddress.
     * @param {UserAddressUpsertArgs} args - Arguments to update or create a UserAddress.
     * @example
     * // Update or create a UserAddress
     * const userAddress = await prisma.userAddress.upsert({
     *   create: {
     *     // ... data to create a UserAddress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserAddress we want to update
     *   }
     * })
    **/
    upsert<T extends UserAddressUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserAddressUpsertArgs<ExtArgs>>
    ): Prisma__UserAddressClient<$Types.GetResult<UserAddressPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of UserAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAddressCountArgs} args - Arguments to filter UserAddresses to count.
     * @example
     * // Count the number of UserAddresses
     * const count = await prisma.userAddress.count({
     *   where: {
     *     // ... the filter for the UserAddresses we want to count
     *   }
     * })
    **/
    count<T extends UserAddressCountArgs>(
      args?: Subset<T, UserAddressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserAddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAddressAggregateArgs>(args: Subset<T, UserAddressAggregateArgs>): Prisma.PrismaPromise<GetUserAddressAggregateType<T>>

    /**
     * Group by UserAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserAddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserAddressGroupByArgs['orderBy'] }
        : { orderBy?: UserAddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserAddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for UserAddress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserAddressClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    address<T extends AddressArgs<ExtArgs> = {}>(args?: Subset<T, AddressArgs<ExtArgs>>): Prisma__AddressClient<$Types.GetResult<AddressPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * UserAddress base type for findUnique actions
   */
  export type UserAddressFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserAddressInclude<ExtArgs> | null
    /**
     * Filter, which UserAddress to fetch.
     */
    where: UserAddressWhereUniqueInput
  }

  /**
   * UserAddress findUnique
   */
  export interface UserAddressFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends UserAddressFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserAddress findUniqueOrThrow
   */
  export type UserAddressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserAddressInclude<ExtArgs> | null
    /**
     * Filter, which UserAddress to fetch.
     */
    where: UserAddressWhereUniqueInput
  }


  /**
   * UserAddress base type for findFirst actions
   */
  export type UserAddressFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserAddressInclude<ExtArgs> | null
    /**
     * Filter, which UserAddress to fetch.
     */
    where?: UserAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAddresses to fetch.
     */
    orderBy?: Enumerable<UserAddressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAddresses.
     */
    cursor?: UserAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAddresses.
     */
    distinct?: Enumerable<UserAddressScalarFieldEnum>
  }

  /**
   * UserAddress findFirst
   */
  export interface UserAddressFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends UserAddressFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserAddress findFirstOrThrow
   */
  export type UserAddressFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserAddressInclude<ExtArgs> | null
    /**
     * Filter, which UserAddress to fetch.
     */
    where?: UserAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAddresses to fetch.
     */
    orderBy?: Enumerable<UserAddressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAddresses.
     */
    cursor?: UserAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAddresses.
     */
    distinct?: Enumerable<UserAddressScalarFieldEnum>
  }


  /**
   * UserAddress findMany
   */
  export type UserAddressFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserAddressInclude<ExtArgs> | null
    /**
     * Filter, which UserAddresses to fetch.
     */
    where?: UserAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAddresses to fetch.
     */
    orderBy?: Enumerable<UserAddressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserAddresses.
     */
    cursor?: UserAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAddresses.
     */
    skip?: number
    distinct?: Enumerable<UserAddressScalarFieldEnum>
  }


  /**
   * UserAddress create
   */
  export type UserAddressCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserAddressInclude<ExtArgs> | null
    /**
     * The data needed to create a UserAddress.
     */
    data: XOR<UserAddressCreateInput, UserAddressUncheckedCreateInput>
  }


  /**
   * UserAddress createMany
   */
  export type UserAddressCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserAddresses.
     */
    data: Enumerable<UserAddressCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserAddress update
   */
  export type UserAddressUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserAddressInclude<ExtArgs> | null
    /**
     * The data needed to update a UserAddress.
     */
    data: XOR<UserAddressUpdateInput, UserAddressUncheckedUpdateInput>
    /**
     * Choose, which UserAddress to update.
     */
    where: UserAddressWhereUniqueInput
  }


  /**
   * UserAddress updateMany
   */
  export type UserAddressUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserAddresses.
     */
    data: XOR<UserAddressUpdateManyMutationInput, UserAddressUncheckedUpdateManyInput>
    /**
     * Filter which UserAddresses to update
     */
    where?: UserAddressWhereInput
  }


  /**
   * UserAddress upsert
   */
  export type UserAddressUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserAddressInclude<ExtArgs> | null
    /**
     * The filter to search for the UserAddress to update in case it exists.
     */
    where: UserAddressWhereUniqueInput
    /**
     * In case the UserAddress found by the `where` argument doesn't exist, create a new UserAddress with this data.
     */
    create: XOR<UserAddressCreateInput, UserAddressUncheckedCreateInput>
    /**
     * In case the UserAddress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserAddressUpdateInput, UserAddressUncheckedUpdateInput>
  }


  /**
   * UserAddress delete
   */
  export type UserAddressDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserAddressInclude<ExtArgs> | null
    /**
     * Filter which UserAddress to delete.
     */
    where: UserAddressWhereUniqueInput
  }


  /**
   * UserAddress deleteMany
   */
  export type UserAddressDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAddresses to delete
     */
    where?: UserAddressWhereInput
  }


  /**
   * UserAddress without action
   */
  export type UserAddressArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserAddressInclude<ExtArgs> | null
  }



  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    roleId: number | null
    genderId: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    roleId: number | null
    genderId: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    username: string | null
    email: string | null
    mobile: string | null
    token: string | null
    roleId: number | null
    genderId: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    username: string | null
    email: string | null
    mobile: string | null
    token: string | null
    roleId: number | null
    genderId: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    email: number
    mobile: number
    token: number
    roleId: number
    genderId: number
    isActive: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    roleId?: true
    genderId?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    roleId?: true
    genderId?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    email?: true
    mobile?: true
    token?: true
    roleId?: true
    genderId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    email?: true
    mobile?: true
    token?: true
    roleId?: true
    genderId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    email?: true
    mobile?: true
    token?: true
    roleId?: true
    genderId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: UserScalarFieldEnum[]
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: number
    username: string
    email: string
    mobile: string
    token: string | null
    roleId: number
    genderId: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    mobile?: boolean
    token?: boolean
    roleId?: boolean
    genderId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    userProduct?: boolean | User$userProductArgs<ExtArgs>
    userAddress?: boolean | User$userAddressArgs<ExtArgs>
    addCart?: boolean | User$addCartArgs<ExtArgs>
    wishlist?: boolean | User$wishlistArgs<ExtArgs>
    loginRequests?: boolean | User$loginRequestsArgs<ExtArgs>
    ProductReview?: boolean | User$ProductReviewArgs<ExtArgs>
    order?: boolean | User$orderArgs<ExtArgs>
    userSearchItems?: boolean | User$userSearchItemsArgs<ExtArgs>
    password?: boolean | User$passwordArgs<ExtArgs>
    roles?: boolean | RolesArgs<ExtArgs>
    gender?: boolean | GenderArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    username?: boolean
    email?: boolean
    mobile?: boolean
    token?: boolean
    roleId?: boolean
    genderId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    userProduct?: boolean | User$userProductArgs<ExtArgs>
    userAddress?: boolean | User$userAddressArgs<ExtArgs>
    addCart?: boolean | User$addCartArgs<ExtArgs>
    wishlist?: boolean | User$wishlistArgs<ExtArgs>
    loginRequests?: boolean | User$loginRequestsArgs<ExtArgs>
    ProductReview?: boolean | User$ProductReviewArgs<ExtArgs>
    order?: boolean | User$orderArgs<ExtArgs>
    userSearchItems?: boolean | User$userSearchItemsArgs<ExtArgs>
    password?: boolean | User$passwordArgs<ExtArgs>
    roles?: boolean | RolesArgs<ExtArgs>
    gender?: boolean | GenderArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeArgs<ExtArgs>
  }


  type UserGetPayload<S extends boolean | null | undefined | UserArgs> = $Types.GetResult<UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<UserPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    userProduct<T extends User$userProductArgs<ExtArgs> = {}>(args?: Subset<T, User$userProductArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ProductPayload<ExtArgs>, T, 'findMany', never>| Null>;

    userAddress<T extends User$userAddressArgs<ExtArgs> = {}>(args?: Subset<T, User$userAddressArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<UserAddressPayload<ExtArgs>, T, 'findMany', never>| Null>;

    addCart<T extends User$addCartArgs<ExtArgs> = {}>(args?: Subset<T, User$addCartArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<CartPayload<ExtArgs>, T, 'findMany', never>| Null>;

    wishlist<T extends User$wishlistArgs<ExtArgs> = {}>(args?: Subset<T, User$wishlistArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<WishlistPayload<ExtArgs>, T, 'findMany', never>| Null>;

    loginRequests<T extends User$loginRequestsArgs<ExtArgs> = {}>(args?: Subset<T, User$loginRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<UserLoginRequestPayload<ExtArgs>, T, 'findMany', never>| Null>;

    ProductReview<T extends User$ProductReviewArgs<ExtArgs> = {}>(args?: Subset<T, User$ProductReviewArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ProductReviewPayload<ExtArgs>, T, 'findMany', never>| Null>;

    order<T extends User$orderArgs<ExtArgs> = {}>(args?: Subset<T, User$orderArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<OrderPayload<ExtArgs>, T, 'findMany', never>| Null>;

    userSearchItems<T extends User$userSearchItemsArgs<ExtArgs> = {}>(args?: Subset<T, User$userSearchItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<SearchItemsPayload<ExtArgs>, T, 'findMany', never>| Null>;

    password<T extends User$passwordArgs<ExtArgs> = {}>(args?: Subset<T, User$passwordArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<UserPasswordPayload<ExtArgs>, T, 'findMany', never>| Null>;

    roles<T extends RolesArgs<ExtArgs> = {}>(args?: Subset<T, RolesArgs<ExtArgs>>): Prisma__RolesClient<$Types.GetResult<RolesPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    gender<T extends GenderArgs<ExtArgs> = {}>(args?: Subset<T, GenderArgs<ExtArgs>>): Prisma__GenderClient<$Types.GetResult<GenderPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * User base type for findUnique actions
   */
  export type UserFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUnique
   */
  export interface UserFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends UserFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User base type for findFirst actions
   */
  export type UserFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }

  /**
   * User findFirst
   */
  export interface UserFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends UserFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.userProduct
   */
  export type User$userProductArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ProductScalarFieldEnum>
  }


  /**
   * User.userAddress
   */
  export type User$userAddressArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserAddressInclude<ExtArgs> | null
    where?: UserAddressWhereInput
    orderBy?: Enumerable<UserAddressOrderByWithRelationInput>
    cursor?: UserAddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserAddressScalarFieldEnum>
  }


  /**
   * User.addCart
   */
  export type User$addCartArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CartInclude<ExtArgs> | null
    where?: CartWhereInput
    orderBy?: Enumerable<CartOrderByWithRelationInput>
    cursor?: CartWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CartScalarFieldEnum>
  }


  /**
   * User.wishlist
   */
  export type User$wishlistArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WishlistInclude<ExtArgs> | null
    where?: WishlistWhereInput
    orderBy?: Enumerable<WishlistOrderByWithRelationInput>
    cursor?: WishlistWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<WishlistScalarFieldEnum>
  }


  /**
   * User.loginRequests
   */
  export type User$loginRequestsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLoginRequest
     */
    select?: UserLoginRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserLoginRequestInclude<ExtArgs> | null
    where?: UserLoginRequestWhereInput
    orderBy?: Enumerable<UserLoginRequestOrderByWithRelationInput>
    cursor?: UserLoginRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserLoginRequestScalarFieldEnum>
  }


  /**
   * User.ProductReview
   */
  export type User$ProductReviewArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReview
     */
    select?: ProductReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductReviewInclude<ExtArgs> | null
    where?: ProductReviewWhereInput
    orderBy?: Enumerable<ProductReviewOrderByWithRelationInput>
    cursor?: ProductReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ProductReviewScalarFieldEnum>
  }


  /**
   * User.order
   */
  export type User$orderArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: Enumerable<OrderOrderByWithRelationInput>
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<OrderScalarFieldEnum>
  }


  /**
   * User.userSearchItems
   */
  export type User$userSearchItemsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchItems
     */
    select?: SearchItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SearchItemsInclude<ExtArgs> | null
    where?: SearchItemsWhereInput
    orderBy?: Enumerable<SearchItemsOrderByWithRelationInput>
    cursor?: SearchItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SearchItemsScalarFieldEnum>
  }


  /**
   * User.password
   */
  export type User$passwordArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPassword
     */
    select?: UserPasswordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserPasswordInclude<ExtArgs> | null
    where?: UserPasswordWhereInput
    orderBy?: Enumerable<UserPasswordOrderByWithRelationInput>
    cursor?: UserPasswordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserPasswordScalarFieldEnum>
  }


  /**
   * User without action
   */
  export type UserArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
  }



  /**
   * Model ProductOwner
   */


  export type AggregateProductOwner = {
    _count: ProductOwnerCountAggregateOutputType | null
    _avg: ProductOwnerAvgAggregateOutputType | null
    _sum: ProductOwnerSumAggregateOutputType | null
    _min: ProductOwnerMinAggregateOutputType | null
    _max: ProductOwnerMaxAggregateOutputType | null
  }

  export type ProductOwnerAvgAggregateOutputType = {
    id: number | null
    syncUserId: number | null
  }

  export type ProductOwnerSumAggregateOutputType = {
    id: number | null
    syncUserId: number | null
  }

  export type ProductOwnerMinAggregateOutputType = {
    id: number | null
    syncUserId: number | null
    ownerName: string | null
    ownerEmail: string | null
    ownerMobile: string | null
    storeName: string | null
    storeAddress: string | null
    storeCity: string | null
    storePincode: string | null
    storeState: string | null
    customerCareEmail: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ProductOwnerMaxAggregateOutputType = {
    id: number | null
    syncUserId: number | null
    ownerName: string | null
    ownerEmail: string | null
    ownerMobile: string | null
    storeName: string | null
    storeAddress: string | null
    storeCity: string | null
    storePincode: string | null
    storeState: string | null
    customerCareEmail: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ProductOwnerCountAggregateOutputType = {
    id: number
    syncUserId: number
    ownerName: number
    ownerEmail: number
    ownerMobile: number
    storeName: number
    storeAddress: number
    storeCity: number
    storePincode: number
    storeState: number
    customerCareEmail: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type ProductOwnerAvgAggregateInputType = {
    id?: true
    syncUserId?: true
  }

  export type ProductOwnerSumAggregateInputType = {
    id?: true
    syncUserId?: true
  }

  export type ProductOwnerMinAggregateInputType = {
    id?: true
    syncUserId?: true
    ownerName?: true
    ownerEmail?: true
    ownerMobile?: true
    storeName?: true
    storeAddress?: true
    storeCity?: true
    storePincode?: true
    storeState?: true
    customerCareEmail?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ProductOwnerMaxAggregateInputType = {
    id?: true
    syncUserId?: true
    ownerName?: true
    ownerEmail?: true
    ownerMobile?: true
    storeName?: true
    storeAddress?: true
    storeCity?: true
    storePincode?: true
    storeState?: true
    customerCareEmail?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ProductOwnerCountAggregateInputType = {
    id?: true
    syncUserId?: true
    ownerName?: true
    ownerEmail?: true
    ownerMobile?: true
    storeName?: true
    storeAddress?: true
    storeCity?: true
    storePincode?: true
    storeState?: true
    customerCareEmail?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type ProductOwnerAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductOwner to aggregate.
     */
    where?: ProductOwnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductOwners to fetch.
     */
    orderBy?: Enumerable<ProductOwnerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductOwnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductOwners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductOwners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductOwners
    **/
    _count?: true | ProductOwnerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductOwnerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductOwnerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductOwnerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductOwnerMaxAggregateInputType
  }

  export type GetProductOwnerAggregateType<T extends ProductOwnerAggregateArgs> = {
        [P in keyof T & keyof AggregateProductOwner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductOwner[P]>
      : GetScalarType<T[P], AggregateProductOwner[P]>
  }




  export type ProductOwnerGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ProductOwnerWhereInput
    orderBy?: Enumerable<ProductOwnerOrderByWithAggregationInput>
    by: ProductOwnerScalarFieldEnum[]
    having?: ProductOwnerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductOwnerCountAggregateInputType | true
    _avg?: ProductOwnerAvgAggregateInputType
    _sum?: ProductOwnerSumAggregateInputType
    _min?: ProductOwnerMinAggregateInputType
    _max?: ProductOwnerMaxAggregateInputType
  }


  export type ProductOwnerGroupByOutputType = {
    id: number
    syncUserId: number
    ownerName: string
    ownerEmail: string
    ownerMobile: string
    storeName: string
    storeAddress: string
    storeCity: string
    storePincode: string
    storeState: string
    customerCareEmail: string
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: ProductOwnerCountAggregateOutputType | null
    _avg: ProductOwnerAvgAggregateOutputType | null
    _sum: ProductOwnerSumAggregateOutputType | null
    _min: ProductOwnerMinAggregateOutputType | null
    _max: ProductOwnerMaxAggregateOutputType | null
  }

  type GetProductOwnerGroupByPayload<T extends ProductOwnerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ProductOwnerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductOwnerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductOwnerGroupByOutputType[P]>
            : GetScalarType<T[P], ProductOwnerGroupByOutputType[P]>
        }
      >
    >


  export type ProductOwnerSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    syncUserId?: boolean
    ownerName?: boolean
    ownerEmail?: boolean
    ownerMobile?: boolean
    storeName?: boolean
    storeAddress?: boolean
    storeCity?: boolean
    storePincode?: boolean
    storeState?: boolean
    customerCareEmail?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    product?: boolean | ProductOwner$productArgs<ExtArgs>
    _count?: boolean | ProductOwnerCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["productOwner"]>

  export type ProductOwnerSelectScalar = {
    id?: boolean
    syncUserId?: boolean
    ownerName?: boolean
    ownerEmail?: boolean
    ownerMobile?: boolean
    storeName?: boolean
    storeAddress?: boolean
    storeCity?: boolean
    storePincode?: boolean
    storeState?: boolean
    customerCareEmail?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type ProductOwnerInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    product?: boolean | ProductOwner$productArgs<ExtArgs>
    _count?: boolean | ProductOwnerCountOutputTypeArgs<ExtArgs>
  }


  type ProductOwnerGetPayload<S extends boolean | null | undefined | ProductOwnerArgs> = $Types.GetResult<ProductOwnerPayload, S>

  type ProductOwnerCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ProductOwnerFindManyArgs, 'select' | 'include'> & {
      select?: ProductOwnerCountAggregateInputType | true
    }

  export interface ProductOwnerDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductOwner'], meta: { name: 'ProductOwner' } }
    /**
     * Find zero or one ProductOwner that matches the filter.
     * @param {ProductOwnerFindUniqueArgs} args - Arguments to find a ProductOwner
     * @example
     * // Get one ProductOwner
     * const productOwner = await prisma.productOwner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductOwnerFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductOwnerFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ProductOwner'> extends True ? Prisma__ProductOwnerClient<$Types.GetResult<ProductOwnerPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ProductOwnerClient<$Types.GetResult<ProductOwnerPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one ProductOwner that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProductOwnerFindUniqueOrThrowArgs} args - Arguments to find a ProductOwner
     * @example
     * // Get one ProductOwner
     * const productOwner = await prisma.productOwner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProductOwnerFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductOwnerFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProductOwnerClient<$Types.GetResult<ProductOwnerPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first ProductOwner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductOwnerFindFirstArgs} args - Arguments to find a ProductOwner
     * @example
     * // Get one ProductOwner
     * const productOwner = await prisma.productOwner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductOwnerFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductOwnerFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ProductOwner'> extends True ? Prisma__ProductOwnerClient<$Types.GetResult<ProductOwnerPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ProductOwnerClient<$Types.GetResult<ProductOwnerPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first ProductOwner that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductOwnerFindFirstOrThrowArgs} args - Arguments to find a ProductOwner
     * @example
     * // Get one ProductOwner
     * const productOwner = await prisma.productOwner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProductOwnerFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductOwnerFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProductOwnerClient<$Types.GetResult<ProductOwnerPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more ProductOwners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductOwnerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductOwners
     * const productOwners = await prisma.productOwner.findMany()
     * 
     * // Get first 10 ProductOwners
     * const productOwners = await prisma.productOwner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productOwnerWithIdOnly = await prisma.productOwner.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductOwnerFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductOwnerFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ProductOwnerPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a ProductOwner.
     * @param {ProductOwnerCreateArgs} args - Arguments to create a ProductOwner.
     * @example
     * // Create one ProductOwner
     * const ProductOwner = await prisma.productOwner.create({
     *   data: {
     *     // ... data to create a ProductOwner
     *   }
     * })
     * 
    **/
    create<T extends ProductOwnerCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductOwnerCreateArgs<ExtArgs>>
    ): Prisma__ProductOwnerClient<$Types.GetResult<ProductOwnerPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many ProductOwners.
     *     @param {ProductOwnerCreateManyArgs} args - Arguments to create many ProductOwners.
     *     @example
     *     // Create many ProductOwners
     *     const productOwner = await prisma.productOwner.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductOwnerCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductOwnerCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProductOwner.
     * @param {ProductOwnerDeleteArgs} args - Arguments to delete one ProductOwner.
     * @example
     * // Delete one ProductOwner
     * const ProductOwner = await prisma.productOwner.delete({
     *   where: {
     *     // ... filter to delete one ProductOwner
     *   }
     * })
     * 
    **/
    delete<T extends ProductOwnerDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ProductOwnerDeleteArgs<ExtArgs>>
    ): Prisma__ProductOwnerClient<$Types.GetResult<ProductOwnerPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one ProductOwner.
     * @param {ProductOwnerUpdateArgs} args - Arguments to update one ProductOwner.
     * @example
     * // Update one ProductOwner
     * const productOwner = await prisma.productOwner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductOwnerUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductOwnerUpdateArgs<ExtArgs>>
    ): Prisma__ProductOwnerClient<$Types.GetResult<ProductOwnerPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more ProductOwners.
     * @param {ProductOwnerDeleteManyArgs} args - Arguments to filter ProductOwners to delete.
     * @example
     * // Delete a few ProductOwners
     * const { count } = await prisma.productOwner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductOwnerDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductOwnerDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductOwners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductOwnerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductOwners
     * const productOwner = await prisma.productOwner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductOwnerUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ProductOwnerUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductOwner.
     * @param {ProductOwnerUpsertArgs} args - Arguments to update or create a ProductOwner.
     * @example
     * // Update or create a ProductOwner
     * const productOwner = await prisma.productOwner.upsert({
     *   create: {
     *     // ... data to create a ProductOwner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductOwner we want to update
     *   }
     * })
    **/
    upsert<T extends ProductOwnerUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ProductOwnerUpsertArgs<ExtArgs>>
    ): Prisma__ProductOwnerClient<$Types.GetResult<ProductOwnerPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of ProductOwners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductOwnerCountArgs} args - Arguments to filter ProductOwners to count.
     * @example
     * // Count the number of ProductOwners
     * const count = await prisma.productOwner.count({
     *   where: {
     *     // ... the filter for the ProductOwners we want to count
     *   }
     * })
    **/
    count<T extends ProductOwnerCountArgs>(
      args?: Subset<T, ProductOwnerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductOwnerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductOwner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductOwnerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductOwnerAggregateArgs>(args: Subset<T, ProductOwnerAggregateArgs>): Prisma.PrismaPromise<GetProductOwnerAggregateType<T>>

    /**
     * Group by ProductOwner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductOwnerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductOwnerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductOwnerGroupByArgs['orderBy'] }
        : { orderBy?: ProductOwnerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductOwnerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductOwnerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductOwner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductOwnerClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    product<T extends ProductOwner$productArgs<ExtArgs> = {}>(args?: Subset<T, ProductOwner$productArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ProductPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ProductOwner base type for findUnique actions
   */
  export type ProductOwnerFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductOwner
     */
    select?: ProductOwnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductOwnerInclude<ExtArgs> | null
    /**
     * Filter, which ProductOwner to fetch.
     */
    where: ProductOwnerWhereUniqueInput
  }

  /**
   * ProductOwner findUnique
   */
  export interface ProductOwnerFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ProductOwnerFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProductOwner findUniqueOrThrow
   */
  export type ProductOwnerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductOwner
     */
    select?: ProductOwnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductOwnerInclude<ExtArgs> | null
    /**
     * Filter, which ProductOwner to fetch.
     */
    where: ProductOwnerWhereUniqueInput
  }


  /**
   * ProductOwner base type for findFirst actions
   */
  export type ProductOwnerFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductOwner
     */
    select?: ProductOwnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductOwnerInclude<ExtArgs> | null
    /**
     * Filter, which ProductOwner to fetch.
     */
    where?: ProductOwnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductOwners to fetch.
     */
    orderBy?: Enumerable<ProductOwnerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductOwners.
     */
    cursor?: ProductOwnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductOwners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductOwners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductOwners.
     */
    distinct?: Enumerable<ProductOwnerScalarFieldEnum>
  }

  /**
   * ProductOwner findFirst
   */
  export interface ProductOwnerFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ProductOwnerFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProductOwner findFirstOrThrow
   */
  export type ProductOwnerFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductOwner
     */
    select?: ProductOwnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductOwnerInclude<ExtArgs> | null
    /**
     * Filter, which ProductOwner to fetch.
     */
    where?: ProductOwnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductOwners to fetch.
     */
    orderBy?: Enumerable<ProductOwnerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductOwners.
     */
    cursor?: ProductOwnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductOwners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductOwners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductOwners.
     */
    distinct?: Enumerable<ProductOwnerScalarFieldEnum>
  }


  /**
   * ProductOwner findMany
   */
  export type ProductOwnerFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductOwner
     */
    select?: ProductOwnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductOwnerInclude<ExtArgs> | null
    /**
     * Filter, which ProductOwners to fetch.
     */
    where?: ProductOwnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductOwners to fetch.
     */
    orderBy?: Enumerable<ProductOwnerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductOwners.
     */
    cursor?: ProductOwnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductOwners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductOwners.
     */
    skip?: number
    distinct?: Enumerable<ProductOwnerScalarFieldEnum>
  }


  /**
   * ProductOwner create
   */
  export type ProductOwnerCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductOwner
     */
    select?: ProductOwnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductOwnerInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductOwner.
     */
    data: XOR<ProductOwnerCreateInput, ProductOwnerUncheckedCreateInput>
  }


  /**
   * ProductOwner createMany
   */
  export type ProductOwnerCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductOwners.
     */
    data: Enumerable<ProductOwnerCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ProductOwner update
   */
  export type ProductOwnerUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductOwner
     */
    select?: ProductOwnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductOwnerInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductOwner.
     */
    data: XOR<ProductOwnerUpdateInput, ProductOwnerUncheckedUpdateInput>
    /**
     * Choose, which ProductOwner to update.
     */
    where: ProductOwnerWhereUniqueInput
  }


  /**
   * ProductOwner updateMany
   */
  export type ProductOwnerUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductOwners.
     */
    data: XOR<ProductOwnerUpdateManyMutationInput, ProductOwnerUncheckedUpdateManyInput>
    /**
     * Filter which ProductOwners to update
     */
    where?: ProductOwnerWhereInput
  }


  /**
   * ProductOwner upsert
   */
  export type ProductOwnerUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductOwner
     */
    select?: ProductOwnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductOwnerInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductOwner to update in case it exists.
     */
    where: ProductOwnerWhereUniqueInput
    /**
     * In case the ProductOwner found by the `where` argument doesn't exist, create a new ProductOwner with this data.
     */
    create: XOR<ProductOwnerCreateInput, ProductOwnerUncheckedCreateInput>
    /**
     * In case the ProductOwner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductOwnerUpdateInput, ProductOwnerUncheckedUpdateInput>
  }


  /**
   * ProductOwner delete
   */
  export type ProductOwnerDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductOwner
     */
    select?: ProductOwnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductOwnerInclude<ExtArgs> | null
    /**
     * Filter which ProductOwner to delete.
     */
    where: ProductOwnerWhereUniqueInput
  }


  /**
   * ProductOwner deleteMany
   */
  export type ProductOwnerDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductOwners to delete
     */
    where?: ProductOwnerWhereInput
  }


  /**
   * ProductOwner.product
   */
  export type ProductOwner$productArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ProductScalarFieldEnum>
  }


  /**
   * ProductOwner without action
   */
  export type ProductOwnerArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductOwner
     */
    select?: ProductOwnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductOwnerInclude<ExtArgs> | null
  }



  /**
   * Model UserPassword
   */


  export type AggregateUserPassword = {
    _count: UserPasswordCountAggregateOutputType | null
    _avg: UserPasswordAvgAggregateOutputType | null
    _sum: UserPasswordSumAggregateOutputType | null
    _min: UserPasswordMinAggregateOutputType | null
    _max: UserPasswordMaxAggregateOutputType | null
  }

  export type UserPasswordAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type UserPasswordSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type UserPasswordMinAggregateOutputType = {
    id: number | null
    password: string | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type UserPasswordMaxAggregateOutputType = {
    id: number | null
    password: string | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type UserPasswordCountAggregateOutputType = {
    id: number
    password: number
    userId: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type UserPasswordAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type UserPasswordSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type UserPasswordMinAggregateInputType = {
    id?: true
    password?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type UserPasswordMaxAggregateInputType = {
    id?: true
    password?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type UserPasswordCountAggregateInputType = {
    id?: true
    password?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type UserPasswordAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPassword to aggregate.
     */
    where?: UserPasswordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPasswords to fetch.
     */
    orderBy?: Enumerable<UserPasswordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserPasswordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPasswords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPasswords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserPasswords
    **/
    _count?: true | UserPasswordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserPasswordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserPasswordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserPasswordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserPasswordMaxAggregateInputType
  }

  export type GetUserPasswordAggregateType<T extends UserPasswordAggregateArgs> = {
        [P in keyof T & keyof AggregateUserPassword]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserPassword[P]>
      : GetScalarType<T[P], AggregateUserPassword[P]>
  }




  export type UserPasswordGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserPasswordWhereInput
    orderBy?: Enumerable<UserPasswordOrderByWithAggregationInput>
    by: UserPasswordScalarFieldEnum[]
    having?: UserPasswordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserPasswordCountAggregateInputType | true
    _avg?: UserPasswordAvgAggregateInputType
    _sum?: UserPasswordSumAggregateInputType
    _min?: UserPasswordMinAggregateInputType
    _max?: UserPasswordMaxAggregateInputType
  }


  export type UserPasswordGroupByOutputType = {
    id: number
    password: string
    userId: number
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: UserPasswordCountAggregateOutputType | null
    _avg: UserPasswordAvgAggregateOutputType | null
    _sum: UserPasswordSumAggregateOutputType | null
    _min: UserPasswordMinAggregateOutputType | null
    _max: UserPasswordMaxAggregateOutputType | null
  }

  type GetUserPasswordGroupByPayload<T extends UserPasswordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserPasswordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserPasswordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserPasswordGroupByOutputType[P]>
            : GetScalarType<T[P], UserPasswordGroupByOutputType[P]>
        }
      >
    >


  export type UserPasswordSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    password?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["userPassword"]>

  export type UserPasswordSelectScalar = {
    id?: boolean
    password?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type UserPasswordInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
  }


  type UserPasswordGetPayload<S extends boolean | null | undefined | UserPasswordArgs> = $Types.GetResult<UserPasswordPayload, S>

  type UserPasswordCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<UserPasswordFindManyArgs, 'select' | 'include'> & {
      select?: UserPasswordCountAggregateInputType | true
    }

  export interface UserPasswordDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserPassword'], meta: { name: 'UserPassword' } }
    /**
     * Find zero or one UserPassword that matches the filter.
     * @param {UserPasswordFindUniqueArgs} args - Arguments to find a UserPassword
     * @example
     * // Get one UserPassword
     * const userPassword = await prisma.userPassword.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserPasswordFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserPasswordFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserPassword'> extends True ? Prisma__UserPasswordClient<$Types.GetResult<UserPasswordPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__UserPasswordClient<$Types.GetResult<UserPasswordPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one UserPassword that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserPasswordFindUniqueOrThrowArgs} args - Arguments to find a UserPassword
     * @example
     * // Get one UserPassword
     * const userPassword = await prisma.userPassword.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserPasswordFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserPasswordFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserPasswordClient<$Types.GetResult<UserPasswordPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first UserPassword that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPasswordFindFirstArgs} args - Arguments to find a UserPassword
     * @example
     * // Get one UserPassword
     * const userPassword = await prisma.userPassword.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserPasswordFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserPasswordFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserPassword'> extends True ? Prisma__UserPasswordClient<$Types.GetResult<UserPasswordPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__UserPasswordClient<$Types.GetResult<UserPasswordPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first UserPassword that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPasswordFindFirstOrThrowArgs} args - Arguments to find a UserPassword
     * @example
     * // Get one UserPassword
     * const userPassword = await prisma.userPassword.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserPasswordFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserPasswordFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserPasswordClient<$Types.GetResult<UserPasswordPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more UserPasswords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPasswordFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserPasswords
     * const userPasswords = await prisma.userPassword.findMany()
     * 
     * // Get first 10 UserPasswords
     * const userPasswords = await prisma.userPassword.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userPasswordWithIdOnly = await prisma.userPassword.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserPasswordFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserPasswordFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<UserPasswordPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a UserPassword.
     * @param {UserPasswordCreateArgs} args - Arguments to create a UserPassword.
     * @example
     * // Create one UserPassword
     * const UserPassword = await prisma.userPassword.create({
     *   data: {
     *     // ... data to create a UserPassword
     *   }
     * })
     * 
    **/
    create<T extends UserPasswordCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserPasswordCreateArgs<ExtArgs>>
    ): Prisma__UserPasswordClient<$Types.GetResult<UserPasswordPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many UserPasswords.
     *     @param {UserPasswordCreateManyArgs} args - Arguments to create many UserPasswords.
     *     @example
     *     // Create many UserPasswords
     *     const userPassword = await prisma.userPassword.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserPasswordCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserPasswordCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserPassword.
     * @param {UserPasswordDeleteArgs} args - Arguments to delete one UserPassword.
     * @example
     * // Delete one UserPassword
     * const UserPassword = await prisma.userPassword.delete({
     *   where: {
     *     // ... filter to delete one UserPassword
     *   }
     * })
     * 
    **/
    delete<T extends UserPasswordDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserPasswordDeleteArgs<ExtArgs>>
    ): Prisma__UserPasswordClient<$Types.GetResult<UserPasswordPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one UserPassword.
     * @param {UserPasswordUpdateArgs} args - Arguments to update one UserPassword.
     * @example
     * // Update one UserPassword
     * const userPassword = await prisma.userPassword.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserPasswordUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserPasswordUpdateArgs<ExtArgs>>
    ): Prisma__UserPasswordClient<$Types.GetResult<UserPasswordPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more UserPasswords.
     * @param {UserPasswordDeleteManyArgs} args - Arguments to filter UserPasswords to delete.
     * @example
     * // Delete a few UserPasswords
     * const { count } = await prisma.userPassword.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserPasswordDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserPasswordDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPasswords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPasswordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserPasswords
     * const userPassword = await prisma.userPassword.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserPasswordUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserPasswordUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserPassword.
     * @param {UserPasswordUpsertArgs} args - Arguments to update or create a UserPassword.
     * @example
     * // Update or create a UserPassword
     * const userPassword = await prisma.userPassword.upsert({
     *   create: {
     *     // ... data to create a UserPassword
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserPassword we want to update
     *   }
     * })
    **/
    upsert<T extends UserPasswordUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserPasswordUpsertArgs<ExtArgs>>
    ): Prisma__UserPasswordClient<$Types.GetResult<UserPasswordPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of UserPasswords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPasswordCountArgs} args - Arguments to filter UserPasswords to count.
     * @example
     * // Count the number of UserPasswords
     * const count = await prisma.userPassword.count({
     *   where: {
     *     // ... the filter for the UserPasswords we want to count
     *   }
     * })
    **/
    count<T extends UserPasswordCountArgs>(
      args?: Subset<T, UserPasswordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserPasswordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserPassword.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPasswordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserPasswordAggregateArgs>(args: Subset<T, UserPasswordAggregateArgs>): Prisma.PrismaPromise<GetUserPasswordAggregateType<T>>

    /**
     * Group by UserPassword.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPasswordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserPasswordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserPasswordGroupByArgs['orderBy'] }
        : { orderBy?: UserPasswordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserPasswordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserPasswordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for UserPassword.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserPasswordClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * UserPassword base type for findUnique actions
   */
  export type UserPasswordFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPassword
     */
    select?: UserPasswordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserPasswordInclude<ExtArgs> | null
    /**
     * Filter, which UserPassword to fetch.
     */
    where: UserPasswordWhereUniqueInput
  }

  /**
   * UserPassword findUnique
   */
  export interface UserPasswordFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends UserPasswordFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserPassword findUniqueOrThrow
   */
  export type UserPasswordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPassword
     */
    select?: UserPasswordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserPasswordInclude<ExtArgs> | null
    /**
     * Filter, which UserPassword to fetch.
     */
    where: UserPasswordWhereUniqueInput
  }


  /**
   * UserPassword base type for findFirst actions
   */
  export type UserPasswordFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPassword
     */
    select?: UserPasswordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserPasswordInclude<ExtArgs> | null
    /**
     * Filter, which UserPassword to fetch.
     */
    where?: UserPasswordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPasswords to fetch.
     */
    orderBy?: Enumerable<UserPasswordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPasswords.
     */
    cursor?: UserPasswordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPasswords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPasswords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPasswords.
     */
    distinct?: Enumerable<UserPasswordScalarFieldEnum>
  }

  /**
   * UserPassword findFirst
   */
  export interface UserPasswordFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends UserPasswordFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserPassword findFirstOrThrow
   */
  export type UserPasswordFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPassword
     */
    select?: UserPasswordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserPasswordInclude<ExtArgs> | null
    /**
     * Filter, which UserPassword to fetch.
     */
    where?: UserPasswordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPasswords to fetch.
     */
    orderBy?: Enumerable<UserPasswordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPasswords.
     */
    cursor?: UserPasswordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPasswords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPasswords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPasswords.
     */
    distinct?: Enumerable<UserPasswordScalarFieldEnum>
  }


  /**
   * UserPassword findMany
   */
  export type UserPasswordFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPassword
     */
    select?: UserPasswordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserPasswordInclude<ExtArgs> | null
    /**
     * Filter, which UserPasswords to fetch.
     */
    where?: UserPasswordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPasswords to fetch.
     */
    orderBy?: Enumerable<UserPasswordOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserPasswords.
     */
    cursor?: UserPasswordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPasswords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPasswords.
     */
    skip?: number
    distinct?: Enumerable<UserPasswordScalarFieldEnum>
  }


  /**
   * UserPassword create
   */
  export type UserPasswordCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPassword
     */
    select?: UserPasswordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserPasswordInclude<ExtArgs> | null
    /**
     * The data needed to create a UserPassword.
     */
    data: XOR<UserPasswordCreateInput, UserPasswordUncheckedCreateInput>
  }


  /**
   * UserPassword createMany
   */
  export type UserPasswordCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserPasswords.
     */
    data: Enumerable<UserPasswordCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserPassword update
   */
  export type UserPasswordUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPassword
     */
    select?: UserPasswordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserPasswordInclude<ExtArgs> | null
    /**
     * The data needed to update a UserPassword.
     */
    data: XOR<UserPasswordUpdateInput, UserPasswordUncheckedUpdateInput>
    /**
     * Choose, which UserPassword to update.
     */
    where: UserPasswordWhereUniqueInput
  }


  /**
   * UserPassword updateMany
   */
  export type UserPasswordUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserPasswords.
     */
    data: XOR<UserPasswordUpdateManyMutationInput, UserPasswordUncheckedUpdateManyInput>
    /**
     * Filter which UserPasswords to update
     */
    where?: UserPasswordWhereInput
  }


  /**
   * UserPassword upsert
   */
  export type UserPasswordUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPassword
     */
    select?: UserPasswordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserPasswordInclude<ExtArgs> | null
    /**
     * The filter to search for the UserPassword to update in case it exists.
     */
    where: UserPasswordWhereUniqueInput
    /**
     * In case the UserPassword found by the `where` argument doesn't exist, create a new UserPassword with this data.
     */
    create: XOR<UserPasswordCreateInput, UserPasswordUncheckedCreateInput>
    /**
     * In case the UserPassword was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserPasswordUpdateInput, UserPasswordUncheckedUpdateInput>
  }


  /**
   * UserPassword delete
   */
  export type UserPasswordDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPassword
     */
    select?: UserPasswordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserPasswordInclude<ExtArgs> | null
    /**
     * Filter which UserPassword to delete.
     */
    where: UserPasswordWhereUniqueInput
  }


  /**
   * UserPassword deleteMany
   */
  export type UserPasswordDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPasswords to delete
     */
    where?: UserPasswordWhereInput
  }


  /**
   * UserPassword without action
   */
  export type UserPasswordArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPassword
     */
    select?: UserPasswordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserPasswordInclude<ExtArgs> | null
  }



  /**
   * Model SearchItems
   */


  export type AggregateSearchItems = {
    _count: SearchItemsCountAggregateOutputType | null
    _avg: SearchItemsAvgAggregateOutputType | null
    _sum: SearchItemsSumAggregateOutputType | null
    _min: SearchItemsMinAggregateOutputType | null
    _max: SearchItemsMaxAggregateOutputType | null
  }

  export type SearchItemsAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type SearchItemsSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type SearchItemsMinAggregateOutputType = {
    id: number | null
    searchName: string | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type SearchItemsMaxAggregateOutputType = {
    id: number | null
    searchName: string | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type SearchItemsCountAggregateOutputType = {
    id: number
    searchName: number
    userId: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type SearchItemsAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type SearchItemsSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type SearchItemsMinAggregateInputType = {
    id?: true
    searchName?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type SearchItemsMaxAggregateInputType = {
    id?: true
    searchName?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type SearchItemsCountAggregateInputType = {
    id?: true
    searchName?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type SearchItemsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which SearchItems to aggregate.
     */
    where?: SearchItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchItems to fetch.
     */
    orderBy?: Enumerable<SearchItemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SearchItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SearchItems
    **/
    _count?: true | SearchItemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SearchItemsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SearchItemsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SearchItemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SearchItemsMaxAggregateInputType
  }

  export type GetSearchItemsAggregateType<T extends SearchItemsAggregateArgs> = {
        [P in keyof T & keyof AggregateSearchItems]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSearchItems[P]>
      : GetScalarType<T[P], AggregateSearchItems[P]>
  }




  export type SearchItemsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: SearchItemsWhereInput
    orderBy?: Enumerable<SearchItemsOrderByWithAggregationInput>
    by: SearchItemsScalarFieldEnum[]
    having?: SearchItemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SearchItemsCountAggregateInputType | true
    _avg?: SearchItemsAvgAggregateInputType
    _sum?: SearchItemsSumAggregateInputType
    _min?: SearchItemsMinAggregateInputType
    _max?: SearchItemsMaxAggregateInputType
  }


  export type SearchItemsGroupByOutputType = {
    id: number
    searchName: string
    userId: number
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: SearchItemsCountAggregateOutputType | null
    _avg: SearchItemsAvgAggregateOutputType | null
    _sum: SearchItemsSumAggregateOutputType | null
    _min: SearchItemsMinAggregateOutputType | null
    _max: SearchItemsMaxAggregateOutputType | null
  }

  type GetSearchItemsGroupByPayload<T extends SearchItemsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<SearchItemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SearchItemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SearchItemsGroupByOutputType[P]>
            : GetScalarType<T[P], SearchItemsGroupByOutputType[P]>
        }
      >
    >


  export type SearchItemsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    searchName?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    User?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["searchItems"]>

  export type SearchItemsSelectScalar = {
    id?: boolean
    searchName?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type SearchItemsInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    User?: boolean | UserArgs<ExtArgs>
  }


  type SearchItemsGetPayload<S extends boolean | null | undefined | SearchItemsArgs> = $Types.GetResult<SearchItemsPayload, S>

  type SearchItemsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<SearchItemsFindManyArgs, 'select' | 'include'> & {
      select?: SearchItemsCountAggregateInputType | true
    }

  export interface SearchItemsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SearchItems'], meta: { name: 'SearchItems' } }
    /**
     * Find zero or one SearchItems that matches the filter.
     * @param {SearchItemsFindUniqueArgs} args - Arguments to find a SearchItems
     * @example
     * // Get one SearchItems
     * const searchItems = await prisma.searchItems.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SearchItemsFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SearchItemsFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SearchItems'> extends True ? Prisma__SearchItemsClient<$Types.GetResult<SearchItemsPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__SearchItemsClient<$Types.GetResult<SearchItemsPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one SearchItems that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SearchItemsFindUniqueOrThrowArgs} args - Arguments to find a SearchItems
     * @example
     * // Get one SearchItems
     * const searchItems = await prisma.searchItems.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SearchItemsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SearchItemsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SearchItemsClient<$Types.GetResult<SearchItemsPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first SearchItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchItemsFindFirstArgs} args - Arguments to find a SearchItems
     * @example
     * // Get one SearchItems
     * const searchItems = await prisma.searchItems.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SearchItemsFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SearchItemsFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SearchItems'> extends True ? Prisma__SearchItemsClient<$Types.GetResult<SearchItemsPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__SearchItemsClient<$Types.GetResult<SearchItemsPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first SearchItems that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchItemsFindFirstOrThrowArgs} args - Arguments to find a SearchItems
     * @example
     * // Get one SearchItems
     * const searchItems = await prisma.searchItems.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SearchItemsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SearchItemsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SearchItemsClient<$Types.GetResult<SearchItemsPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more SearchItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchItemsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SearchItems
     * const searchItems = await prisma.searchItems.findMany()
     * 
     * // Get first 10 SearchItems
     * const searchItems = await prisma.searchItems.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const searchItemsWithIdOnly = await prisma.searchItems.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SearchItemsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SearchItemsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<SearchItemsPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a SearchItems.
     * @param {SearchItemsCreateArgs} args - Arguments to create a SearchItems.
     * @example
     * // Create one SearchItems
     * const SearchItems = await prisma.searchItems.create({
     *   data: {
     *     // ... data to create a SearchItems
     *   }
     * })
     * 
    **/
    create<T extends SearchItemsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SearchItemsCreateArgs<ExtArgs>>
    ): Prisma__SearchItemsClient<$Types.GetResult<SearchItemsPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many SearchItems.
     *     @param {SearchItemsCreateManyArgs} args - Arguments to create many SearchItems.
     *     @example
     *     // Create many SearchItems
     *     const searchItems = await prisma.searchItems.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SearchItemsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SearchItemsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SearchItems.
     * @param {SearchItemsDeleteArgs} args - Arguments to delete one SearchItems.
     * @example
     * // Delete one SearchItems
     * const SearchItems = await prisma.searchItems.delete({
     *   where: {
     *     // ... filter to delete one SearchItems
     *   }
     * })
     * 
    **/
    delete<T extends SearchItemsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SearchItemsDeleteArgs<ExtArgs>>
    ): Prisma__SearchItemsClient<$Types.GetResult<SearchItemsPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one SearchItems.
     * @param {SearchItemsUpdateArgs} args - Arguments to update one SearchItems.
     * @example
     * // Update one SearchItems
     * const searchItems = await prisma.searchItems.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SearchItemsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SearchItemsUpdateArgs<ExtArgs>>
    ): Prisma__SearchItemsClient<$Types.GetResult<SearchItemsPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more SearchItems.
     * @param {SearchItemsDeleteManyArgs} args - Arguments to filter SearchItems to delete.
     * @example
     * // Delete a few SearchItems
     * const { count } = await prisma.searchItems.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SearchItemsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SearchItemsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SearchItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchItemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SearchItems
     * const searchItems = await prisma.searchItems.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SearchItemsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SearchItemsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SearchItems.
     * @param {SearchItemsUpsertArgs} args - Arguments to update or create a SearchItems.
     * @example
     * // Update or create a SearchItems
     * const searchItems = await prisma.searchItems.upsert({
     *   create: {
     *     // ... data to create a SearchItems
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SearchItems we want to update
     *   }
     * })
    **/
    upsert<T extends SearchItemsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SearchItemsUpsertArgs<ExtArgs>>
    ): Prisma__SearchItemsClient<$Types.GetResult<SearchItemsPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of SearchItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchItemsCountArgs} args - Arguments to filter SearchItems to count.
     * @example
     * // Count the number of SearchItems
     * const count = await prisma.searchItems.count({
     *   where: {
     *     // ... the filter for the SearchItems we want to count
     *   }
     * })
    **/
    count<T extends SearchItemsCountArgs>(
      args?: Subset<T, SearchItemsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SearchItemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SearchItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchItemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SearchItemsAggregateArgs>(args: Subset<T, SearchItemsAggregateArgs>): Prisma.PrismaPromise<GetSearchItemsAggregateType<T>>

    /**
     * Group by SearchItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchItemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SearchItemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SearchItemsGroupByArgs['orderBy'] }
        : { orderBy?: SearchItemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SearchItemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSearchItemsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for SearchItems.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SearchItemsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    User<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * SearchItems base type for findUnique actions
   */
  export type SearchItemsFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchItems
     */
    select?: SearchItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SearchItemsInclude<ExtArgs> | null
    /**
     * Filter, which SearchItems to fetch.
     */
    where: SearchItemsWhereUniqueInput
  }

  /**
   * SearchItems findUnique
   */
  export interface SearchItemsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends SearchItemsFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SearchItems findUniqueOrThrow
   */
  export type SearchItemsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchItems
     */
    select?: SearchItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SearchItemsInclude<ExtArgs> | null
    /**
     * Filter, which SearchItems to fetch.
     */
    where: SearchItemsWhereUniqueInput
  }


  /**
   * SearchItems base type for findFirst actions
   */
  export type SearchItemsFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchItems
     */
    select?: SearchItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SearchItemsInclude<ExtArgs> | null
    /**
     * Filter, which SearchItems to fetch.
     */
    where?: SearchItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchItems to fetch.
     */
    orderBy?: Enumerable<SearchItemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SearchItems.
     */
    cursor?: SearchItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SearchItems.
     */
    distinct?: Enumerable<SearchItemsScalarFieldEnum>
  }

  /**
   * SearchItems findFirst
   */
  export interface SearchItemsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends SearchItemsFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SearchItems findFirstOrThrow
   */
  export type SearchItemsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchItems
     */
    select?: SearchItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SearchItemsInclude<ExtArgs> | null
    /**
     * Filter, which SearchItems to fetch.
     */
    where?: SearchItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchItems to fetch.
     */
    orderBy?: Enumerable<SearchItemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SearchItems.
     */
    cursor?: SearchItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SearchItems.
     */
    distinct?: Enumerable<SearchItemsScalarFieldEnum>
  }


  /**
   * SearchItems findMany
   */
  export type SearchItemsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchItems
     */
    select?: SearchItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SearchItemsInclude<ExtArgs> | null
    /**
     * Filter, which SearchItems to fetch.
     */
    where?: SearchItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchItems to fetch.
     */
    orderBy?: Enumerable<SearchItemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SearchItems.
     */
    cursor?: SearchItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchItems.
     */
    skip?: number
    distinct?: Enumerable<SearchItemsScalarFieldEnum>
  }


  /**
   * SearchItems create
   */
  export type SearchItemsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchItems
     */
    select?: SearchItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SearchItemsInclude<ExtArgs> | null
    /**
     * The data needed to create a SearchItems.
     */
    data: XOR<SearchItemsCreateInput, SearchItemsUncheckedCreateInput>
  }


  /**
   * SearchItems createMany
   */
  export type SearchItemsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SearchItems.
     */
    data: Enumerable<SearchItemsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SearchItems update
   */
  export type SearchItemsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchItems
     */
    select?: SearchItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SearchItemsInclude<ExtArgs> | null
    /**
     * The data needed to update a SearchItems.
     */
    data: XOR<SearchItemsUpdateInput, SearchItemsUncheckedUpdateInput>
    /**
     * Choose, which SearchItems to update.
     */
    where: SearchItemsWhereUniqueInput
  }


  /**
   * SearchItems updateMany
   */
  export type SearchItemsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SearchItems.
     */
    data: XOR<SearchItemsUpdateManyMutationInput, SearchItemsUncheckedUpdateManyInput>
    /**
     * Filter which SearchItems to update
     */
    where?: SearchItemsWhereInput
  }


  /**
   * SearchItems upsert
   */
  export type SearchItemsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchItems
     */
    select?: SearchItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SearchItemsInclude<ExtArgs> | null
    /**
     * The filter to search for the SearchItems to update in case it exists.
     */
    where: SearchItemsWhereUniqueInput
    /**
     * In case the SearchItems found by the `where` argument doesn't exist, create a new SearchItems with this data.
     */
    create: XOR<SearchItemsCreateInput, SearchItemsUncheckedCreateInput>
    /**
     * In case the SearchItems was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SearchItemsUpdateInput, SearchItemsUncheckedUpdateInput>
  }


  /**
   * SearchItems delete
   */
  export type SearchItemsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchItems
     */
    select?: SearchItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SearchItemsInclude<ExtArgs> | null
    /**
     * Filter which SearchItems to delete.
     */
    where: SearchItemsWhereUniqueInput
  }


  /**
   * SearchItems deleteMany
   */
  export type SearchItemsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which SearchItems to delete
     */
    where?: SearchItemsWhereInput
  }


  /**
   * SearchItems without action
   */
  export type SearchItemsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchItems
     */
    select?: SearchItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SearchItemsInclude<ExtArgs> | null
  }



  /**
   * Model Order
   */


  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    productId: number | null
  }

  export type OrderSumAggregateOutputType = {
    id: number | null
    userId: number | null
    productId: number | null
  }

  export type OrderMinAggregateOutputType = {
    id: number | null
    userId: number | null
    productId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type OrderMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    productId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    userId: number
    productId: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
  }

  export type OrderSumAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: Enumerable<OrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: Enumerable<OrderOrderByWithAggregationInput>
    by: OrderScalarFieldEnum[]
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }


  export type OrderGroupByOutputType = {
    id: number
    userId: number
    productId: number
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    productId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserArgs<ExtArgs>
    product?: boolean | ProductArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectScalar = {
    id?: boolean
    userId?: boolean
    productId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type OrderInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
    product?: boolean | ProductArgs<ExtArgs>
  }


  type OrderGetPayload<S extends boolean | null | undefined | OrderArgs> = $Types.GetResult<OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<OrderFindManyArgs, 'select' | 'include'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OrderFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Order'> extends True ? Prisma__OrderClient<$Types.GetResult<OrderPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__OrderClient<$Types.GetResult<OrderPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Order that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OrderClient<$Types.GetResult<OrderPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OrderFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Order'> extends True ? Prisma__OrderClient<$Types.GetResult<OrderPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__OrderClient<$Types.GetResult<OrderPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Order that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OrderClient<$Types.GetResult<OrderPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OrderFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<OrderPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
    **/
    create<T extends OrderCreateArgs<ExtArgs>>(
      args: SelectSubset<T, OrderCreateArgs<ExtArgs>>
    ): Prisma__OrderClient<$Types.GetResult<OrderPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Orders.
     *     @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     *     @example
     *     // Create many Orders
     *     const order = await prisma.order.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OrderCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
    **/
    delete<T extends OrderDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>
    ): Prisma__OrderClient<$Types.GetResult<OrderPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OrderUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>
    ): Prisma__OrderClient<$Types.GetResult<OrderPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OrderDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OrderUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
    **/
    upsert<T extends OrderUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>
    ): Prisma__OrderClient<$Types.GetResult<OrderPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    product<T extends ProductArgs<ExtArgs> = {}>(args?: Subset<T, ProductArgs<ExtArgs>>): Prisma__ProductClient<$Types.GetResult<ProductPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Order base type for findUnique actions
   */
  export type OrderFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUnique
   */
  export interface OrderFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends OrderFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }


  /**
   * Order base type for findFirst actions
   */
  export type OrderFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: Enumerable<OrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: Enumerable<OrderScalarFieldEnum>
  }

  /**
   * Order findFirst
   */
  export interface OrderFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends OrderFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: Enumerable<OrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: Enumerable<OrderScalarFieldEnum>
  }


  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: Enumerable<OrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: Enumerable<OrderScalarFieldEnum>
  }


  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }


  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: Enumerable<OrderCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }


  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
  }


  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }


  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }


  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
  }


  /**
   * Order without action
   */
  export type OrderArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude<ExtArgs> | null
  }



  /**
   * Model UserLoginRequest
   */


  export type AggregateUserLoginRequest = {
    _count: UserLoginRequestCountAggregateOutputType | null
    _avg: UserLoginRequestAvgAggregateOutputType | null
    _sum: UserLoginRequestSumAggregateOutputType | null
    _min: UserLoginRequestMinAggregateOutputType | null
    _max: UserLoginRequestMaxAggregateOutputType | null
  }

  export type UserLoginRequestAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type UserLoginRequestSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type UserLoginRequestMinAggregateOutputType = {
    id: number | null
    userId: number | null
    email: string | null
    mobile: string | null
    otp: string | null
    isUsed: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type UserLoginRequestMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    email: string | null
    mobile: string | null
    otp: string | null
    isUsed: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type UserLoginRequestCountAggregateOutputType = {
    id: number
    userId: number
    email: number
    mobile: number
    otp: number
    isUsed: number
    isActive: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type UserLoginRequestAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type UserLoginRequestSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type UserLoginRequestMinAggregateInputType = {
    id?: true
    userId?: true
    email?: true
    mobile?: true
    otp?: true
    isUsed?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type UserLoginRequestMaxAggregateInputType = {
    id?: true
    userId?: true
    email?: true
    mobile?: true
    otp?: true
    isUsed?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type UserLoginRequestCountAggregateInputType = {
    id?: true
    userId?: true
    email?: true
    mobile?: true
    otp?: true
    isUsed?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type UserLoginRequestAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserLoginRequest to aggregate.
     */
    where?: UserLoginRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLoginRequests to fetch.
     */
    orderBy?: Enumerable<UserLoginRequestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserLoginRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLoginRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLoginRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserLoginRequests
    **/
    _count?: true | UserLoginRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserLoginRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserLoginRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserLoginRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserLoginRequestMaxAggregateInputType
  }

  export type GetUserLoginRequestAggregateType<T extends UserLoginRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateUserLoginRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserLoginRequest[P]>
      : GetScalarType<T[P], AggregateUserLoginRequest[P]>
  }




  export type UserLoginRequestGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserLoginRequestWhereInput
    orderBy?: Enumerable<UserLoginRequestOrderByWithAggregationInput>
    by: UserLoginRequestScalarFieldEnum[]
    having?: UserLoginRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserLoginRequestCountAggregateInputType | true
    _avg?: UserLoginRequestAvgAggregateInputType
    _sum?: UserLoginRequestSumAggregateInputType
    _min?: UserLoginRequestMinAggregateInputType
    _max?: UserLoginRequestMaxAggregateInputType
  }


  export type UserLoginRequestGroupByOutputType = {
    id: number
    userId: number
    email: string
    mobile: string | null
    otp: string
    isUsed: boolean
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: UserLoginRequestCountAggregateOutputType | null
    _avg: UserLoginRequestAvgAggregateOutputType | null
    _sum: UserLoginRequestSumAggregateOutputType | null
    _min: UserLoginRequestMinAggregateOutputType | null
    _max: UserLoginRequestMaxAggregateOutputType | null
  }

  type GetUserLoginRequestGroupByPayload<T extends UserLoginRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserLoginRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserLoginRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserLoginRequestGroupByOutputType[P]>
            : GetScalarType<T[P], UserLoginRequestGroupByOutputType[P]>
        }
      >
    >


  export type UserLoginRequestSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    email?: boolean
    mobile?: boolean
    otp?: boolean
    isUsed?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["userLoginRequest"]>

  export type UserLoginRequestSelectScalar = {
    id?: boolean
    userId?: boolean
    email?: boolean
    mobile?: boolean
    otp?: boolean
    isUsed?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type UserLoginRequestInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
  }


  type UserLoginRequestGetPayload<S extends boolean | null | undefined | UserLoginRequestArgs> = $Types.GetResult<UserLoginRequestPayload, S>

  type UserLoginRequestCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<UserLoginRequestFindManyArgs, 'select' | 'include'> & {
      select?: UserLoginRequestCountAggregateInputType | true
    }

  export interface UserLoginRequestDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserLoginRequest'], meta: { name: 'UserLoginRequest' } }
    /**
     * Find zero or one UserLoginRequest that matches the filter.
     * @param {UserLoginRequestFindUniqueArgs} args - Arguments to find a UserLoginRequest
     * @example
     * // Get one UserLoginRequest
     * const userLoginRequest = await prisma.userLoginRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserLoginRequestFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserLoginRequestFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserLoginRequest'> extends True ? Prisma__UserLoginRequestClient<$Types.GetResult<UserLoginRequestPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__UserLoginRequestClient<$Types.GetResult<UserLoginRequestPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one UserLoginRequest that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserLoginRequestFindUniqueOrThrowArgs} args - Arguments to find a UserLoginRequest
     * @example
     * // Get one UserLoginRequest
     * const userLoginRequest = await prisma.userLoginRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserLoginRequestFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserLoginRequestFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserLoginRequestClient<$Types.GetResult<UserLoginRequestPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first UserLoginRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLoginRequestFindFirstArgs} args - Arguments to find a UserLoginRequest
     * @example
     * // Get one UserLoginRequest
     * const userLoginRequest = await prisma.userLoginRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserLoginRequestFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserLoginRequestFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserLoginRequest'> extends True ? Prisma__UserLoginRequestClient<$Types.GetResult<UserLoginRequestPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__UserLoginRequestClient<$Types.GetResult<UserLoginRequestPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first UserLoginRequest that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLoginRequestFindFirstOrThrowArgs} args - Arguments to find a UserLoginRequest
     * @example
     * // Get one UserLoginRequest
     * const userLoginRequest = await prisma.userLoginRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserLoginRequestFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserLoginRequestFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserLoginRequestClient<$Types.GetResult<UserLoginRequestPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more UserLoginRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLoginRequestFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserLoginRequests
     * const userLoginRequests = await prisma.userLoginRequest.findMany()
     * 
     * // Get first 10 UserLoginRequests
     * const userLoginRequests = await prisma.userLoginRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userLoginRequestWithIdOnly = await prisma.userLoginRequest.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserLoginRequestFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserLoginRequestFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<UserLoginRequestPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a UserLoginRequest.
     * @param {UserLoginRequestCreateArgs} args - Arguments to create a UserLoginRequest.
     * @example
     * // Create one UserLoginRequest
     * const UserLoginRequest = await prisma.userLoginRequest.create({
     *   data: {
     *     // ... data to create a UserLoginRequest
     *   }
     * })
     * 
    **/
    create<T extends UserLoginRequestCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserLoginRequestCreateArgs<ExtArgs>>
    ): Prisma__UserLoginRequestClient<$Types.GetResult<UserLoginRequestPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many UserLoginRequests.
     *     @param {UserLoginRequestCreateManyArgs} args - Arguments to create many UserLoginRequests.
     *     @example
     *     // Create many UserLoginRequests
     *     const userLoginRequest = await prisma.userLoginRequest.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserLoginRequestCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserLoginRequestCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserLoginRequest.
     * @param {UserLoginRequestDeleteArgs} args - Arguments to delete one UserLoginRequest.
     * @example
     * // Delete one UserLoginRequest
     * const UserLoginRequest = await prisma.userLoginRequest.delete({
     *   where: {
     *     // ... filter to delete one UserLoginRequest
     *   }
     * })
     * 
    **/
    delete<T extends UserLoginRequestDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserLoginRequestDeleteArgs<ExtArgs>>
    ): Prisma__UserLoginRequestClient<$Types.GetResult<UserLoginRequestPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one UserLoginRequest.
     * @param {UserLoginRequestUpdateArgs} args - Arguments to update one UserLoginRequest.
     * @example
     * // Update one UserLoginRequest
     * const userLoginRequest = await prisma.userLoginRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserLoginRequestUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserLoginRequestUpdateArgs<ExtArgs>>
    ): Prisma__UserLoginRequestClient<$Types.GetResult<UserLoginRequestPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more UserLoginRequests.
     * @param {UserLoginRequestDeleteManyArgs} args - Arguments to filter UserLoginRequests to delete.
     * @example
     * // Delete a few UserLoginRequests
     * const { count } = await prisma.userLoginRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserLoginRequestDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserLoginRequestDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserLoginRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLoginRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserLoginRequests
     * const userLoginRequest = await prisma.userLoginRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserLoginRequestUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserLoginRequestUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserLoginRequest.
     * @param {UserLoginRequestUpsertArgs} args - Arguments to update or create a UserLoginRequest.
     * @example
     * // Update or create a UserLoginRequest
     * const userLoginRequest = await prisma.userLoginRequest.upsert({
     *   create: {
     *     // ... data to create a UserLoginRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserLoginRequest we want to update
     *   }
     * })
    **/
    upsert<T extends UserLoginRequestUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserLoginRequestUpsertArgs<ExtArgs>>
    ): Prisma__UserLoginRequestClient<$Types.GetResult<UserLoginRequestPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of UserLoginRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLoginRequestCountArgs} args - Arguments to filter UserLoginRequests to count.
     * @example
     * // Count the number of UserLoginRequests
     * const count = await prisma.userLoginRequest.count({
     *   where: {
     *     // ... the filter for the UserLoginRequests we want to count
     *   }
     * })
    **/
    count<T extends UserLoginRequestCountArgs>(
      args?: Subset<T, UserLoginRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserLoginRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserLoginRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLoginRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserLoginRequestAggregateArgs>(args: Subset<T, UserLoginRequestAggregateArgs>): Prisma.PrismaPromise<GetUserLoginRequestAggregateType<T>>

    /**
     * Group by UserLoginRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLoginRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserLoginRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserLoginRequestGroupByArgs['orderBy'] }
        : { orderBy?: UserLoginRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserLoginRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserLoginRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for UserLoginRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserLoginRequestClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * UserLoginRequest base type for findUnique actions
   */
  export type UserLoginRequestFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLoginRequest
     */
    select?: UserLoginRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserLoginRequestInclude<ExtArgs> | null
    /**
     * Filter, which UserLoginRequest to fetch.
     */
    where: UserLoginRequestWhereUniqueInput
  }

  /**
   * UserLoginRequest findUnique
   */
  export interface UserLoginRequestFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends UserLoginRequestFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserLoginRequest findUniqueOrThrow
   */
  export type UserLoginRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLoginRequest
     */
    select?: UserLoginRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserLoginRequestInclude<ExtArgs> | null
    /**
     * Filter, which UserLoginRequest to fetch.
     */
    where: UserLoginRequestWhereUniqueInput
  }


  /**
   * UserLoginRequest base type for findFirst actions
   */
  export type UserLoginRequestFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLoginRequest
     */
    select?: UserLoginRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserLoginRequestInclude<ExtArgs> | null
    /**
     * Filter, which UserLoginRequest to fetch.
     */
    where?: UserLoginRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLoginRequests to fetch.
     */
    orderBy?: Enumerable<UserLoginRequestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserLoginRequests.
     */
    cursor?: UserLoginRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLoginRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLoginRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserLoginRequests.
     */
    distinct?: Enumerable<UserLoginRequestScalarFieldEnum>
  }

  /**
   * UserLoginRequest findFirst
   */
  export interface UserLoginRequestFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends UserLoginRequestFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserLoginRequest findFirstOrThrow
   */
  export type UserLoginRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLoginRequest
     */
    select?: UserLoginRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserLoginRequestInclude<ExtArgs> | null
    /**
     * Filter, which UserLoginRequest to fetch.
     */
    where?: UserLoginRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLoginRequests to fetch.
     */
    orderBy?: Enumerable<UserLoginRequestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserLoginRequests.
     */
    cursor?: UserLoginRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLoginRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLoginRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserLoginRequests.
     */
    distinct?: Enumerable<UserLoginRequestScalarFieldEnum>
  }


  /**
   * UserLoginRequest findMany
   */
  export type UserLoginRequestFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLoginRequest
     */
    select?: UserLoginRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserLoginRequestInclude<ExtArgs> | null
    /**
     * Filter, which UserLoginRequests to fetch.
     */
    where?: UserLoginRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLoginRequests to fetch.
     */
    orderBy?: Enumerable<UserLoginRequestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserLoginRequests.
     */
    cursor?: UserLoginRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLoginRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLoginRequests.
     */
    skip?: number
    distinct?: Enumerable<UserLoginRequestScalarFieldEnum>
  }


  /**
   * UserLoginRequest create
   */
  export type UserLoginRequestCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLoginRequest
     */
    select?: UserLoginRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserLoginRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a UserLoginRequest.
     */
    data: XOR<UserLoginRequestCreateInput, UserLoginRequestUncheckedCreateInput>
  }


  /**
   * UserLoginRequest createMany
   */
  export type UserLoginRequestCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserLoginRequests.
     */
    data: Enumerable<UserLoginRequestCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserLoginRequest update
   */
  export type UserLoginRequestUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLoginRequest
     */
    select?: UserLoginRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserLoginRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a UserLoginRequest.
     */
    data: XOR<UserLoginRequestUpdateInput, UserLoginRequestUncheckedUpdateInput>
    /**
     * Choose, which UserLoginRequest to update.
     */
    where: UserLoginRequestWhereUniqueInput
  }


  /**
   * UserLoginRequest updateMany
   */
  export type UserLoginRequestUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserLoginRequests.
     */
    data: XOR<UserLoginRequestUpdateManyMutationInput, UserLoginRequestUncheckedUpdateManyInput>
    /**
     * Filter which UserLoginRequests to update
     */
    where?: UserLoginRequestWhereInput
  }


  /**
   * UserLoginRequest upsert
   */
  export type UserLoginRequestUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLoginRequest
     */
    select?: UserLoginRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserLoginRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the UserLoginRequest to update in case it exists.
     */
    where: UserLoginRequestWhereUniqueInput
    /**
     * In case the UserLoginRequest found by the `where` argument doesn't exist, create a new UserLoginRequest with this data.
     */
    create: XOR<UserLoginRequestCreateInput, UserLoginRequestUncheckedCreateInput>
    /**
     * In case the UserLoginRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserLoginRequestUpdateInput, UserLoginRequestUncheckedUpdateInput>
  }


  /**
   * UserLoginRequest delete
   */
  export type UserLoginRequestDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLoginRequest
     */
    select?: UserLoginRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserLoginRequestInclude<ExtArgs> | null
    /**
     * Filter which UserLoginRequest to delete.
     */
    where: UserLoginRequestWhereUniqueInput
  }


  /**
   * UserLoginRequest deleteMany
   */
  export type UserLoginRequestDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserLoginRequests to delete
     */
    where?: UserLoginRequestWhereInput
  }


  /**
   * UserLoginRequest without action
   */
  export type UserLoginRequestArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLoginRequest
     */
    select?: UserLoginRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserLoginRequestInclude<ExtArgs> | null
  }



  /**
   * Model Product
   */


  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    id: number | null
    syncId: number | null
    price: number | null
    productTypeId: number | null
    productOwnerId: number | null
    userId: number | null
  }

  export type ProductSumAggregateOutputType = {
    id: number | null
    syncId: number | null
    price: number | null
    productTypeId: number | null
    productOwnerId: number | null
    userId: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: number | null
    syncId: number | null
    title: string | null
    price: number | null
    productTypeId: number | null
    productOwnerId: number | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    isActive: boolean | null
  }

  export type ProductMaxAggregateOutputType = {
    id: number | null
    syncId: number | null
    title: string | null
    price: number | null
    productTypeId: number | null
    productOwnerId: number | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    isActive: boolean | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    syncId: number
    title: number
    price: number
    productTypeId: number
    productOwnerId: number
    userId: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    isActive: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    id?: true
    syncId?: true
    price?: true
    productTypeId?: true
    productOwnerId?: true
    userId?: true
  }

  export type ProductSumAggregateInputType = {
    id?: true
    syncId?: true
    price?: true
    productTypeId?: true
    productOwnerId?: true
    userId?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    syncId?: true
    title?: true
    price?: true
    productTypeId?: true
    productOwnerId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    isActive?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    syncId?: true
    title?: true
    price?: true
    productTypeId?: true
    productOwnerId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    isActive?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    syncId?: true
    title?: true
    price?: true
    productTypeId?: true
    productOwnerId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    isActive?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: Enumerable<ProductOrderByWithAggregationInput>
    by: ProductScalarFieldEnum[]
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }


  export type ProductGroupByOutputType = {
    id: number
    syncId: number
    title: string
    price: number
    productTypeId: number
    productOwnerId: number | null
    userId: number | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    isActive: boolean
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    syncId?: boolean
    title?: boolean
    price?: boolean
    productTypeId?: boolean
    productOwnerId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    isActive?: boolean
    color?: boolean | Product$colorArgs<ExtArgs>
    offer?: boolean | Product$offerArgs<ExtArgs>
    seasonalDresses?: boolean | Product$seasonalDressesArgs<ExtArgs>
    productType?: boolean | ProductTypeArgs<ExtArgs>
    user?: boolean | UserArgs<ExtArgs>
    priceHistory?: boolean | Product$priceHistoryArgs<ExtArgs>
    commonDescription?: boolean | Product$commonDescriptionArgs<ExtArgs>
    delivery?: boolean | Product$deliveryArgs<ExtArgs>
    returns?: boolean | Product$returnsArgs<ExtArgs>
    cart?: boolean | Product$cartArgs<ExtArgs>
    wishlistItem?: boolean | Product$wishlistItemArgs<ExtArgs>
    productReviews?: boolean | Product$productReviewsArgs<ExtArgs>
    order?: boolean | Product$orderArgs<ExtArgs>
    productOwner?: boolean | ProductOwnerArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    syncId?: boolean
    title?: boolean
    price?: boolean
    productTypeId?: boolean
    productOwnerId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    isActive?: boolean
  }

  export type ProductInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    color?: boolean | Product$colorArgs<ExtArgs>
    offer?: boolean | Product$offerArgs<ExtArgs>
    seasonalDresses?: boolean | Product$seasonalDressesArgs<ExtArgs>
    productType?: boolean | ProductTypeArgs<ExtArgs>
    user?: boolean | UserArgs<ExtArgs>
    priceHistory?: boolean | Product$priceHistoryArgs<ExtArgs>
    commonDescription?: boolean | Product$commonDescriptionArgs<ExtArgs>
    delivery?: boolean | Product$deliveryArgs<ExtArgs>
    returns?: boolean | Product$returnsArgs<ExtArgs>
    cart?: boolean | Product$cartArgs<ExtArgs>
    wishlistItem?: boolean | Product$wishlistItemArgs<ExtArgs>
    productReviews?: boolean | Product$productReviewsArgs<ExtArgs>
    order?: boolean | Product$orderArgs<ExtArgs>
    productOwner?: boolean | ProductOwnerArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeArgs<ExtArgs>
  }


  type ProductGetPayload<S extends boolean | null | undefined | ProductArgs> = $Types.GetResult<ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ProductFindManyArgs, 'select' | 'include'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Product'> extends True ? Prisma__ProductClient<$Types.GetResult<ProductPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ProductClient<$Types.GetResult<ProductPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Product that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProductClient<$Types.GetResult<ProductPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Product'> extends True ? Prisma__ProductClient<$Types.GetResult<ProductPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ProductClient<$Types.GetResult<ProductPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Product that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProductClient<$Types.GetResult<ProductPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ProductPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
    **/
    create<T extends ProductCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductCreateArgs<ExtArgs>>
    ): Prisma__ProductClient<$Types.GetResult<ProductPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Products.
     *     @param {ProductCreateManyArgs} args - Arguments to create many Products.
     *     @example
     *     // Create many Products
     *     const product = await prisma.product.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
    **/
    delete<T extends ProductDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>
    ): Prisma__ProductClient<$Types.GetResult<ProductPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>
    ): Prisma__ProductClient<$Types.GetResult<ProductPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
    **/
    upsert<T extends ProductUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>
    ): Prisma__ProductClient<$Types.GetResult<ProductPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    color<T extends Product$colorArgs<ExtArgs> = {}>(args?: Subset<T, Product$colorArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ProductColorPayload<ExtArgs>, T, 'findMany', never>| Null>;

    offer<T extends Product$offerArgs<ExtArgs> = {}>(args?: Subset<T, Product$offerArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<OfferPayload<ExtArgs>, T, 'findMany', never>| Null>;

    seasonalDresses<T extends Product$seasonalDressesArgs<ExtArgs> = {}>(args?: Subset<T, Product$seasonalDressesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<SeasonalDressesPayload<ExtArgs>, T, 'findMany', never>| Null>;

    productType<T extends ProductTypeArgs<ExtArgs> = {}>(args?: Subset<T, ProductTypeArgs<ExtArgs>>): Prisma__ProductTypeClient<$Types.GetResult<ProductTypePayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    priceHistory<T extends Product$priceHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Product$priceHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<PriceHistoryPayload<ExtArgs>, T, 'findMany', never>| Null>;

    commonDescription<T extends Product$commonDescriptionArgs<ExtArgs> = {}>(args?: Subset<T, Product$commonDescriptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<CommonDescriptionPayload<ExtArgs>, T, 'findMany', never>| Null>;

    delivery<T extends Product$deliveryArgs<ExtArgs> = {}>(args?: Subset<T, Product$deliveryArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<DeleveryPeriodPayload<ExtArgs>, T, 'findMany', never>| Null>;

    returns<T extends Product$returnsArgs<ExtArgs> = {}>(args?: Subset<T, Product$returnsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ReturnedProductPayload<ExtArgs>, T, 'findMany', never>| Null>;

    cart<T extends Product$cartArgs<ExtArgs> = {}>(args?: Subset<T, Product$cartArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<CartPayload<ExtArgs>, T, 'findMany', never>| Null>;

    wishlistItem<T extends Product$wishlistItemArgs<ExtArgs> = {}>(args?: Subset<T, Product$wishlistItemArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<WishlistItemPayload<ExtArgs>, T, 'findMany', never>| Null>;

    productReviews<T extends Product$productReviewsArgs<ExtArgs> = {}>(args?: Subset<T, Product$productReviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ProductReviewPayload<ExtArgs>, T, 'findMany', never>| Null>;

    order<T extends Product$orderArgs<ExtArgs> = {}>(args?: Subset<T, Product$orderArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<OrderPayload<ExtArgs>, T, 'findMany', never>| Null>;

    productOwner<T extends ProductOwnerArgs<ExtArgs> = {}>(args?: Subset<T, ProductOwnerArgs<ExtArgs>>): Prisma__ProductOwnerClient<$Types.GetResult<ProductOwnerPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Product base type for findUnique actions
   */
  export type ProductFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUnique
   */
  export interface ProductFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ProductFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }


  /**
   * Product base type for findFirst actions
   */
  export type ProductFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: Enumerable<ProductScalarFieldEnum>
  }

  /**
   * Product findFirst
   */
  export interface ProductFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ProductFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: Enumerable<ProductScalarFieldEnum>
  }


  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: Enumerable<ProductScalarFieldEnum>
  }


  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }


  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: Enumerable<ProductCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }


  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
  }


  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }


  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }


  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
  }


  /**
   * Product.color
   */
  export type Product$colorArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductColor
     */
    select?: ProductColorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductColorInclude<ExtArgs> | null
    where?: ProductColorWhereInput
    orderBy?: Enumerable<ProductColorOrderByWithRelationInput>
    cursor?: ProductColorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ProductColorScalarFieldEnum>
  }


  /**
   * Product.offer
   */
  export type Product$offerArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferInclude<ExtArgs> | null
    where?: OfferWhereInput
    orderBy?: Enumerable<OfferOrderByWithRelationInput>
    cursor?: OfferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<OfferScalarFieldEnum>
  }


  /**
   * Product.seasonalDresses
   */
  export type Product$seasonalDressesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeasonalDresses
     */
    select?: SeasonalDressesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SeasonalDressesInclude<ExtArgs> | null
    where?: SeasonalDressesWhereInput
    orderBy?: Enumerable<SeasonalDressesOrderByWithRelationInput>
    cursor?: SeasonalDressesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SeasonalDressesScalarFieldEnum>
  }


  /**
   * Product.priceHistory
   */
  export type Product$priceHistoryArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PriceHistoryInclude<ExtArgs> | null
    where?: PriceHistoryWhereInput
    orderBy?: Enumerable<PriceHistoryOrderByWithRelationInput>
    cursor?: PriceHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PriceHistoryScalarFieldEnum>
  }


  /**
   * Product.commonDescription
   */
  export type Product$commonDescriptionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommonDescription
     */
    select?: CommonDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommonDescriptionInclude<ExtArgs> | null
    where?: CommonDescriptionWhereInput
    orderBy?: Enumerable<CommonDescriptionOrderByWithRelationInput>
    cursor?: CommonDescriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CommonDescriptionScalarFieldEnum>
  }


  /**
   * Product.delivery
   */
  export type Product$deliveryArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeleveryPeriod
     */
    select?: DeleveryPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeleveryPeriodInclude<ExtArgs> | null
    where?: DeleveryPeriodWhereInput
    orderBy?: Enumerable<DeleveryPeriodOrderByWithRelationInput>
    cursor?: DeleveryPeriodWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DeleveryPeriodScalarFieldEnum>
  }


  /**
   * Product.returns
   */
  export type Product$returnsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnedProduct
     */
    select?: ReturnedProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReturnedProductInclude<ExtArgs> | null
    where?: ReturnedProductWhereInput
    orderBy?: Enumerable<ReturnedProductOrderByWithRelationInput>
    cursor?: ReturnedProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ReturnedProductScalarFieldEnum>
  }


  /**
   * Product.cart
   */
  export type Product$cartArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CartInclude<ExtArgs> | null
    where?: CartWhereInput
    orderBy?: Enumerable<CartOrderByWithRelationInput>
    cursor?: CartWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CartScalarFieldEnum>
  }


  /**
   * Product.wishlistItem
   */
  export type Product$wishlistItemArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WishlistItemInclude<ExtArgs> | null
    where?: WishlistItemWhereInput
    orderBy?: Enumerable<WishlistItemOrderByWithRelationInput>
    cursor?: WishlistItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<WishlistItemScalarFieldEnum>
  }


  /**
   * Product.productReviews
   */
  export type Product$productReviewsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReview
     */
    select?: ProductReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductReviewInclude<ExtArgs> | null
    where?: ProductReviewWhereInput
    orderBy?: Enumerable<ProductReviewOrderByWithRelationInput>
    cursor?: ProductReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ProductReviewScalarFieldEnum>
  }


  /**
   * Product.order
   */
  export type Product$orderArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: Enumerable<OrderOrderByWithRelationInput>
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<OrderScalarFieldEnum>
  }


  /**
   * Product without action
   */
  export type ProductArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
  }



  /**
   * Model ProductReview
   */


  export type AggregateProductReview = {
    _count: ProductReviewCountAggregateOutputType | null
    _avg: ProductReviewAvgAggregateOutputType | null
    _sum: ProductReviewSumAggregateOutputType | null
    _min: ProductReviewMinAggregateOutputType | null
    _max: ProductReviewMaxAggregateOutputType | null
  }

  export type ProductReviewAvgAggregateOutputType = {
    id: number | null
    productId: number | null
    userId: number | null
  }

  export type ProductReviewSumAggregateOutputType = {
    id: number | null
    productId: number | null
    userId: number | null
  }

  export type ProductReviewMinAggregateOutputType = {
    id: number | null
    productId: number | null
    userId: number | null
    review: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ProductReviewMaxAggregateOutputType = {
    id: number | null
    productId: number | null
    userId: number | null
    review: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ProductReviewCountAggregateOutputType = {
    id: number
    productId: number
    userId: number
    review: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type ProductReviewAvgAggregateInputType = {
    id?: true
    productId?: true
    userId?: true
  }

  export type ProductReviewSumAggregateInputType = {
    id?: true
    productId?: true
    userId?: true
  }

  export type ProductReviewMinAggregateInputType = {
    id?: true
    productId?: true
    userId?: true
    review?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ProductReviewMaxAggregateInputType = {
    id?: true
    productId?: true
    userId?: true
    review?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ProductReviewCountAggregateInputType = {
    id?: true
    productId?: true
    userId?: true
    review?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type ProductReviewAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductReview to aggregate.
     */
    where?: ProductReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductReviews to fetch.
     */
    orderBy?: Enumerable<ProductReviewOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductReviews
    **/
    _count?: true | ProductReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductReviewMaxAggregateInputType
  }

  export type GetProductReviewAggregateType<T extends ProductReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateProductReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductReview[P]>
      : GetScalarType<T[P], AggregateProductReview[P]>
  }




  export type ProductReviewGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ProductReviewWhereInput
    orderBy?: Enumerable<ProductReviewOrderByWithAggregationInput>
    by: ProductReviewScalarFieldEnum[]
    having?: ProductReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductReviewCountAggregateInputType | true
    _avg?: ProductReviewAvgAggregateInputType
    _sum?: ProductReviewSumAggregateInputType
    _min?: ProductReviewMinAggregateInputType
    _max?: ProductReviewMaxAggregateInputType
  }


  export type ProductReviewGroupByOutputType = {
    id: number
    productId: number
    userId: number
    review: string
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: ProductReviewCountAggregateOutputType | null
    _avg: ProductReviewAvgAggregateOutputType | null
    _sum: ProductReviewSumAggregateOutputType | null
    _min: ProductReviewMinAggregateOutputType | null
    _max: ProductReviewMaxAggregateOutputType | null
  }

  type GetProductReviewGroupByPayload<T extends ProductReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ProductReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ProductReviewGroupByOutputType[P]>
        }
      >
    >


  export type ProductReviewSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    userId?: boolean
    review?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    product?: boolean | ProductArgs<ExtArgs>
    user?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["productReview"]>

  export type ProductReviewSelectScalar = {
    id?: boolean
    productId?: boolean
    userId?: boolean
    review?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type ProductReviewInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    product?: boolean | ProductArgs<ExtArgs>
    user?: boolean | UserArgs<ExtArgs>
  }


  type ProductReviewGetPayload<S extends boolean | null | undefined | ProductReviewArgs> = $Types.GetResult<ProductReviewPayload, S>

  type ProductReviewCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ProductReviewFindManyArgs, 'select' | 'include'> & {
      select?: ProductReviewCountAggregateInputType | true
    }

  export interface ProductReviewDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductReview'], meta: { name: 'ProductReview' } }
    /**
     * Find zero or one ProductReview that matches the filter.
     * @param {ProductReviewFindUniqueArgs} args - Arguments to find a ProductReview
     * @example
     * // Get one ProductReview
     * const productReview = await prisma.productReview.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductReviewFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductReviewFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ProductReview'> extends True ? Prisma__ProductReviewClient<$Types.GetResult<ProductReviewPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ProductReviewClient<$Types.GetResult<ProductReviewPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one ProductReview that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProductReviewFindUniqueOrThrowArgs} args - Arguments to find a ProductReview
     * @example
     * // Get one ProductReview
     * const productReview = await prisma.productReview.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProductReviewFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductReviewFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProductReviewClient<$Types.GetResult<ProductReviewPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first ProductReview that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductReviewFindFirstArgs} args - Arguments to find a ProductReview
     * @example
     * // Get one ProductReview
     * const productReview = await prisma.productReview.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductReviewFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductReviewFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ProductReview'> extends True ? Prisma__ProductReviewClient<$Types.GetResult<ProductReviewPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ProductReviewClient<$Types.GetResult<ProductReviewPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first ProductReview that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductReviewFindFirstOrThrowArgs} args - Arguments to find a ProductReview
     * @example
     * // Get one ProductReview
     * const productReview = await prisma.productReview.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProductReviewFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductReviewFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProductReviewClient<$Types.GetResult<ProductReviewPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more ProductReviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductReviewFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductReviews
     * const productReviews = await prisma.productReview.findMany()
     * 
     * // Get first 10 ProductReviews
     * const productReviews = await prisma.productReview.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productReviewWithIdOnly = await prisma.productReview.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductReviewFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductReviewFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ProductReviewPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a ProductReview.
     * @param {ProductReviewCreateArgs} args - Arguments to create a ProductReview.
     * @example
     * // Create one ProductReview
     * const ProductReview = await prisma.productReview.create({
     *   data: {
     *     // ... data to create a ProductReview
     *   }
     * })
     * 
    **/
    create<T extends ProductReviewCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductReviewCreateArgs<ExtArgs>>
    ): Prisma__ProductReviewClient<$Types.GetResult<ProductReviewPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many ProductReviews.
     *     @param {ProductReviewCreateManyArgs} args - Arguments to create many ProductReviews.
     *     @example
     *     // Create many ProductReviews
     *     const productReview = await prisma.productReview.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductReviewCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductReviewCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProductReview.
     * @param {ProductReviewDeleteArgs} args - Arguments to delete one ProductReview.
     * @example
     * // Delete one ProductReview
     * const ProductReview = await prisma.productReview.delete({
     *   where: {
     *     // ... filter to delete one ProductReview
     *   }
     * })
     * 
    **/
    delete<T extends ProductReviewDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ProductReviewDeleteArgs<ExtArgs>>
    ): Prisma__ProductReviewClient<$Types.GetResult<ProductReviewPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one ProductReview.
     * @param {ProductReviewUpdateArgs} args - Arguments to update one ProductReview.
     * @example
     * // Update one ProductReview
     * const productReview = await prisma.productReview.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductReviewUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductReviewUpdateArgs<ExtArgs>>
    ): Prisma__ProductReviewClient<$Types.GetResult<ProductReviewPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more ProductReviews.
     * @param {ProductReviewDeleteManyArgs} args - Arguments to filter ProductReviews to delete.
     * @example
     * // Delete a few ProductReviews
     * const { count } = await prisma.productReview.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductReviewDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductReviewDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductReviews
     * const productReview = await prisma.productReview.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductReviewUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ProductReviewUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductReview.
     * @param {ProductReviewUpsertArgs} args - Arguments to update or create a ProductReview.
     * @example
     * // Update or create a ProductReview
     * const productReview = await prisma.productReview.upsert({
     *   create: {
     *     // ... data to create a ProductReview
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductReview we want to update
     *   }
     * })
    **/
    upsert<T extends ProductReviewUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ProductReviewUpsertArgs<ExtArgs>>
    ): Prisma__ProductReviewClient<$Types.GetResult<ProductReviewPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of ProductReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductReviewCountArgs} args - Arguments to filter ProductReviews to count.
     * @example
     * // Count the number of ProductReviews
     * const count = await prisma.productReview.count({
     *   where: {
     *     // ... the filter for the ProductReviews we want to count
     *   }
     * })
    **/
    count<T extends ProductReviewCountArgs>(
      args?: Subset<T, ProductReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductReviewAggregateArgs>(args: Subset<T, ProductReviewAggregateArgs>): Prisma.PrismaPromise<GetProductReviewAggregateType<T>>

    /**
     * Group by ProductReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductReviewGroupByArgs['orderBy'] }
        : { orderBy?: ProductReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductReview.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductReviewClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    product<T extends ProductArgs<ExtArgs> = {}>(args?: Subset<T, ProductArgs<ExtArgs>>): Prisma__ProductClient<$Types.GetResult<ProductPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ProductReview base type for findUnique actions
   */
  export type ProductReviewFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReview
     */
    select?: ProductReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductReviewInclude<ExtArgs> | null
    /**
     * Filter, which ProductReview to fetch.
     */
    where: ProductReviewWhereUniqueInput
  }

  /**
   * ProductReview findUnique
   */
  export interface ProductReviewFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ProductReviewFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProductReview findUniqueOrThrow
   */
  export type ProductReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReview
     */
    select?: ProductReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductReviewInclude<ExtArgs> | null
    /**
     * Filter, which ProductReview to fetch.
     */
    where: ProductReviewWhereUniqueInput
  }


  /**
   * ProductReview base type for findFirst actions
   */
  export type ProductReviewFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReview
     */
    select?: ProductReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductReviewInclude<ExtArgs> | null
    /**
     * Filter, which ProductReview to fetch.
     */
    where?: ProductReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductReviews to fetch.
     */
    orderBy?: Enumerable<ProductReviewOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductReviews.
     */
    cursor?: ProductReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductReviews.
     */
    distinct?: Enumerable<ProductReviewScalarFieldEnum>
  }

  /**
   * ProductReview findFirst
   */
  export interface ProductReviewFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ProductReviewFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProductReview findFirstOrThrow
   */
  export type ProductReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReview
     */
    select?: ProductReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductReviewInclude<ExtArgs> | null
    /**
     * Filter, which ProductReview to fetch.
     */
    where?: ProductReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductReviews to fetch.
     */
    orderBy?: Enumerable<ProductReviewOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductReviews.
     */
    cursor?: ProductReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductReviews.
     */
    distinct?: Enumerable<ProductReviewScalarFieldEnum>
  }


  /**
   * ProductReview findMany
   */
  export type ProductReviewFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReview
     */
    select?: ProductReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductReviewInclude<ExtArgs> | null
    /**
     * Filter, which ProductReviews to fetch.
     */
    where?: ProductReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductReviews to fetch.
     */
    orderBy?: Enumerable<ProductReviewOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductReviews.
     */
    cursor?: ProductReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductReviews.
     */
    skip?: number
    distinct?: Enumerable<ProductReviewScalarFieldEnum>
  }


  /**
   * ProductReview create
   */
  export type ProductReviewCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReview
     */
    select?: ProductReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductReview.
     */
    data: XOR<ProductReviewCreateInput, ProductReviewUncheckedCreateInput>
  }


  /**
   * ProductReview createMany
   */
  export type ProductReviewCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductReviews.
     */
    data: Enumerable<ProductReviewCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ProductReview update
   */
  export type ProductReviewUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReview
     */
    select?: ProductReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductReview.
     */
    data: XOR<ProductReviewUpdateInput, ProductReviewUncheckedUpdateInput>
    /**
     * Choose, which ProductReview to update.
     */
    where: ProductReviewWhereUniqueInput
  }


  /**
   * ProductReview updateMany
   */
  export type ProductReviewUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductReviews.
     */
    data: XOR<ProductReviewUpdateManyMutationInput, ProductReviewUncheckedUpdateManyInput>
    /**
     * Filter which ProductReviews to update
     */
    where?: ProductReviewWhereInput
  }


  /**
   * ProductReview upsert
   */
  export type ProductReviewUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReview
     */
    select?: ProductReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductReview to update in case it exists.
     */
    where: ProductReviewWhereUniqueInput
    /**
     * In case the ProductReview found by the `where` argument doesn't exist, create a new ProductReview with this data.
     */
    create: XOR<ProductReviewCreateInput, ProductReviewUncheckedCreateInput>
    /**
     * In case the ProductReview was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductReviewUpdateInput, ProductReviewUncheckedUpdateInput>
  }


  /**
   * ProductReview delete
   */
  export type ProductReviewDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReview
     */
    select?: ProductReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductReviewInclude<ExtArgs> | null
    /**
     * Filter which ProductReview to delete.
     */
    where: ProductReviewWhereUniqueInput
  }


  /**
   * ProductReview deleteMany
   */
  export type ProductReviewDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductReviews to delete
     */
    where?: ProductReviewWhereInput
  }


  /**
   * ProductReview without action
   */
  export type ProductReviewArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReview
     */
    select?: ProductReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductReviewInclude<ExtArgs> | null
  }



  /**
   * Model ReturnedProduct
   */


  export type AggregateReturnedProduct = {
    _count: ReturnedProductCountAggregateOutputType | null
    _avg: ReturnedProductAvgAggregateOutputType | null
    _sum: ReturnedProductSumAggregateOutputType | null
    _min: ReturnedProductMinAggregateOutputType | null
    _max: ReturnedProductMaxAggregateOutputType | null
  }

  export type ReturnedProductAvgAggregateOutputType = {
    id: number | null
    productId: number | null
    returns: number | null
  }

  export type ReturnedProductSumAggregateOutputType = {
    id: number | null
    productId: number | null
    returns: number | null
  }

  export type ReturnedProductMinAggregateOutputType = {
    id: number | null
    productId: number | null
    returns: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ReturnedProductMaxAggregateOutputType = {
    id: number | null
    productId: number | null
    returns: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ReturnedProductCountAggregateOutputType = {
    id: number
    productId: number
    returns: number
    isActive: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type ReturnedProductAvgAggregateInputType = {
    id?: true
    productId?: true
    returns?: true
  }

  export type ReturnedProductSumAggregateInputType = {
    id?: true
    productId?: true
    returns?: true
  }

  export type ReturnedProductMinAggregateInputType = {
    id?: true
    productId?: true
    returns?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ReturnedProductMaxAggregateInputType = {
    id?: true
    productId?: true
    returns?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ReturnedProductCountAggregateInputType = {
    id?: true
    productId?: true
    returns?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type ReturnedProductAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReturnedProduct to aggregate.
     */
    where?: ReturnedProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReturnedProducts to fetch.
     */
    orderBy?: Enumerable<ReturnedProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReturnedProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReturnedProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReturnedProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReturnedProducts
    **/
    _count?: true | ReturnedProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReturnedProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReturnedProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReturnedProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReturnedProductMaxAggregateInputType
  }

  export type GetReturnedProductAggregateType<T extends ReturnedProductAggregateArgs> = {
        [P in keyof T & keyof AggregateReturnedProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReturnedProduct[P]>
      : GetScalarType<T[P], AggregateReturnedProduct[P]>
  }




  export type ReturnedProductGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ReturnedProductWhereInput
    orderBy?: Enumerable<ReturnedProductOrderByWithAggregationInput>
    by: ReturnedProductScalarFieldEnum[]
    having?: ReturnedProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReturnedProductCountAggregateInputType | true
    _avg?: ReturnedProductAvgAggregateInputType
    _sum?: ReturnedProductSumAggregateInputType
    _min?: ReturnedProductMinAggregateInputType
    _max?: ReturnedProductMaxAggregateInputType
  }


  export type ReturnedProductGroupByOutputType = {
    id: number
    productId: number
    returns: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: ReturnedProductCountAggregateOutputType | null
    _avg: ReturnedProductAvgAggregateOutputType | null
    _sum: ReturnedProductSumAggregateOutputType | null
    _min: ReturnedProductMinAggregateOutputType | null
    _max: ReturnedProductMaxAggregateOutputType | null
  }

  type GetReturnedProductGroupByPayload<T extends ReturnedProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ReturnedProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReturnedProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReturnedProductGroupByOutputType[P]>
            : GetScalarType<T[P], ReturnedProductGroupByOutputType[P]>
        }
      >
    >


  export type ReturnedProductSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    returns?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    product?: boolean | ProductArgs<ExtArgs>
  }, ExtArgs["result"]["returnedProduct"]>

  export type ReturnedProductSelectScalar = {
    id?: boolean
    productId?: boolean
    returns?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type ReturnedProductInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    product?: boolean | ProductArgs<ExtArgs>
  }


  type ReturnedProductGetPayload<S extends boolean | null | undefined | ReturnedProductArgs> = $Types.GetResult<ReturnedProductPayload, S>

  type ReturnedProductCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ReturnedProductFindManyArgs, 'select' | 'include'> & {
      select?: ReturnedProductCountAggregateInputType | true
    }

  export interface ReturnedProductDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReturnedProduct'], meta: { name: 'ReturnedProduct' } }
    /**
     * Find zero or one ReturnedProduct that matches the filter.
     * @param {ReturnedProductFindUniqueArgs} args - Arguments to find a ReturnedProduct
     * @example
     * // Get one ReturnedProduct
     * const returnedProduct = await prisma.returnedProduct.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ReturnedProductFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ReturnedProductFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ReturnedProduct'> extends True ? Prisma__ReturnedProductClient<$Types.GetResult<ReturnedProductPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ReturnedProductClient<$Types.GetResult<ReturnedProductPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one ReturnedProduct that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ReturnedProductFindUniqueOrThrowArgs} args - Arguments to find a ReturnedProduct
     * @example
     * // Get one ReturnedProduct
     * const returnedProduct = await prisma.returnedProduct.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ReturnedProductFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReturnedProductFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ReturnedProductClient<$Types.GetResult<ReturnedProductPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first ReturnedProduct that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnedProductFindFirstArgs} args - Arguments to find a ReturnedProduct
     * @example
     * // Get one ReturnedProduct
     * const returnedProduct = await prisma.returnedProduct.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ReturnedProductFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ReturnedProductFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ReturnedProduct'> extends True ? Prisma__ReturnedProductClient<$Types.GetResult<ReturnedProductPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ReturnedProductClient<$Types.GetResult<ReturnedProductPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first ReturnedProduct that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnedProductFindFirstOrThrowArgs} args - Arguments to find a ReturnedProduct
     * @example
     * // Get one ReturnedProduct
     * const returnedProduct = await prisma.returnedProduct.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ReturnedProductFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReturnedProductFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ReturnedProductClient<$Types.GetResult<ReturnedProductPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more ReturnedProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnedProductFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReturnedProducts
     * const returnedProducts = await prisma.returnedProduct.findMany()
     * 
     * // Get first 10 ReturnedProducts
     * const returnedProducts = await prisma.returnedProduct.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const returnedProductWithIdOnly = await prisma.returnedProduct.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ReturnedProductFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReturnedProductFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ReturnedProductPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a ReturnedProduct.
     * @param {ReturnedProductCreateArgs} args - Arguments to create a ReturnedProduct.
     * @example
     * // Create one ReturnedProduct
     * const ReturnedProduct = await prisma.returnedProduct.create({
     *   data: {
     *     // ... data to create a ReturnedProduct
     *   }
     * })
     * 
    **/
    create<T extends ReturnedProductCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ReturnedProductCreateArgs<ExtArgs>>
    ): Prisma__ReturnedProductClient<$Types.GetResult<ReturnedProductPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many ReturnedProducts.
     *     @param {ReturnedProductCreateManyArgs} args - Arguments to create many ReturnedProducts.
     *     @example
     *     // Create many ReturnedProducts
     *     const returnedProduct = await prisma.returnedProduct.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ReturnedProductCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReturnedProductCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ReturnedProduct.
     * @param {ReturnedProductDeleteArgs} args - Arguments to delete one ReturnedProduct.
     * @example
     * // Delete one ReturnedProduct
     * const ReturnedProduct = await prisma.returnedProduct.delete({
     *   where: {
     *     // ... filter to delete one ReturnedProduct
     *   }
     * })
     * 
    **/
    delete<T extends ReturnedProductDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ReturnedProductDeleteArgs<ExtArgs>>
    ): Prisma__ReturnedProductClient<$Types.GetResult<ReturnedProductPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one ReturnedProduct.
     * @param {ReturnedProductUpdateArgs} args - Arguments to update one ReturnedProduct.
     * @example
     * // Update one ReturnedProduct
     * const returnedProduct = await prisma.returnedProduct.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReturnedProductUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ReturnedProductUpdateArgs<ExtArgs>>
    ): Prisma__ReturnedProductClient<$Types.GetResult<ReturnedProductPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more ReturnedProducts.
     * @param {ReturnedProductDeleteManyArgs} args - Arguments to filter ReturnedProducts to delete.
     * @example
     * // Delete a few ReturnedProducts
     * const { count } = await prisma.returnedProduct.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReturnedProductDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReturnedProductDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReturnedProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnedProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReturnedProducts
     * const returnedProduct = await prisma.returnedProduct.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReturnedProductUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ReturnedProductUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReturnedProduct.
     * @param {ReturnedProductUpsertArgs} args - Arguments to update or create a ReturnedProduct.
     * @example
     * // Update or create a ReturnedProduct
     * const returnedProduct = await prisma.returnedProduct.upsert({
     *   create: {
     *     // ... data to create a ReturnedProduct
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReturnedProduct we want to update
     *   }
     * })
    **/
    upsert<T extends ReturnedProductUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ReturnedProductUpsertArgs<ExtArgs>>
    ): Prisma__ReturnedProductClient<$Types.GetResult<ReturnedProductPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of ReturnedProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnedProductCountArgs} args - Arguments to filter ReturnedProducts to count.
     * @example
     * // Count the number of ReturnedProducts
     * const count = await prisma.returnedProduct.count({
     *   where: {
     *     // ... the filter for the ReturnedProducts we want to count
     *   }
     * })
    **/
    count<T extends ReturnedProductCountArgs>(
      args?: Subset<T, ReturnedProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReturnedProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReturnedProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnedProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReturnedProductAggregateArgs>(args: Subset<T, ReturnedProductAggregateArgs>): Prisma.PrismaPromise<GetReturnedProductAggregateType<T>>

    /**
     * Group by ReturnedProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnedProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReturnedProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReturnedProductGroupByArgs['orderBy'] }
        : { orderBy?: ReturnedProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReturnedProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReturnedProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ReturnedProduct.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ReturnedProductClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    product<T extends ProductArgs<ExtArgs> = {}>(args?: Subset<T, ProductArgs<ExtArgs>>): Prisma__ProductClient<$Types.GetResult<ProductPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ReturnedProduct base type for findUnique actions
   */
  export type ReturnedProductFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnedProduct
     */
    select?: ReturnedProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReturnedProductInclude<ExtArgs> | null
    /**
     * Filter, which ReturnedProduct to fetch.
     */
    where: ReturnedProductWhereUniqueInput
  }

  /**
   * ReturnedProduct findUnique
   */
  export interface ReturnedProductFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ReturnedProductFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ReturnedProduct findUniqueOrThrow
   */
  export type ReturnedProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnedProduct
     */
    select?: ReturnedProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReturnedProductInclude<ExtArgs> | null
    /**
     * Filter, which ReturnedProduct to fetch.
     */
    where: ReturnedProductWhereUniqueInput
  }


  /**
   * ReturnedProduct base type for findFirst actions
   */
  export type ReturnedProductFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnedProduct
     */
    select?: ReturnedProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReturnedProductInclude<ExtArgs> | null
    /**
     * Filter, which ReturnedProduct to fetch.
     */
    where?: ReturnedProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReturnedProducts to fetch.
     */
    orderBy?: Enumerable<ReturnedProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReturnedProducts.
     */
    cursor?: ReturnedProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReturnedProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReturnedProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReturnedProducts.
     */
    distinct?: Enumerable<ReturnedProductScalarFieldEnum>
  }

  /**
   * ReturnedProduct findFirst
   */
  export interface ReturnedProductFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ReturnedProductFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ReturnedProduct findFirstOrThrow
   */
  export type ReturnedProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnedProduct
     */
    select?: ReturnedProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReturnedProductInclude<ExtArgs> | null
    /**
     * Filter, which ReturnedProduct to fetch.
     */
    where?: ReturnedProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReturnedProducts to fetch.
     */
    orderBy?: Enumerable<ReturnedProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReturnedProducts.
     */
    cursor?: ReturnedProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReturnedProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReturnedProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReturnedProducts.
     */
    distinct?: Enumerable<ReturnedProductScalarFieldEnum>
  }


  /**
   * ReturnedProduct findMany
   */
  export type ReturnedProductFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnedProduct
     */
    select?: ReturnedProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReturnedProductInclude<ExtArgs> | null
    /**
     * Filter, which ReturnedProducts to fetch.
     */
    where?: ReturnedProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReturnedProducts to fetch.
     */
    orderBy?: Enumerable<ReturnedProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReturnedProducts.
     */
    cursor?: ReturnedProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReturnedProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReturnedProducts.
     */
    skip?: number
    distinct?: Enumerable<ReturnedProductScalarFieldEnum>
  }


  /**
   * ReturnedProduct create
   */
  export type ReturnedProductCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnedProduct
     */
    select?: ReturnedProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReturnedProductInclude<ExtArgs> | null
    /**
     * The data needed to create a ReturnedProduct.
     */
    data: XOR<ReturnedProductCreateInput, ReturnedProductUncheckedCreateInput>
  }


  /**
   * ReturnedProduct createMany
   */
  export type ReturnedProductCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReturnedProducts.
     */
    data: Enumerable<ReturnedProductCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ReturnedProduct update
   */
  export type ReturnedProductUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnedProduct
     */
    select?: ReturnedProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReturnedProductInclude<ExtArgs> | null
    /**
     * The data needed to update a ReturnedProduct.
     */
    data: XOR<ReturnedProductUpdateInput, ReturnedProductUncheckedUpdateInput>
    /**
     * Choose, which ReturnedProduct to update.
     */
    where: ReturnedProductWhereUniqueInput
  }


  /**
   * ReturnedProduct updateMany
   */
  export type ReturnedProductUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReturnedProducts.
     */
    data: XOR<ReturnedProductUpdateManyMutationInput, ReturnedProductUncheckedUpdateManyInput>
    /**
     * Filter which ReturnedProducts to update
     */
    where?: ReturnedProductWhereInput
  }


  /**
   * ReturnedProduct upsert
   */
  export type ReturnedProductUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnedProduct
     */
    select?: ReturnedProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReturnedProductInclude<ExtArgs> | null
    /**
     * The filter to search for the ReturnedProduct to update in case it exists.
     */
    where: ReturnedProductWhereUniqueInput
    /**
     * In case the ReturnedProduct found by the `where` argument doesn't exist, create a new ReturnedProduct with this data.
     */
    create: XOR<ReturnedProductCreateInput, ReturnedProductUncheckedCreateInput>
    /**
     * In case the ReturnedProduct was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReturnedProductUpdateInput, ReturnedProductUncheckedUpdateInput>
  }


  /**
   * ReturnedProduct delete
   */
  export type ReturnedProductDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnedProduct
     */
    select?: ReturnedProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReturnedProductInclude<ExtArgs> | null
    /**
     * Filter which ReturnedProduct to delete.
     */
    where: ReturnedProductWhereUniqueInput
  }


  /**
   * ReturnedProduct deleteMany
   */
  export type ReturnedProductDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReturnedProducts to delete
     */
    where?: ReturnedProductWhereInput
  }


  /**
   * ReturnedProduct without action
   */
  export type ReturnedProductArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnedProduct
     */
    select?: ReturnedProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReturnedProductInclude<ExtArgs> | null
  }



  /**
   * Model DeleveryPeriod
   */


  export type AggregateDeleveryPeriod = {
    _count: DeleveryPeriodCountAggregateOutputType | null
    _avg: DeleveryPeriodAvgAggregateOutputType | null
    _sum: DeleveryPeriodSumAggregateOutputType | null
    _min: DeleveryPeriodMinAggregateOutputType | null
    _max: DeleveryPeriodMaxAggregateOutputType | null
  }

  export type DeleveryPeriodAvgAggregateOutputType = {
    id: number | null
    productId: number | null
    deliveryForMetroCitys: number | null
    deliveryForOtherCitys: number | null
  }

  export type DeleveryPeriodSumAggregateOutputType = {
    id: number | null
    productId: number | null
    deliveryForMetroCitys: number | null
    deliveryForOtherCitys: number | null
  }

  export type DeleveryPeriodMinAggregateOutputType = {
    id: number | null
    productId: number | null
    deliveryForMetroCitys: number | null
    deliveryForOtherCitys: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type DeleveryPeriodMaxAggregateOutputType = {
    id: number | null
    productId: number | null
    deliveryForMetroCitys: number | null
    deliveryForOtherCitys: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type DeleveryPeriodCountAggregateOutputType = {
    id: number
    productId: number
    deliveryForMetroCitys: number
    deliveryForOtherCitys: number
    isActive: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type DeleveryPeriodAvgAggregateInputType = {
    id?: true
    productId?: true
    deliveryForMetroCitys?: true
    deliveryForOtherCitys?: true
  }

  export type DeleveryPeriodSumAggregateInputType = {
    id?: true
    productId?: true
    deliveryForMetroCitys?: true
    deliveryForOtherCitys?: true
  }

  export type DeleveryPeriodMinAggregateInputType = {
    id?: true
    productId?: true
    deliveryForMetroCitys?: true
    deliveryForOtherCitys?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type DeleveryPeriodMaxAggregateInputType = {
    id?: true
    productId?: true
    deliveryForMetroCitys?: true
    deliveryForOtherCitys?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type DeleveryPeriodCountAggregateInputType = {
    id?: true
    productId?: true
    deliveryForMetroCitys?: true
    deliveryForOtherCitys?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type DeleveryPeriodAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeleveryPeriod to aggregate.
     */
    where?: DeleveryPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeleveryPeriods to fetch.
     */
    orderBy?: Enumerable<DeleveryPeriodOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeleveryPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeleveryPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeleveryPeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeleveryPeriods
    **/
    _count?: true | DeleveryPeriodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeleveryPeriodAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeleveryPeriodSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeleveryPeriodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeleveryPeriodMaxAggregateInputType
  }

  export type GetDeleveryPeriodAggregateType<T extends DeleveryPeriodAggregateArgs> = {
        [P in keyof T & keyof AggregateDeleveryPeriod]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeleveryPeriod[P]>
      : GetScalarType<T[P], AggregateDeleveryPeriod[P]>
  }




  export type DeleveryPeriodGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DeleveryPeriodWhereInput
    orderBy?: Enumerable<DeleveryPeriodOrderByWithAggregationInput>
    by: DeleveryPeriodScalarFieldEnum[]
    having?: DeleveryPeriodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeleveryPeriodCountAggregateInputType | true
    _avg?: DeleveryPeriodAvgAggregateInputType
    _sum?: DeleveryPeriodSumAggregateInputType
    _min?: DeleveryPeriodMinAggregateInputType
    _max?: DeleveryPeriodMaxAggregateInputType
  }


  export type DeleveryPeriodGroupByOutputType = {
    id: number
    productId: number
    deliveryForMetroCitys: number
    deliveryForOtherCitys: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: DeleveryPeriodCountAggregateOutputType | null
    _avg: DeleveryPeriodAvgAggregateOutputType | null
    _sum: DeleveryPeriodSumAggregateOutputType | null
    _min: DeleveryPeriodMinAggregateOutputType | null
    _max: DeleveryPeriodMaxAggregateOutputType | null
  }

  type GetDeleveryPeriodGroupByPayload<T extends DeleveryPeriodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DeleveryPeriodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeleveryPeriodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeleveryPeriodGroupByOutputType[P]>
            : GetScalarType<T[P], DeleveryPeriodGroupByOutputType[P]>
        }
      >
    >


  export type DeleveryPeriodSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    deliveryForMetroCitys?: boolean
    deliveryForOtherCitys?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    product?: boolean | ProductArgs<ExtArgs>
  }, ExtArgs["result"]["deleveryPeriod"]>

  export type DeleveryPeriodSelectScalar = {
    id?: boolean
    productId?: boolean
    deliveryForMetroCitys?: boolean
    deliveryForOtherCitys?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type DeleveryPeriodInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    product?: boolean | ProductArgs<ExtArgs>
  }


  type DeleveryPeriodGetPayload<S extends boolean | null | undefined | DeleveryPeriodArgs> = $Types.GetResult<DeleveryPeriodPayload, S>

  type DeleveryPeriodCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<DeleveryPeriodFindManyArgs, 'select' | 'include'> & {
      select?: DeleveryPeriodCountAggregateInputType | true
    }

  export interface DeleveryPeriodDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeleveryPeriod'], meta: { name: 'DeleveryPeriod' } }
    /**
     * Find zero or one DeleveryPeriod that matches the filter.
     * @param {DeleveryPeriodFindUniqueArgs} args - Arguments to find a DeleveryPeriod
     * @example
     * // Get one DeleveryPeriod
     * const deleveryPeriod = await prisma.deleveryPeriod.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DeleveryPeriodFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DeleveryPeriodFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'DeleveryPeriod'> extends True ? Prisma__DeleveryPeriodClient<$Types.GetResult<DeleveryPeriodPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__DeleveryPeriodClient<$Types.GetResult<DeleveryPeriodPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one DeleveryPeriod that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DeleveryPeriodFindUniqueOrThrowArgs} args - Arguments to find a DeleveryPeriod
     * @example
     * // Get one DeleveryPeriod
     * const deleveryPeriod = await prisma.deleveryPeriod.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DeleveryPeriodFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DeleveryPeriodFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DeleveryPeriodClient<$Types.GetResult<DeleveryPeriodPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first DeleveryPeriod that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeleveryPeriodFindFirstArgs} args - Arguments to find a DeleveryPeriod
     * @example
     * // Get one DeleveryPeriod
     * const deleveryPeriod = await prisma.deleveryPeriod.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DeleveryPeriodFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DeleveryPeriodFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'DeleveryPeriod'> extends True ? Prisma__DeleveryPeriodClient<$Types.GetResult<DeleveryPeriodPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__DeleveryPeriodClient<$Types.GetResult<DeleveryPeriodPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first DeleveryPeriod that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeleveryPeriodFindFirstOrThrowArgs} args - Arguments to find a DeleveryPeriod
     * @example
     * // Get one DeleveryPeriod
     * const deleveryPeriod = await prisma.deleveryPeriod.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DeleveryPeriodFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DeleveryPeriodFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DeleveryPeriodClient<$Types.GetResult<DeleveryPeriodPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more DeleveryPeriods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeleveryPeriodFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeleveryPeriods
     * const deleveryPeriods = await prisma.deleveryPeriod.findMany()
     * 
     * // Get first 10 DeleveryPeriods
     * const deleveryPeriods = await prisma.deleveryPeriod.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deleveryPeriodWithIdOnly = await prisma.deleveryPeriod.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DeleveryPeriodFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DeleveryPeriodFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<DeleveryPeriodPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a DeleveryPeriod.
     * @param {DeleveryPeriodCreateArgs} args - Arguments to create a DeleveryPeriod.
     * @example
     * // Create one DeleveryPeriod
     * const DeleveryPeriod = await prisma.deleveryPeriod.create({
     *   data: {
     *     // ... data to create a DeleveryPeriod
     *   }
     * })
     * 
    **/
    create<T extends DeleveryPeriodCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DeleveryPeriodCreateArgs<ExtArgs>>
    ): Prisma__DeleveryPeriodClient<$Types.GetResult<DeleveryPeriodPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many DeleveryPeriods.
     *     @param {DeleveryPeriodCreateManyArgs} args - Arguments to create many DeleveryPeriods.
     *     @example
     *     // Create many DeleveryPeriods
     *     const deleveryPeriod = await prisma.deleveryPeriod.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DeleveryPeriodCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DeleveryPeriodCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DeleveryPeriod.
     * @param {DeleveryPeriodDeleteArgs} args - Arguments to delete one DeleveryPeriod.
     * @example
     * // Delete one DeleveryPeriod
     * const DeleveryPeriod = await prisma.deleveryPeriod.delete({
     *   where: {
     *     // ... filter to delete one DeleveryPeriod
     *   }
     * })
     * 
    **/
    delete<T extends DeleveryPeriodDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DeleveryPeriodDeleteArgs<ExtArgs>>
    ): Prisma__DeleveryPeriodClient<$Types.GetResult<DeleveryPeriodPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one DeleveryPeriod.
     * @param {DeleveryPeriodUpdateArgs} args - Arguments to update one DeleveryPeriod.
     * @example
     * // Update one DeleveryPeriod
     * const deleveryPeriod = await prisma.deleveryPeriod.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DeleveryPeriodUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DeleveryPeriodUpdateArgs<ExtArgs>>
    ): Prisma__DeleveryPeriodClient<$Types.GetResult<DeleveryPeriodPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more DeleveryPeriods.
     * @param {DeleveryPeriodDeleteManyArgs} args - Arguments to filter DeleveryPeriods to delete.
     * @example
     * // Delete a few DeleveryPeriods
     * const { count } = await prisma.deleveryPeriod.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DeleveryPeriodDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DeleveryPeriodDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeleveryPeriods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeleveryPeriodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeleveryPeriods
     * const deleveryPeriod = await prisma.deleveryPeriod.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DeleveryPeriodUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DeleveryPeriodUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DeleveryPeriod.
     * @param {DeleveryPeriodUpsertArgs} args - Arguments to update or create a DeleveryPeriod.
     * @example
     * // Update or create a DeleveryPeriod
     * const deleveryPeriod = await prisma.deleveryPeriod.upsert({
     *   create: {
     *     // ... data to create a DeleveryPeriod
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeleveryPeriod we want to update
     *   }
     * })
    **/
    upsert<T extends DeleveryPeriodUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DeleveryPeriodUpsertArgs<ExtArgs>>
    ): Prisma__DeleveryPeriodClient<$Types.GetResult<DeleveryPeriodPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of DeleveryPeriods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeleveryPeriodCountArgs} args - Arguments to filter DeleveryPeriods to count.
     * @example
     * // Count the number of DeleveryPeriods
     * const count = await prisma.deleveryPeriod.count({
     *   where: {
     *     // ... the filter for the DeleveryPeriods we want to count
     *   }
     * })
    **/
    count<T extends DeleveryPeriodCountArgs>(
      args?: Subset<T, DeleveryPeriodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeleveryPeriodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeleveryPeriod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeleveryPeriodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeleveryPeriodAggregateArgs>(args: Subset<T, DeleveryPeriodAggregateArgs>): Prisma.PrismaPromise<GetDeleveryPeriodAggregateType<T>>

    /**
     * Group by DeleveryPeriod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeleveryPeriodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeleveryPeriodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeleveryPeriodGroupByArgs['orderBy'] }
        : { orderBy?: DeleveryPeriodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeleveryPeriodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeleveryPeriodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for DeleveryPeriod.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DeleveryPeriodClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    product<T extends ProductArgs<ExtArgs> = {}>(args?: Subset<T, ProductArgs<ExtArgs>>): Prisma__ProductClient<$Types.GetResult<ProductPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * DeleveryPeriod base type for findUnique actions
   */
  export type DeleveryPeriodFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeleveryPeriod
     */
    select?: DeleveryPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeleveryPeriodInclude<ExtArgs> | null
    /**
     * Filter, which DeleveryPeriod to fetch.
     */
    where: DeleveryPeriodWhereUniqueInput
  }

  /**
   * DeleveryPeriod findUnique
   */
  export interface DeleveryPeriodFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends DeleveryPeriodFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DeleveryPeriod findUniqueOrThrow
   */
  export type DeleveryPeriodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeleveryPeriod
     */
    select?: DeleveryPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeleveryPeriodInclude<ExtArgs> | null
    /**
     * Filter, which DeleveryPeriod to fetch.
     */
    where: DeleveryPeriodWhereUniqueInput
  }


  /**
   * DeleveryPeriod base type for findFirst actions
   */
  export type DeleveryPeriodFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeleveryPeriod
     */
    select?: DeleveryPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeleveryPeriodInclude<ExtArgs> | null
    /**
     * Filter, which DeleveryPeriod to fetch.
     */
    where?: DeleveryPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeleveryPeriods to fetch.
     */
    orderBy?: Enumerable<DeleveryPeriodOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeleveryPeriods.
     */
    cursor?: DeleveryPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeleveryPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeleveryPeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeleveryPeriods.
     */
    distinct?: Enumerable<DeleveryPeriodScalarFieldEnum>
  }

  /**
   * DeleveryPeriod findFirst
   */
  export interface DeleveryPeriodFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends DeleveryPeriodFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DeleveryPeriod findFirstOrThrow
   */
  export type DeleveryPeriodFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeleveryPeriod
     */
    select?: DeleveryPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeleveryPeriodInclude<ExtArgs> | null
    /**
     * Filter, which DeleveryPeriod to fetch.
     */
    where?: DeleveryPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeleveryPeriods to fetch.
     */
    orderBy?: Enumerable<DeleveryPeriodOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeleveryPeriods.
     */
    cursor?: DeleveryPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeleveryPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeleveryPeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeleveryPeriods.
     */
    distinct?: Enumerable<DeleveryPeriodScalarFieldEnum>
  }


  /**
   * DeleveryPeriod findMany
   */
  export type DeleveryPeriodFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeleveryPeriod
     */
    select?: DeleveryPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeleveryPeriodInclude<ExtArgs> | null
    /**
     * Filter, which DeleveryPeriods to fetch.
     */
    where?: DeleveryPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeleveryPeriods to fetch.
     */
    orderBy?: Enumerable<DeleveryPeriodOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeleveryPeriods.
     */
    cursor?: DeleveryPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeleveryPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeleveryPeriods.
     */
    skip?: number
    distinct?: Enumerable<DeleveryPeriodScalarFieldEnum>
  }


  /**
   * DeleveryPeriod create
   */
  export type DeleveryPeriodCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeleveryPeriod
     */
    select?: DeleveryPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeleveryPeriodInclude<ExtArgs> | null
    /**
     * The data needed to create a DeleveryPeriod.
     */
    data: XOR<DeleveryPeriodCreateInput, DeleveryPeriodUncheckedCreateInput>
  }


  /**
   * DeleveryPeriod createMany
   */
  export type DeleveryPeriodCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeleveryPeriods.
     */
    data: Enumerable<DeleveryPeriodCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * DeleveryPeriod update
   */
  export type DeleveryPeriodUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeleveryPeriod
     */
    select?: DeleveryPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeleveryPeriodInclude<ExtArgs> | null
    /**
     * The data needed to update a DeleveryPeriod.
     */
    data: XOR<DeleveryPeriodUpdateInput, DeleveryPeriodUncheckedUpdateInput>
    /**
     * Choose, which DeleveryPeriod to update.
     */
    where: DeleveryPeriodWhereUniqueInput
  }


  /**
   * DeleveryPeriod updateMany
   */
  export type DeleveryPeriodUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeleveryPeriods.
     */
    data: XOR<DeleveryPeriodUpdateManyMutationInput, DeleveryPeriodUncheckedUpdateManyInput>
    /**
     * Filter which DeleveryPeriods to update
     */
    where?: DeleveryPeriodWhereInput
  }


  /**
   * DeleveryPeriod upsert
   */
  export type DeleveryPeriodUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeleveryPeriod
     */
    select?: DeleveryPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeleveryPeriodInclude<ExtArgs> | null
    /**
     * The filter to search for the DeleveryPeriod to update in case it exists.
     */
    where: DeleveryPeriodWhereUniqueInput
    /**
     * In case the DeleveryPeriod found by the `where` argument doesn't exist, create a new DeleveryPeriod with this data.
     */
    create: XOR<DeleveryPeriodCreateInput, DeleveryPeriodUncheckedCreateInput>
    /**
     * In case the DeleveryPeriod was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeleveryPeriodUpdateInput, DeleveryPeriodUncheckedUpdateInput>
  }


  /**
   * DeleveryPeriod delete
   */
  export type DeleveryPeriodDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeleveryPeriod
     */
    select?: DeleveryPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeleveryPeriodInclude<ExtArgs> | null
    /**
     * Filter which DeleveryPeriod to delete.
     */
    where: DeleveryPeriodWhereUniqueInput
  }


  /**
   * DeleveryPeriod deleteMany
   */
  export type DeleveryPeriodDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeleveryPeriods to delete
     */
    where?: DeleveryPeriodWhereInput
  }


  /**
   * DeleveryPeriod without action
   */
  export type DeleveryPeriodArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeleveryPeriod
     */
    select?: DeleveryPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeleveryPeriodInclude<ExtArgs> | null
  }



  /**
   * Model ProductColor
   */


  export type AggregateProductColor = {
    _count: ProductColorCountAggregateOutputType | null
    _avg: ProductColorAvgAggregateOutputType | null
    _sum: ProductColorSumAggregateOutputType | null
    _min: ProductColorMinAggregateOutputType | null
    _max: ProductColorMaxAggregateOutputType | null
  }

  export type ProductColorAvgAggregateOutputType = {
    id: number | null
    productId: number | null
  }

  export type ProductColorSumAggregateOutputType = {
    id: number | null
    productId: number | null
  }

  export type ProductColorMinAggregateOutputType = {
    id: number | null
    productId: number | null
    colors: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ProductColorMaxAggregateOutputType = {
    id: number | null
    productId: number | null
    colors: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ProductColorCountAggregateOutputType = {
    id: number
    productId: number
    colors: number
    isActive: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type ProductColorAvgAggregateInputType = {
    id?: true
    productId?: true
  }

  export type ProductColorSumAggregateInputType = {
    id?: true
    productId?: true
  }

  export type ProductColorMinAggregateInputType = {
    id?: true
    productId?: true
    colors?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ProductColorMaxAggregateInputType = {
    id?: true
    productId?: true
    colors?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ProductColorCountAggregateInputType = {
    id?: true
    productId?: true
    colors?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type ProductColorAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductColor to aggregate.
     */
    where?: ProductColorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductColors to fetch.
     */
    orderBy?: Enumerable<ProductColorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductColorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductColors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductColors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductColors
    **/
    _count?: true | ProductColorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductColorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductColorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductColorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductColorMaxAggregateInputType
  }

  export type GetProductColorAggregateType<T extends ProductColorAggregateArgs> = {
        [P in keyof T & keyof AggregateProductColor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductColor[P]>
      : GetScalarType<T[P], AggregateProductColor[P]>
  }




  export type ProductColorGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ProductColorWhereInput
    orderBy?: Enumerable<ProductColorOrderByWithAggregationInput>
    by: ProductColorScalarFieldEnum[]
    having?: ProductColorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductColorCountAggregateInputType | true
    _avg?: ProductColorAvgAggregateInputType
    _sum?: ProductColorSumAggregateInputType
    _min?: ProductColorMinAggregateInputType
    _max?: ProductColorMaxAggregateInputType
  }


  export type ProductColorGroupByOutputType = {
    id: number
    productId: number
    colors: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: ProductColorCountAggregateOutputType | null
    _avg: ProductColorAvgAggregateOutputType | null
    _sum: ProductColorSumAggregateOutputType | null
    _min: ProductColorMinAggregateOutputType | null
    _max: ProductColorMaxAggregateOutputType | null
  }

  type GetProductColorGroupByPayload<T extends ProductColorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ProductColorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductColorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductColorGroupByOutputType[P]>
            : GetScalarType<T[P], ProductColorGroupByOutputType[P]>
        }
      >
    >


  export type ProductColorSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    colors?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    product?: boolean | ProductArgs<ExtArgs>
    colorSize?: boolean | ProductColor$colorSizeArgs<ExtArgs>
    productImages?: boolean | ProductColor$productImagesArgs<ExtArgs>
    _count?: boolean | ProductColorCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["productColor"]>

  export type ProductColorSelectScalar = {
    id?: boolean
    productId?: boolean
    colors?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type ProductColorInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    product?: boolean | ProductArgs<ExtArgs>
    colorSize?: boolean | ProductColor$colorSizeArgs<ExtArgs>
    productImages?: boolean | ProductColor$productImagesArgs<ExtArgs>
    _count?: boolean | ProductColorCountOutputTypeArgs<ExtArgs>
  }


  type ProductColorGetPayload<S extends boolean | null | undefined | ProductColorArgs> = $Types.GetResult<ProductColorPayload, S>

  type ProductColorCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ProductColorFindManyArgs, 'select' | 'include'> & {
      select?: ProductColorCountAggregateInputType | true
    }

  export interface ProductColorDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductColor'], meta: { name: 'ProductColor' } }
    /**
     * Find zero or one ProductColor that matches the filter.
     * @param {ProductColorFindUniqueArgs} args - Arguments to find a ProductColor
     * @example
     * // Get one ProductColor
     * const productColor = await prisma.productColor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductColorFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductColorFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ProductColor'> extends True ? Prisma__ProductColorClient<$Types.GetResult<ProductColorPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ProductColorClient<$Types.GetResult<ProductColorPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one ProductColor that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProductColorFindUniqueOrThrowArgs} args - Arguments to find a ProductColor
     * @example
     * // Get one ProductColor
     * const productColor = await prisma.productColor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProductColorFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductColorFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProductColorClient<$Types.GetResult<ProductColorPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first ProductColor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductColorFindFirstArgs} args - Arguments to find a ProductColor
     * @example
     * // Get one ProductColor
     * const productColor = await prisma.productColor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductColorFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductColorFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ProductColor'> extends True ? Prisma__ProductColorClient<$Types.GetResult<ProductColorPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ProductColorClient<$Types.GetResult<ProductColorPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first ProductColor that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductColorFindFirstOrThrowArgs} args - Arguments to find a ProductColor
     * @example
     * // Get one ProductColor
     * const productColor = await prisma.productColor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProductColorFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductColorFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProductColorClient<$Types.GetResult<ProductColorPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more ProductColors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductColorFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductColors
     * const productColors = await prisma.productColor.findMany()
     * 
     * // Get first 10 ProductColors
     * const productColors = await prisma.productColor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productColorWithIdOnly = await prisma.productColor.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductColorFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductColorFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ProductColorPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a ProductColor.
     * @param {ProductColorCreateArgs} args - Arguments to create a ProductColor.
     * @example
     * // Create one ProductColor
     * const ProductColor = await prisma.productColor.create({
     *   data: {
     *     // ... data to create a ProductColor
     *   }
     * })
     * 
    **/
    create<T extends ProductColorCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductColorCreateArgs<ExtArgs>>
    ): Prisma__ProductColorClient<$Types.GetResult<ProductColorPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many ProductColors.
     *     @param {ProductColorCreateManyArgs} args - Arguments to create many ProductColors.
     *     @example
     *     // Create many ProductColors
     *     const productColor = await prisma.productColor.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductColorCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductColorCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProductColor.
     * @param {ProductColorDeleteArgs} args - Arguments to delete one ProductColor.
     * @example
     * // Delete one ProductColor
     * const ProductColor = await prisma.productColor.delete({
     *   where: {
     *     // ... filter to delete one ProductColor
     *   }
     * })
     * 
    **/
    delete<T extends ProductColorDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ProductColorDeleteArgs<ExtArgs>>
    ): Prisma__ProductColorClient<$Types.GetResult<ProductColorPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one ProductColor.
     * @param {ProductColorUpdateArgs} args - Arguments to update one ProductColor.
     * @example
     * // Update one ProductColor
     * const productColor = await prisma.productColor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductColorUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductColorUpdateArgs<ExtArgs>>
    ): Prisma__ProductColorClient<$Types.GetResult<ProductColorPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more ProductColors.
     * @param {ProductColorDeleteManyArgs} args - Arguments to filter ProductColors to delete.
     * @example
     * // Delete a few ProductColors
     * const { count } = await prisma.productColor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductColorDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductColorDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductColors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductColorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductColors
     * const productColor = await prisma.productColor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductColorUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ProductColorUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductColor.
     * @param {ProductColorUpsertArgs} args - Arguments to update or create a ProductColor.
     * @example
     * // Update or create a ProductColor
     * const productColor = await prisma.productColor.upsert({
     *   create: {
     *     // ... data to create a ProductColor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductColor we want to update
     *   }
     * })
    **/
    upsert<T extends ProductColorUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ProductColorUpsertArgs<ExtArgs>>
    ): Prisma__ProductColorClient<$Types.GetResult<ProductColorPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of ProductColors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductColorCountArgs} args - Arguments to filter ProductColors to count.
     * @example
     * // Count the number of ProductColors
     * const count = await prisma.productColor.count({
     *   where: {
     *     // ... the filter for the ProductColors we want to count
     *   }
     * })
    **/
    count<T extends ProductColorCountArgs>(
      args?: Subset<T, ProductColorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductColorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductColor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductColorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductColorAggregateArgs>(args: Subset<T, ProductColorAggregateArgs>): Prisma.PrismaPromise<GetProductColorAggregateType<T>>

    /**
     * Group by ProductColor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductColorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductColorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductColorGroupByArgs['orderBy'] }
        : { orderBy?: ProductColorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductColorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductColorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductColor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductColorClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    product<T extends ProductArgs<ExtArgs> = {}>(args?: Subset<T, ProductArgs<ExtArgs>>): Prisma__ProductClient<$Types.GetResult<ProductPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    colorSize<T extends ProductColor$colorSizeArgs<ExtArgs> = {}>(args?: Subset<T, ProductColor$colorSizeArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ProductAviableSizesPayload<ExtArgs>, T, 'findMany', never>| Null>;

    productImages<T extends ProductColor$productImagesArgs<ExtArgs> = {}>(args?: Subset<T, ProductColor$productImagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ProductImagesPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ProductColor base type for findUnique actions
   */
  export type ProductColorFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductColor
     */
    select?: ProductColorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductColorInclude<ExtArgs> | null
    /**
     * Filter, which ProductColor to fetch.
     */
    where: ProductColorWhereUniqueInput
  }

  /**
   * ProductColor findUnique
   */
  export interface ProductColorFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ProductColorFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProductColor findUniqueOrThrow
   */
  export type ProductColorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductColor
     */
    select?: ProductColorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductColorInclude<ExtArgs> | null
    /**
     * Filter, which ProductColor to fetch.
     */
    where: ProductColorWhereUniqueInput
  }


  /**
   * ProductColor base type for findFirst actions
   */
  export type ProductColorFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductColor
     */
    select?: ProductColorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductColorInclude<ExtArgs> | null
    /**
     * Filter, which ProductColor to fetch.
     */
    where?: ProductColorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductColors to fetch.
     */
    orderBy?: Enumerable<ProductColorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductColors.
     */
    cursor?: ProductColorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductColors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductColors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductColors.
     */
    distinct?: Enumerable<ProductColorScalarFieldEnum>
  }

  /**
   * ProductColor findFirst
   */
  export interface ProductColorFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ProductColorFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProductColor findFirstOrThrow
   */
  export type ProductColorFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductColor
     */
    select?: ProductColorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductColorInclude<ExtArgs> | null
    /**
     * Filter, which ProductColor to fetch.
     */
    where?: ProductColorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductColors to fetch.
     */
    orderBy?: Enumerable<ProductColorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductColors.
     */
    cursor?: ProductColorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductColors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductColors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductColors.
     */
    distinct?: Enumerable<ProductColorScalarFieldEnum>
  }


  /**
   * ProductColor findMany
   */
  export type ProductColorFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductColor
     */
    select?: ProductColorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductColorInclude<ExtArgs> | null
    /**
     * Filter, which ProductColors to fetch.
     */
    where?: ProductColorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductColors to fetch.
     */
    orderBy?: Enumerable<ProductColorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductColors.
     */
    cursor?: ProductColorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductColors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductColors.
     */
    skip?: number
    distinct?: Enumerable<ProductColorScalarFieldEnum>
  }


  /**
   * ProductColor create
   */
  export type ProductColorCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductColor
     */
    select?: ProductColorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductColorInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductColor.
     */
    data: XOR<ProductColorCreateInput, ProductColorUncheckedCreateInput>
  }


  /**
   * ProductColor createMany
   */
  export type ProductColorCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductColors.
     */
    data: Enumerable<ProductColorCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ProductColor update
   */
  export type ProductColorUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductColor
     */
    select?: ProductColorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductColorInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductColor.
     */
    data: XOR<ProductColorUpdateInput, ProductColorUncheckedUpdateInput>
    /**
     * Choose, which ProductColor to update.
     */
    where: ProductColorWhereUniqueInput
  }


  /**
   * ProductColor updateMany
   */
  export type ProductColorUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductColors.
     */
    data: XOR<ProductColorUpdateManyMutationInput, ProductColorUncheckedUpdateManyInput>
    /**
     * Filter which ProductColors to update
     */
    where?: ProductColorWhereInput
  }


  /**
   * ProductColor upsert
   */
  export type ProductColorUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductColor
     */
    select?: ProductColorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductColorInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductColor to update in case it exists.
     */
    where: ProductColorWhereUniqueInput
    /**
     * In case the ProductColor found by the `where` argument doesn't exist, create a new ProductColor with this data.
     */
    create: XOR<ProductColorCreateInput, ProductColorUncheckedCreateInput>
    /**
     * In case the ProductColor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductColorUpdateInput, ProductColorUncheckedUpdateInput>
  }


  /**
   * ProductColor delete
   */
  export type ProductColorDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductColor
     */
    select?: ProductColorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductColorInclude<ExtArgs> | null
    /**
     * Filter which ProductColor to delete.
     */
    where: ProductColorWhereUniqueInput
  }


  /**
   * ProductColor deleteMany
   */
  export type ProductColorDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductColors to delete
     */
    where?: ProductColorWhereInput
  }


  /**
   * ProductColor.colorSize
   */
  export type ProductColor$colorSizeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductAviableSizes
     */
    select?: ProductAviableSizesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductAviableSizesInclude<ExtArgs> | null
    where?: ProductAviableSizesWhereInput
    orderBy?: Enumerable<ProductAviableSizesOrderByWithRelationInput>
    cursor?: ProductAviableSizesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ProductAviableSizesScalarFieldEnum>
  }


  /**
   * ProductColor.productImages
   */
  export type ProductColor$productImagesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImages
     */
    select?: ProductImagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductImagesInclude<ExtArgs> | null
    where?: ProductImagesWhereInput
    orderBy?: Enumerable<ProductImagesOrderByWithRelationInput>
    cursor?: ProductImagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ProductImagesScalarFieldEnum>
  }


  /**
   * ProductColor without action
   */
  export type ProductColorArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductColor
     */
    select?: ProductColorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductColorInclude<ExtArgs> | null
  }



  /**
   * Model PriceHistory
   */


  export type AggregatePriceHistory = {
    _count: PriceHistoryCountAggregateOutputType | null
    _avg: PriceHistoryAvgAggregateOutputType | null
    _sum: PriceHistorySumAggregateOutputType | null
    _min: PriceHistoryMinAggregateOutputType | null
    _max: PriceHistoryMaxAggregateOutputType | null
  }

  export type PriceHistoryAvgAggregateOutputType = {
    id: number | null
    price: number | null
    productId: number | null
  }

  export type PriceHistorySumAggregateOutputType = {
    id: number | null
    price: number | null
    productId: number | null
  }

  export type PriceHistoryMinAggregateOutputType = {
    id: number | null
    price: number | null
    productId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type PriceHistoryMaxAggregateOutputType = {
    id: number | null
    price: number | null
    productId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type PriceHistoryCountAggregateOutputType = {
    id: number
    price: number
    productId: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type PriceHistoryAvgAggregateInputType = {
    id?: true
    price?: true
    productId?: true
  }

  export type PriceHistorySumAggregateInputType = {
    id?: true
    price?: true
    productId?: true
  }

  export type PriceHistoryMinAggregateInputType = {
    id?: true
    price?: true
    productId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type PriceHistoryMaxAggregateInputType = {
    id?: true
    price?: true
    productId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type PriceHistoryCountAggregateInputType = {
    id?: true
    price?: true
    productId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type PriceHistoryAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which PriceHistory to aggregate.
     */
    where?: PriceHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceHistories to fetch.
     */
    orderBy?: Enumerable<PriceHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PriceHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PriceHistories
    **/
    _count?: true | PriceHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PriceHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PriceHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PriceHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PriceHistoryMaxAggregateInputType
  }

  export type GetPriceHistoryAggregateType<T extends PriceHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregatePriceHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePriceHistory[P]>
      : GetScalarType<T[P], AggregatePriceHistory[P]>
  }




  export type PriceHistoryGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PriceHistoryWhereInput
    orderBy?: Enumerable<PriceHistoryOrderByWithAggregationInput>
    by: PriceHistoryScalarFieldEnum[]
    having?: PriceHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PriceHistoryCountAggregateInputType | true
    _avg?: PriceHistoryAvgAggregateInputType
    _sum?: PriceHistorySumAggregateInputType
    _min?: PriceHistoryMinAggregateInputType
    _max?: PriceHistoryMaxAggregateInputType
  }


  export type PriceHistoryGroupByOutputType = {
    id: number
    price: number
    productId: number
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: PriceHistoryCountAggregateOutputType | null
    _avg: PriceHistoryAvgAggregateOutputType | null
    _sum: PriceHistorySumAggregateOutputType | null
    _min: PriceHistoryMinAggregateOutputType | null
    _max: PriceHistoryMaxAggregateOutputType | null
  }

  type GetPriceHistoryGroupByPayload<T extends PriceHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PriceHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PriceHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PriceHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], PriceHistoryGroupByOutputType[P]>
        }
      >
    >


  export type PriceHistorySelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    price?: boolean
    productId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    Product?: boolean | ProductArgs<ExtArgs>
  }, ExtArgs["result"]["priceHistory"]>

  export type PriceHistorySelectScalar = {
    id?: boolean
    price?: boolean
    productId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type PriceHistoryInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    Product?: boolean | ProductArgs<ExtArgs>
  }


  type PriceHistoryGetPayload<S extends boolean | null | undefined | PriceHistoryArgs> = $Types.GetResult<PriceHistoryPayload, S>

  type PriceHistoryCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<PriceHistoryFindManyArgs, 'select' | 'include'> & {
      select?: PriceHistoryCountAggregateInputType | true
    }

  export interface PriceHistoryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PriceHistory'], meta: { name: 'PriceHistory' } }
    /**
     * Find zero or one PriceHistory that matches the filter.
     * @param {PriceHistoryFindUniqueArgs} args - Arguments to find a PriceHistory
     * @example
     * // Get one PriceHistory
     * const priceHistory = await prisma.priceHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PriceHistoryFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PriceHistoryFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PriceHistory'> extends True ? Prisma__PriceHistoryClient<$Types.GetResult<PriceHistoryPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__PriceHistoryClient<$Types.GetResult<PriceHistoryPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one PriceHistory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PriceHistoryFindUniqueOrThrowArgs} args - Arguments to find a PriceHistory
     * @example
     * // Get one PriceHistory
     * const priceHistory = await prisma.priceHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PriceHistoryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PriceHistoryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PriceHistoryClient<$Types.GetResult<PriceHistoryPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first PriceHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceHistoryFindFirstArgs} args - Arguments to find a PriceHistory
     * @example
     * // Get one PriceHistory
     * const priceHistory = await prisma.priceHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PriceHistoryFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PriceHistoryFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PriceHistory'> extends True ? Prisma__PriceHistoryClient<$Types.GetResult<PriceHistoryPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__PriceHistoryClient<$Types.GetResult<PriceHistoryPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first PriceHistory that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceHistoryFindFirstOrThrowArgs} args - Arguments to find a PriceHistory
     * @example
     * // Get one PriceHistory
     * const priceHistory = await prisma.priceHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PriceHistoryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PriceHistoryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PriceHistoryClient<$Types.GetResult<PriceHistoryPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more PriceHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceHistoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PriceHistories
     * const priceHistories = await prisma.priceHistory.findMany()
     * 
     * // Get first 10 PriceHistories
     * const priceHistories = await prisma.priceHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const priceHistoryWithIdOnly = await prisma.priceHistory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PriceHistoryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PriceHistoryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<PriceHistoryPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a PriceHistory.
     * @param {PriceHistoryCreateArgs} args - Arguments to create a PriceHistory.
     * @example
     * // Create one PriceHistory
     * const PriceHistory = await prisma.priceHistory.create({
     *   data: {
     *     // ... data to create a PriceHistory
     *   }
     * })
     * 
    **/
    create<T extends PriceHistoryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PriceHistoryCreateArgs<ExtArgs>>
    ): Prisma__PriceHistoryClient<$Types.GetResult<PriceHistoryPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many PriceHistories.
     *     @param {PriceHistoryCreateManyArgs} args - Arguments to create many PriceHistories.
     *     @example
     *     // Create many PriceHistories
     *     const priceHistory = await prisma.priceHistory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PriceHistoryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PriceHistoryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PriceHistory.
     * @param {PriceHistoryDeleteArgs} args - Arguments to delete one PriceHistory.
     * @example
     * // Delete one PriceHistory
     * const PriceHistory = await prisma.priceHistory.delete({
     *   where: {
     *     // ... filter to delete one PriceHistory
     *   }
     * })
     * 
    **/
    delete<T extends PriceHistoryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PriceHistoryDeleteArgs<ExtArgs>>
    ): Prisma__PriceHistoryClient<$Types.GetResult<PriceHistoryPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one PriceHistory.
     * @param {PriceHistoryUpdateArgs} args - Arguments to update one PriceHistory.
     * @example
     * // Update one PriceHistory
     * const priceHistory = await prisma.priceHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PriceHistoryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PriceHistoryUpdateArgs<ExtArgs>>
    ): Prisma__PriceHistoryClient<$Types.GetResult<PriceHistoryPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more PriceHistories.
     * @param {PriceHistoryDeleteManyArgs} args - Arguments to filter PriceHistories to delete.
     * @example
     * // Delete a few PriceHistories
     * const { count } = await prisma.priceHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PriceHistoryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PriceHistoryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PriceHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PriceHistories
     * const priceHistory = await prisma.priceHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PriceHistoryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PriceHistoryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PriceHistory.
     * @param {PriceHistoryUpsertArgs} args - Arguments to update or create a PriceHistory.
     * @example
     * // Update or create a PriceHistory
     * const priceHistory = await prisma.priceHistory.upsert({
     *   create: {
     *     // ... data to create a PriceHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PriceHistory we want to update
     *   }
     * })
    **/
    upsert<T extends PriceHistoryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PriceHistoryUpsertArgs<ExtArgs>>
    ): Prisma__PriceHistoryClient<$Types.GetResult<PriceHistoryPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of PriceHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceHistoryCountArgs} args - Arguments to filter PriceHistories to count.
     * @example
     * // Count the number of PriceHistories
     * const count = await prisma.priceHistory.count({
     *   where: {
     *     // ... the filter for the PriceHistories we want to count
     *   }
     * })
    **/
    count<T extends PriceHistoryCountArgs>(
      args?: Subset<T, PriceHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PriceHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PriceHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PriceHistoryAggregateArgs>(args: Subset<T, PriceHistoryAggregateArgs>): Prisma.PrismaPromise<GetPriceHistoryAggregateType<T>>

    /**
     * Group by PriceHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PriceHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PriceHistoryGroupByArgs['orderBy'] }
        : { orderBy?: PriceHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PriceHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPriceHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for PriceHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PriceHistoryClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    Product<T extends ProductArgs<ExtArgs> = {}>(args?: Subset<T, ProductArgs<ExtArgs>>): Prisma__ProductClient<$Types.GetResult<ProductPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * PriceHistory base type for findUnique actions
   */
  export type PriceHistoryFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PriceHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PriceHistory to fetch.
     */
    where: PriceHistoryWhereUniqueInput
  }

  /**
   * PriceHistory findUnique
   */
  export interface PriceHistoryFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends PriceHistoryFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PriceHistory findUniqueOrThrow
   */
  export type PriceHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PriceHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PriceHistory to fetch.
     */
    where: PriceHistoryWhereUniqueInput
  }


  /**
   * PriceHistory base type for findFirst actions
   */
  export type PriceHistoryFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PriceHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PriceHistory to fetch.
     */
    where?: PriceHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceHistories to fetch.
     */
    orderBy?: Enumerable<PriceHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PriceHistories.
     */
    cursor?: PriceHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PriceHistories.
     */
    distinct?: Enumerable<PriceHistoryScalarFieldEnum>
  }

  /**
   * PriceHistory findFirst
   */
  export interface PriceHistoryFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends PriceHistoryFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PriceHistory findFirstOrThrow
   */
  export type PriceHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PriceHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PriceHistory to fetch.
     */
    where?: PriceHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceHistories to fetch.
     */
    orderBy?: Enumerable<PriceHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PriceHistories.
     */
    cursor?: PriceHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PriceHistories.
     */
    distinct?: Enumerable<PriceHistoryScalarFieldEnum>
  }


  /**
   * PriceHistory findMany
   */
  export type PriceHistoryFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PriceHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PriceHistories to fetch.
     */
    where?: PriceHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceHistories to fetch.
     */
    orderBy?: Enumerable<PriceHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PriceHistories.
     */
    cursor?: PriceHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceHistories.
     */
    skip?: number
    distinct?: Enumerable<PriceHistoryScalarFieldEnum>
  }


  /**
   * PriceHistory create
   */
  export type PriceHistoryCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PriceHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a PriceHistory.
     */
    data: XOR<PriceHistoryCreateInput, PriceHistoryUncheckedCreateInput>
  }


  /**
   * PriceHistory createMany
   */
  export type PriceHistoryCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PriceHistories.
     */
    data: Enumerable<PriceHistoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PriceHistory update
   */
  export type PriceHistoryUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PriceHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a PriceHistory.
     */
    data: XOR<PriceHistoryUpdateInput, PriceHistoryUncheckedUpdateInput>
    /**
     * Choose, which PriceHistory to update.
     */
    where: PriceHistoryWhereUniqueInput
  }


  /**
   * PriceHistory updateMany
   */
  export type PriceHistoryUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PriceHistories.
     */
    data: XOR<PriceHistoryUpdateManyMutationInput, PriceHistoryUncheckedUpdateManyInput>
    /**
     * Filter which PriceHistories to update
     */
    where?: PriceHistoryWhereInput
  }


  /**
   * PriceHistory upsert
   */
  export type PriceHistoryUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PriceHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the PriceHistory to update in case it exists.
     */
    where: PriceHistoryWhereUniqueInput
    /**
     * In case the PriceHistory found by the `where` argument doesn't exist, create a new PriceHistory with this data.
     */
    create: XOR<PriceHistoryCreateInput, PriceHistoryUncheckedCreateInput>
    /**
     * In case the PriceHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PriceHistoryUpdateInput, PriceHistoryUncheckedUpdateInput>
  }


  /**
   * PriceHistory delete
   */
  export type PriceHistoryDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PriceHistoryInclude<ExtArgs> | null
    /**
     * Filter which PriceHistory to delete.
     */
    where: PriceHistoryWhereUniqueInput
  }


  /**
   * PriceHistory deleteMany
   */
  export type PriceHistoryDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which PriceHistories to delete
     */
    where?: PriceHistoryWhereInput
  }


  /**
   * PriceHistory without action
   */
  export type PriceHistoryArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PriceHistoryInclude<ExtArgs> | null
  }



  /**
   * Model ProductAviableSizes
   */


  export type AggregateProductAviableSizes = {
    _count: ProductAviableSizesCountAggregateOutputType | null
    _avg: ProductAviableSizesAvgAggregateOutputType | null
    _sum: ProductAviableSizesSumAggregateOutputType | null
    _min: ProductAviableSizesMinAggregateOutputType | null
    _max: ProductAviableSizesMaxAggregateOutputType | null
  }

  export type ProductAviableSizesAvgAggregateOutputType = {
    id: number | null
    quantity: number | null
    productColorId: number | null
    productTypeSizeId: number | null
  }

  export type ProductAviableSizesSumAggregateOutputType = {
    id: number | null
    quantity: number | null
    productColorId: number | null
    productTypeSizeId: number | null
  }

  export type ProductAviableSizesMinAggregateOutputType = {
    id: number | null
    quantity: number | null
    productColorId: number | null
    productTypeSizeId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ProductAviableSizesMaxAggregateOutputType = {
    id: number | null
    quantity: number | null
    productColorId: number | null
    productTypeSizeId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ProductAviableSizesCountAggregateOutputType = {
    id: number
    quantity: number
    productColorId: number
    productTypeSizeId: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type ProductAviableSizesAvgAggregateInputType = {
    id?: true
    quantity?: true
    productColorId?: true
    productTypeSizeId?: true
  }

  export type ProductAviableSizesSumAggregateInputType = {
    id?: true
    quantity?: true
    productColorId?: true
    productTypeSizeId?: true
  }

  export type ProductAviableSizesMinAggregateInputType = {
    id?: true
    quantity?: true
    productColorId?: true
    productTypeSizeId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ProductAviableSizesMaxAggregateInputType = {
    id?: true
    quantity?: true
    productColorId?: true
    productTypeSizeId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ProductAviableSizesCountAggregateInputType = {
    id?: true
    quantity?: true
    productColorId?: true
    productTypeSizeId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type ProductAviableSizesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductAviableSizes to aggregate.
     */
    where?: ProductAviableSizesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductAviableSizes to fetch.
     */
    orderBy?: Enumerable<ProductAviableSizesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductAviableSizesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductAviableSizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductAviableSizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductAviableSizes
    **/
    _count?: true | ProductAviableSizesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAviableSizesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductAviableSizesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductAviableSizesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductAviableSizesMaxAggregateInputType
  }

  export type GetProductAviableSizesAggregateType<T extends ProductAviableSizesAggregateArgs> = {
        [P in keyof T & keyof AggregateProductAviableSizes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductAviableSizes[P]>
      : GetScalarType<T[P], AggregateProductAviableSizes[P]>
  }




  export type ProductAviableSizesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ProductAviableSizesWhereInput
    orderBy?: Enumerable<ProductAviableSizesOrderByWithAggregationInput>
    by: ProductAviableSizesScalarFieldEnum[]
    having?: ProductAviableSizesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductAviableSizesCountAggregateInputType | true
    _avg?: ProductAviableSizesAvgAggregateInputType
    _sum?: ProductAviableSizesSumAggregateInputType
    _min?: ProductAviableSizesMinAggregateInputType
    _max?: ProductAviableSizesMaxAggregateInputType
  }


  export type ProductAviableSizesGroupByOutputType = {
    id: number
    quantity: number
    productColorId: number
    productTypeSizeId: number
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: ProductAviableSizesCountAggregateOutputType | null
    _avg: ProductAviableSizesAvgAggregateOutputType | null
    _sum: ProductAviableSizesSumAggregateOutputType | null
    _min: ProductAviableSizesMinAggregateOutputType | null
    _max: ProductAviableSizesMaxAggregateOutputType | null
  }

  type GetProductAviableSizesGroupByPayload<T extends ProductAviableSizesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ProductAviableSizesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductAviableSizesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductAviableSizesGroupByOutputType[P]>
            : GetScalarType<T[P], ProductAviableSizesGroupByOutputType[P]>
        }
      >
    >


  export type ProductAviableSizesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quantity?: boolean
    productColorId?: boolean
    productTypeSizeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    history?: boolean | ProductAviableSizes$historyArgs<ExtArgs>
    productColor?: boolean | ProductColorArgs<ExtArgs>
    productTypeSize?: boolean | ProductTypeSizeArgs<ExtArgs>
    _count?: boolean | ProductAviableSizesCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["productAviableSizes"]>

  export type ProductAviableSizesSelectScalar = {
    id?: boolean
    quantity?: boolean
    productColorId?: boolean
    productTypeSizeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type ProductAviableSizesInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    history?: boolean | ProductAviableSizes$historyArgs<ExtArgs>
    productColor?: boolean | ProductColorArgs<ExtArgs>
    productTypeSize?: boolean | ProductTypeSizeArgs<ExtArgs>
    _count?: boolean | ProductAviableSizesCountOutputTypeArgs<ExtArgs>
  }


  type ProductAviableSizesGetPayload<S extends boolean | null | undefined | ProductAviableSizesArgs> = $Types.GetResult<ProductAviableSizesPayload, S>

  type ProductAviableSizesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ProductAviableSizesFindManyArgs, 'select' | 'include'> & {
      select?: ProductAviableSizesCountAggregateInputType | true
    }

  export interface ProductAviableSizesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductAviableSizes'], meta: { name: 'ProductAviableSizes' } }
    /**
     * Find zero or one ProductAviableSizes that matches the filter.
     * @param {ProductAviableSizesFindUniqueArgs} args - Arguments to find a ProductAviableSizes
     * @example
     * // Get one ProductAviableSizes
     * const productAviableSizes = await prisma.productAviableSizes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductAviableSizesFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductAviableSizesFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ProductAviableSizes'> extends True ? Prisma__ProductAviableSizesClient<$Types.GetResult<ProductAviableSizesPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ProductAviableSizesClient<$Types.GetResult<ProductAviableSizesPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one ProductAviableSizes that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProductAviableSizesFindUniqueOrThrowArgs} args - Arguments to find a ProductAviableSizes
     * @example
     * // Get one ProductAviableSizes
     * const productAviableSizes = await prisma.productAviableSizes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProductAviableSizesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductAviableSizesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProductAviableSizesClient<$Types.GetResult<ProductAviableSizesPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first ProductAviableSizes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAviableSizesFindFirstArgs} args - Arguments to find a ProductAviableSizes
     * @example
     * // Get one ProductAviableSizes
     * const productAviableSizes = await prisma.productAviableSizes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductAviableSizesFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductAviableSizesFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ProductAviableSizes'> extends True ? Prisma__ProductAviableSizesClient<$Types.GetResult<ProductAviableSizesPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ProductAviableSizesClient<$Types.GetResult<ProductAviableSizesPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first ProductAviableSizes that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAviableSizesFindFirstOrThrowArgs} args - Arguments to find a ProductAviableSizes
     * @example
     * // Get one ProductAviableSizes
     * const productAviableSizes = await prisma.productAviableSizes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProductAviableSizesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductAviableSizesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProductAviableSizesClient<$Types.GetResult<ProductAviableSizesPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more ProductAviableSizes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAviableSizesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductAviableSizes
     * const productAviableSizes = await prisma.productAviableSizes.findMany()
     * 
     * // Get first 10 ProductAviableSizes
     * const productAviableSizes = await prisma.productAviableSizes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productAviableSizesWithIdOnly = await prisma.productAviableSizes.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductAviableSizesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductAviableSizesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ProductAviableSizesPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a ProductAviableSizes.
     * @param {ProductAviableSizesCreateArgs} args - Arguments to create a ProductAviableSizes.
     * @example
     * // Create one ProductAviableSizes
     * const ProductAviableSizes = await prisma.productAviableSizes.create({
     *   data: {
     *     // ... data to create a ProductAviableSizes
     *   }
     * })
     * 
    **/
    create<T extends ProductAviableSizesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductAviableSizesCreateArgs<ExtArgs>>
    ): Prisma__ProductAviableSizesClient<$Types.GetResult<ProductAviableSizesPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many ProductAviableSizes.
     *     @param {ProductAviableSizesCreateManyArgs} args - Arguments to create many ProductAviableSizes.
     *     @example
     *     // Create many ProductAviableSizes
     *     const productAviableSizes = await prisma.productAviableSizes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductAviableSizesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductAviableSizesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProductAviableSizes.
     * @param {ProductAviableSizesDeleteArgs} args - Arguments to delete one ProductAviableSizes.
     * @example
     * // Delete one ProductAviableSizes
     * const ProductAviableSizes = await prisma.productAviableSizes.delete({
     *   where: {
     *     // ... filter to delete one ProductAviableSizes
     *   }
     * })
     * 
    **/
    delete<T extends ProductAviableSizesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ProductAviableSizesDeleteArgs<ExtArgs>>
    ): Prisma__ProductAviableSizesClient<$Types.GetResult<ProductAviableSizesPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one ProductAviableSizes.
     * @param {ProductAviableSizesUpdateArgs} args - Arguments to update one ProductAviableSizes.
     * @example
     * // Update one ProductAviableSizes
     * const productAviableSizes = await prisma.productAviableSizes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductAviableSizesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductAviableSizesUpdateArgs<ExtArgs>>
    ): Prisma__ProductAviableSizesClient<$Types.GetResult<ProductAviableSizesPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more ProductAviableSizes.
     * @param {ProductAviableSizesDeleteManyArgs} args - Arguments to filter ProductAviableSizes to delete.
     * @example
     * // Delete a few ProductAviableSizes
     * const { count } = await prisma.productAviableSizes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductAviableSizesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductAviableSizesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductAviableSizes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAviableSizesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductAviableSizes
     * const productAviableSizes = await prisma.productAviableSizes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductAviableSizesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ProductAviableSizesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductAviableSizes.
     * @param {ProductAviableSizesUpsertArgs} args - Arguments to update or create a ProductAviableSizes.
     * @example
     * // Update or create a ProductAviableSizes
     * const productAviableSizes = await prisma.productAviableSizes.upsert({
     *   create: {
     *     // ... data to create a ProductAviableSizes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductAviableSizes we want to update
     *   }
     * })
    **/
    upsert<T extends ProductAviableSizesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ProductAviableSizesUpsertArgs<ExtArgs>>
    ): Prisma__ProductAviableSizesClient<$Types.GetResult<ProductAviableSizesPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of ProductAviableSizes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAviableSizesCountArgs} args - Arguments to filter ProductAviableSizes to count.
     * @example
     * // Count the number of ProductAviableSizes
     * const count = await prisma.productAviableSizes.count({
     *   where: {
     *     // ... the filter for the ProductAviableSizes we want to count
     *   }
     * })
    **/
    count<T extends ProductAviableSizesCountArgs>(
      args?: Subset<T, ProductAviableSizesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductAviableSizesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductAviableSizes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAviableSizesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAviableSizesAggregateArgs>(args: Subset<T, ProductAviableSizesAggregateArgs>): Prisma.PrismaPromise<GetProductAviableSizesAggregateType<T>>

    /**
     * Group by ProductAviableSizes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAviableSizesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductAviableSizesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductAviableSizesGroupByArgs['orderBy'] }
        : { orderBy?: ProductAviableSizesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductAviableSizesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductAviableSizesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductAviableSizes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductAviableSizesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    history<T extends ProductAviableSizes$historyArgs<ExtArgs> = {}>(args?: Subset<T, ProductAviableSizes$historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<QuantityHistoryPayload<ExtArgs>, T, 'findMany', never>| Null>;

    productColor<T extends ProductColorArgs<ExtArgs> = {}>(args?: Subset<T, ProductColorArgs<ExtArgs>>): Prisma__ProductColorClient<$Types.GetResult<ProductColorPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    productTypeSize<T extends ProductTypeSizeArgs<ExtArgs> = {}>(args?: Subset<T, ProductTypeSizeArgs<ExtArgs>>): Prisma__ProductTypeSizeClient<$Types.GetResult<ProductTypeSizePayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ProductAviableSizes base type for findUnique actions
   */
  export type ProductAviableSizesFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductAviableSizes
     */
    select?: ProductAviableSizesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductAviableSizesInclude<ExtArgs> | null
    /**
     * Filter, which ProductAviableSizes to fetch.
     */
    where: ProductAviableSizesWhereUniqueInput
  }

  /**
   * ProductAviableSizes findUnique
   */
  export interface ProductAviableSizesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ProductAviableSizesFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProductAviableSizes findUniqueOrThrow
   */
  export type ProductAviableSizesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductAviableSizes
     */
    select?: ProductAviableSizesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductAviableSizesInclude<ExtArgs> | null
    /**
     * Filter, which ProductAviableSizes to fetch.
     */
    where: ProductAviableSizesWhereUniqueInput
  }


  /**
   * ProductAviableSizes base type for findFirst actions
   */
  export type ProductAviableSizesFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductAviableSizes
     */
    select?: ProductAviableSizesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductAviableSizesInclude<ExtArgs> | null
    /**
     * Filter, which ProductAviableSizes to fetch.
     */
    where?: ProductAviableSizesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductAviableSizes to fetch.
     */
    orderBy?: Enumerable<ProductAviableSizesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductAviableSizes.
     */
    cursor?: ProductAviableSizesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductAviableSizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductAviableSizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductAviableSizes.
     */
    distinct?: Enumerable<ProductAviableSizesScalarFieldEnum>
  }

  /**
   * ProductAviableSizes findFirst
   */
  export interface ProductAviableSizesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ProductAviableSizesFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProductAviableSizes findFirstOrThrow
   */
  export type ProductAviableSizesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductAviableSizes
     */
    select?: ProductAviableSizesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductAviableSizesInclude<ExtArgs> | null
    /**
     * Filter, which ProductAviableSizes to fetch.
     */
    where?: ProductAviableSizesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductAviableSizes to fetch.
     */
    orderBy?: Enumerable<ProductAviableSizesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductAviableSizes.
     */
    cursor?: ProductAviableSizesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductAviableSizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductAviableSizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductAviableSizes.
     */
    distinct?: Enumerable<ProductAviableSizesScalarFieldEnum>
  }


  /**
   * ProductAviableSizes findMany
   */
  export type ProductAviableSizesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductAviableSizes
     */
    select?: ProductAviableSizesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductAviableSizesInclude<ExtArgs> | null
    /**
     * Filter, which ProductAviableSizes to fetch.
     */
    where?: ProductAviableSizesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductAviableSizes to fetch.
     */
    orderBy?: Enumerable<ProductAviableSizesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductAviableSizes.
     */
    cursor?: ProductAviableSizesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductAviableSizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductAviableSizes.
     */
    skip?: number
    distinct?: Enumerable<ProductAviableSizesScalarFieldEnum>
  }


  /**
   * ProductAviableSizes create
   */
  export type ProductAviableSizesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductAviableSizes
     */
    select?: ProductAviableSizesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductAviableSizesInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductAviableSizes.
     */
    data: XOR<ProductAviableSizesCreateInput, ProductAviableSizesUncheckedCreateInput>
  }


  /**
   * ProductAviableSizes createMany
   */
  export type ProductAviableSizesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductAviableSizes.
     */
    data: Enumerable<ProductAviableSizesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ProductAviableSizes update
   */
  export type ProductAviableSizesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductAviableSizes
     */
    select?: ProductAviableSizesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductAviableSizesInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductAviableSizes.
     */
    data: XOR<ProductAviableSizesUpdateInput, ProductAviableSizesUncheckedUpdateInput>
    /**
     * Choose, which ProductAviableSizes to update.
     */
    where: ProductAviableSizesWhereUniqueInput
  }


  /**
   * ProductAviableSizes updateMany
   */
  export type ProductAviableSizesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductAviableSizes.
     */
    data: XOR<ProductAviableSizesUpdateManyMutationInput, ProductAviableSizesUncheckedUpdateManyInput>
    /**
     * Filter which ProductAviableSizes to update
     */
    where?: ProductAviableSizesWhereInput
  }


  /**
   * ProductAviableSizes upsert
   */
  export type ProductAviableSizesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductAviableSizes
     */
    select?: ProductAviableSizesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductAviableSizesInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductAviableSizes to update in case it exists.
     */
    where: ProductAviableSizesWhereUniqueInput
    /**
     * In case the ProductAviableSizes found by the `where` argument doesn't exist, create a new ProductAviableSizes with this data.
     */
    create: XOR<ProductAviableSizesCreateInput, ProductAviableSizesUncheckedCreateInput>
    /**
     * In case the ProductAviableSizes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductAviableSizesUpdateInput, ProductAviableSizesUncheckedUpdateInput>
  }


  /**
   * ProductAviableSizes delete
   */
  export type ProductAviableSizesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductAviableSizes
     */
    select?: ProductAviableSizesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductAviableSizesInclude<ExtArgs> | null
    /**
     * Filter which ProductAviableSizes to delete.
     */
    where: ProductAviableSizesWhereUniqueInput
  }


  /**
   * ProductAviableSizes deleteMany
   */
  export type ProductAviableSizesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductAviableSizes to delete
     */
    where?: ProductAviableSizesWhereInput
  }


  /**
   * ProductAviableSizes.history
   */
  export type ProductAviableSizes$historyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuantityHistory
     */
    select?: QuantityHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuantityHistoryInclude<ExtArgs> | null
    where?: QuantityHistoryWhereInput
    orderBy?: Enumerable<QuantityHistoryOrderByWithRelationInput>
    cursor?: QuantityHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<QuantityHistoryScalarFieldEnum>
  }


  /**
   * ProductAviableSizes without action
   */
  export type ProductAviableSizesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductAviableSizes
     */
    select?: ProductAviableSizesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductAviableSizesInclude<ExtArgs> | null
  }



  /**
   * Model SeasonalDresses
   */


  export type AggregateSeasonalDresses = {
    _count: SeasonalDressesCountAggregateOutputType | null
    _avg: SeasonalDressesAvgAggregateOutputType | null
    _sum: SeasonalDressesSumAggregateOutputType | null
    _min: SeasonalDressesMinAggregateOutputType | null
    _max: SeasonalDressesMaxAggregateOutputType | null
  }

  export type SeasonalDressesAvgAggregateOutputType = {
    id: number | null
    productId: number | null
  }

  export type SeasonalDressesSumAggregateOutputType = {
    id: number | null
    productId: number | null
  }

  export type SeasonalDressesMinAggregateOutputType = {
    id: number | null
    seasonal: string | null
    productId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type SeasonalDressesMaxAggregateOutputType = {
    id: number | null
    seasonal: string | null
    productId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type SeasonalDressesCountAggregateOutputType = {
    id: number
    seasonal: number
    productId: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type SeasonalDressesAvgAggregateInputType = {
    id?: true
    productId?: true
  }

  export type SeasonalDressesSumAggregateInputType = {
    id?: true
    productId?: true
  }

  export type SeasonalDressesMinAggregateInputType = {
    id?: true
    seasonal?: true
    productId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type SeasonalDressesMaxAggregateInputType = {
    id?: true
    seasonal?: true
    productId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type SeasonalDressesCountAggregateInputType = {
    id?: true
    seasonal?: true
    productId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type SeasonalDressesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which SeasonalDresses to aggregate.
     */
    where?: SeasonalDressesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeasonalDresses to fetch.
     */
    orderBy?: Enumerable<SeasonalDressesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SeasonalDressesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeasonalDresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeasonalDresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SeasonalDresses
    **/
    _count?: true | SeasonalDressesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SeasonalDressesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SeasonalDressesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SeasonalDressesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SeasonalDressesMaxAggregateInputType
  }

  export type GetSeasonalDressesAggregateType<T extends SeasonalDressesAggregateArgs> = {
        [P in keyof T & keyof AggregateSeasonalDresses]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeasonalDresses[P]>
      : GetScalarType<T[P], AggregateSeasonalDresses[P]>
  }




  export type SeasonalDressesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: SeasonalDressesWhereInput
    orderBy?: Enumerable<SeasonalDressesOrderByWithAggregationInput>
    by: SeasonalDressesScalarFieldEnum[]
    having?: SeasonalDressesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SeasonalDressesCountAggregateInputType | true
    _avg?: SeasonalDressesAvgAggregateInputType
    _sum?: SeasonalDressesSumAggregateInputType
    _min?: SeasonalDressesMinAggregateInputType
    _max?: SeasonalDressesMaxAggregateInputType
  }


  export type SeasonalDressesGroupByOutputType = {
    id: number
    seasonal: string
    productId: number
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: SeasonalDressesCountAggregateOutputType | null
    _avg: SeasonalDressesAvgAggregateOutputType | null
    _sum: SeasonalDressesSumAggregateOutputType | null
    _min: SeasonalDressesMinAggregateOutputType | null
    _max: SeasonalDressesMaxAggregateOutputType | null
  }

  type GetSeasonalDressesGroupByPayload<T extends SeasonalDressesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<SeasonalDressesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SeasonalDressesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SeasonalDressesGroupByOutputType[P]>
            : GetScalarType<T[P], SeasonalDressesGroupByOutputType[P]>
        }
      >
    >


  export type SeasonalDressesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seasonal?: boolean
    productId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    product?: boolean | ProductArgs<ExtArgs>
  }, ExtArgs["result"]["seasonalDresses"]>

  export type SeasonalDressesSelectScalar = {
    id?: boolean
    seasonal?: boolean
    productId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type SeasonalDressesInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    product?: boolean | ProductArgs<ExtArgs>
  }


  type SeasonalDressesGetPayload<S extends boolean | null | undefined | SeasonalDressesArgs> = $Types.GetResult<SeasonalDressesPayload, S>

  type SeasonalDressesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<SeasonalDressesFindManyArgs, 'select' | 'include'> & {
      select?: SeasonalDressesCountAggregateInputType | true
    }

  export interface SeasonalDressesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SeasonalDresses'], meta: { name: 'SeasonalDresses' } }
    /**
     * Find zero or one SeasonalDresses that matches the filter.
     * @param {SeasonalDressesFindUniqueArgs} args - Arguments to find a SeasonalDresses
     * @example
     * // Get one SeasonalDresses
     * const seasonalDresses = await prisma.seasonalDresses.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SeasonalDressesFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SeasonalDressesFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SeasonalDresses'> extends True ? Prisma__SeasonalDressesClient<$Types.GetResult<SeasonalDressesPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__SeasonalDressesClient<$Types.GetResult<SeasonalDressesPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one SeasonalDresses that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SeasonalDressesFindUniqueOrThrowArgs} args - Arguments to find a SeasonalDresses
     * @example
     * // Get one SeasonalDresses
     * const seasonalDresses = await prisma.seasonalDresses.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SeasonalDressesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SeasonalDressesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SeasonalDressesClient<$Types.GetResult<SeasonalDressesPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first SeasonalDresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonalDressesFindFirstArgs} args - Arguments to find a SeasonalDresses
     * @example
     * // Get one SeasonalDresses
     * const seasonalDresses = await prisma.seasonalDresses.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SeasonalDressesFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SeasonalDressesFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SeasonalDresses'> extends True ? Prisma__SeasonalDressesClient<$Types.GetResult<SeasonalDressesPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__SeasonalDressesClient<$Types.GetResult<SeasonalDressesPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first SeasonalDresses that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonalDressesFindFirstOrThrowArgs} args - Arguments to find a SeasonalDresses
     * @example
     * // Get one SeasonalDresses
     * const seasonalDresses = await prisma.seasonalDresses.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SeasonalDressesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SeasonalDressesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SeasonalDressesClient<$Types.GetResult<SeasonalDressesPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more SeasonalDresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonalDressesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SeasonalDresses
     * const seasonalDresses = await prisma.seasonalDresses.findMany()
     * 
     * // Get first 10 SeasonalDresses
     * const seasonalDresses = await prisma.seasonalDresses.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const seasonalDressesWithIdOnly = await prisma.seasonalDresses.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SeasonalDressesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SeasonalDressesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<SeasonalDressesPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a SeasonalDresses.
     * @param {SeasonalDressesCreateArgs} args - Arguments to create a SeasonalDresses.
     * @example
     * // Create one SeasonalDresses
     * const SeasonalDresses = await prisma.seasonalDresses.create({
     *   data: {
     *     // ... data to create a SeasonalDresses
     *   }
     * })
     * 
    **/
    create<T extends SeasonalDressesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SeasonalDressesCreateArgs<ExtArgs>>
    ): Prisma__SeasonalDressesClient<$Types.GetResult<SeasonalDressesPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many SeasonalDresses.
     *     @param {SeasonalDressesCreateManyArgs} args - Arguments to create many SeasonalDresses.
     *     @example
     *     // Create many SeasonalDresses
     *     const seasonalDresses = await prisma.seasonalDresses.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SeasonalDressesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SeasonalDressesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SeasonalDresses.
     * @param {SeasonalDressesDeleteArgs} args - Arguments to delete one SeasonalDresses.
     * @example
     * // Delete one SeasonalDresses
     * const SeasonalDresses = await prisma.seasonalDresses.delete({
     *   where: {
     *     // ... filter to delete one SeasonalDresses
     *   }
     * })
     * 
    **/
    delete<T extends SeasonalDressesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SeasonalDressesDeleteArgs<ExtArgs>>
    ): Prisma__SeasonalDressesClient<$Types.GetResult<SeasonalDressesPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one SeasonalDresses.
     * @param {SeasonalDressesUpdateArgs} args - Arguments to update one SeasonalDresses.
     * @example
     * // Update one SeasonalDresses
     * const seasonalDresses = await prisma.seasonalDresses.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SeasonalDressesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SeasonalDressesUpdateArgs<ExtArgs>>
    ): Prisma__SeasonalDressesClient<$Types.GetResult<SeasonalDressesPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more SeasonalDresses.
     * @param {SeasonalDressesDeleteManyArgs} args - Arguments to filter SeasonalDresses to delete.
     * @example
     * // Delete a few SeasonalDresses
     * const { count } = await prisma.seasonalDresses.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SeasonalDressesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SeasonalDressesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SeasonalDresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonalDressesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SeasonalDresses
     * const seasonalDresses = await prisma.seasonalDresses.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SeasonalDressesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SeasonalDressesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SeasonalDresses.
     * @param {SeasonalDressesUpsertArgs} args - Arguments to update or create a SeasonalDresses.
     * @example
     * // Update or create a SeasonalDresses
     * const seasonalDresses = await prisma.seasonalDresses.upsert({
     *   create: {
     *     // ... data to create a SeasonalDresses
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SeasonalDresses we want to update
     *   }
     * })
    **/
    upsert<T extends SeasonalDressesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SeasonalDressesUpsertArgs<ExtArgs>>
    ): Prisma__SeasonalDressesClient<$Types.GetResult<SeasonalDressesPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of SeasonalDresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonalDressesCountArgs} args - Arguments to filter SeasonalDresses to count.
     * @example
     * // Count the number of SeasonalDresses
     * const count = await prisma.seasonalDresses.count({
     *   where: {
     *     // ... the filter for the SeasonalDresses we want to count
     *   }
     * })
    **/
    count<T extends SeasonalDressesCountArgs>(
      args?: Subset<T, SeasonalDressesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SeasonalDressesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SeasonalDresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonalDressesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SeasonalDressesAggregateArgs>(args: Subset<T, SeasonalDressesAggregateArgs>): Prisma.PrismaPromise<GetSeasonalDressesAggregateType<T>>

    /**
     * Group by SeasonalDresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonalDressesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SeasonalDressesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SeasonalDressesGroupByArgs['orderBy'] }
        : { orderBy?: SeasonalDressesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SeasonalDressesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeasonalDressesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for SeasonalDresses.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SeasonalDressesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    product<T extends ProductArgs<ExtArgs> = {}>(args?: Subset<T, ProductArgs<ExtArgs>>): Prisma__ProductClient<$Types.GetResult<ProductPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * SeasonalDresses base type for findUnique actions
   */
  export type SeasonalDressesFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeasonalDresses
     */
    select?: SeasonalDressesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SeasonalDressesInclude<ExtArgs> | null
    /**
     * Filter, which SeasonalDresses to fetch.
     */
    where: SeasonalDressesWhereUniqueInput
  }

  /**
   * SeasonalDresses findUnique
   */
  export interface SeasonalDressesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends SeasonalDressesFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SeasonalDresses findUniqueOrThrow
   */
  export type SeasonalDressesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeasonalDresses
     */
    select?: SeasonalDressesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SeasonalDressesInclude<ExtArgs> | null
    /**
     * Filter, which SeasonalDresses to fetch.
     */
    where: SeasonalDressesWhereUniqueInput
  }


  /**
   * SeasonalDresses base type for findFirst actions
   */
  export type SeasonalDressesFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeasonalDresses
     */
    select?: SeasonalDressesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SeasonalDressesInclude<ExtArgs> | null
    /**
     * Filter, which SeasonalDresses to fetch.
     */
    where?: SeasonalDressesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeasonalDresses to fetch.
     */
    orderBy?: Enumerable<SeasonalDressesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SeasonalDresses.
     */
    cursor?: SeasonalDressesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeasonalDresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeasonalDresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SeasonalDresses.
     */
    distinct?: Enumerable<SeasonalDressesScalarFieldEnum>
  }

  /**
   * SeasonalDresses findFirst
   */
  export interface SeasonalDressesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends SeasonalDressesFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SeasonalDresses findFirstOrThrow
   */
  export type SeasonalDressesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeasonalDresses
     */
    select?: SeasonalDressesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SeasonalDressesInclude<ExtArgs> | null
    /**
     * Filter, which SeasonalDresses to fetch.
     */
    where?: SeasonalDressesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeasonalDresses to fetch.
     */
    orderBy?: Enumerable<SeasonalDressesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SeasonalDresses.
     */
    cursor?: SeasonalDressesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeasonalDresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeasonalDresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SeasonalDresses.
     */
    distinct?: Enumerable<SeasonalDressesScalarFieldEnum>
  }


  /**
   * SeasonalDresses findMany
   */
  export type SeasonalDressesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeasonalDresses
     */
    select?: SeasonalDressesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SeasonalDressesInclude<ExtArgs> | null
    /**
     * Filter, which SeasonalDresses to fetch.
     */
    where?: SeasonalDressesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeasonalDresses to fetch.
     */
    orderBy?: Enumerable<SeasonalDressesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SeasonalDresses.
     */
    cursor?: SeasonalDressesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeasonalDresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeasonalDresses.
     */
    skip?: number
    distinct?: Enumerable<SeasonalDressesScalarFieldEnum>
  }


  /**
   * SeasonalDresses create
   */
  export type SeasonalDressesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeasonalDresses
     */
    select?: SeasonalDressesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SeasonalDressesInclude<ExtArgs> | null
    /**
     * The data needed to create a SeasonalDresses.
     */
    data: XOR<SeasonalDressesCreateInput, SeasonalDressesUncheckedCreateInput>
  }


  /**
   * SeasonalDresses createMany
   */
  export type SeasonalDressesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SeasonalDresses.
     */
    data: Enumerable<SeasonalDressesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SeasonalDresses update
   */
  export type SeasonalDressesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeasonalDresses
     */
    select?: SeasonalDressesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SeasonalDressesInclude<ExtArgs> | null
    /**
     * The data needed to update a SeasonalDresses.
     */
    data: XOR<SeasonalDressesUpdateInput, SeasonalDressesUncheckedUpdateInput>
    /**
     * Choose, which SeasonalDresses to update.
     */
    where: SeasonalDressesWhereUniqueInput
  }


  /**
   * SeasonalDresses updateMany
   */
  export type SeasonalDressesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SeasonalDresses.
     */
    data: XOR<SeasonalDressesUpdateManyMutationInput, SeasonalDressesUncheckedUpdateManyInput>
    /**
     * Filter which SeasonalDresses to update
     */
    where?: SeasonalDressesWhereInput
  }


  /**
   * SeasonalDresses upsert
   */
  export type SeasonalDressesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeasonalDresses
     */
    select?: SeasonalDressesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SeasonalDressesInclude<ExtArgs> | null
    /**
     * The filter to search for the SeasonalDresses to update in case it exists.
     */
    where: SeasonalDressesWhereUniqueInput
    /**
     * In case the SeasonalDresses found by the `where` argument doesn't exist, create a new SeasonalDresses with this data.
     */
    create: XOR<SeasonalDressesCreateInput, SeasonalDressesUncheckedCreateInput>
    /**
     * In case the SeasonalDresses was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SeasonalDressesUpdateInput, SeasonalDressesUncheckedUpdateInput>
  }


  /**
   * SeasonalDresses delete
   */
  export type SeasonalDressesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeasonalDresses
     */
    select?: SeasonalDressesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SeasonalDressesInclude<ExtArgs> | null
    /**
     * Filter which SeasonalDresses to delete.
     */
    where: SeasonalDressesWhereUniqueInput
  }


  /**
   * SeasonalDresses deleteMany
   */
  export type SeasonalDressesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which SeasonalDresses to delete
     */
    where?: SeasonalDressesWhereInput
  }


  /**
   * SeasonalDresses without action
   */
  export type SeasonalDressesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeasonalDresses
     */
    select?: SeasonalDressesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SeasonalDressesInclude<ExtArgs> | null
  }



  /**
   * Model ProductImages
   */


  export type AggregateProductImages = {
    _count: ProductImagesCountAggregateOutputType | null
    _avg: ProductImagesAvgAggregateOutputType | null
    _sum: ProductImagesSumAggregateOutputType | null
    _min: ProductImagesMinAggregateOutputType | null
    _max: ProductImagesMaxAggregateOutputType | null
  }

  export type ProductImagesAvgAggregateOutputType = {
    id: number | null
    productColorId: number | null
  }

  export type ProductImagesSumAggregateOutputType = {
    id: number | null
    productColorId: number | null
  }

  export type ProductImagesMinAggregateOutputType = {
    id: number | null
    imageUrl: string | null
    productColorId: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ProductImagesMaxAggregateOutputType = {
    id: number | null
    imageUrl: string | null
    productColorId: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ProductImagesCountAggregateOutputType = {
    id: number
    imageUrl: number
    productColorId: number
    isActive: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type ProductImagesAvgAggregateInputType = {
    id?: true
    productColorId?: true
  }

  export type ProductImagesSumAggregateInputType = {
    id?: true
    productColorId?: true
  }

  export type ProductImagesMinAggregateInputType = {
    id?: true
    imageUrl?: true
    productColorId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ProductImagesMaxAggregateInputType = {
    id?: true
    imageUrl?: true
    productColorId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ProductImagesCountAggregateInputType = {
    id?: true
    imageUrl?: true
    productColorId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type ProductImagesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductImages to aggregate.
     */
    where?: ProductImagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductImages to fetch.
     */
    orderBy?: Enumerable<ProductImagesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductImagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductImages
    **/
    _count?: true | ProductImagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductImagesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductImagesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductImagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductImagesMaxAggregateInputType
  }

  export type GetProductImagesAggregateType<T extends ProductImagesAggregateArgs> = {
        [P in keyof T & keyof AggregateProductImages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductImages[P]>
      : GetScalarType<T[P], AggregateProductImages[P]>
  }




  export type ProductImagesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ProductImagesWhereInput
    orderBy?: Enumerable<ProductImagesOrderByWithAggregationInput>
    by: ProductImagesScalarFieldEnum[]
    having?: ProductImagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductImagesCountAggregateInputType | true
    _avg?: ProductImagesAvgAggregateInputType
    _sum?: ProductImagesSumAggregateInputType
    _min?: ProductImagesMinAggregateInputType
    _max?: ProductImagesMaxAggregateInputType
  }


  export type ProductImagesGroupByOutputType = {
    id: number
    imageUrl: string
    productColorId: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: ProductImagesCountAggregateOutputType | null
    _avg: ProductImagesAvgAggregateOutputType | null
    _sum: ProductImagesSumAggregateOutputType | null
    _min: ProductImagesMinAggregateOutputType | null
    _max: ProductImagesMaxAggregateOutputType | null
  }

  type GetProductImagesGroupByPayload<T extends ProductImagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ProductImagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductImagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductImagesGroupByOutputType[P]>
            : GetScalarType<T[P], ProductImagesGroupByOutputType[P]>
        }
      >
    >


  export type ProductImagesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    imageUrl?: boolean
    productColorId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    productColor?: boolean | ProductColorArgs<ExtArgs>
  }, ExtArgs["result"]["productImages"]>

  export type ProductImagesSelectScalar = {
    id?: boolean
    imageUrl?: boolean
    productColorId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type ProductImagesInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    productColor?: boolean | ProductColorArgs<ExtArgs>
  }


  type ProductImagesGetPayload<S extends boolean | null | undefined | ProductImagesArgs> = $Types.GetResult<ProductImagesPayload, S>

  type ProductImagesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ProductImagesFindManyArgs, 'select' | 'include'> & {
      select?: ProductImagesCountAggregateInputType | true
    }

  export interface ProductImagesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductImages'], meta: { name: 'ProductImages' } }
    /**
     * Find zero or one ProductImages that matches the filter.
     * @param {ProductImagesFindUniqueArgs} args - Arguments to find a ProductImages
     * @example
     * // Get one ProductImages
     * const productImages = await prisma.productImages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductImagesFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductImagesFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ProductImages'> extends True ? Prisma__ProductImagesClient<$Types.GetResult<ProductImagesPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ProductImagesClient<$Types.GetResult<ProductImagesPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one ProductImages that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProductImagesFindUniqueOrThrowArgs} args - Arguments to find a ProductImages
     * @example
     * // Get one ProductImages
     * const productImages = await prisma.productImages.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProductImagesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductImagesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProductImagesClient<$Types.GetResult<ProductImagesPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first ProductImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImagesFindFirstArgs} args - Arguments to find a ProductImages
     * @example
     * // Get one ProductImages
     * const productImages = await prisma.productImages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductImagesFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductImagesFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ProductImages'> extends True ? Prisma__ProductImagesClient<$Types.GetResult<ProductImagesPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ProductImagesClient<$Types.GetResult<ProductImagesPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first ProductImages that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImagesFindFirstOrThrowArgs} args - Arguments to find a ProductImages
     * @example
     * // Get one ProductImages
     * const productImages = await prisma.productImages.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProductImagesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductImagesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProductImagesClient<$Types.GetResult<ProductImagesPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more ProductImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImagesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductImages
     * const productImages = await prisma.productImages.findMany()
     * 
     * // Get first 10 ProductImages
     * const productImages = await prisma.productImages.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productImagesWithIdOnly = await prisma.productImages.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductImagesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductImagesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ProductImagesPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a ProductImages.
     * @param {ProductImagesCreateArgs} args - Arguments to create a ProductImages.
     * @example
     * // Create one ProductImages
     * const ProductImages = await prisma.productImages.create({
     *   data: {
     *     // ... data to create a ProductImages
     *   }
     * })
     * 
    **/
    create<T extends ProductImagesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductImagesCreateArgs<ExtArgs>>
    ): Prisma__ProductImagesClient<$Types.GetResult<ProductImagesPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many ProductImages.
     *     @param {ProductImagesCreateManyArgs} args - Arguments to create many ProductImages.
     *     @example
     *     // Create many ProductImages
     *     const productImages = await prisma.productImages.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductImagesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductImagesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProductImages.
     * @param {ProductImagesDeleteArgs} args - Arguments to delete one ProductImages.
     * @example
     * // Delete one ProductImages
     * const ProductImages = await prisma.productImages.delete({
     *   where: {
     *     // ... filter to delete one ProductImages
     *   }
     * })
     * 
    **/
    delete<T extends ProductImagesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ProductImagesDeleteArgs<ExtArgs>>
    ): Prisma__ProductImagesClient<$Types.GetResult<ProductImagesPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one ProductImages.
     * @param {ProductImagesUpdateArgs} args - Arguments to update one ProductImages.
     * @example
     * // Update one ProductImages
     * const productImages = await prisma.productImages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductImagesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductImagesUpdateArgs<ExtArgs>>
    ): Prisma__ProductImagesClient<$Types.GetResult<ProductImagesPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more ProductImages.
     * @param {ProductImagesDeleteManyArgs} args - Arguments to filter ProductImages to delete.
     * @example
     * // Delete a few ProductImages
     * const { count } = await prisma.productImages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductImagesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductImagesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductImages
     * const productImages = await prisma.productImages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductImagesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ProductImagesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductImages.
     * @param {ProductImagesUpsertArgs} args - Arguments to update or create a ProductImages.
     * @example
     * // Update or create a ProductImages
     * const productImages = await prisma.productImages.upsert({
     *   create: {
     *     // ... data to create a ProductImages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductImages we want to update
     *   }
     * })
    **/
    upsert<T extends ProductImagesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ProductImagesUpsertArgs<ExtArgs>>
    ): Prisma__ProductImagesClient<$Types.GetResult<ProductImagesPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of ProductImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImagesCountArgs} args - Arguments to filter ProductImages to count.
     * @example
     * // Count the number of ProductImages
     * const count = await prisma.productImages.count({
     *   where: {
     *     // ... the filter for the ProductImages we want to count
     *   }
     * })
    **/
    count<T extends ProductImagesCountArgs>(
      args?: Subset<T, ProductImagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductImagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductImagesAggregateArgs>(args: Subset<T, ProductImagesAggregateArgs>): Prisma.PrismaPromise<GetProductImagesAggregateType<T>>

    /**
     * Group by ProductImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductImagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductImagesGroupByArgs['orderBy'] }
        : { orderBy?: ProductImagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductImagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductImagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductImages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductImagesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    productColor<T extends ProductColorArgs<ExtArgs> = {}>(args?: Subset<T, ProductColorArgs<ExtArgs>>): Prisma__ProductColorClient<$Types.GetResult<ProductColorPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ProductImages base type for findUnique actions
   */
  export type ProductImagesFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImages
     */
    select?: ProductImagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductImagesInclude<ExtArgs> | null
    /**
     * Filter, which ProductImages to fetch.
     */
    where: ProductImagesWhereUniqueInput
  }

  /**
   * ProductImages findUnique
   */
  export interface ProductImagesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ProductImagesFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProductImages findUniqueOrThrow
   */
  export type ProductImagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImages
     */
    select?: ProductImagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductImagesInclude<ExtArgs> | null
    /**
     * Filter, which ProductImages to fetch.
     */
    where: ProductImagesWhereUniqueInput
  }


  /**
   * ProductImages base type for findFirst actions
   */
  export type ProductImagesFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImages
     */
    select?: ProductImagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductImagesInclude<ExtArgs> | null
    /**
     * Filter, which ProductImages to fetch.
     */
    where?: ProductImagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductImages to fetch.
     */
    orderBy?: Enumerable<ProductImagesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductImages.
     */
    cursor?: ProductImagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductImages.
     */
    distinct?: Enumerable<ProductImagesScalarFieldEnum>
  }

  /**
   * ProductImages findFirst
   */
  export interface ProductImagesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ProductImagesFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProductImages findFirstOrThrow
   */
  export type ProductImagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImages
     */
    select?: ProductImagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductImagesInclude<ExtArgs> | null
    /**
     * Filter, which ProductImages to fetch.
     */
    where?: ProductImagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductImages to fetch.
     */
    orderBy?: Enumerable<ProductImagesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductImages.
     */
    cursor?: ProductImagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductImages.
     */
    distinct?: Enumerable<ProductImagesScalarFieldEnum>
  }


  /**
   * ProductImages findMany
   */
  export type ProductImagesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImages
     */
    select?: ProductImagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductImagesInclude<ExtArgs> | null
    /**
     * Filter, which ProductImages to fetch.
     */
    where?: ProductImagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductImages to fetch.
     */
    orderBy?: Enumerable<ProductImagesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductImages.
     */
    cursor?: ProductImagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductImages.
     */
    skip?: number
    distinct?: Enumerable<ProductImagesScalarFieldEnum>
  }


  /**
   * ProductImages create
   */
  export type ProductImagesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImages
     */
    select?: ProductImagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductImagesInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductImages.
     */
    data: XOR<ProductImagesCreateInput, ProductImagesUncheckedCreateInput>
  }


  /**
   * ProductImages createMany
   */
  export type ProductImagesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductImages.
     */
    data: Enumerable<ProductImagesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ProductImages update
   */
  export type ProductImagesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImages
     */
    select?: ProductImagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductImagesInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductImages.
     */
    data: XOR<ProductImagesUpdateInput, ProductImagesUncheckedUpdateInput>
    /**
     * Choose, which ProductImages to update.
     */
    where: ProductImagesWhereUniqueInput
  }


  /**
   * ProductImages updateMany
   */
  export type ProductImagesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductImages.
     */
    data: XOR<ProductImagesUpdateManyMutationInput, ProductImagesUncheckedUpdateManyInput>
    /**
     * Filter which ProductImages to update
     */
    where?: ProductImagesWhereInput
  }


  /**
   * ProductImages upsert
   */
  export type ProductImagesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImages
     */
    select?: ProductImagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductImagesInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductImages to update in case it exists.
     */
    where: ProductImagesWhereUniqueInput
    /**
     * In case the ProductImages found by the `where` argument doesn't exist, create a new ProductImages with this data.
     */
    create: XOR<ProductImagesCreateInput, ProductImagesUncheckedCreateInput>
    /**
     * In case the ProductImages was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductImagesUpdateInput, ProductImagesUncheckedUpdateInput>
  }


  /**
   * ProductImages delete
   */
  export type ProductImagesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImages
     */
    select?: ProductImagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductImagesInclude<ExtArgs> | null
    /**
     * Filter which ProductImages to delete.
     */
    where: ProductImagesWhereUniqueInput
  }


  /**
   * ProductImages deleteMany
   */
  export type ProductImagesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductImages to delete
     */
    where?: ProductImagesWhereInput
  }


  /**
   * ProductImages without action
   */
  export type ProductImagesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImages
     */
    select?: ProductImagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductImagesInclude<ExtArgs> | null
  }



  /**
   * Model CommonDescription
   */


  export type AggregateCommonDescription = {
    _count: CommonDescriptionCountAggregateOutputType | null
    _avg: CommonDescriptionAvgAggregateOutputType | null
    _sum: CommonDescriptionSumAggregateOutputType | null
    _min: CommonDescriptionMinAggregateOutputType | null
    _max: CommonDescriptionMaxAggregateOutputType | null
  }

  export type CommonDescriptionAvgAggregateOutputType = {
    id: number | null
    productId: number | null
  }

  export type CommonDescriptionSumAggregateOutputType = {
    id: number | null
    productId: number | null
  }

  export type CommonDescriptionMinAggregateOutputType = {
    id: number | null
    fit: string | null
    materail: string | null
    care: string | null
    brandName: string | null
    origin: string | null
    productId: number | null
    occasion: string | null
    specialFeature: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type CommonDescriptionMaxAggregateOutputType = {
    id: number | null
    fit: string | null
    materail: string | null
    care: string | null
    brandName: string | null
    origin: string | null
    productId: number | null
    occasion: string | null
    specialFeature: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type CommonDescriptionCountAggregateOutputType = {
    id: number
    fit: number
    materail: number
    care: number
    brandName: number
    origin: number
    productId: number
    occasion: number
    specialFeature: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type CommonDescriptionAvgAggregateInputType = {
    id?: true
    productId?: true
  }

  export type CommonDescriptionSumAggregateInputType = {
    id?: true
    productId?: true
  }

  export type CommonDescriptionMinAggregateInputType = {
    id?: true
    fit?: true
    materail?: true
    care?: true
    brandName?: true
    origin?: true
    productId?: true
    occasion?: true
    specialFeature?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type CommonDescriptionMaxAggregateInputType = {
    id?: true
    fit?: true
    materail?: true
    care?: true
    brandName?: true
    origin?: true
    productId?: true
    occasion?: true
    specialFeature?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type CommonDescriptionCountAggregateInputType = {
    id?: true
    fit?: true
    materail?: true
    care?: true
    brandName?: true
    origin?: true
    productId?: true
    occasion?: true
    specialFeature?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type CommonDescriptionAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommonDescription to aggregate.
     */
    where?: CommonDescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommonDescriptions to fetch.
     */
    orderBy?: Enumerable<CommonDescriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommonDescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommonDescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommonDescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommonDescriptions
    **/
    _count?: true | CommonDescriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommonDescriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommonDescriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommonDescriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommonDescriptionMaxAggregateInputType
  }

  export type GetCommonDescriptionAggregateType<T extends CommonDescriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateCommonDescription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommonDescription[P]>
      : GetScalarType<T[P], AggregateCommonDescription[P]>
  }




  export type CommonDescriptionGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CommonDescriptionWhereInput
    orderBy?: Enumerable<CommonDescriptionOrderByWithAggregationInput>
    by: CommonDescriptionScalarFieldEnum[]
    having?: CommonDescriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommonDescriptionCountAggregateInputType | true
    _avg?: CommonDescriptionAvgAggregateInputType
    _sum?: CommonDescriptionSumAggregateInputType
    _min?: CommonDescriptionMinAggregateInputType
    _max?: CommonDescriptionMaxAggregateInputType
  }


  export type CommonDescriptionGroupByOutputType = {
    id: number
    fit: string | null
    materail: string
    care: string
    brandName: string
    origin: string
    productId: number
    occasion: string
    specialFeature: string | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: CommonDescriptionCountAggregateOutputType | null
    _avg: CommonDescriptionAvgAggregateOutputType | null
    _sum: CommonDescriptionSumAggregateOutputType | null
    _min: CommonDescriptionMinAggregateOutputType | null
    _max: CommonDescriptionMaxAggregateOutputType | null
  }

  type GetCommonDescriptionGroupByPayload<T extends CommonDescriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CommonDescriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommonDescriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommonDescriptionGroupByOutputType[P]>
            : GetScalarType<T[P], CommonDescriptionGroupByOutputType[P]>
        }
      >
    >


  export type CommonDescriptionSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fit?: boolean
    materail?: boolean
    care?: boolean
    brandName?: boolean
    origin?: boolean
    productId?: boolean
    occasion?: boolean
    specialFeature?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    product?: boolean | ProductArgs<ExtArgs>
    topDescription?: boolean | CommonDescription$topDescriptionArgs<ExtArgs>
    pantDescription?: boolean | CommonDescription$pantDescriptionArgs<ExtArgs>
    kurtasDescription?: boolean | CommonDescription$kurtasDescriptionArgs<ExtArgs>
    shoesDescription?: boolean | CommonDescription$shoesDescriptionArgs<ExtArgs>
    innerDescription?: boolean | CommonDescription$innerDescriptionArgs<ExtArgs>
    watchesDescription?: boolean | CommonDescription$watchesDescriptionArgs<ExtArgs>
    perfumesDescription?: boolean | CommonDescription$perfumesDescriptionArgs<ExtArgs>
    _count?: boolean | CommonDescriptionCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["commonDescription"]>

  export type CommonDescriptionSelectScalar = {
    id?: boolean
    fit?: boolean
    materail?: boolean
    care?: boolean
    brandName?: boolean
    origin?: boolean
    productId?: boolean
    occasion?: boolean
    specialFeature?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type CommonDescriptionInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    product?: boolean | ProductArgs<ExtArgs>
    topDescription?: boolean | CommonDescription$topDescriptionArgs<ExtArgs>
    pantDescription?: boolean | CommonDescription$pantDescriptionArgs<ExtArgs>
    kurtasDescription?: boolean | CommonDescription$kurtasDescriptionArgs<ExtArgs>
    shoesDescription?: boolean | CommonDescription$shoesDescriptionArgs<ExtArgs>
    innerDescription?: boolean | CommonDescription$innerDescriptionArgs<ExtArgs>
    watchesDescription?: boolean | CommonDescription$watchesDescriptionArgs<ExtArgs>
    perfumesDescription?: boolean | CommonDescription$perfumesDescriptionArgs<ExtArgs>
    _count?: boolean | CommonDescriptionCountOutputTypeArgs<ExtArgs>
  }


  type CommonDescriptionGetPayload<S extends boolean | null | undefined | CommonDescriptionArgs> = $Types.GetResult<CommonDescriptionPayload, S>

  type CommonDescriptionCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<CommonDescriptionFindManyArgs, 'select' | 'include'> & {
      select?: CommonDescriptionCountAggregateInputType | true
    }

  export interface CommonDescriptionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CommonDescription'], meta: { name: 'CommonDescription' } }
    /**
     * Find zero or one CommonDescription that matches the filter.
     * @param {CommonDescriptionFindUniqueArgs} args - Arguments to find a CommonDescription
     * @example
     * // Get one CommonDescription
     * const commonDescription = await prisma.commonDescription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CommonDescriptionFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CommonDescriptionFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CommonDescription'> extends True ? Prisma__CommonDescriptionClient<$Types.GetResult<CommonDescriptionPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__CommonDescriptionClient<$Types.GetResult<CommonDescriptionPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one CommonDescription that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CommonDescriptionFindUniqueOrThrowArgs} args - Arguments to find a CommonDescription
     * @example
     * // Get one CommonDescription
     * const commonDescription = await prisma.commonDescription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CommonDescriptionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CommonDescriptionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CommonDescriptionClient<$Types.GetResult<CommonDescriptionPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first CommonDescription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommonDescriptionFindFirstArgs} args - Arguments to find a CommonDescription
     * @example
     * // Get one CommonDescription
     * const commonDescription = await prisma.commonDescription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CommonDescriptionFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CommonDescriptionFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CommonDescription'> extends True ? Prisma__CommonDescriptionClient<$Types.GetResult<CommonDescriptionPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__CommonDescriptionClient<$Types.GetResult<CommonDescriptionPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first CommonDescription that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommonDescriptionFindFirstOrThrowArgs} args - Arguments to find a CommonDescription
     * @example
     * // Get one CommonDescription
     * const commonDescription = await prisma.commonDescription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CommonDescriptionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CommonDescriptionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CommonDescriptionClient<$Types.GetResult<CommonDescriptionPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more CommonDescriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommonDescriptionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommonDescriptions
     * const commonDescriptions = await prisma.commonDescription.findMany()
     * 
     * // Get first 10 CommonDescriptions
     * const commonDescriptions = await prisma.commonDescription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commonDescriptionWithIdOnly = await prisma.commonDescription.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CommonDescriptionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommonDescriptionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<CommonDescriptionPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a CommonDescription.
     * @param {CommonDescriptionCreateArgs} args - Arguments to create a CommonDescription.
     * @example
     * // Create one CommonDescription
     * const CommonDescription = await prisma.commonDescription.create({
     *   data: {
     *     // ... data to create a CommonDescription
     *   }
     * })
     * 
    **/
    create<T extends CommonDescriptionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CommonDescriptionCreateArgs<ExtArgs>>
    ): Prisma__CommonDescriptionClient<$Types.GetResult<CommonDescriptionPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many CommonDescriptions.
     *     @param {CommonDescriptionCreateManyArgs} args - Arguments to create many CommonDescriptions.
     *     @example
     *     // Create many CommonDescriptions
     *     const commonDescription = await prisma.commonDescription.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CommonDescriptionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommonDescriptionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CommonDescription.
     * @param {CommonDescriptionDeleteArgs} args - Arguments to delete one CommonDescription.
     * @example
     * // Delete one CommonDescription
     * const CommonDescription = await prisma.commonDescription.delete({
     *   where: {
     *     // ... filter to delete one CommonDescription
     *   }
     * })
     * 
    **/
    delete<T extends CommonDescriptionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CommonDescriptionDeleteArgs<ExtArgs>>
    ): Prisma__CommonDescriptionClient<$Types.GetResult<CommonDescriptionPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one CommonDescription.
     * @param {CommonDescriptionUpdateArgs} args - Arguments to update one CommonDescription.
     * @example
     * // Update one CommonDescription
     * const commonDescription = await prisma.commonDescription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CommonDescriptionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CommonDescriptionUpdateArgs<ExtArgs>>
    ): Prisma__CommonDescriptionClient<$Types.GetResult<CommonDescriptionPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more CommonDescriptions.
     * @param {CommonDescriptionDeleteManyArgs} args - Arguments to filter CommonDescriptions to delete.
     * @example
     * // Delete a few CommonDescriptions
     * const { count } = await prisma.commonDescription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CommonDescriptionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommonDescriptionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommonDescriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommonDescriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommonDescriptions
     * const commonDescription = await prisma.commonDescription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CommonDescriptionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CommonDescriptionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CommonDescription.
     * @param {CommonDescriptionUpsertArgs} args - Arguments to update or create a CommonDescription.
     * @example
     * // Update or create a CommonDescription
     * const commonDescription = await prisma.commonDescription.upsert({
     *   create: {
     *     // ... data to create a CommonDescription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommonDescription we want to update
     *   }
     * })
    **/
    upsert<T extends CommonDescriptionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CommonDescriptionUpsertArgs<ExtArgs>>
    ): Prisma__CommonDescriptionClient<$Types.GetResult<CommonDescriptionPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of CommonDescriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommonDescriptionCountArgs} args - Arguments to filter CommonDescriptions to count.
     * @example
     * // Count the number of CommonDescriptions
     * const count = await prisma.commonDescription.count({
     *   where: {
     *     // ... the filter for the CommonDescriptions we want to count
     *   }
     * })
    **/
    count<T extends CommonDescriptionCountArgs>(
      args?: Subset<T, CommonDescriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommonDescriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommonDescription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommonDescriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommonDescriptionAggregateArgs>(args: Subset<T, CommonDescriptionAggregateArgs>): Prisma.PrismaPromise<GetCommonDescriptionAggregateType<T>>

    /**
     * Group by CommonDescription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommonDescriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommonDescriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommonDescriptionGroupByArgs['orderBy'] }
        : { orderBy?: CommonDescriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommonDescriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommonDescriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for CommonDescription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CommonDescriptionClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    product<T extends ProductArgs<ExtArgs> = {}>(args?: Subset<T, ProductArgs<ExtArgs>>): Prisma__ProductClient<$Types.GetResult<ProductPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    topDescription<T extends CommonDescription$topDescriptionArgs<ExtArgs> = {}>(args?: Subset<T, CommonDescription$topDescriptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<TopDescriptionPayload<ExtArgs>, T, 'findMany', never>| Null>;

    pantDescription<T extends CommonDescription$pantDescriptionArgs<ExtArgs> = {}>(args?: Subset<T, CommonDescription$pantDescriptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<BottomDescriptionPayload<ExtArgs>, T, 'findMany', never>| Null>;

    kurtasDescription<T extends CommonDescription$kurtasDescriptionArgs<ExtArgs> = {}>(args?: Subset<T, CommonDescription$kurtasDescriptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<KurtasDescriptionPayload<ExtArgs>, T, 'findMany', never>| Null>;

    shoesDescription<T extends CommonDescription$shoesDescriptionArgs<ExtArgs> = {}>(args?: Subset<T, CommonDescription$shoesDescriptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ShoesDescriptionPayload<ExtArgs>, T, 'findMany', never>| Null>;

    innerDescription<T extends CommonDescription$innerDescriptionArgs<ExtArgs> = {}>(args?: Subset<T, CommonDescription$innerDescriptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<InnersDescriptionPayload<ExtArgs>, T, 'findMany', never>| Null>;

    watchesDescription<T extends CommonDescription$watchesDescriptionArgs<ExtArgs> = {}>(args?: Subset<T, CommonDescription$watchesDescriptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<WatchesDescriptionPayload<ExtArgs>, T, 'findMany', never>| Null>;

    perfumesDescription<T extends CommonDescription$perfumesDescriptionArgs<ExtArgs> = {}>(args?: Subset<T, CommonDescription$perfumesDescriptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<PerfumesDescriptionPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * CommonDescription base type for findUnique actions
   */
  export type CommonDescriptionFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommonDescription
     */
    select?: CommonDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommonDescriptionInclude<ExtArgs> | null
    /**
     * Filter, which CommonDescription to fetch.
     */
    where: CommonDescriptionWhereUniqueInput
  }

  /**
   * CommonDescription findUnique
   */
  export interface CommonDescriptionFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends CommonDescriptionFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CommonDescription findUniqueOrThrow
   */
  export type CommonDescriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommonDescription
     */
    select?: CommonDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommonDescriptionInclude<ExtArgs> | null
    /**
     * Filter, which CommonDescription to fetch.
     */
    where: CommonDescriptionWhereUniqueInput
  }


  /**
   * CommonDescription base type for findFirst actions
   */
  export type CommonDescriptionFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommonDescription
     */
    select?: CommonDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommonDescriptionInclude<ExtArgs> | null
    /**
     * Filter, which CommonDescription to fetch.
     */
    where?: CommonDescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommonDescriptions to fetch.
     */
    orderBy?: Enumerable<CommonDescriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommonDescriptions.
     */
    cursor?: CommonDescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommonDescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommonDescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommonDescriptions.
     */
    distinct?: Enumerable<CommonDescriptionScalarFieldEnum>
  }

  /**
   * CommonDescription findFirst
   */
  export interface CommonDescriptionFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends CommonDescriptionFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CommonDescription findFirstOrThrow
   */
  export type CommonDescriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommonDescription
     */
    select?: CommonDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommonDescriptionInclude<ExtArgs> | null
    /**
     * Filter, which CommonDescription to fetch.
     */
    where?: CommonDescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommonDescriptions to fetch.
     */
    orderBy?: Enumerable<CommonDescriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommonDescriptions.
     */
    cursor?: CommonDescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommonDescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommonDescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommonDescriptions.
     */
    distinct?: Enumerable<CommonDescriptionScalarFieldEnum>
  }


  /**
   * CommonDescription findMany
   */
  export type CommonDescriptionFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommonDescription
     */
    select?: CommonDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommonDescriptionInclude<ExtArgs> | null
    /**
     * Filter, which CommonDescriptions to fetch.
     */
    where?: CommonDescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommonDescriptions to fetch.
     */
    orderBy?: Enumerable<CommonDescriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommonDescriptions.
     */
    cursor?: CommonDescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommonDescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommonDescriptions.
     */
    skip?: number
    distinct?: Enumerable<CommonDescriptionScalarFieldEnum>
  }


  /**
   * CommonDescription create
   */
  export type CommonDescriptionCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommonDescription
     */
    select?: CommonDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommonDescriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a CommonDescription.
     */
    data: XOR<CommonDescriptionCreateInput, CommonDescriptionUncheckedCreateInput>
  }


  /**
   * CommonDescription createMany
   */
  export type CommonDescriptionCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CommonDescriptions.
     */
    data: Enumerable<CommonDescriptionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CommonDescription update
   */
  export type CommonDescriptionUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommonDescription
     */
    select?: CommonDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommonDescriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a CommonDescription.
     */
    data: XOR<CommonDescriptionUpdateInput, CommonDescriptionUncheckedUpdateInput>
    /**
     * Choose, which CommonDescription to update.
     */
    where: CommonDescriptionWhereUniqueInput
  }


  /**
   * CommonDescription updateMany
   */
  export type CommonDescriptionUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CommonDescriptions.
     */
    data: XOR<CommonDescriptionUpdateManyMutationInput, CommonDescriptionUncheckedUpdateManyInput>
    /**
     * Filter which CommonDescriptions to update
     */
    where?: CommonDescriptionWhereInput
  }


  /**
   * CommonDescription upsert
   */
  export type CommonDescriptionUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommonDescription
     */
    select?: CommonDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommonDescriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the CommonDescription to update in case it exists.
     */
    where: CommonDescriptionWhereUniqueInput
    /**
     * In case the CommonDescription found by the `where` argument doesn't exist, create a new CommonDescription with this data.
     */
    create: XOR<CommonDescriptionCreateInput, CommonDescriptionUncheckedCreateInput>
    /**
     * In case the CommonDescription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommonDescriptionUpdateInput, CommonDescriptionUncheckedUpdateInput>
  }


  /**
   * CommonDescription delete
   */
  export type CommonDescriptionDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommonDescription
     */
    select?: CommonDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommonDescriptionInclude<ExtArgs> | null
    /**
     * Filter which CommonDescription to delete.
     */
    where: CommonDescriptionWhereUniqueInput
  }


  /**
   * CommonDescription deleteMany
   */
  export type CommonDescriptionDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommonDescriptions to delete
     */
    where?: CommonDescriptionWhereInput
  }


  /**
   * CommonDescription.topDescription
   */
  export type CommonDescription$topDescriptionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopDescription
     */
    select?: TopDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TopDescriptionInclude<ExtArgs> | null
    where?: TopDescriptionWhereInput
    orderBy?: Enumerable<TopDescriptionOrderByWithRelationInput>
    cursor?: TopDescriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TopDescriptionScalarFieldEnum>
  }


  /**
   * CommonDescription.pantDescription
   */
  export type CommonDescription$pantDescriptionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BottomDescription
     */
    select?: BottomDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BottomDescriptionInclude<ExtArgs> | null
    where?: BottomDescriptionWhereInput
    orderBy?: Enumerable<BottomDescriptionOrderByWithRelationInput>
    cursor?: BottomDescriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BottomDescriptionScalarFieldEnum>
  }


  /**
   * CommonDescription.kurtasDescription
   */
  export type CommonDescription$kurtasDescriptionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KurtasDescription
     */
    select?: KurtasDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KurtasDescriptionInclude<ExtArgs> | null
    where?: KurtasDescriptionWhereInput
    orderBy?: Enumerable<KurtasDescriptionOrderByWithRelationInput>
    cursor?: KurtasDescriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<KurtasDescriptionScalarFieldEnum>
  }


  /**
   * CommonDescription.shoesDescription
   */
  export type CommonDescription$shoesDescriptionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShoesDescription
     */
    select?: ShoesDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShoesDescriptionInclude<ExtArgs> | null
    where?: ShoesDescriptionWhereInput
    orderBy?: Enumerable<ShoesDescriptionOrderByWithRelationInput>
    cursor?: ShoesDescriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ShoesDescriptionScalarFieldEnum>
  }


  /**
   * CommonDescription.innerDescription
   */
  export type CommonDescription$innerDescriptionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InnersDescription
     */
    select?: InnersDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InnersDescriptionInclude<ExtArgs> | null
    where?: InnersDescriptionWhereInput
    orderBy?: Enumerable<InnersDescriptionOrderByWithRelationInput>
    cursor?: InnersDescriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<InnersDescriptionScalarFieldEnum>
  }


  /**
   * CommonDescription.watchesDescription
   */
  export type CommonDescription$watchesDescriptionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchesDescription
     */
    select?: WatchesDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WatchesDescriptionInclude<ExtArgs> | null
    where?: WatchesDescriptionWhereInput
    orderBy?: Enumerable<WatchesDescriptionOrderByWithRelationInput>
    cursor?: WatchesDescriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<WatchesDescriptionScalarFieldEnum>
  }


  /**
   * CommonDescription.perfumesDescription
   */
  export type CommonDescription$perfumesDescriptionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerfumesDescription
     */
    select?: PerfumesDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PerfumesDescriptionInclude<ExtArgs> | null
    where?: PerfumesDescriptionWhereInput
    orderBy?: Enumerable<PerfumesDescriptionOrderByWithRelationInput>
    cursor?: PerfumesDescriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PerfumesDescriptionScalarFieldEnum>
  }


  /**
   * CommonDescription without action
   */
  export type CommonDescriptionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommonDescription
     */
    select?: CommonDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommonDescriptionInclude<ExtArgs> | null
  }



  /**
   * Model TopDescription
   */


  export type AggregateTopDescription = {
    _count: TopDescriptionCountAggregateOutputType | null
    _avg: TopDescriptionAvgAggregateOutputType | null
    _sum: TopDescriptionSumAggregateOutputType | null
    _min: TopDescriptionMinAggregateOutputType | null
    _max: TopDescriptionMaxAggregateOutputType | null
  }

  export type TopDescriptionAvgAggregateOutputType = {
    id: number | null
    sleeveTypeId: number | null
    weight: number | null
    chest: number | null
    shoulder: number | null
    neckTypeId: number | null
    length: number | null
    commonDescriptionId: number | null
  }

  export type TopDescriptionSumAggregateOutputType = {
    id: number | null
    sleeveTypeId: number | null
    weight: number | null
    chest: number | null
    shoulder: number | null
    neckTypeId: number | null
    length: number | null
    commonDescriptionId: number | null
  }

  export type TopDescriptionMinAggregateOutputType = {
    id: number | null
    productDescription: string | null
    sleeveTypeId: number | null
    weight: number | null
    chest: number | null
    shoulder: number | null
    neckTypeId: number | null
    type: string | null
    colorFamily: string | null
    printAndPattern: string | null
    length: number | null
    pocket: string | null
    commonDescriptionId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type TopDescriptionMaxAggregateOutputType = {
    id: number | null
    productDescription: string | null
    sleeveTypeId: number | null
    weight: number | null
    chest: number | null
    shoulder: number | null
    neckTypeId: number | null
    type: string | null
    colorFamily: string | null
    printAndPattern: string | null
    length: number | null
    pocket: string | null
    commonDescriptionId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type TopDescriptionCountAggregateOutputType = {
    id: number
    productDescription: number
    sleeveTypeId: number
    weight: number
    chest: number
    shoulder: number
    neckTypeId: number
    type: number
    colorFamily: number
    printAndPattern: number
    length: number
    pocket: number
    commonDescriptionId: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type TopDescriptionAvgAggregateInputType = {
    id?: true
    sleeveTypeId?: true
    weight?: true
    chest?: true
    shoulder?: true
    neckTypeId?: true
    length?: true
    commonDescriptionId?: true
  }

  export type TopDescriptionSumAggregateInputType = {
    id?: true
    sleeveTypeId?: true
    weight?: true
    chest?: true
    shoulder?: true
    neckTypeId?: true
    length?: true
    commonDescriptionId?: true
  }

  export type TopDescriptionMinAggregateInputType = {
    id?: true
    productDescription?: true
    sleeveTypeId?: true
    weight?: true
    chest?: true
    shoulder?: true
    neckTypeId?: true
    type?: true
    colorFamily?: true
    printAndPattern?: true
    length?: true
    pocket?: true
    commonDescriptionId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type TopDescriptionMaxAggregateInputType = {
    id?: true
    productDescription?: true
    sleeveTypeId?: true
    weight?: true
    chest?: true
    shoulder?: true
    neckTypeId?: true
    type?: true
    colorFamily?: true
    printAndPattern?: true
    length?: true
    pocket?: true
    commonDescriptionId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type TopDescriptionCountAggregateInputType = {
    id?: true
    productDescription?: true
    sleeveTypeId?: true
    weight?: true
    chest?: true
    shoulder?: true
    neckTypeId?: true
    type?: true
    colorFamily?: true
    printAndPattern?: true
    length?: true
    pocket?: true
    commonDescriptionId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type TopDescriptionAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which TopDescription to aggregate.
     */
    where?: TopDescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TopDescriptions to fetch.
     */
    orderBy?: Enumerable<TopDescriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TopDescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TopDescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TopDescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TopDescriptions
    **/
    _count?: true | TopDescriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TopDescriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TopDescriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TopDescriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TopDescriptionMaxAggregateInputType
  }

  export type GetTopDescriptionAggregateType<T extends TopDescriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateTopDescription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTopDescription[P]>
      : GetScalarType<T[P], AggregateTopDescription[P]>
  }




  export type TopDescriptionGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: TopDescriptionWhereInput
    orderBy?: Enumerable<TopDescriptionOrderByWithAggregationInput>
    by: TopDescriptionScalarFieldEnum[]
    having?: TopDescriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TopDescriptionCountAggregateInputType | true
    _avg?: TopDescriptionAvgAggregateInputType
    _sum?: TopDescriptionSumAggregateInputType
    _min?: TopDescriptionMinAggregateInputType
    _max?: TopDescriptionMaxAggregateInputType
  }


  export type TopDescriptionGroupByOutputType = {
    id: number
    productDescription: string | null
    sleeveTypeId: number
    weight: number | null
    chest: number
    shoulder: number
    neckTypeId: number
    type: string | null
    colorFamily: string | null
    printAndPattern: string | null
    length: number
    pocket: string
    commonDescriptionId: number
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: TopDescriptionCountAggregateOutputType | null
    _avg: TopDescriptionAvgAggregateOutputType | null
    _sum: TopDescriptionSumAggregateOutputType | null
    _min: TopDescriptionMinAggregateOutputType | null
    _max: TopDescriptionMaxAggregateOutputType | null
  }

  type GetTopDescriptionGroupByPayload<T extends TopDescriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TopDescriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TopDescriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TopDescriptionGroupByOutputType[P]>
            : GetScalarType<T[P], TopDescriptionGroupByOutputType[P]>
        }
      >
    >


  export type TopDescriptionSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productDescription?: boolean
    sleeveTypeId?: boolean
    weight?: boolean
    chest?: boolean
    shoulder?: boolean
    neckTypeId?: boolean
    type?: boolean
    colorFamily?: boolean
    printAndPattern?: boolean
    length?: boolean
    pocket?: boolean
    commonDescriptionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    commonDescription?: boolean | CommonDescriptionArgs<ExtArgs>
    sleeveType?: boolean | SleeveTypeArgs<ExtArgs>
    neckType?: boolean | NeckTypeArgs<ExtArgs>
    bottomDescription?: boolean | TopDescription$bottomDescriptionArgs<ExtArgs>
    _count?: boolean | TopDescriptionCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["topDescription"]>

  export type TopDescriptionSelectScalar = {
    id?: boolean
    productDescription?: boolean
    sleeveTypeId?: boolean
    weight?: boolean
    chest?: boolean
    shoulder?: boolean
    neckTypeId?: boolean
    type?: boolean
    colorFamily?: boolean
    printAndPattern?: boolean
    length?: boolean
    pocket?: boolean
    commonDescriptionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type TopDescriptionInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    commonDescription?: boolean | CommonDescriptionArgs<ExtArgs>
    sleeveType?: boolean | SleeveTypeArgs<ExtArgs>
    neckType?: boolean | NeckTypeArgs<ExtArgs>
    bottomDescription?: boolean | TopDescription$bottomDescriptionArgs<ExtArgs>
    _count?: boolean | TopDescriptionCountOutputTypeArgs<ExtArgs>
  }


  type TopDescriptionGetPayload<S extends boolean | null | undefined | TopDescriptionArgs> = $Types.GetResult<TopDescriptionPayload, S>

  type TopDescriptionCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<TopDescriptionFindManyArgs, 'select' | 'include'> & {
      select?: TopDescriptionCountAggregateInputType | true
    }

  export interface TopDescriptionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TopDescription'], meta: { name: 'TopDescription' } }
    /**
     * Find zero or one TopDescription that matches the filter.
     * @param {TopDescriptionFindUniqueArgs} args - Arguments to find a TopDescription
     * @example
     * // Get one TopDescription
     * const topDescription = await prisma.topDescription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TopDescriptionFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TopDescriptionFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TopDescription'> extends True ? Prisma__TopDescriptionClient<$Types.GetResult<TopDescriptionPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__TopDescriptionClient<$Types.GetResult<TopDescriptionPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one TopDescription that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TopDescriptionFindUniqueOrThrowArgs} args - Arguments to find a TopDescription
     * @example
     * // Get one TopDescription
     * const topDescription = await prisma.topDescription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TopDescriptionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TopDescriptionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TopDescriptionClient<$Types.GetResult<TopDescriptionPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first TopDescription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopDescriptionFindFirstArgs} args - Arguments to find a TopDescription
     * @example
     * // Get one TopDescription
     * const topDescription = await prisma.topDescription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TopDescriptionFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TopDescriptionFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TopDescription'> extends True ? Prisma__TopDescriptionClient<$Types.GetResult<TopDescriptionPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__TopDescriptionClient<$Types.GetResult<TopDescriptionPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first TopDescription that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopDescriptionFindFirstOrThrowArgs} args - Arguments to find a TopDescription
     * @example
     * // Get one TopDescription
     * const topDescription = await prisma.topDescription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TopDescriptionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TopDescriptionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TopDescriptionClient<$Types.GetResult<TopDescriptionPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more TopDescriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopDescriptionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TopDescriptions
     * const topDescriptions = await prisma.topDescription.findMany()
     * 
     * // Get first 10 TopDescriptions
     * const topDescriptions = await prisma.topDescription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const topDescriptionWithIdOnly = await prisma.topDescription.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TopDescriptionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TopDescriptionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<TopDescriptionPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a TopDescription.
     * @param {TopDescriptionCreateArgs} args - Arguments to create a TopDescription.
     * @example
     * // Create one TopDescription
     * const TopDescription = await prisma.topDescription.create({
     *   data: {
     *     // ... data to create a TopDescription
     *   }
     * })
     * 
    **/
    create<T extends TopDescriptionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TopDescriptionCreateArgs<ExtArgs>>
    ): Prisma__TopDescriptionClient<$Types.GetResult<TopDescriptionPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many TopDescriptions.
     *     @param {TopDescriptionCreateManyArgs} args - Arguments to create many TopDescriptions.
     *     @example
     *     // Create many TopDescriptions
     *     const topDescription = await prisma.topDescription.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TopDescriptionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TopDescriptionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TopDescription.
     * @param {TopDescriptionDeleteArgs} args - Arguments to delete one TopDescription.
     * @example
     * // Delete one TopDescription
     * const TopDescription = await prisma.topDescription.delete({
     *   where: {
     *     // ... filter to delete one TopDescription
     *   }
     * })
     * 
    **/
    delete<T extends TopDescriptionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TopDescriptionDeleteArgs<ExtArgs>>
    ): Prisma__TopDescriptionClient<$Types.GetResult<TopDescriptionPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one TopDescription.
     * @param {TopDescriptionUpdateArgs} args - Arguments to update one TopDescription.
     * @example
     * // Update one TopDescription
     * const topDescription = await prisma.topDescription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TopDescriptionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TopDescriptionUpdateArgs<ExtArgs>>
    ): Prisma__TopDescriptionClient<$Types.GetResult<TopDescriptionPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more TopDescriptions.
     * @param {TopDescriptionDeleteManyArgs} args - Arguments to filter TopDescriptions to delete.
     * @example
     * // Delete a few TopDescriptions
     * const { count } = await prisma.topDescription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TopDescriptionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TopDescriptionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TopDescriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopDescriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TopDescriptions
     * const topDescription = await prisma.topDescription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TopDescriptionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TopDescriptionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TopDescription.
     * @param {TopDescriptionUpsertArgs} args - Arguments to update or create a TopDescription.
     * @example
     * // Update or create a TopDescription
     * const topDescription = await prisma.topDescription.upsert({
     *   create: {
     *     // ... data to create a TopDescription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TopDescription we want to update
     *   }
     * })
    **/
    upsert<T extends TopDescriptionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TopDescriptionUpsertArgs<ExtArgs>>
    ): Prisma__TopDescriptionClient<$Types.GetResult<TopDescriptionPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of TopDescriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopDescriptionCountArgs} args - Arguments to filter TopDescriptions to count.
     * @example
     * // Count the number of TopDescriptions
     * const count = await prisma.topDescription.count({
     *   where: {
     *     // ... the filter for the TopDescriptions we want to count
     *   }
     * })
    **/
    count<T extends TopDescriptionCountArgs>(
      args?: Subset<T, TopDescriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TopDescriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TopDescription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopDescriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TopDescriptionAggregateArgs>(args: Subset<T, TopDescriptionAggregateArgs>): Prisma.PrismaPromise<GetTopDescriptionAggregateType<T>>

    /**
     * Group by TopDescription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopDescriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TopDescriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TopDescriptionGroupByArgs['orderBy'] }
        : { orderBy?: TopDescriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TopDescriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTopDescriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TopDescription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TopDescriptionClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    commonDescription<T extends CommonDescriptionArgs<ExtArgs> = {}>(args?: Subset<T, CommonDescriptionArgs<ExtArgs>>): Prisma__CommonDescriptionClient<$Types.GetResult<CommonDescriptionPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    sleeveType<T extends SleeveTypeArgs<ExtArgs> = {}>(args?: Subset<T, SleeveTypeArgs<ExtArgs>>): Prisma__SleeveTypeClient<$Types.GetResult<SleeveTypePayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    neckType<T extends NeckTypeArgs<ExtArgs> = {}>(args?: Subset<T, NeckTypeArgs<ExtArgs>>): Prisma__NeckTypeClient<$Types.GetResult<NeckTypePayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    bottomDescription<T extends TopDescription$bottomDescriptionArgs<ExtArgs> = {}>(args?: Subset<T, TopDescription$bottomDescriptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<BottomDescriptionPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TopDescription base type for findUnique actions
   */
  export type TopDescriptionFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopDescription
     */
    select?: TopDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TopDescriptionInclude<ExtArgs> | null
    /**
     * Filter, which TopDescription to fetch.
     */
    where: TopDescriptionWhereUniqueInput
  }

  /**
   * TopDescription findUnique
   */
  export interface TopDescriptionFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends TopDescriptionFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TopDescription findUniqueOrThrow
   */
  export type TopDescriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopDescription
     */
    select?: TopDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TopDescriptionInclude<ExtArgs> | null
    /**
     * Filter, which TopDescription to fetch.
     */
    where: TopDescriptionWhereUniqueInput
  }


  /**
   * TopDescription base type for findFirst actions
   */
  export type TopDescriptionFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopDescription
     */
    select?: TopDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TopDescriptionInclude<ExtArgs> | null
    /**
     * Filter, which TopDescription to fetch.
     */
    where?: TopDescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TopDescriptions to fetch.
     */
    orderBy?: Enumerable<TopDescriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TopDescriptions.
     */
    cursor?: TopDescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TopDescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TopDescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TopDescriptions.
     */
    distinct?: Enumerable<TopDescriptionScalarFieldEnum>
  }

  /**
   * TopDescription findFirst
   */
  export interface TopDescriptionFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends TopDescriptionFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TopDescription findFirstOrThrow
   */
  export type TopDescriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopDescription
     */
    select?: TopDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TopDescriptionInclude<ExtArgs> | null
    /**
     * Filter, which TopDescription to fetch.
     */
    where?: TopDescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TopDescriptions to fetch.
     */
    orderBy?: Enumerable<TopDescriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TopDescriptions.
     */
    cursor?: TopDescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TopDescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TopDescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TopDescriptions.
     */
    distinct?: Enumerable<TopDescriptionScalarFieldEnum>
  }


  /**
   * TopDescription findMany
   */
  export type TopDescriptionFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopDescription
     */
    select?: TopDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TopDescriptionInclude<ExtArgs> | null
    /**
     * Filter, which TopDescriptions to fetch.
     */
    where?: TopDescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TopDescriptions to fetch.
     */
    orderBy?: Enumerable<TopDescriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TopDescriptions.
     */
    cursor?: TopDescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TopDescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TopDescriptions.
     */
    skip?: number
    distinct?: Enumerable<TopDescriptionScalarFieldEnum>
  }


  /**
   * TopDescription create
   */
  export type TopDescriptionCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopDescription
     */
    select?: TopDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TopDescriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a TopDescription.
     */
    data: XOR<TopDescriptionCreateInput, TopDescriptionUncheckedCreateInput>
  }


  /**
   * TopDescription createMany
   */
  export type TopDescriptionCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TopDescriptions.
     */
    data: Enumerable<TopDescriptionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TopDescription update
   */
  export type TopDescriptionUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopDescription
     */
    select?: TopDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TopDescriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a TopDescription.
     */
    data: XOR<TopDescriptionUpdateInput, TopDescriptionUncheckedUpdateInput>
    /**
     * Choose, which TopDescription to update.
     */
    where: TopDescriptionWhereUniqueInput
  }


  /**
   * TopDescription updateMany
   */
  export type TopDescriptionUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TopDescriptions.
     */
    data: XOR<TopDescriptionUpdateManyMutationInput, TopDescriptionUncheckedUpdateManyInput>
    /**
     * Filter which TopDescriptions to update
     */
    where?: TopDescriptionWhereInput
  }


  /**
   * TopDescription upsert
   */
  export type TopDescriptionUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopDescription
     */
    select?: TopDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TopDescriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the TopDescription to update in case it exists.
     */
    where: TopDescriptionWhereUniqueInput
    /**
     * In case the TopDescription found by the `where` argument doesn't exist, create a new TopDescription with this data.
     */
    create: XOR<TopDescriptionCreateInput, TopDescriptionUncheckedCreateInput>
    /**
     * In case the TopDescription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TopDescriptionUpdateInput, TopDescriptionUncheckedUpdateInput>
  }


  /**
   * TopDescription delete
   */
  export type TopDescriptionDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopDescription
     */
    select?: TopDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TopDescriptionInclude<ExtArgs> | null
    /**
     * Filter which TopDescription to delete.
     */
    where: TopDescriptionWhereUniqueInput
  }


  /**
   * TopDescription deleteMany
   */
  export type TopDescriptionDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which TopDescriptions to delete
     */
    where?: TopDescriptionWhereInput
  }


  /**
   * TopDescription.bottomDescription
   */
  export type TopDescription$bottomDescriptionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BottomDescription
     */
    select?: BottomDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BottomDescriptionInclude<ExtArgs> | null
    where?: BottomDescriptionWhereInput
    orderBy?: Enumerable<BottomDescriptionOrderByWithRelationInput>
    cursor?: BottomDescriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BottomDescriptionScalarFieldEnum>
  }


  /**
   * TopDescription without action
   */
  export type TopDescriptionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopDescription
     */
    select?: TopDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TopDescriptionInclude<ExtArgs> | null
  }



  /**
   * Model BottomDescription
   */


  export type AggregateBottomDescription = {
    _count: BottomDescriptionCountAggregateOutputType | null
    _avg: BottomDescriptionAvgAggregateOutputType | null
    _sum: BottomDescriptionSumAggregateOutputType | null
    _min: BottomDescriptionMinAggregateOutputType | null
    _max: BottomDescriptionMaxAggregateOutputType | null
  }

  export type BottomDescriptionAvgAggregateOutputType = {
    id: number | null
    weight: number | null
    length: number | null
    waist: number | null
    hip: number | null
    commonDescriptionId: number | null
    kurtasDescriptionId: number | null
    topDescriptionId: number | null
    typeOfPantId: number | null
    typesOfPleatsId: number | null
    typesOfLengthId: number | null
  }

  export type BottomDescriptionSumAggregateOutputType = {
    id: number | null
    weight: number | null
    length: number | null
    waist: number | null
    hip: number | null
    commonDescriptionId: number | null
    kurtasDescriptionId: number | null
    topDescriptionId: number | null
    typeOfPantId: number | null
    typesOfPleatsId: number | null
    typesOfLengthId: number | null
  }

  export type BottomDescriptionMinAggregateOutputType = {
    id: number | null
    productDescription: string | null
    weight: number | null
    printAndPattern: string | null
    length: number | null
    waist: number | null
    hip: number | null
    commonDescriptionId: number | null
    type: string | null
    colorFamily: string | null
    pocket: string | null
    kurtasDescriptionId: number | null
    topDescriptionId: number | null
    beltLoop: boolean | null
    typeOfPantId: number | null
    typesOfPleatsId: number | null
    typesOfLengthId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type BottomDescriptionMaxAggregateOutputType = {
    id: number | null
    productDescription: string | null
    weight: number | null
    printAndPattern: string | null
    length: number | null
    waist: number | null
    hip: number | null
    commonDescriptionId: number | null
    type: string | null
    colorFamily: string | null
    pocket: string | null
    kurtasDescriptionId: number | null
    topDescriptionId: number | null
    beltLoop: boolean | null
    typeOfPantId: number | null
    typesOfPleatsId: number | null
    typesOfLengthId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type BottomDescriptionCountAggregateOutputType = {
    id: number
    productDescription: number
    weight: number
    printAndPattern: number
    length: number
    waist: number
    hip: number
    commonDescriptionId: number
    type: number
    colorFamily: number
    pocket: number
    kurtasDescriptionId: number
    topDescriptionId: number
    beltLoop: number
    typeOfPantId: number
    typesOfPleatsId: number
    typesOfLengthId: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type BottomDescriptionAvgAggregateInputType = {
    id?: true
    weight?: true
    length?: true
    waist?: true
    hip?: true
    commonDescriptionId?: true
    kurtasDescriptionId?: true
    topDescriptionId?: true
    typeOfPantId?: true
    typesOfPleatsId?: true
    typesOfLengthId?: true
  }

  export type BottomDescriptionSumAggregateInputType = {
    id?: true
    weight?: true
    length?: true
    waist?: true
    hip?: true
    commonDescriptionId?: true
    kurtasDescriptionId?: true
    topDescriptionId?: true
    typeOfPantId?: true
    typesOfPleatsId?: true
    typesOfLengthId?: true
  }

  export type BottomDescriptionMinAggregateInputType = {
    id?: true
    productDescription?: true
    weight?: true
    printAndPattern?: true
    length?: true
    waist?: true
    hip?: true
    commonDescriptionId?: true
    type?: true
    colorFamily?: true
    pocket?: true
    kurtasDescriptionId?: true
    topDescriptionId?: true
    beltLoop?: true
    typeOfPantId?: true
    typesOfPleatsId?: true
    typesOfLengthId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type BottomDescriptionMaxAggregateInputType = {
    id?: true
    productDescription?: true
    weight?: true
    printAndPattern?: true
    length?: true
    waist?: true
    hip?: true
    commonDescriptionId?: true
    type?: true
    colorFamily?: true
    pocket?: true
    kurtasDescriptionId?: true
    topDescriptionId?: true
    beltLoop?: true
    typeOfPantId?: true
    typesOfPleatsId?: true
    typesOfLengthId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type BottomDescriptionCountAggregateInputType = {
    id?: true
    productDescription?: true
    weight?: true
    printAndPattern?: true
    length?: true
    waist?: true
    hip?: true
    commonDescriptionId?: true
    type?: true
    colorFamily?: true
    pocket?: true
    kurtasDescriptionId?: true
    topDescriptionId?: true
    beltLoop?: true
    typeOfPantId?: true
    typesOfPleatsId?: true
    typesOfLengthId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type BottomDescriptionAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which BottomDescription to aggregate.
     */
    where?: BottomDescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BottomDescriptions to fetch.
     */
    orderBy?: Enumerable<BottomDescriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BottomDescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BottomDescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BottomDescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BottomDescriptions
    **/
    _count?: true | BottomDescriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BottomDescriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BottomDescriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BottomDescriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BottomDescriptionMaxAggregateInputType
  }

  export type GetBottomDescriptionAggregateType<T extends BottomDescriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateBottomDescription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBottomDescription[P]>
      : GetScalarType<T[P], AggregateBottomDescription[P]>
  }




  export type BottomDescriptionGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: BottomDescriptionWhereInput
    orderBy?: Enumerable<BottomDescriptionOrderByWithAggregationInput>
    by: BottomDescriptionScalarFieldEnum[]
    having?: BottomDescriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BottomDescriptionCountAggregateInputType | true
    _avg?: BottomDescriptionAvgAggregateInputType
    _sum?: BottomDescriptionSumAggregateInputType
    _min?: BottomDescriptionMinAggregateInputType
    _max?: BottomDescriptionMaxAggregateInputType
  }


  export type BottomDescriptionGroupByOutputType = {
    id: number
    productDescription: string | null
    weight: number | null
    printAndPattern: string
    length: number
    waist: number
    hip: number
    commonDescriptionId: number
    type: string | null
    colorFamily: string | null
    pocket: string | null
    kurtasDescriptionId: number | null
    topDescriptionId: number | null
    beltLoop: boolean
    typeOfPantId: number
    typesOfPleatsId: number
    typesOfLengthId: number
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: BottomDescriptionCountAggregateOutputType | null
    _avg: BottomDescriptionAvgAggregateOutputType | null
    _sum: BottomDescriptionSumAggregateOutputType | null
    _min: BottomDescriptionMinAggregateOutputType | null
    _max: BottomDescriptionMaxAggregateOutputType | null
  }

  type GetBottomDescriptionGroupByPayload<T extends BottomDescriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BottomDescriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BottomDescriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BottomDescriptionGroupByOutputType[P]>
            : GetScalarType<T[P], BottomDescriptionGroupByOutputType[P]>
        }
      >
    >


  export type BottomDescriptionSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productDescription?: boolean
    weight?: boolean
    printAndPattern?: boolean
    length?: boolean
    waist?: boolean
    hip?: boolean
    commonDescriptionId?: boolean
    type?: boolean
    colorFamily?: boolean
    pocket?: boolean
    kurtasDescriptionId?: boolean
    topDescriptionId?: boolean
    beltLoop?: boolean
    typeOfPantId?: boolean
    typesOfPleatsId?: boolean
    typesOfLengthId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    typesOfPants?: boolean | TypesOfBottomArgs<ExtArgs>
    typesOfPleats?: boolean | TypesOfPleatsArgs<ExtArgs>
    typesOfLength?: boolean | TypesOfLengthBottomArgs<ExtArgs>
    commonDescription?: boolean | CommonDescriptionArgs<ExtArgs>
    kurtasDescription?: boolean | KurtasDescriptionArgs<ExtArgs>
    topDescription?: boolean | TopDescriptionArgs<ExtArgs>
  }, ExtArgs["result"]["bottomDescription"]>

  export type BottomDescriptionSelectScalar = {
    id?: boolean
    productDescription?: boolean
    weight?: boolean
    printAndPattern?: boolean
    length?: boolean
    waist?: boolean
    hip?: boolean
    commonDescriptionId?: boolean
    type?: boolean
    colorFamily?: boolean
    pocket?: boolean
    kurtasDescriptionId?: boolean
    topDescriptionId?: boolean
    beltLoop?: boolean
    typeOfPantId?: boolean
    typesOfPleatsId?: boolean
    typesOfLengthId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type BottomDescriptionInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    typesOfPants?: boolean | TypesOfBottomArgs<ExtArgs>
    typesOfPleats?: boolean | TypesOfPleatsArgs<ExtArgs>
    typesOfLength?: boolean | TypesOfLengthBottomArgs<ExtArgs>
    commonDescription?: boolean | CommonDescriptionArgs<ExtArgs>
    kurtasDescription?: boolean | KurtasDescriptionArgs<ExtArgs>
    topDescription?: boolean | TopDescriptionArgs<ExtArgs>
  }


  type BottomDescriptionGetPayload<S extends boolean | null | undefined | BottomDescriptionArgs> = $Types.GetResult<BottomDescriptionPayload, S>

  type BottomDescriptionCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<BottomDescriptionFindManyArgs, 'select' | 'include'> & {
      select?: BottomDescriptionCountAggregateInputType | true
    }

  export interface BottomDescriptionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BottomDescription'], meta: { name: 'BottomDescription' } }
    /**
     * Find zero or one BottomDescription that matches the filter.
     * @param {BottomDescriptionFindUniqueArgs} args - Arguments to find a BottomDescription
     * @example
     * // Get one BottomDescription
     * const bottomDescription = await prisma.bottomDescription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BottomDescriptionFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BottomDescriptionFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'BottomDescription'> extends True ? Prisma__BottomDescriptionClient<$Types.GetResult<BottomDescriptionPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__BottomDescriptionClient<$Types.GetResult<BottomDescriptionPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one BottomDescription that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BottomDescriptionFindUniqueOrThrowArgs} args - Arguments to find a BottomDescription
     * @example
     * // Get one BottomDescription
     * const bottomDescription = await prisma.bottomDescription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BottomDescriptionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BottomDescriptionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BottomDescriptionClient<$Types.GetResult<BottomDescriptionPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first BottomDescription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BottomDescriptionFindFirstArgs} args - Arguments to find a BottomDescription
     * @example
     * // Get one BottomDescription
     * const bottomDescription = await prisma.bottomDescription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BottomDescriptionFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BottomDescriptionFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'BottomDescription'> extends True ? Prisma__BottomDescriptionClient<$Types.GetResult<BottomDescriptionPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__BottomDescriptionClient<$Types.GetResult<BottomDescriptionPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first BottomDescription that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BottomDescriptionFindFirstOrThrowArgs} args - Arguments to find a BottomDescription
     * @example
     * // Get one BottomDescription
     * const bottomDescription = await prisma.bottomDescription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BottomDescriptionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BottomDescriptionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BottomDescriptionClient<$Types.GetResult<BottomDescriptionPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more BottomDescriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BottomDescriptionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BottomDescriptions
     * const bottomDescriptions = await prisma.bottomDescription.findMany()
     * 
     * // Get first 10 BottomDescriptions
     * const bottomDescriptions = await prisma.bottomDescription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bottomDescriptionWithIdOnly = await prisma.bottomDescription.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BottomDescriptionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BottomDescriptionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<BottomDescriptionPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a BottomDescription.
     * @param {BottomDescriptionCreateArgs} args - Arguments to create a BottomDescription.
     * @example
     * // Create one BottomDescription
     * const BottomDescription = await prisma.bottomDescription.create({
     *   data: {
     *     // ... data to create a BottomDescription
     *   }
     * })
     * 
    **/
    create<T extends BottomDescriptionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BottomDescriptionCreateArgs<ExtArgs>>
    ): Prisma__BottomDescriptionClient<$Types.GetResult<BottomDescriptionPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many BottomDescriptions.
     *     @param {BottomDescriptionCreateManyArgs} args - Arguments to create many BottomDescriptions.
     *     @example
     *     // Create many BottomDescriptions
     *     const bottomDescription = await prisma.bottomDescription.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BottomDescriptionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BottomDescriptionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BottomDescription.
     * @param {BottomDescriptionDeleteArgs} args - Arguments to delete one BottomDescription.
     * @example
     * // Delete one BottomDescription
     * const BottomDescription = await prisma.bottomDescription.delete({
     *   where: {
     *     // ... filter to delete one BottomDescription
     *   }
     * })
     * 
    **/
    delete<T extends BottomDescriptionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BottomDescriptionDeleteArgs<ExtArgs>>
    ): Prisma__BottomDescriptionClient<$Types.GetResult<BottomDescriptionPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one BottomDescription.
     * @param {BottomDescriptionUpdateArgs} args - Arguments to update one BottomDescription.
     * @example
     * // Update one BottomDescription
     * const bottomDescription = await prisma.bottomDescription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BottomDescriptionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BottomDescriptionUpdateArgs<ExtArgs>>
    ): Prisma__BottomDescriptionClient<$Types.GetResult<BottomDescriptionPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more BottomDescriptions.
     * @param {BottomDescriptionDeleteManyArgs} args - Arguments to filter BottomDescriptions to delete.
     * @example
     * // Delete a few BottomDescriptions
     * const { count } = await prisma.bottomDescription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BottomDescriptionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BottomDescriptionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BottomDescriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BottomDescriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BottomDescriptions
     * const bottomDescription = await prisma.bottomDescription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BottomDescriptionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BottomDescriptionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BottomDescription.
     * @param {BottomDescriptionUpsertArgs} args - Arguments to update or create a BottomDescription.
     * @example
     * // Update or create a BottomDescription
     * const bottomDescription = await prisma.bottomDescription.upsert({
     *   create: {
     *     // ... data to create a BottomDescription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BottomDescription we want to update
     *   }
     * })
    **/
    upsert<T extends BottomDescriptionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BottomDescriptionUpsertArgs<ExtArgs>>
    ): Prisma__BottomDescriptionClient<$Types.GetResult<BottomDescriptionPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of BottomDescriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BottomDescriptionCountArgs} args - Arguments to filter BottomDescriptions to count.
     * @example
     * // Count the number of BottomDescriptions
     * const count = await prisma.bottomDescription.count({
     *   where: {
     *     // ... the filter for the BottomDescriptions we want to count
     *   }
     * })
    **/
    count<T extends BottomDescriptionCountArgs>(
      args?: Subset<T, BottomDescriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BottomDescriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BottomDescription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BottomDescriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BottomDescriptionAggregateArgs>(args: Subset<T, BottomDescriptionAggregateArgs>): Prisma.PrismaPromise<GetBottomDescriptionAggregateType<T>>

    /**
     * Group by BottomDescription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BottomDescriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BottomDescriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BottomDescriptionGroupByArgs['orderBy'] }
        : { orderBy?: BottomDescriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BottomDescriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBottomDescriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for BottomDescription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BottomDescriptionClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    typesOfPants<T extends TypesOfBottomArgs<ExtArgs> = {}>(args?: Subset<T, TypesOfBottomArgs<ExtArgs>>): Prisma__TypesOfBottomClient<$Types.GetResult<TypesOfBottomPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    typesOfPleats<T extends TypesOfPleatsArgs<ExtArgs> = {}>(args?: Subset<T, TypesOfPleatsArgs<ExtArgs>>): Prisma__TypesOfPleatsClient<$Types.GetResult<TypesOfPleatsPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    typesOfLength<T extends TypesOfLengthBottomArgs<ExtArgs> = {}>(args?: Subset<T, TypesOfLengthBottomArgs<ExtArgs>>): Prisma__TypesOfLengthBottomClient<$Types.GetResult<TypesOfLengthBottomPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    commonDescription<T extends CommonDescriptionArgs<ExtArgs> = {}>(args?: Subset<T, CommonDescriptionArgs<ExtArgs>>): Prisma__CommonDescriptionClient<$Types.GetResult<CommonDescriptionPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    kurtasDescription<T extends KurtasDescriptionArgs<ExtArgs> = {}>(args?: Subset<T, KurtasDescriptionArgs<ExtArgs>>): Prisma__KurtasDescriptionClient<$Types.GetResult<KurtasDescriptionPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    topDescription<T extends TopDescriptionArgs<ExtArgs> = {}>(args?: Subset<T, TopDescriptionArgs<ExtArgs>>): Prisma__TopDescriptionClient<$Types.GetResult<TopDescriptionPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * BottomDescription base type for findUnique actions
   */
  export type BottomDescriptionFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BottomDescription
     */
    select?: BottomDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BottomDescriptionInclude<ExtArgs> | null
    /**
     * Filter, which BottomDescription to fetch.
     */
    where: BottomDescriptionWhereUniqueInput
  }

  /**
   * BottomDescription findUnique
   */
  export interface BottomDescriptionFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends BottomDescriptionFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BottomDescription findUniqueOrThrow
   */
  export type BottomDescriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BottomDescription
     */
    select?: BottomDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BottomDescriptionInclude<ExtArgs> | null
    /**
     * Filter, which BottomDescription to fetch.
     */
    where: BottomDescriptionWhereUniqueInput
  }


  /**
   * BottomDescription base type for findFirst actions
   */
  export type BottomDescriptionFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BottomDescription
     */
    select?: BottomDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BottomDescriptionInclude<ExtArgs> | null
    /**
     * Filter, which BottomDescription to fetch.
     */
    where?: BottomDescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BottomDescriptions to fetch.
     */
    orderBy?: Enumerable<BottomDescriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BottomDescriptions.
     */
    cursor?: BottomDescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BottomDescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BottomDescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BottomDescriptions.
     */
    distinct?: Enumerable<BottomDescriptionScalarFieldEnum>
  }

  /**
   * BottomDescription findFirst
   */
  export interface BottomDescriptionFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends BottomDescriptionFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BottomDescription findFirstOrThrow
   */
  export type BottomDescriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BottomDescription
     */
    select?: BottomDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BottomDescriptionInclude<ExtArgs> | null
    /**
     * Filter, which BottomDescription to fetch.
     */
    where?: BottomDescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BottomDescriptions to fetch.
     */
    orderBy?: Enumerable<BottomDescriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BottomDescriptions.
     */
    cursor?: BottomDescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BottomDescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BottomDescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BottomDescriptions.
     */
    distinct?: Enumerable<BottomDescriptionScalarFieldEnum>
  }


  /**
   * BottomDescription findMany
   */
  export type BottomDescriptionFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BottomDescription
     */
    select?: BottomDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BottomDescriptionInclude<ExtArgs> | null
    /**
     * Filter, which BottomDescriptions to fetch.
     */
    where?: BottomDescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BottomDescriptions to fetch.
     */
    orderBy?: Enumerable<BottomDescriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BottomDescriptions.
     */
    cursor?: BottomDescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BottomDescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BottomDescriptions.
     */
    skip?: number
    distinct?: Enumerable<BottomDescriptionScalarFieldEnum>
  }


  /**
   * BottomDescription create
   */
  export type BottomDescriptionCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BottomDescription
     */
    select?: BottomDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BottomDescriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a BottomDescription.
     */
    data: XOR<BottomDescriptionCreateInput, BottomDescriptionUncheckedCreateInput>
  }


  /**
   * BottomDescription createMany
   */
  export type BottomDescriptionCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BottomDescriptions.
     */
    data: Enumerable<BottomDescriptionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * BottomDescription update
   */
  export type BottomDescriptionUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BottomDescription
     */
    select?: BottomDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BottomDescriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a BottomDescription.
     */
    data: XOR<BottomDescriptionUpdateInput, BottomDescriptionUncheckedUpdateInput>
    /**
     * Choose, which BottomDescription to update.
     */
    where: BottomDescriptionWhereUniqueInput
  }


  /**
   * BottomDescription updateMany
   */
  export type BottomDescriptionUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BottomDescriptions.
     */
    data: XOR<BottomDescriptionUpdateManyMutationInput, BottomDescriptionUncheckedUpdateManyInput>
    /**
     * Filter which BottomDescriptions to update
     */
    where?: BottomDescriptionWhereInput
  }


  /**
   * BottomDescription upsert
   */
  export type BottomDescriptionUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BottomDescription
     */
    select?: BottomDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BottomDescriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the BottomDescription to update in case it exists.
     */
    where: BottomDescriptionWhereUniqueInput
    /**
     * In case the BottomDescription found by the `where` argument doesn't exist, create a new BottomDescription with this data.
     */
    create: XOR<BottomDescriptionCreateInput, BottomDescriptionUncheckedCreateInput>
    /**
     * In case the BottomDescription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BottomDescriptionUpdateInput, BottomDescriptionUncheckedUpdateInput>
  }


  /**
   * BottomDescription delete
   */
  export type BottomDescriptionDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BottomDescription
     */
    select?: BottomDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BottomDescriptionInclude<ExtArgs> | null
    /**
     * Filter which BottomDescription to delete.
     */
    where: BottomDescriptionWhereUniqueInput
  }


  /**
   * BottomDescription deleteMany
   */
  export type BottomDescriptionDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which BottomDescriptions to delete
     */
    where?: BottomDescriptionWhereInput
  }


  /**
   * BottomDescription without action
   */
  export type BottomDescriptionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BottomDescription
     */
    select?: BottomDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BottomDescriptionInclude<ExtArgs> | null
  }



  /**
   * Model KurtasDescription
   */


  export type AggregateKurtasDescription = {
    _count: KurtasDescriptionCountAggregateOutputType | null
    _avg: KurtasDescriptionAvgAggregateOutputType | null
    _sum: KurtasDescriptionSumAggregateOutputType | null
    _min: KurtasDescriptionMinAggregateOutputType | null
    _max: KurtasDescriptionMaxAggregateOutputType | null
  }

  export type KurtasDescriptionAvgAggregateOutputType = {
    id: number | null
    chest: number | null
    shoulder: number | null
    kurtasLengthTypeId: number | null
    weight: number | null
    kurtasNeckTypeId: number | null
    kurtasSleeveTypeId: number | null
    commonDescriptionId: number | null
  }

  export type KurtasDescriptionSumAggregateOutputType = {
    id: number | null
    chest: number | null
    shoulder: number | null
    kurtasLengthTypeId: number | null
    weight: number | null
    kurtasNeckTypeId: number | null
    kurtasSleeveTypeId: number | null
    commonDescriptionId: number | null
  }

  export type KurtasDescriptionMinAggregateOutputType = {
    id: number | null
    work: string | null
    productDescription: string | null
    chest: number | null
    shoulder: number | null
    transparencyOfTheFabric: boolean | null
    kurtasLengthTypeId: number | null
    weight: number | null
    colorFamily: string | null
    pocket: string | null
    type: string | null
    printAndpattern: string | null
    kurtasNeckTypeId: number | null
    kurtasSleeveTypeId: number | null
    commonDescriptionId: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type KurtasDescriptionMaxAggregateOutputType = {
    id: number | null
    work: string | null
    productDescription: string | null
    chest: number | null
    shoulder: number | null
    transparencyOfTheFabric: boolean | null
    kurtasLengthTypeId: number | null
    weight: number | null
    colorFamily: string | null
    pocket: string | null
    type: string | null
    printAndpattern: string | null
    kurtasNeckTypeId: number | null
    kurtasSleeveTypeId: number | null
    commonDescriptionId: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type KurtasDescriptionCountAggregateOutputType = {
    id: number
    work: number
    productDescription: number
    chest: number
    shoulder: number
    transparencyOfTheFabric: number
    kurtasLengthTypeId: number
    weight: number
    colorFamily: number
    pocket: number
    type: number
    printAndpattern: number
    kurtasNeckTypeId: number
    kurtasSleeveTypeId: number
    commonDescriptionId: number
    isActive: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type KurtasDescriptionAvgAggregateInputType = {
    id?: true
    chest?: true
    shoulder?: true
    kurtasLengthTypeId?: true
    weight?: true
    kurtasNeckTypeId?: true
    kurtasSleeveTypeId?: true
    commonDescriptionId?: true
  }

  export type KurtasDescriptionSumAggregateInputType = {
    id?: true
    chest?: true
    shoulder?: true
    kurtasLengthTypeId?: true
    weight?: true
    kurtasNeckTypeId?: true
    kurtasSleeveTypeId?: true
    commonDescriptionId?: true
  }

  export type KurtasDescriptionMinAggregateInputType = {
    id?: true
    work?: true
    productDescription?: true
    chest?: true
    shoulder?: true
    transparencyOfTheFabric?: true
    kurtasLengthTypeId?: true
    weight?: true
    colorFamily?: true
    pocket?: true
    type?: true
    printAndpattern?: true
    kurtasNeckTypeId?: true
    kurtasSleeveTypeId?: true
    commonDescriptionId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type KurtasDescriptionMaxAggregateInputType = {
    id?: true
    work?: true
    productDescription?: true
    chest?: true
    shoulder?: true
    transparencyOfTheFabric?: true
    kurtasLengthTypeId?: true
    weight?: true
    colorFamily?: true
    pocket?: true
    type?: true
    printAndpattern?: true
    kurtasNeckTypeId?: true
    kurtasSleeveTypeId?: true
    commonDescriptionId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type KurtasDescriptionCountAggregateInputType = {
    id?: true
    work?: true
    productDescription?: true
    chest?: true
    shoulder?: true
    transparencyOfTheFabric?: true
    kurtasLengthTypeId?: true
    weight?: true
    colorFamily?: true
    pocket?: true
    type?: true
    printAndpattern?: true
    kurtasNeckTypeId?: true
    kurtasSleeveTypeId?: true
    commonDescriptionId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type KurtasDescriptionAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which KurtasDescription to aggregate.
     */
    where?: KurtasDescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KurtasDescriptions to fetch.
     */
    orderBy?: Enumerable<KurtasDescriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KurtasDescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KurtasDescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KurtasDescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KurtasDescriptions
    **/
    _count?: true | KurtasDescriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KurtasDescriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KurtasDescriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KurtasDescriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KurtasDescriptionMaxAggregateInputType
  }

  export type GetKurtasDescriptionAggregateType<T extends KurtasDescriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateKurtasDescription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKurtasDescription[P]>
      : GetScalarType<T[P], AggregateKurtasDescription[P]>
  }




  export type KurtasDescriptionGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: KurtasDescriptionWhereInput
    orderBy?: Enumerable<KurtasDescriptionOrderByWithAggregationInput>
    by: KurtasDescriptionScalarFieldEnum[]
    having?: KurtasDescriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KurtasDescriptionCountAggregateInputType | true
    _avg?: KurtasDescriptionAvgAggregateInputType
    _sum?: KurtasDescriptionSumAggregateInputType
    _min?: KurtasDescriptionMinAggregateInputType
    _max?: KurtasDescriptionMaxAggregateInputType
  }


  export type KurtasDescriptionGroupByOutputType = {
    id: number
    work: string | null
    productDescription: string
    chest: number
    shoulder: number
    transparencyOfTheFabric: boolean
    kurtasLengthTypeId: number
    weight: number | null
    colorFamily: string | null
    pocket: string
    type: string
    printAndpattern: string | null
    kurtasNeckTypeId: number
    kurtasSleeveTypeId: number
    commonDescriptionId: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: KurtasDescriptionCountAggregateOutputType | null
    _avg: KurtasDescriptionAvgAggregateOutputType | null
    _sum: KurtasDescriptionSumAggregateOutputType | null
    _min: KurtasDescriptionMinAggregateOutputType | null
    _max: KurtasDescriptionMaxAggregateOutputType | null
  }

  type GetKurtasDescriptionGroupByPayload<T extends KurtasDescriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<KurtasDescriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KurtasDescriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KurtasDescriptionGroupByOutputType[P]>
            : GetScalarType<T[P], KurtasDescriptionGroupByOutputType[P]>
        }
      >
    >


  export type KurtasDescriptionSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    work?: boolean
    productDescription?: boolean
    chest?: boolean
    shoulder?: boolean
    transparencyOfTheFabric?: boolean
    kurtasLengthTypeId?: boolean
    weight?: boolean
    colorFamily?: boolean
    pocket?: boolean
    type?: boolean
    printAndpattern?: boolean
    kurtasNeckTypeId?: boolean
    kurtasSleeveTypeId?: boolean
    commonDescriptionId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    kurtasLengthType?: boolean | KurtasLengthTypeArgs<ExtArgs>
    neckType?: boolean | NeckTypeArgs<ExtArgs>
    sleeveType?: boolean | SleeveTypeArgs<ExtArgs>
    commonDescription?: boolean | CommonDescriptionArgs<ExtArgs>
    bottomDescription?: boolean | KurtasDescription$bottomDescriptionArgs<ExtArgs>
    _count?: boolean | KurtasDescriptionCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["kurtasDescription"]>

  export type KurtasDescriptionSelectScalar = {
    id?: boolean
    work?: boolean
    productDescription?: boolean
    chest?: boolean
    shoulder?: boolean
    transparencyOfTheFabric?: boolean
    kurtasLengthTypeId?: boolean
    weight?: boolean
    colorFamily?: boolean
    pocket?: boolean
    type?: boolean
    printAndpattern?: boolean
    kurtasNeckTypeId?: boolean
    kurtasSleeveTypeId?: boolean
    commonDescriptionId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type KurtasDescriptionInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    kurtasLengthType?: boolean | KurtasLengthTypeArgs<ExtArgs>
    neckType?: boolean | NeckTypeArgs<ExtArgs>
    sleeveType?: boolean | SleeveTypeArgs<ExtArgs>
    commonDescription?: boolean | CommonDescriptionArgs<ExtArgs>
    bottomDescription?: boolean | KurtasDescription$bottomDescriptionArgs<ExtArgs>
    _count?: boolean | KurtasDescriptionCountOutputTypeArgs<ExtArgs>
  }


  type KurtasDescriptionGetPayload<S extends boolean | null | undefined | KurtasDescriptionArgs> = $Types.GetResult<KurtasDescriptionPayload, S>

  type KurtasDescriptionCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<KurtasDescriptionFindManyArgs, 'select' | 'include'> & {
      select?: KurtasDescriptionCountAggregateInputType | true
    }

  export interface KurtasDescriptionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KurtasDescription'], meta: { name: 'KurtasDescription' } }
    /**
     * Find zero or one KurtasDescription that matches the filter.
     * @param {KurtasDescriptionFindUniqueArgs} args - Arguments to find a KurtasDescription
     * @example
     * // Get one KurtasDescription
     * const kurtasDescription = await prisma.kurtasDescription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends KurtasDescriptionFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, KurtasDescriptionFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'KurtasDescription'> extends True ? Prisma__KurtasDescriptionClient<$Types.GetResult<KurtasDescriptionPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__KurtasDescriptionClient<$Types.GetResult<KurtasDescriptionPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one KurtasDescription that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {KurtasDescriptionFindUniqueOrThrowArgs} args - Arguments to find a KurtasDescription
     * @example
     * // Get one KurtasDescription
     * const kurtasDescription = await prisma.kurtasDescription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends KurtasDescriptionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, KurtasDescriptionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__KurtasDescriptionClient<$Types.GetResult<KurtasDescriptionPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first KurtasDescription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KurtasDescriptionFindFirstArgs} args - Arguments to find a KurtasDescription
     * @example
     * // Get one KurtasDescription
     * const kurtasDescription = await prisma.kurtasDescription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends KurtasDescriptionFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, KurtasDescriptionFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'KurtasDescription'> extends True ? Prisma__KurtasDescriptionClient<$Types.GetResult<KurtasDescriptionPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__KurtasDescriptionClient<$Types.GetResult<KurtasDescriptionPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first KurtasDescription that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KurtasDescriptionFindFirstOrThrowArgs} args - Arguments to find a KurtasDescription
     * @example
     * // Get one KurtasDescription
     * const kurtasDescription = await prisma.kurtasDescription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends KurtasDescriptionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, KurtasDescriptionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__KurtasDescriptionClient<$Types.GetResult<KurtasDescriptionPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more KurtasDescriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KurtasDescriptionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KurtasDescriptions
     * const kurtasDescriptions = await prisma.kurtasDescription.findMany()
     * 
     * // Get first 10 KurtasDescriptions
     * const kurtasDescriptions = await prisma.kurtasDescription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kurtasDescriptionWithIdOnly = await prisma.kurtasDescription.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends KurtasDescriptionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, KurtasDescriptionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<KurtasDescriptionPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a KurtasDescription.
     * @param {KurtasDescriptionCreateArgs} args - Arguments to create a KurtasDescription.
     * @example
     * // Create one KurtasDescription
     * const KurtasDescription = await prisma.kurtasDescription.create({
     *   data: {
     *     // ... data to create a KurtasDescription
     *   }
     * })
     * 
    **/
    create<T extends KurtasDescriptionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, KurtasDescriptionCreateArgs<ExtArgs>>
    ): Prisma__KurtasDescriptionClient<$Types.GetResult<KurtasDescriptionPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many KurtasDescriptions.
     *     @param {KurtasDescriptionCreateManyArgs} args - Arguments to create many KurtasDescriptions.
     *     @example
     *     // Create many KurtasDescriptions
     *     const kurtasDescription = await prisma.kurtasDescription.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends KurtasDescriptionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, KurtasDescriptionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a KurtasDescription.
     * @param {KurtasDescriptionDeleteArgs} args - Arguments to delete one KurtasDescription.
     * @example
     * // Delete one KurtasDescription
     * const KurtasDescription = await prisma.kurtasDescription.delete({
     *   where: {
     *     // ... filter to delete one KurtasDescription
     *   }
     * })
     * 
    **/
    delete<T extends KurtasDescriptionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, KurtasDescriptionDeleteArgs<ExtArgs>>
    ): Prisma__KurtasDescriptionClient<$Types.GetResult<KurtasDescriptionPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one KurtasDescription.
     * @param {KurtasDescriptionUpdateArgs} args - Arguments to update one KurtasDescription.
     * @example
     * // Update one KurtasDescription
     * const kurtasDescription = await prisma.kurtasDescription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends KurtasDescriptionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, KurtasDescriptionUpdateArgs<ExtArgs>>
    ): Prisma__KurtasDescriptionClient<$Types.GetResult<KurtasDescriptionPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more KurtasDescriptions.
     * @param {KurtasDescriptionDeleteManyArgs} args - Arguments to filter KurtasDescriptions to delete.
     * @example
     * // Delete a few KurtasDescriptions
     * const { count } = await prisma.kurtasDescription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends KurtasDescriptionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, KurtasDescriptionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KurtasDescriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KurtasDescriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KurtasDescriptions
     * const kurtasDescription = await prisma.kurtasDescription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends KurtasDescriptionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, KurtasDescriptionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one KurtasDescription.
     * @param {KurtasDescriptionUpsertArgs} args - Arguments to update or create a KurtasDescription.
     * @example
     * // Update or create a KurtasDescription
     * const kurtasDescription = await prisma.kurtasDescription.upsert({
     *   create: {
     *     // ... data to create a KurtasDescription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KurtasDescription we want to update
     *   }
     * })
    **/
    upsert<T extends KurtasDescriptionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, KurtasDescriptionUpsertArgs<ExtArgs>>
    ): Prisma__KurtasDescriptionClient<$Types.GetResult<KurtasDescriptionPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of KurtasDescriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KurtasDescriptionCountArgs} args - Arguments to filter KurtasDescriptions to count.
     * @example
     * // Count the number of KurtasDescriptions
     * const count = await prisma.kurtasDescription.count({
     *   where: {
     *     // ... the filter for the KurtasDescriptions we want to count
     *   }
     * })
    **/
    count<T extends KurtasDescriptionCountArgs>(
      args?: Subset<T, KurtasDescriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KurtasDescriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KurtasDescription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KurtasDescriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KurtasDescriptionAggregateArgs>(args: Subset<T, KurtasDescriptionAggregateArgs>): Prisma.PrismaPromise<GetKurtasDescriptionAggregateType<T>>

    /**
     * Group by KurtasDescription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KurtasDescriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KurtasDescriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KurtasDescriptionGroupByArgs['orderBy'] }
        : { orderBy?: KurtasDescriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KurtasDescriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKurtasDescriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for KurtasDescription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__KurtasDescriptionClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    kurtasLengthType<T extends KurtasLengthTypeArgs<ExtArgs> = {}>(args?: Subset<T, KurtasLengthTypeArgs<ExtArgs>>): Prisma__KurtasLengthTypeClient<$Types.GetResult<KurtasLengthTypePayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    neckType<T extends NeckTypeArgs<ExtArgs> = {}>(args?: Subset<T, NeckTypeArgs<ExtArgs>>): Prisma__NeckTypeClient<$Types.GetResult<NeckTypePayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    sleeveType<T extends SleeveTypeArgs<ExtArgs> = {}>(args?: Subset<T, SleeveTypeArgs<ExtArgs>>): Prisma__SleeveTypeClient<$Types.GetResult<SleeveTypePayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    commonDescription<T extends CommonDescriptionArgs<ExtArgs> = {}>(args?: Subset<T, CommonDescriptionArgs<ExtArgs>>): Prisma__CommonDescriptionClient<$Types.GetResult<CommonDescriptionPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    bottomDescription<T extends KurtasDescription$bottomDescriptionArgs<ExtArgs> = {}>(args?: Subset<T, KurtasDescription$bottomDescriptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<BottomDescriptionPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * KurtasDescription base type for findUnique actions
   */
  export type KurtasDescriptionFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KurtasDescription
     */
    select?: KurtasDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KurtasDescriptionInclude<ExtArgs> | null
    /**
     * Filter, which KurtasDescription to fetch.
     */
    where: KurtasDescriptionWhereUniqueInput
  }

  /**
   * KurtasDescription findUnique
   */
  export interface KurtasDescriptionFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends KurtasDescriptionFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * KurtasDescription findUniqueOrThrow
   */
  export type KurtasDescriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KurtasDescription
     */
    select?: KurtasDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KurtasDescriptionInclude<ExtArgs> | null
    /**
     * Filter, which KurtasDescription to fetch.
     */
    where: KurtasDescriptionWhereUniqueInput
  }


  /**
   * KurtasDescription base type for findFirst actions
   */
  export type KurtasDescriptionFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KurtasDescription
     */
    select?: KurtasDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KurtasDescriptionInclude<ExtArgs> | null
    /**
     * Filter, which KurtasDescription to fetch.
     */
    where?: KurtasDescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KurtasDescriptions to fetch.
     */
    orderBy?: Enumerable<KurtasDescriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KurtasDescriptions.
     */
    cursor?: KurtasDescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KurtasDescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KurtasDescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KurtasDescriptions.
     */
    distinct?: Enumerable<KurtasDescriptionScalarFieldEnum>
  }

  /**
   * KurtasDescription findFirst
   */
  export interface KurtasDescriptionFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends KurtasDescriptionFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * KurtasDescription findFirstOrThrow
   */
  export type KurtasDescriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KurtasDescription
     */
    select?: KurtasDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KurtasDescriptionInclude<ExtArgs> | null
    /**
     * Filter, which KurtasDescription to fetch.
     */
    where?: KurtasDescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KurtasDescriptions to fetch.
     */
    orderBy?: Enumerable<KurtasDescriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KurtasDescriptions.
     */
    cursor?: KurtasDescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KurtasDescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KurtasDescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KurtasDescriptions.
     */
    distinct?: Enumerable<KurtasDescriptionScalarFieldEnum>
  }


  /**
   * KurtasDescription findMany
   */
  export type KurtasDescriptionFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KurtasDescription
     */
    select?: KurtasDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KurtasDescriptionInclude<ExtArgs> | null
    /**
     * Filter, which KurtasDescriptions to fetch.
     */
    where?: KurtasDescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KurtasDescriptions to fetch.
     */
    orderBy?: Enumerable<KurtasDescriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KurtasDescriptions.
     */
    cursor?: KurtasDescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KurtasDescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KurtasDescriptions.
     */
    skip?: number
    distinct?: Enumerable<KurtasDescriptionScalarFieldEnum>
  }


  /**
   * KurtasDescription create
   */
  export type KurtasDescriptionCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KurtasDescription
     */
    select?: KurtasDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KurtasDescriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a KurtasDescription.
     */
    data: XOR<KurtasDescriptionCreateInput, KurtasDescriptionUncheckedCreateInput>
  }


  /**
   * KurtasDescription createMany
   */
  export type KurtasDescriptionCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KurtasDescriptions.
     */
    data: Enumerable<KurtasDescriptionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * KurtasDescription update
   */
  export type KurtasDescriptionUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KurtasDescription
     */
    select?: KurtasDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KurtasDescriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a KurtasDescription.
     */
    data: XOR<KurtasDescriptionUpdateInput, KurtasDescriptionUncheckedUpdateInput>
    /**
     * Choose, which KurtasDescription to update.
     */
    where: KurtasDescriptionWhereUniqueInput
  }


  /**
   * KurtasDescription updateMany
   */
  export type KurtasDescriptionUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KurtasDescriptions.
     */
    data: XOR<KurtasDescriptionUpdateManyMutationInput, KurtasDescriptionUncheckedUpdateManyInput>
    /**
     * Filter which KurtasDescriptions to update
     */
    where?: KurtasDescriptionWhereInput
  }


  /**
   * KurtasDescription upsert
   */
  export type KurtasDescriptionUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KurtasDescription
     */
    select?: KurtasDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KurtasDescriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the KurtasDescription to update in case it exists.
     */
    where: KurtasDescriptionWhereUniqueInput
    /**
     * In case the KurtasDescription found by the `where` argument doesn't exist, create a new KurtasDescription with this data.
     */
    create: XOR<KurtasDescriptionCreateInput, KurtasDescriptionUncheckedCreateInput>
    /**
     * In case the KurtasDescription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KurtasDescriptionUpdateInput, KurtasDescriptionUncheckedUpdateInput>
  }


  /**
   * KurtasDescription delete
   */
  export type KurtasDescriptionDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KurtasDescription
     */
    select?: KurtasDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KurtasDescriptionInclude<ExtArgs> | null
    /**
     * Filter which KurtasDescription to delete.
     */
    where: KurtasDescriptionWhereUniqueInput
  }


  /**
   * KurtasDescription deleteMany
   */
  export type KurtasDescriptionDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which KurtasDescriptions to delete
     */
    where?: KurtasDescriptionWhereInput
  }


  /**
   * KurtasDescription.bottomDescription
   */
  export type KurtasDescription$bottomDescriptionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BottomDescription
     */
    select?: BottomDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BottomDescriptionInclude<ExtArgs> | null
    where?: BottomDescriptionWhereInput
    orderBy?: Enumerable<BottomDescriptionOrderByWithRelationInput>
    cursor?: BottomDescriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BottomDescriptionScalarFieldEnum>
  }


  /**
   * KurtasDescription without action
   */
  export type KurtasDescriptionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KurtasDescription
     */
    select?: KurtasDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KurtasDescriptionInclude<ExtArgs> | null
  }



  /**
   * Model ShoesDescription
   */


  export type AggregateShoesDescription = {
    _count: ShoesDescriptionCountAggregateOutputType | null
    _avg: ShoesDescriptionAvgAggregateOutputType | null
    _sum: ShoesDescriptionSumAggregateOutputType | null
    _min: ShoesDescriptionMinAggregateOutputType | null
    _max: ShoesDescriptionMaxAggregateOutputType | null
  }

  export type ShoesDescriptionAvgAggregateOutputType = {
    id: number | null
    weight: number | null
    packageContains: number | null
    commonDescriptionId: number | null
  }

  export type ShoesDescriptionSumAggregateOutputType = {
    id: number | null
    weight: number | null
    packageContains: number | null
    commonDescriptionId: number | null
  }

  export type ShoesDescriptionMinAggregateOutputType = {
    id: number | null
    pattern: string | null
    footLength: string | null
    type: string | null
    soleMaterial: string | null
    printAndPattern: string | null
    upperMaterial: string | null
    closure: string | null
    toeType: string | null
    weight: number | null
    colorFamily: string | null
    productDescription: string | null
    packageContains: number | null
    commonDescriptionId: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ShoesDescriptionMaxAggregateOutputType = {
    id: number | null
    pattern: string | null
    footLength: string | null
    type: string | null
    soleMaterial: string | null
    printAndPattern: string | null
    upperMaterial: string | null
    closure: string | null
    toeType: string | null
    weight: number | null
    colorFamily: string | null
    productDescription: string | null
    packageContains: number | null
    commonDescriptionId: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ShoesDescriptionCountAggregateOutputType = {
    id: number
    pattern: number
    footLength: number
    type: number
    soleMaterial: number
    printAndPattern: number
    upperMaterial: number
    closure: number
    toeType: number
    weight: number
    colorFamily: number
    productDescription: number
    packageContains: number
    commonDescriptionId: number
    isActive: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type ShoesDescriptionAvgAggregateInputType = {
    id?: true
    weight?: true
    packageContains?: true
    commonDescriptionId?: true
  }

  export type ShoesDescriptionSumAggregateInputType = {
    id?: true
    weight?: true
    packageContains?: true
    commonDescriptionId?: true
  }

  export type ShoesDescriptionMinAggregateInputType = {
    id?: true
    pattern?: true
    footLength?: true
    type?: true
    soleMaterial?: true
    printAndPattern?: true
    upperMaterial?: true
    closure?: true
    toeType?: true
    weight?: true
    colorFamily?: true
    productDescription?: true
    packageContains?: true
    commonDescriptionId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ShoesDescriptionMaxAggregateInputType = {
    id?: true
    pattern?: true
    footLength?: true
    type?: true
    soleMaterial?: true
    printAndPattern?: true
    upperMaterial?: true
    closure?: true
    toeType?: true
    weight?: true
    colorFamily?: true
    productDescription?: true
    packageContains?: true
    commonDescriptionId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ShoesDescriptionCountAggregateInputType = {
    id?: true
    pattern?: true
    footLength?: true
    type?: true
    soleMaterial?: true
    printAndPattern?: true
    upperMaterial?: true
    closure?: true
    toeType?: true
    weight?: true
    colorFamily?: true
    productDescription?: true
    packageContains?: true
    commonDescriptionId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type ShoesDescriptionAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShoesDescription to aggregate.
     */
    where?: ShoesDescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShoesDescriptions to fetch.
     */
    orderBy?: Enumerable<ShoesDescriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShoesDescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShoesDescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShoesDescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShoesDescriptions
    **/
    _count?: true | ShoesDescriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShoesDescriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShoesDescriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShoesDescriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShoesDescriptionMaxAggregateInputType
  }

  export type GetShoesDescriptionAggregateType<T extends ShoesDescriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateShoesDescription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShoesDescription[P]>
      : GetScalarType<T[P], AggregateShoesDescription[P]>
  }




  export type ShoesDescriptionGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ShoesDescriptionWhereInput
    orderBy?: Enumerable<ShoesDescriptionOrderByWithAggregationInput>
    by: ShoesDescriptionScalarFieldEnum[]
    having?: ShoesDescriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShoesDescriptionCountAggregateInputType | true
    _avg?: ShoesDescriptionAvgAggregateInputType
    _sum?: ShoesDescriptionSumAggregateInputType
    _min?: ShoesDescriptionMinAggregateInputType
    _max?: ShoesDescriptionMaxAggregateInputType
  }


  export type ShoesDescriptionGroupByOutputType = {
    id: number
    pattern: string | null
    footLength: string
    type: string
    soleMaterial: string | null
    printAndPattern: string | null
    upperMaterial: string | null
    closure: string | null
    toeType: string
    weight: number | null
    colorFamily: string | null
    productDescription: string | null
    packageContains: number | null
    commonDescriptionId: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: ShoesDescriptionCountAggregateOutputType | null
    _avg: ShoesDescriptionAvgAggregateOutputType | null
    _sum: ShoesDescriptionSumAggregateOutputType | null
    _min: ShoesDescriptionMinAggregateOutputType | null
    _max: ShoesDescriptionMaxAggregateOutputType | null
  }

  type GetShoesDescriptionGroupByPayload<T extends ShoesDescriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ShoesDescriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShoesDescriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShoesDescriptionGroupByOutputType[P]>
            : GetScalarType<T[P], ShoesDescriptionGroupByOutputType[P]>
        }
      >
    >


  export type ShoesDescriptionSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pattern?: boolean
    footLength?: boolean
    type?: boolean
    soleMaterial?: boolean
    printAndPattern?: boolean
    upperMaterial?: boolean
    closure?: boolean
    toeType?: boolean
    weight?: boolean
    colorFamily?: boolean
    productDescription?: boolean
    packageContains?: boolean
    commonDescriptionId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    warranty?: boolean | ShoesDescription$warrantyArgs<ExtArgs>
    commonDescription?: boolean | CommonDescriptionArgs<ExtArgs>
    _count?: boolean | ShoesDescriptionCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["shoesDescription"]>

  export type ShoesDescriptionSelectScalar = {
    id?: boolean
    pattern?: boolean
    footLength?: boolean
    type?: boolean
    soleMaterial?: boolean
    printAndPattern?: boolean
    upperMaterial?: boolean
    closure?: boolean
    toeType?: boolean
    weight?: boolean
    colorFamily?: boolean
    productDescription?: boolean
    packageContains?: boolean
    commonDescriptionId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type ShoesDescriptionInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    warranty?: boolean | ShoesDescription$warrantyArgs<ExtArgs>
    commonDescription?: boolean | CommonDescriptionArgs<ExtArgs>
    _count?: boolean | ShoesDescriptionCountOutputTypeArgs<ExtArgs>
  }


  type ShoesDescriptionGetPayload<S extends boolean | null | undefined | ShoesDescriptionArgs> = $Types.GetResult<ShoesDescriptionPayload, S>

  type ShoesDescriptionCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ShoesDescriptionFindManyArgs, 'select' | 'include'> & {
      select?: ShoesDescriptionCountAggregateInputType | true
    }

  export interface ShoesDescriptionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ShoesDescription'], meta: { name: 'ShoesDescription' } }
    /**
     * Find zero or one ShoesDescription that matches the filter.
     * @param {ShoesDescriptionFindUniqueArgs} args - Arguments to find a ShoesDescription
     * @example
     * // Get one ShoesDescription
     * const shoesDescription = await prisma.shoesDescription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ShoesDescriptionFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ShoesDescriptionFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ShoesDescription'> extends True ? Prisma__ShoesDescriptionClient<$Types.GetResult<ShoesDescriptionPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ShoesDescriptionClient<$Types.GetResult<ShoesDescriptionPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one ShoesDescription that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ShoesDescriptionFindUniqueOrThrowArgs} args - Arguments to find a ShoesDescription
     * @example
     * // Get one ShoesDescription
     * const shoesDescription = await prisma.shoesDescription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ShoesDescriptionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ShoesDescriptionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ShoesDescriptionClient<$Types.GetResult<ShoesDescriptionPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first ShoesDescription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShoesDescriptionFindFirstArgs} args - Arguments to find a ShoesDescription
     * @example
     * // Get one ShoesDescription
     * const shoesDescription = await prisma.shoesDescription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ShoesDescriptionFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ShoesDescriptionFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ShoesDescription'> extends True ? Prisma__ShoesDescriptionClient<$Types.GetResult<ShoesDescriptionPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ShoesDescriptionClient<$Types.GetResult<ShoesDescriptionPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first ShoesDescription that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShoesDescriptionFindFirstOrThrowArgs} args - Arguments to find a ShoesDescription
     * @example
     * // Get one ShoesDescription
     * const shoesDescription = await prisma.shoesDescription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ShoesDescriptionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ShoesDescriptionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ShoesDescriptionClient<$Types.GetResult<ShoesDescriptionPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more ShoesDescriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShoesDescriptionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShoesDescriptions
     * const shoesDescriptions = await prisma.shoesDescription.findMany()
     * 
     * // Get first 10 ShoesDescriptions
     * const shoesDescriptions = await prisma.shoesDescription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shoesDescriptionWithIdOnly = await prisma.shoesDescription.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ShoesDescriptionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ShoesDescriptionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ShoesDescriptionPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a ShoesDescription.
     * @param {ShoesDescriptionCreateArgs} args - Arguments to create a ShoesDescription.
     * @example
     * // Create one ShoesDescription
     * const ShoesDescription = await prisma.shoesDescription.create({
     *   data: {
     *     // ... data to create a ShoesDescription
     *   }
     * })
     * 
    **/
    create<T extends ShoesDescriptionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ShoesDescriptionCreateArgs<ExtArgs>>
    ): Prisma__ShoesDescriptionClient<$Types.GetResult<ShoesDescriptionPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many ShoesDescriptions.
     *     @param {ShoesDescriptionCreateManyArgs} args - Arguments to create many ShoesDescriptions.
     *     @example
     *     // Create many ShoesDescriptions
     *     const shoesDescription = await prisma.shoesDescription.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ShoesDescriptionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ShoesDescriptionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ShoesDescription.
     * @param {ShoesDescriptionDeleteArgs} args - Arguments to delete one ShoesDescription.
     * @example
     * // Delete one ShoesDescription
     * const ShoesDescription = await prisma.shoesDescription.delete({
     *   where: {
     *     // ... filter to delete one ShoesDescription
     *   }
     * })
     * 
    **/
    delete<T extends ShoesDescriptionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ShoesDescriptionDeleteArgs<ExtArgs>>
    ): Prisma__ShoesDescriptionClient<$Types.GetResult<ShoesDescriptionPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one ShoesDescription.
     * @param {ShoesDescriptionUpdateArgs} args - Arguments to update one ShoesDescription.
     * @example
     * // Update one ShoesDescription
     * const shoesDescription = await prisma.shoesDescription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ShoesDescriptionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ShoesDescriptionUpdateArgs<ExtArgs>>
    ): Prisma__ShoesDescriptionClient<$Types.GetResult<ShoesDescriptionPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more ShoesDescriptions.
     * @param {ShoesDescriptionDeleteManyArgs} args - Arguments to filter ShoesDescriptions to delete.
     * @example
     * // Delete a few ShoesDescriptions
     * const { count } = await prisma.shoesDescription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ShoesDescriptionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ShoesDescriptionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShoesDescriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShoesDescriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShoesDescriptions
     * const shoesDescription = await prisma.shoesDescription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ShoesDescriptionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ShoesDescriptionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ShoesDescription.
     * @param {ShoesDescriptionUpsertArgs} args - Arguments to update or create a ShoesDescription.
     * @example
     * // Update or create a ShoesDescription
     * const shoesDescription = await prisma.shoesDescription.upsert({
     *   create: {
     *     // ... data to create a ShoesDescription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShoesDescription we want to update
     *   }
     * })
    **/
    upsert<T extends ShoesDescriptionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ShoesDescriptionUpsertArgs<ExtArgs>>
    ): Prisma__ShoesDescriptionClient<$Types.GetResult<ShoesDescriptionPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of ShoesDescriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShoesDescriptionCountArgs} args - Arguments to filter ShoesDescriptions to count.
     * @example
     * // Count the number of ShoesDescriptions
     * const count = await prisma.shoesDescription.count({
     *   where: {
     *     // ... the filter for the ShoesDescriptions we want to count
     *   }
     * })
    **/
    count<T extends ShoesDescriptionCountArgs>(
      args?: Subset<T, ShoesDescriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShoesDescriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShoesDescription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShoesDescriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShoesDescriptionAggregateArgs>(args: Subset<T, ShoesDescriptionAggregateArgs>): Prisma.PrismaPromise<GetShoesDescriptionAggregateType<T>>

    /**
     * Group by ShoesDescription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShoesDescriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShoesDescriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShoesDescriptionGroupByArgs['orderBy'] }
        : { orderBy?: ShoesDescriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShoesDescriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShoesDescriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ShoesDescription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ShoesDescriptionClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    warranty<T extends ShoesDescription$warrantyArgs<ExtArgs> = {}>(args?: Subset<T, ShoesDescription$warrantyArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<WarrantyPayload<ExtArgs>, T, 'findMany', never>| Null>;

    commonDescription<T extends CommonDescriptionArgs<ExtArgs> = {}>(args?: Subset<T, CommonDescriptionArgs<ExtArgs>>): Prisma__CommonDescriptionClient<$Types.GetResult<CommonDescriptionPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ShoesDescription base type for findUnique actions
   */
  export type ShoesDescriptionFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShoesDescription
     */
    select?: ShoesDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShoesDescriptionInclude<ExtArgs> | null
    /**
     * Filter, which ShoesDescription to fetch.
     */
    where: ShoesDescriptionWhereUniqueInput
  }

  /**
   * ShoesDescription findUnique
   */
  export interface ShoesDescriptionFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ShoesDescriptionFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ShoesDescription findUniqueOrThrow
   */
  export type ShoesDescriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShoesDescription
     */
    select?: ShoesDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShoesDescriptionInclude<ExtArgs> | null
    /**
     * Filter, which ShoesDescription to fetch.
     */
    where: ShoesDescriptionWhereUniqueInput
  }


  /**
   * ShoesDescription base type for findFirst actions
   */
  export type ShoesDescriptionFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShoesDescription
     */
    select?: ShoesDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShoesDescriptionInclude<ExtArgs> | null
    /**
     * Filter, which ShoesDescription to fetch.
     */
    where?: ShoesDescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShoesDescriptions to fetch.
     */
    orderBy?: Enumerable<ShoesDescriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShoesDescriptions.
     */
    cursor?: ShoesDescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShoesDescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShoesDescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShoesDescriptions.
     */
    distinct?: Enumerable<ShoesDescriptionScalarFieldEnum>
  }

  /**
   * ShoesDescription findFirst
   */
  export interface ShoesDescriptionFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ShoesDescriptionFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ShoesDescription findFirstOrThrow
   */
  export type ShoesDescriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShoesDescription
     */
    select?: ShoesDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShoesDescriptionInclude<ExtArgs> | null
    /**
     * Filter, which ShoesDescription to fetch.
     */
    where?: ShoesDescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShoesDescriptions to fetch.
     */
    orderBy?: Enumerable<ShoesDescriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShoesDescriptions.
     */
    cursor?: ShoesDescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShoesDescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShoesDescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShoesDescriptions.
     */
    distinct?: Enumerable<ShoesDescriptionScalarFieldEnum>
  }


  /**
   * ShoesDescription findMany
   */
  export type ShoesDescriptionFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShoesDescription
     */
    select?: ShoesDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShoesDescriptionInclude<ExtArgs> | null
    /**
     * Filter, which ShoesDescriptions to fetch.
     */
    where?: ShoesDescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShoesDescriptions to fetch.
     */
    orderBy?: Enumerable<ShoesDescriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShoesDescriptions.
     */
    cursor?: ShoesDescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShoesDescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShoesDescriptions.
     */
    skip?: number
    distinct?: Enumerable<ShoesDescriptionScalarFieldEnum>
  }


  /**
   * ShoesDescription create
   */
  export type ShoesDescriptionCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShoesDescription
     */
    select?: ShoesDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShoesDescriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a ShoesDescription.
     */
    data: XOR<ShoesDescriptionCreateInput, ShoesDescriptionUncheckedCreateInput>
  }


  /**
   * ShoesDescription createMany
   */
  export type ShoesDescriptionCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ShoesDescriptions.
     */
    data: Enumerable<ShoesDescriptionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ShoesDescription update
   */
  export type ShoesDescriptionUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShoesDescription
     */
    select?: ShoesDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShoesDescriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a ShoesDescription.
     */
    data: XOR<ShoesDescriptionUpdateInput, ShoesDescriptionUncheckedUpdateInput>
    /**
     * Choose, which ShoesDescription to update.
     */
    where: ShoesDescriptionWhereUniqueInput
  }


  /**
   * ShoesDescription updateMany
   */
  export type ShoesDescriptionUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ShoesDescriptions.
     */
    data: XOR<ShoesDescriptionUpdateManyMutationInput, ShoesDescriptionUncheckedUpdateManyInput>
    /**
     * Filter which ShoesDescriptions to update
     */
    where?: ShoesDescriptionWhereInput
  }


  /**
   * ShoesDescription upsert
   */
  export type ShoesDescriptionUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShoesDescription
     */
    select?: ShoesDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShoesDescriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the ShoesDescription to update in case it exists.
     */
    where: ShoesDescriptionWhereUniqueInput
    /**
     * In case the ShoesDescription found by the `where` argument doesn't exist, create a new ShoesDescription with this data.
     */
    create: XOR<ShoesDescriptionCreateInput, ShoesDescriptionUncheckedCreateInput>
    /**
     * In case the ShoesDescription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShoesDescriptionUpdateInput, ShoesDescriptionUncheckedUpdateInput>
  }


  /**
   * ShoesDescription delete
   */
  export type ShoesDescriptionDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShoesDescription
     */
    select?: ShoesDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShoesDescriptionInclude<ExtArgs> | null
    /**
     * Filter which ShoesDescription to delete.
     */
    where: ShoesDescriptionWhereUniqueInput
  }


  /**
   * ShoesDescription deleteMany
   */
  export type ShoesDescriptionDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShoesDescriptions to delete
     */
    where?: ShoesDescriptionWhereInput
  }


  /**
   * ShoesDescription.warranty
   */
  export type ShoesDescription$warrantyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warranty
     */
    select?: WarrantySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WarrantyInclude<ExtArgs> | null
    where?: WarrantyWhereInput
    orderBy?: Enumerable<WarrantyOrderByWithRelationInput>
    cursor?: WarrantyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<WarrantyScalarFieldEnum>
  }


  /**
   * ShoesDescription without action
   */
  export type ShoesDescriptionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShoesDescription
     */
    select?: ShoesDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShoesDescriptionInclude<ExtArgs> | null
  }



  /**
   * Model WatchesDescription
   */


  export type AggregateWatchesDescription = {
    _count: WatchesDescriptionCountAggregateOutputType | null
    _avg: WatchesDescriptionAvgAggregateOutputType | null
    _sum: WatchesDescriptionSumAggregateOutputType | null
    _min: WatchesDescriptionMinAggregateOutputType | null
    _max: WatchesDescriptionMaxAggregateOutputType | null
  }

  export type WatchesDescriptionAvgAggregateOutputType = {
    id: number | null
    weight: number | null
    commonDescriptionId: number | null
  }

  export type WatchesDescriptionSumAggregateOutputType = {
    id: number | null
    weight: number | null
    commonDescriptionId: number | null
  }

  export type WatchesDescriptionMinAggregateOutputType = {
    id: number | null
    type: string | null
    weight: number | null
    model: string | null
    dialShape: string | null
    printAndPattern: string | null
    dialDiameter: string | null
    dialColor: string | null
    strapColor: string | null
    colorFamily: string | null
    productDescription: string | null
    commonDescriptionId: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type WatchesDescriptionMaxAggregateOutputType = {
    id: number | null
    type: string | null
    weight: number | null
    model: string | null
    dialShape: string | null
    printAndPattern: string | null
    dialDiameter: string | null
    dialColor: string | null
    strapColor: string | null
    colorFamily: string | null
    productDescription: string | null
    commonDescriptionId: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type WatchesDescriptionCountAggregateOutputType = {
    id: number
    type: number
    weight: number
    model: number
    dialShape: number
    printAndPattern: number
    dialDiameter: number
    dialColor: number
    strapColor: number
    colorFamily: number
    productDescription: number
    commonDescriptionId: number
    isActive: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type WatchesDescriptionAvgAggregateInputType = {
    id?: true
    weight?: true
    commonDescriptionId?: true
  }

  export type WatchesDescriptionSumAggregateInputType = {
    id?: true
    weight?: true
    commonDescriptionId?: true
  }

  export type WatchesDescriptionMinAggregateInputType = {
    id?: true
    type?: true
    weight?: true
    model?: true
    dialShape?: true
    printAndPattern?: true
    dialDiameter?: true
    dialColor?: true
    strapColor?: true
    colorFamily?: true
    productDescription?: true
    commonDescriptionId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type WatchesDescriptionMaxAggregateInputType = {
    id?: true
    type?: true
    weight?: true
    model?: true
    dialShape?: true
    printAndPattern?: true
    dialDiameter?: true
    dialColor?: true
    strapColor?: true
    colorFamily?: true
    productDescription?: true
    commonDescriptionId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type WatchesDescriptionCountAggregateInputType = {
    id?: true
    type?: true
    weight?: true
    model?: true
    dialShape?: true
    printAndPattern?: true
    dialDiameter?: true
    dialColor?: true
    strapColor?: true
    colorFamily?: true
    productDescription?: true
    commonDescriptionId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type WatchesDescriptionAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which WatchesDescription to aggregate.
     */
    where?: WatchesDescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WatchesDescriptions to fetch.
     */
    orderBy?: Enumerable<WatchesDescriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WatchesDescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WatchesDescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WatchesDescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WatchesDescriptions
    **/
    _count?: true | WatchesDescriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WatchesDescriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WatchesDescriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WatchesDescriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WatchesDescriptionMaxAggregateInputType
  }

  export type GetWatchesDescriptionAggregateType<T extends WatchesDescriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateWatchesDescription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWatchesDescription[P]>
      : GetScalarType<T[P], AggregateWatchesDescription[P]>
  }




  export type WatchesDescriptionGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: WatchesDescriptionWhereInput
    orderBy?: Enumerable<WatchesDescriptionOrderByWithAggregationInput>
    by: WatchesDescriptionScalarFieldEnum[]
    having?: WatchesDescriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WatchesDescriptionCountAggregateInputType | true
    _avg?: WatchesDescriptionAvgAggregateInputType
    _sum?: WatchesDescriptionSumAggregateInputType
    _min?: WatchesDescriptionMinAggregateInputType
    _max?: WatchesDescriptionMaxAggregateInputType
  }


  export type WatchesDescriptionGroupByOutputType = {
    id: number
    type: string | null
    weight: number
    model: string
    dialShape: string
    printAndPattern: string | null
    dialDiameter: string
    dialColor: string
    strapColor: string
    colorFamily: string | null
    productDescription: string | null
    commonDescriptionId: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: WatchesDescriptionCountAggregateOutputType | null
    _avg: WatchesDescriptionAvgAggregateOutputType | null
    _sum: WatchesDescriptionSumAggregateOutputType | null
    _min: WatchesDescriptionMinAggregateOutputType | null
    _max: WatchesDescriptionMaxAggregateOutputType | null
  }

  type GetWatchesDescriptionGroupByPayload<T extends WatchesDescriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<WatchesDescriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WatchesDescriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WatchesDescriptionGroupByOutputType[P]>
            : GetScalarType<T[P], WatchesDescriptionGroupByOutputType[P]>
        }
      >
    >


  export type WatchesDescriptionSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    weight?: boolean
    model?: boolean
    dialShape?: boolean
    printAndPattern?: boolean
    dialDiameter?: boolean
    dialColor?: boolean
    strapColor?: boolean
    colorFamily?: boolean
    productDescription?: boolean
    commonDescriptionId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    warranty?: boolean | WatchesDescription$warrantyArgs<ExtArgs>
    commonDescription?: boolean | CommonDescriptionArgs<ExtArgs>
    _count?: boolean | WatchesDescriptionCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["watchesDescription"]>

  export type WatchesDescriptionSelectScalar = {
    id?: boolean
    type?: boolean
    weight?: boolean
    model?: boolean
    dialShape?: boolean
    printAndPattern?: boolean
    dialDiameter?: boolean
    dialColor?: boolean
    strapColor?: boolean
    colorFamily?: boolean
    productDescription?: boolean
    commonDescriptionId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type WatchesDescriptionInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    warranty?: boolean | WatchesDescription$warrantyArgs<ExtArgs>
    commonDescription?: boolean | CommonDescriptionArgs<ExtArgs>
    _count?: boolean | WatchesDescriptionCountOutputTypeArgs<ExtArgs>
  }


  type WatchesDescriptionGetPayload<S extends boolean | null | undefined | WatchesDescriptionArgs> = $Types.GetResult<WatchesDescriptionPayload, S>

  type WatchesDescriptionCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<WatchesDescriptionFindManyArgs, 'select' | 'include'> & {
      select?: WatchesDescriptionCountAggregateInputType | true
    }

  export interface WatchesDescriptionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WatchesDescription'], meta: { name: 'WatchesDescription' } }
    /**
     * Find zero or one WatchesDescription that matches the filter.
     * @param {WatchesDescriptionFindUniqueArgs} args - Arguments to find a WatchesDescription
     * @example
     * // Get one WatchesDescription
     * const watchesDescription = await prisma.watchesDescription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WatchesDescriptionFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, WatchesDescriptionFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'WatchesDescription'> extends True ? Prisma__WatchesDescriptionClient<$Types.GetResult<WatchesDescriptionPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__WatchesDescriptionClient<$Types.GetResult<WatchesDescriptionPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one WatchesDescription that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {WatchesDescriptionFindUniqueOrThrowArgs} args - Arguments to find a WatchesDescription
     * @example
     * // Get one WatchesDescription
     * const watchesDescription = await prisma.watchesDescription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends WatchesDescriptionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WatchesDescriptionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__WatchesDescriptionClient<$Types.GetResult<WatchesDescriptionPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first WatchesDescription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchesDescriptionFindFirstArgs} args - Arguments to find a WatchesDescription
     * @example
     * // Get one WatchesDescription
     * const watchesDescription = await prisma.watchesDescription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WatchesDescriptionFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, WatchesDescriptionFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'WatchesDescription'> extends True ? Prisma__WatchesDescriptionClient<$Types.GetResult<WatchesDescriptionPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__WatchesDescriptionClient<$Types.GetResult<WatchesDescriptionPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first WatchesDescription that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchesDescriptionFindFirstOrThrowArgs} args - Arguments to find a WatchesDescription
     * @example
     * // Get one WatchesDescription
     * const watchesDescription = await prisma.watchesDescription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends WatchesDescriptionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WatchesDescriptionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__WatchesDescriptionClient<$Types.GetResult<WatchesDescriptionPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more WatchesDescriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchesDescriptionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WatchesDescriptions
     * const watchesDescriptions = await prisma.watchesDescription.findMany()
     * 
     * // Get first 10 WatchesDescriptions
     * const watchesDescriptions = await prisma.watchesDescription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const watchesDescriptionWithIdOnly = await prisma.watchesDescription.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WatchesDescriptionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WatchesDescriptionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<WatchesDescriptionPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a WatchesDescription.
     * @param {WatchesDescriptionCreateArgs} args - Arguments to create a WatchesDescription.
     * @example
     * // Create one WatchesDescription
     * const WatchesDescription = await prisma.watchesDescription.create({
     *   data: {
     *     // ... data to create a WatchesDescription
     *   }
     * })
     * 
    **/
    create<T extends WatchesDescriptionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, WatchesDescriptionCreateArgs<ExtArgs>>
    ): Prisma__WatchesDescriptionClient<$Types.GetResult<WatchesDescriptionPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many WatchesDescriptions.
     *     @param {WatchesDescriptionCreateManyArgs} args - Arguments to create many WatchesDescriptions.
     *     @example
     *     // Create many WatchesDescriptions
     *     const watchesDescription = await prisma.watchesDescription.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WatchesDescriptionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WatchesDescriptionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WatchesDescription.
     * @param {WatchesDescriptionDeleteArgs} args - Arguments to delete one WatchesDescription.
     * @example
     * // Delete one WatchesDescription
     * const WatchesDescription = await prisma.watchesDescription.delete({
     *   where: {
     *     // ... filter to delete one WatchesDescription
     *   }
     * })
     * 
    **/
    delete<T extends WatchesDescriptionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, WatchesDescriptionDeleteArgs<ExtArgs>>
    ): Prisma__WatchesDescriptionClient<$Types.GetResult<WatchesDescriptionPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one WatchesDescription.
     * @param {WatchesDescriptionUpdateArgs} args - Arguments to update one WatchesDescription.
     * @example
     * // Update one WatchesDescription
     * const watchesDescription = await prisma.watchesDescription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WatchesDescriptionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, WatchesDescriptionUpdateArgs<ExtArgs>>
    ): Prisma__WatchesDescriptionClient<$Types.GetResult<WatchesDescriptionPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more WatchesDescriptions.
     * @param {WatchesDescriptionDeleteManyArgs} args - Arguments to filter WatchesDescriptions to delete.
     * @example
     * // Delete a few WatchesDescriptions
     * const { count } = await prisma.watchesDescription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WatchesDescriptionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WatchesDescriptionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WatchesDescriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchesDescriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WatchesDescriptions
     * const watchesDescription = await prisma.watchesDescription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WatchesDescriptionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, WatchesDescriptionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WatchesDescription.
     * @param {WatchesDescriptionUpsertArgs} args - Arguments to update or create a WatchesDescription.
     * @example
     * // Update or create a WatchesDescription
     * const watchesDescription = await prisma.watchesDescription.upsert({
     *   create: {
     *     // ... data to create a WatchesDescription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WatchesDescription we want to update
     *   }
     * })
    **/
    upsert<T extends WatchesDescriptionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, WatchesDescriptionUpsertArgs<ExtArgs>>
    ): Prisma__WatchesDescriptionClient<$Types.GetResult<WatchesDescriptionPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of WatchesDescriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchesDescriptionCountArgs} args - Arguments to filter WatchesDescriptions to count.
     * @example
     * // Count the number of WatchesDescriptions
     * const count = await prisma.watchesDescription.count({
     *   where: {
     *     // ... the filter for the WatchesDescriptions we want to count
     *   }
     * })
    **/
    count<T extends WatchesDescriptionCountArgs>(
      args?: Subset<T, WatchesDescriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WatchesDescriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WatchesDescription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchesDescriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WatchesDescriptionAggregateArgs>(args: Subset<T, WatchesDescriptionAggregateArgs>): Prisma.PrismaPromise<GetWatchesDescriptionAggregateType<T>>

    /**
     * Group by WatchesDescription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchesDescriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WatchesDescriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WatchesDescriptionGroupByArgs['orderBy'] }
        : { orderBy?: WatchesDescriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WatchesDescriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWatchesDescriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for WatchesDescription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__WatchesDescriptionClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    warranty<T extends WatchesDescription$warrantyArgs<ExtArgs> = {}>(args?: Subset<T, WatchesDescription$warrantyArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<WarrantyPayload<ExtArgs>, T, 'findMany', never>| Null>;

    commonDescription<T extends CommonDescriptionArgs<ExtArgs> = {}>(args?: Subset<T, CommonDescriptionArgs<ExtArgs>>): Prisma__CommonDescriptionClient<$Types.GetResult<CommonDescriptionPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * WatchesDescription base type for findUnique actions
   */
  export type WatchesDescriptionFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchesDescription
     */
    select?: WatchesDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WatchesDescriptionInclude<ExtArgs> | null
    /**
     * Filter, which WatchesDescription to fetch.
     */
    where: WatchesDescriptionWhereUniqueInput
  }

  /**
   * WatchesDescription findUnique
   */
  export interface WatchesDescriptionFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends WatchesDescriptionFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * WatchesDescription findUniqueOrThrow
   */
  export type WatchesDescriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchesDescription
     */
    select?: WatchesDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WatchesDescriptionInclude<ExtArgs> | null
    /**
     * Filter, which WatchesDescription to fetch.
     */
    where: WatchesDescriptionWhereUniqueInput
  }


  /**
   * WatchesDescription base type for findFirst actions
   */
  export type WatchesDescriptionFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchesDescription
     */
    select?: WatchesDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WatchesDescriptionInclude<ExtArgs> | null
    /**
     * Filter, which WatchesDescription to fetch.
     */
    where?: WatchesDescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WatchesDescriptions to fetch.
     */
    orderBy?: Enumerable<WatchesDescriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WatchesDescriptions.
     */
    cursor?: WatchesDescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WatchesDescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WatchesDescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WatchesDescriptions.
     */
    distinct?: Enumerable<WatchesDescriptionScalarFieldEnum>
  }

  /**
   * WatchesDescription findFirst
   */
  export interface WatchesDescriptionFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends WatchesDescriptionFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * WatchesDescription findFirstOrThrow
   */
  export type WatchesDescriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchesDescription
     */
    select?: WatchesDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WatchesDescriptionInclude<ExtArgs> | null
    /**
     * Filter, which WatchesDescription to fetch.
     */
    where?: WatchesDescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WatchesDescriptions to fetch.
     */
    orderBy?: Enumerable<WatchesDescriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WatchesDescriptions.
     */
    cursor?: WatchesDescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WatchesDescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WatchesDescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WatchesDescriptions.
     */
    distinct?: Enumerable<WatchesDescriptionScalarFieldEnum>
  }


  /**
   * WatchesDescription findMany
   */
  export type WatchesDescriptionFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchesDescription
     */
    select?: WatchesDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WatchesDescriptionInclude<ExtArgs> | null
    /**
     * Filter, which WatchesDescriptions to fetch.
     */
    where?: WatchesDescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WatchesDescriptions to fetch.
     */
    orderBy?: Enumerable<WatchesDescriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WatchesDescriptions.
     */
    cursor?: WatchesDescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WatchesDescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WatchesDescriptions.
     */
    skip?: number
    distinct?: Enumerable<WatchesDescriptionScalarFieldEnum>
  }


  /**
   * WatchesDescription create
   */
  export type WatchesDescriptionCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchesDescription
     */
    select?: WatchesDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WatchesDescriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a WatchesDescription.
     */
    data: XOR<WatchesDescriptionCreateInput, WatchesDescriptionUncheckedCreateInput>
  }


  /**
   * WatchesDescription createMany
   */
  export type WatchesDescriptionCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WatchesDescriptions.
     */
    data: Enumerable<WatchesDescriptionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * WatchesDescription update
   */
  export type WatchesDescriptionUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchesDescription
     */
    select?: WatchesDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WatchesDescriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a WatchesDescription.
     */
    data: XOR<WatchesDescriptionUpdateInput, WatchesDescriptionUncheckedUpdateInput>
    /**
     * Choose, which WatchesDescription to update.
     */
    where: WatchesDescriptionWhereUniqueInput
  }


  /**
   * WatchesDescription updateMany
   */
  export type WatchesDescriptionUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WatchesDescriptions.
     */
    data: XOR<WatchesDescriptionUpdateManyMutationInput, WatchesDescriptionUncheckedUpdateManyInput>
    /**
     * Filter which WatchesDescriptions to update
     */
    where?: WatchesDescriptionWhereInput
  }


  /**
   * WatchesDescription upsert
   */
  export type WatchesDescriptionUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchesDescription
     */
    select?: WatchesDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WatchesDescriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the WatchesDescription to update in case it exists.
     */
    where: WatchesDescriptionWhereUniqueInput
    /**
     * In case the WatchesDescription found by the `where` argument doesn't exist, create a new WatchesDescription with this data.
     */
    create: XOR<WatchesDescriptionCreateInput, WatchesDescriptionUncheckedCreateInput>
    /**
     * In case the WatchesDescription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WatchesDescriptionUpdateInput, WatchesDescriptionUncheckedUpdateInput>
  }


  /**
   * WatchesDescription delete
   */
  export type WatchesDescriptionDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchesDescription
     */
    select?: WatchesDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WatchesDescriptionInclude<ExtArgs> | null
    /**
     * Filter which WatchesDescription to delete.
     */
    where: WatchesDescriptionWhereUniqueInput
  }


  /**
   * WatchesDescription deleteMany
   */
  export type WatchesDescriptionDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which WatchesDescriptions to delete
     */
    where?: WatchesDescriptionWhereInput
  }


  /**
   * WatchesDescription.warranty
   */
  export type WatchesDescription$warrantyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warranty
     */
    select?: WarrantySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WarrantyInclude<ExtArgs> | null
    where?: WarrantyWhereInput
    orderBy?: Enumerable<WarrantyOrderByWithRelationInput>
    cursor?: WarrantyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<WarrantyScalarFieldEnum>
  }


  /**
   * WatchesDescription without action
   */
  export type WatchesDescriptionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchesDescription
     */
    select?: WatchesDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WatchesDescriptionInclude<ExtArgs> | null
  }



  /**
   * Model PerfumesDescription
   */


  export type AggregatePerfumesDescription = {
    _count: PerfumesDescriptionCountAggregateOutputType | null
    _avg: PerfumesDescriptionAvgAggregateOutputType | null
    _sum: PerfumesDescriptionSumAggregateOutputType | null
    _min: PerfumesDescriptionMinAggregateOutputType | null
    _max: PerfumesDescriptionMaxAggregateOutputType | null
  }

  export type PerfumesDescriptionAvgAggregateOutputType = {
    id: number | null
    weight: number | null
    commonDescriptionId: number | null
  }

  export type PerfumesDescriptionSumAggregateOutputType = {
    id: number | null
    weight: number | null
    commonDescriptionId: number | null
  }

  export type PerfumesDescriptionMinAggregateOutputType = {
    id: number | null
    productDescription: string | null
    type: string | null
    materialDescription: string | null
    weight: number | null
    commonDescriptionId: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type PerfumesDescriptionMaxAggregateOutputType = {
    id: number | null
    productDescription: string | null
    type: string | null
    materialDescription: string | null
    weight: number | null
    commonDescriptionId: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type PerfumesDescriptionCountAggregateOutputType = {
    id: number
    productDescription: number
    type: number
    materialDescription: number
    weight: number
    commonDescriptionId: number
    isActive: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type PerfumesDescriptionAvgAggregateInputType = {
    id?: true
    weight?: true
    commonDescriptionId?: true
  }

  export type PerfumesDescriptionSumAggregateInputType = {
    id?: true
    weight?: true
    commonDescriptionId?: true
  }

  export type PerfumesDescriptionMinAggregateInputType = {
    id?: true
    productDescription?: true
    type?: true
    materialDescription?: true
    weight?: true
    commonDescriptionId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type PerfumesDescriptionMaxAggregateInputType = {
    id?: true
    productDescription?: true
    type?: true
    materialDescription?: true
    weight?: true
    commonDescriptionId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type PerfumesDescriptionCountAggregateInputType = {
    id?: true
    productDescription?: true
    type?: true
    materialDescription?: true
    weight?: true
    commonDescriptionId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type PerfumesDescriptionAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which PerfumesDescription to aggregate.
     */
    where?: PerfumesDescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerfumesDescriptions to fetch.
     */
    orderBy?: Enumerable<PerfumesDescriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PerfumesDescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerfumesDescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerfumesDescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PerfumesDescriptions
    **/
    _count?: true | PerfumesDescriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PerfumesDescriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PerfumesDescriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PerfumesDescriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PerfumesDescriptionMaxAggregateInputType
  }

  export type GetPerfumesDescriptionAggregateType<T extends PerfumesDescriptionAggregateArgs> = {
        [P in keyof T & keyof AggregatePerfumesDescription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePerfumesDescription[P]>
      : GetScalarType<T[P], AggregatePerfumesDescription[P]>
  }




  export type PerfumesDescriptionGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PerfumesDescriptionWhereInput
    orderBy?: Enumerable<PerfumesDescriptionOrderByWithAggregationInput>
    by: PerfumesDescriptionScalarFieldEnum[]
    having?: PerfumesDescriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PerfumesDescriptionCountAggregateInputType | true
    _avg?: PerfumesDescriptionAvgAggregateInputType
    _sum?: PerfumesDescriptionSumAggregateInputType
    _min?: PerfumesDescriptionMinAggregateInputType
    _max?: PerfumesDescriptionMaxAggregateInputType
  }


  export type PerfumesDescriptionGroupByOutputType = {
    id: number
    productDescription: string
    type: string | null
    materialDescription: string
    weight: number
    commonDescriptionId: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: PerfumesDescriptionCountAggregateOutputType | null
    _avg: PerfumesDescriptionAvgAggregateOutputType | null
    _sum: PerfumesDescriptionSumAggregateOutputType | null
    _min: PerfumesDescriptionMinAggregateOutputType | null
    _max: PerfumesDescriptionMaxAggregateOutputType | null
  }

  type GetPerfumesDescriptionGroupByPayload<T extends PerfumesDescriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PerfumesDescriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PerfumesDescriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PerfumesDescriptionGroupByOutputType[P]>
            : GetScalarType<T[P], PerfumesDescriptionGroupByOutputType[P]>
        }
      >
    >


  export type PerfumesDescriptionSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productDescription?: boolean
    type?: boolean
    materialDescription?: boolean
    weight?: boolean
    commonDescriptionId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    commonDescription?: boolean | CommonDescriptionArgs<ExtArgs>
  }, ExtArgs["result"]["perfumesDescription"]>

  export type PerfumesDescriptionSelectScalar = {
    id?: boolean
    productDescription?: boolean
    type?: boolean
    materialDescription?: boolean
    weight?: boolean
    commonDescriptionId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type PerfumesDescriptionInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    commonDescription?: boolean | CommonDescriptionArgs<ExtArgs>
  }


  type PerfumesDescriptionGetPayload<S extends boolean | null | undefined | PerfumesDescriptionArgs> = $Types.GetResult<PerfumesDescriptionPayload, S>

  type PerfumesDescriptionCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<PerfumesDescriptionFindManyArgs, 'select' | 'include'> & {
      select?: PerfumesDescriptionCountAggregateInputType | true
    }

  export interface PerfumesDescriptionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PerfumesDescription'], meta: { name: 'PerfumesDescription' } }
    /**
     * Find zero or one PerfumesDescription that matches the filter.
     * @param {PerfumesDescriptionFindUniqueArgs} args - Arguments to find a PerfumesDescription
     * @example
     * // Get one PerfumesDescription
     * const perfumesDescription = await prisma.perfumesDescription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PerfumesDescriptionFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PerfumesDescriptionFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PerfumesDescription'> extends True ? Prisma__PerfumesDescriptionClient<$Types.GetResult<PerfumesDescriptionPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__PerfumesDescriptionClient<$Types.GetResult<PerfumesDescriptionPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one PerfumesDescription that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PerfumesDescriptionFindUniqueOrThrowArgs} args - Arguments to find a PerfumesDescription
     * @example
     * // Get one PerfumesDescription
     * const perfumesDescription = await prisma.perfumesDescription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PerfumesDescriptionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PerfumesDescriptionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PerfumesDescriptionClient<$Types.GetResult<PerfumesDescriptionPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first PerfumesDescription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerfumesDescriptionFindFirstArgs} args - Arguments to find a PerfumesDescription
     * @example
     * // Get one PerfumesDescription
     * const perfumesDescription = await prisma.perfumesDescription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PerfumesDescriptionFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PerfumesDescriptionFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PerfumesDescription'> extends True ? Prisma__PerfumesDescriptionClient<$Types.GetResult<PerfumesDescriptionPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__PerfumesDescriptionClient<$Types.GetResult<PerfumesDescriptionPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first PerfumesDescription that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerfumesDescriptionFindFirstOrThrowArgs} args - Arguments to find a PerfumesDescription
     * @example
     * // Get one PerfumesDescription
     * const perfumesDescription = await prisma.perfumesDescription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PerfumesDescriptionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PerfumesDescriptionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PerfumesDescriptionClient<$Types.GetResult<PerfumesDescriptionPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more PerfumesDescriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerfumesDescriptionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PerfumesDescriptions
     * const perfumesDescriptions = await prisma.perfumesDescription.findMany()
     * 
     * // Get first 10 PerfumesDescriptions
     * const perfumesDescriptions = await prisma.perfumesDescription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const perfumesDescriptionWithIdOnly = await prisma.perfumesDescription.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PerfumesDescriptionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PerfumesDescriptionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<PerfumesDescriptionPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a PerfumesDescription.
     * @param {PerfumesDescriptionCreateArgs} args - Arguments to create a PerfumesDescription.
     * @example
     * // Create one PerfumesDescription
     * const PerfumesDescription = await prisma.perfumesDescription.create({
     *   data: {
     *     // ... data to create a PerfumesDescription
     *   }
     * })
     * 
    **/
    create<T extends PerfumesDescriptionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PerfumesDescriptionCreateArgs<ExtArgs>>
    ): Prisma__PerfumesDescriptionClient<$Types.GetResult<PerfumesDescriptionPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many PerfumesDescriptions.
     *     @param {PerfumesDescriptionCreateManyArgs} args - Arguments to create many PerfumesDescriptions.
     *     @example
     *     // Create many PerfumesDescriptions
     *     const perfumesDescription = await prisma.perfumesDescription.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PerfumesDescriptionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PerfumesDescriptionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PerfumesDescription.
     * @param {PerfumesDescriptionDeleteArgs} args - Arguments to delete one PerfumesDescription.
     * @example
     * // Delete one PerfumesDescription
     * const PerfumesDescription = await prisma.perfumesDescription.delete({
     *   where: {
     *     // ... filter to delete one PerfumesDescription
     *   }
     * })
     * 
    **/
    delete<T extends PerfumesDescriptionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PerfumesDescriptionDeleteArgs<ExtArgs>>
    ): Prisma__PerfumesDescriptionClient<$Types.GetResult<PerfumesDescriptionPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one PerfumesDescription.
     * @param {PerfumesDescriptionUpdateArgs} args - Arguments to update one PerfumesDescription.
     * @example
     * // Update one PerfumesDescription
     * const perfumesDescription = await prisma.perfumesDescription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PerfumesDescriptionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PerfumesDescriptionUpdateArgs<ExtArgs>>
    ): Prisma__PerfumesDescriptionClient<$Types.GetResult<PerfumesDescriptionPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more PerfumesDescriptions.
     * @param {PerfumesDescriptionDeleteManyArgs} args - Arguments to filter PerfumesDescriptions to delete.
     * @example
     * // Delete a few PerfumesDescriptions
     * const { count } = await prisma.perfumesDescription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PerfumesDescriptionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PerfumesDescriptionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PerfumesDescriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerfumesDescriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PerfumesDescriptions
     * const perfumesDescription = await prisma.perfumesDescription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PerfumesDescriptionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PerfumesDescriptionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PerfumesDescription.
     * @param {PerfumesDescriptionUpsertArgs} args - Arguments to update or create a PerfumesDescription.
     * @example
     * // Update or create a PerfumesDescription
     * const perfumesDescription = await prisma.perfumesDescription.upsert({
     *   create: {
     *     // ... data to create a PerfumesDescription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PerfumesDescription we want to update
     *   }
     * })
    **/
    upsert<T extends PerfumesDescriptionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PerfumesDescriptionUpsertArgs<ExtArgs>>
    ): Prisma__PerfumesDescriptionClient<$Types.GetResult<PerfumesDescriptionPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of PerfumesDescriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerfumesDescriptionCountArgs} args - Arguments to filter PerfumesDescriptions to count.
     * @example
     * // Count the number of PerfumesDescriptions
     * const count = await prisma.perfumesDescription.count({
     *   where: {
     *     // ... the filter for the PerfumesDescriptions we want to count
     *   }
     * })
    **/
    count<T extends PerfumesDescriptionCountArgs>(
      args?: Subset<T, PerfumesDescriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PerfumesDescriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PerfumesDescription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerfumesDescriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PerfumesDescriptionAggregateArgs>(args: Subset<T, PerfumesDescriptionAggregateArgs>): Prisma.PrismaPromise<GetPerfumesDescriptionAggregateType<T>>

    /**
     * Group by PerfumesDescription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerfumesDescriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PerfumesDescriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PerfumesDescriptionGroupByArgs['orderBy'] }
        : { orderBy?: PerfumesDescriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PerfumesDescriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPerfumesDescriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for PerfumesDescription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PerfumesDescriptionClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    commonDescription<T extends CommonDescriptionArgs<ExtArgs> = {}>(args?: Subset<T, CommonDescriptionArgs<ExtArgs>>): Prisma__CommonDescriptionClient<$Types.GetResult<CommonDescriptionPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * PerfumesDescription base type for findUnique actions
   */
  export type PerfumesDescriptionFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerfumesDescription
     */
    select?: PerfumesDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PerfumesDescriptionInclude<ExtArgs> | null
    /**
     * Filter, which PerfumesDescription to fetch.
     */
    where: PerfumesDescriptionWhereUniqueInput
  }

  /**
   * PerfumesDescription findUnique
   */
  export interface PerfumesDescriptionFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends PerfumesDescriptionFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PerfumesDescription findUniqueOrThrow
   */
  export type PerfumesDescriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerfumesDescription
     */
    select?: PerfumesDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PerfumesDescriptionInclude<ExtArgs> | null
    /**
     * Filter, which PerfumesDescription to fetch.
     */
    where: PerfumesDescriptionWhereUniqueInput
  }


  /**
   * PerfumesDescription base type for findFirst actions
   */
  export type PerfumesDescriptionFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerfumesDescription
     */
    select?: PerfumesDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PerfumesDescriptionInclude<ExtArgs> | null
    /**
     * Filter, which PerfumesDescription to fetch.
     */
    where?: PerfumesDescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerfumesDescriptions to fetch.
     */
    orderBy?: Enumerable<PerfumesDescriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PerfumesDescriptions.
     */
    cursor?: PerfumesDescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerfumesDescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerfumesDescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PerfumesDescriptions.
     */
    distinct?: Enumerable<PerfumesDescriptionScalarFieldEnum>
  }

  /**
   * PerfumesDescription findFirst
   */
  export interface PerfumesDescriptionFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends PerfumesDescriptionFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PerfumesDescription findFirstOrThrow
   */
  export type PerfumesDescriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerfumesDescription
     */
    select?: PerfumesDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PerfumesDescriptionInclude<ExtArgs> | null
    /**
     * Filter, which PerfumesDescription to fetch.
     */
    where?: PerfumesDescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerfumesDescriptions to fetch.
     */
    orderBy?: Enumerable<PerfumesDescriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PerfumesDescriptions.
     */
    cursor?: PerfumesDescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerfumesDescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerfumesDescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PerfumesDescriptions.
     */
    distinct?: Enumerable<PerfumesDescriptionScalarFieldEnum>
  }


  /**
   * PerfumesDescription findMany
   */
  export type PerfumesDescriptionFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerfumesDescription
     */
    select?: PerfumesDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PerfumesDescriptionInclude<ExtArgs> | null
    /**
     * Filter, which PerfumesDescriptions to fetch.
     */
    where?: PerfumesDescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerfumesDescriptions to fetch.
     */
    orderBy?: Enumerable<PerfumesDescriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PerfumesDescriptions.
     */
    cursor?: PerfumesDescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerfumesDescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerfumesDescriptions.
     */
    skip?: number
    distinct?: Enumerable<PerfumesDescriptionScalarFieldEnum>
  }


  /**
   * PerfumesDescription create
   */
  export type PerfumesDescriptionCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerfumesDescription
     */
    select?: PerfumesDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PerfumesDescriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a PerfumesDescription.
     */
    data: XOR<PerfumesDescriptionCreateInput, PerfumesDescriptionUncheckedCreateInput>
  }


  /**
   * PerfumesDescription createMany
   */
  export type PerfumesDescriptionCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PerfumesDescriptions.
     */
    data: Enumerable<PerfumesDescriptionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PerfumesDescription update
   */
  export type PerfumesDescriptionUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerfumesDescription
     */
    select?: PerfumesDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PerfumesDescriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a PerfumesDescription.
     */
    data: XOR<PerfumesDescriptionUpdateInput, PerfumesDescriptionUncheckedUpdateInput>
    /**
     * Choose, which PerfumesDescription to update.
     */
    where: PerfumesDescriptionWhereUniqueInput
  }


  /**
   * PerfumesDescription updateMany
   */
  export type PerfumesDescriptionUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PerfumesDescriptions.
     */
    data: XOR<PerfumesDescriptionUpdateManyMutationInput, PerfumesDescriptionUncheckedUpdateManyInput>
    /**
     * Filter which PerfumesDescriptions to update
     */
    where?: PerfumesDescriptionWhereInput
  }


  /**
   * PerfumesDescription upsert
   */
  export type PerfumesDescriptionUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerfumesDescription
     */
    select?: PerfumesDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PerfumesDescriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the PerfumesDescription to update in case it exists.
     */
    where: PerfumesDescriptionWhereUniqueInput
    /**
     * In case the PerfumesDescription found by the `where` argument doesn't exist, create a new PerfumesDescription with this data.
     */
    create: XOR<PerfumesDescriptionCreateInput, PerfumesDescriptionUncheckedCreateInput>
    /**
     * In case the PerfumesDescription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PerfumesDescriptionUpdateInput, PerfumesDescriptionUncheckedUpdateInput>
  }


  /**
   * PerfumesDescription delete
   */
  export type PerfumesDescriptionDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerfumesDescription
     */
    select?: PerfumesDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PerfumesDescriptionInclude<ExtArgs> | null
    /**
     * Filter which PerfumesDescription to delete.
     */
    where: PerfumesDescriptionWhereUniqueInput
  }


  /**
   * PerfumesDescription deleteMany
   */
  export type PerfumesDescriptionDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which PerfumesDescriptions to delete
     */
    where?: PerfumesDescriptionWhereInput
  }


  /**
   * PerfumesDescription without action
   */
  export type PerfumesDescriptionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerfumesDescription
     */
    select?: PerfumesDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PerfumesDescriptionInclude<ExtArgs> | null
  }



  /**
   * Model InnersDescription
   */


  export type AggregateInnersDescription = {
    _count: InnersDescriptionCountAggregateOutputType | null
    _avg: InnersDescriptionAvgAggregateOutputType | null
    _sum: InnersDescriptionSumAggregateOutputType | null
    _min: InnersDescriptionMinAggregateOutputType | null
    _max: InnersDescriptionMaxAggregateOutputType | null
  }

  export type InnersDescriptionAvgAggregateOutputType = {
    id: number | null
    weight: number | null
    length: number | null
    waistRise: number | null
    packageContains: number | null
    vestsSleeveTypeId: number | null
    vestsNeckTypeId: number | null
    commonDescriptionId: number | null
  }

  export type InnersDescriptionSumAggregateOutputType = {
    id: number | null
    weight: number | null
    length: number | null
    waistRise: number | null
    packageContains: number | null
    vestsSleeveTypeId: number | null
    vestsNeckTypeId: number | null
    commonDescriptionId: number | null
  }

  export type InnersDescriptionMinAggregateOutputType = {
    id: number | null
    type: string | null
    productDescription: string | null
    weight: number | null
    length: number | null
    waistRise: number | null
    printAndPattern: string | null
    packageContains: number | null
    lookAndFeel: string | null
    colorFamily: string | null
    vestsSleeveTypeId: number | null
    vestsNeckTypeId: number | null
    commonDescriptionId: number | null
    multiColors: boolean | null
  }

  export type InnersDescriptionMaxAggregateOutputType = {
    id: number | null
    type: string | null
    productDescription: string | null
    weight: number | null
    length: number | null
    waistRise: number | null
    printAndPattern: string | null
    packageContains: number | null
    lookAndFeel: string | null
    colorFamily: string | null
    vestsSleeveTypeId: number | null
    vestsNeckTypeId: number | null
    commonDescriptionId: number | null
    multiColors: boolean | null
  }

  export type InnersDescriptionCountAggregateOutputType = {
    id: number
    type: number
    productDescription: number
    weight: number
    length: number
    waistRise: number
    printAndPattern: number
    packageContains: number
    lookAndFeel: number
    colorFamily: number
    vestsSleeveTypeId: number
    vestsNeckTypeId: number
    commonDescriptionId: number
    multiColors: number
    _all: number
  }


  export type InnersDescriptionAvgAggregateInputType = {
    id?: true
    weight?: true
    length?: true
    waistRise?: true
    packageContains?: true
    vestsSleeveTypeId?: true
    vestsNeckTypeId?: true
    commonDescriptionId?: true
  }

  export type InnersDescriptionSumAggregateInputType = {
    id?: true
    weight?: true
    length?: true
    waistRise?: true
    packageContains?: true
    vestsSleeveTypeId?: true
    vestsNeckTypeId?: true
    commonDescriptionId?: true
  }

  export type InnersDescriptionMinAggregateInputType = {
    id?: true
    type?: true
    productDescription?: true
    weight?: true
    length?: true
    waistRise?: true
    printAndPattern?: true
    packageContains?: true
    lookAndFeel?: true
    colorFamily?: true
    vestsSleeveTypeId?: true
    vestsNeckTypeId?: true
    commonDescriptionId?: true
    multiColors?: true
  }

  export type InnersDescriptionMaxAggregateInputType = {
    id?: true
    type?: true
    productDescription?: true
    weight?: true
    length?: true
    waistRise?: true
    printAndPattern?: true
    packageContains?: true
    lookAndFeel?: true
    colorFamily?: true
    vestsSleeveTypeId?: true
    vestsNeckTypeId?: true
    commonDescriptionId?: true
    multiColors?: true
  }

  export type InnersDescriptionCountAggregateInputType = {
    id?: true
    type?: true
    productDescription?: true
    weight?: true
    length?: true
    waistRise?: true
    printAndPattern?: true
    packageContains?: true
    lookAndFeel?: true
    colorFamily?: true
    vestsSleeveTypeId?: true
    vestsNeckTypeId?: true
    commonDescriptionId?: true
    multiColors?: true
    _all?: true
  }

  export type InnersDescriptionAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which InnersDescription to aggregate.
     */
    where?: InnersDescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InnersDescriptions to fetch.
     */
    orderBy?: Enumerable<InnersDescriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InnersDescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InnersDescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InnersDescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InnersDescriptions
    **/
    _count?: true | InnersDescriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InnersDescriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InnersDescriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InnersDescriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InnersDescriptionMaxAggregateInputType
  }

  export type GetInnersDescriptionAggregateType<T extends InnersDescriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateInnersDescription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInnersDescription[P]>
      : GetScalarType<T[P], AggregateInnersDescription[P]>
  }




  export type InnersDescriptionGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: InnersDescriptionWhereInput
    orderBy?: Enumerable<InnersDescriptionOrderByWithAggregationInput>
    by: InnersDescriptionScalarFieldEnum[]
    having?: InnersDescriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InnersDescriptionCountAggregateInputType | true
    _avg?: InnersDescriptionAvgAggregateInputType
    _sum?: InnersDescriptionSumAggregateInputType
    _min?: InnersDescriptionMinAggregateInputType
    _max?: InnersDescriptionMaxAggregateInputType
  }


  export type InnersDescriptionGroupByOutputType = {
    id: number
    type: string
    productDescription: string
    weight: number | null
    length: number
    waistRise: number
    printAndPattern: string | null
    packageContains: number
    lookAndFeel: string
    colorFamily: string | null
    vestsSleeveTypeId: number | null
    vestsNeckTypeId: number | null
    commonDescriptionId: number
    multiColors: boolean
    _count: InnersDescriptionCountAggregateOutputType | null
    _avg: InnersDescriptionAvgAggregateOutputType | null
    _sum: InnersDescriptionSumAggregateOutputType | null
    _min: InnersDescriptionMinAggregateOutputType | null
    _max: InnersDescriptionMaxAggregateOutputType | null
  }

  type GetInnersDescriptionGroupByPayload<T extends InnersDescriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<InnersDescriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InnersDescriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InnersDescriptionGroupByOutputType[P]>
            : GetScalarType<T[P], InnersDescriptionGroupByOutputType[P]>
        }
      >
    >


  export type InnersDescriptionSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    productDescription?: boolean
    weight?: boolean
    length?: boolean
    waistRise?: boolean
    printAndPattern?: boolean
    packageContains?: boolean
    lookAndFeel?: boolean
    colorFamily?: boolean
    vestsSleeveTypeId?: boolean
    vestsNeckTypeId?: boolean
    commonDescriptionId?: boolean
    multiColors?: boolean
    sleeveType?: boolean | SleeveTypeArgs<ExtArgs>
    neckType?: boolean | NeckTypeArgs<ExtArgs>
    commonDescription?: boolean | CommonDescriptionArgs<ExtArgs>
  }, ExtArgs["result"]["innersDescription"]>

  export type InnersDescriptionSelectScalar = {
    id?: boolean
    type?: boolean
    productDescription?: boolean
    weight?: boolean
    length?: boolean
    waistRise?: boolean
    printAndPattern?: boolean
    packageContains?: boolean
    lookAndFeel?: boolean
    colorFamily?: boolean
    vestsSleeveTypeId?: boolean
    vestsNeckTypeId?: boolean
    commonDescriptionId?: boolean
    multiColors?: boolean
  }

  export type InnersDescriptionInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    sleeveType?: boolean | SleeveTypeArgs<ExtArgs>
    neckType?: boolean | NeckTypeArgs<ExtArgs>
    commonDescription?: boolean | CommonDescriptionArgs<ExtArgs>
  }


  type InnersDescriptionGetPayload<S extends boolean | null | undefined | InnersDescriptionArgs> = $Types.GetResult<InnersDescriptionPayload, S>

  type InnersDescriptionCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<InnersDescriptionFindManyArgs, 'select' | 'include'> & {
      select?: InnersDescriptionCountAggregateInputType | true
    }

  export interface InnersDescriptionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InnersDescription'], meta: { name: 'InnersDescription' } }
    /**
     * Find zero or one InnersDescription that matches the filter.
     * @param {InnersDescriptionFindUniqueArgs} args - Arguments to find a InnersDescription
     * @example
     * // Get one InnersDescription
     * const innersDescription = await prisma.innersDescription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends InnersDescriptionFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, InnersDescriptionFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'InnersDescription'> extends True ? Prisma__InnersDescriptionClient<$Types.GetResult<InnersDescriptionPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__InnersDescriptionClient<$Types.GetResult<InnersDescriptionPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one InnersDescription that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {InnersDescriptionFindUniqueOrThrowArgs} args - Arguments to find a InnersDescription
     * @example
     * // Get one InnersDescription
     * const innersDescription = await prisma.innersDescription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends InnersDescriptionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InnersDescriptionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__InnersDescriptionClient<$Types.GetResult<InnersDescriptionPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first InnersDescription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InnersDescriptionFindFirstArgs} args - Arguments to find a InnersDescription
     * @example
     * // Get one InnersDescription
     * const innersDescription = await prisma.innersDescription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends InnersDescriptionFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, InnersDescriptionFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'InnersDescription'> extends True ? Prisma__InnersDescriptionClient<$Types.GetResult<InnersDescriptionPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__InnersDescriptionClient<$Types.GetResult<InnersDescriptionPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first InnersDescription that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InnersDescriptionFindFirstOrThrowArgs} args - Arguments to find a InnersDescription
     * @example
     * // Get one InnersDescription
     * const innersDescription = await prisma.innersDescription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends InnersDescriptionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InnersDescriptionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__InnersDescriptionClient<$Types.GetResult<InnersDescriptionPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more InnersDescriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InnersDescriptionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InnersDescriptions
     * const innersDescriptions = await prisma.innersDescription.findMany()
     * 
     * // Get first 10 InnersDescriptions
     * const innersDescriptions = await prisma.innersDescription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const innersDescriptionWithIdOnly = await prisma.innersDescription.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends InnersDescriptionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InnersDescriptionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<InnersDescriptionPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a InnersDescription.
     * @param {InnersDescriptionCreateArgs} args - Arguments to create a InnersDescription.
     * @example
     * // Create one InnersDescription
     * const InnersDescription = await prisma.innersDescription.create({
     *   data: {
     *     // ... data to create a InnersDescription
     *   }
     * })
     * 
    **/
    create<T extends InnersDescriptionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, InnersDescriptionCreateArgs<ExtArgs>>
    ): Prisma__InnersDescriptionClient<$Types.GetResult<InnersDescriptionPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many InnersDescriptions.
     *     @param {InnersDescriptionCreateManyArgs} args - Arguments to create many InnersDescriptions.
     *     @example
     *     // Create many InnersDescriptions
     *     const innersDescription = await prisma.innersDescription.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends InnersDescriptionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InnersDescriptionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a InnersDescription.
     * @param {InnersDescriptionDeleteArgs} args - Arguments to delete one InnersDescription.
     * @example
     * // Delete one InnersDescription
     * const InnersDescription = await prisma.innersDescription.delete({
     *   where: {
     *     // ... filter to delete one InnersDescription
     *   }
     * })
     * 
    **/
    delete<T extends InnersDescriptionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, InnersDescriptionDeleteArgs<ExtArgs>>
    ): Prisma__InnersDescriptionClient<$Types.GetResult<InnersDescriptionPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one InnersDescription.
     * @param {InnersDescriptionUpdateArgs} args - Arguments to update one InnersDescription.
     * @example
     * // Update one InnersDescription
     * const innersDescription = await prisma.innersDescription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends InnersDescriptionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, InnersDescriptionUpdateArgs<ExtArgs>>
    ): Prisma__InnersDescriptionClient<$Types.GetResult<InnersDescriptionPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more InnersDescriptions.
     * @param {InnersDescriptionDeleteManyArgs} args - Arguments to filter InnersDescriptions to delete.
     * @example
     * // Delete a few InnersDescriptions
     * const { count } = await prisma.innersDescription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends InnersDescriptionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InnersDescriptionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InnersDescriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InnersDescriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InnersDescriptions
     * const innersDescription = await prisma.innersDescription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends InnersDescriptionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, InnersDescriptionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InnersDescription.
     * @param {InnersDescriptionUpsertArgs} args - Arguments to update or create a InnersDescription.
     * @example
     * // Update or create a InnersDescription
     * const innersDescription = await prisma.innersDescription.upsert({
     *   create: {
     *     // ... data to create a InnersDescription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InnersDescription we want to update
     *   }
     * })
    **/
    upsert<T extends InnersDescriptionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, InnersDescriptionUpsertArgs<ExtArgs>>
    ): Prisma__InnersDescriptionClient<$Types.GetResult<InnersDescriptionPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of InnersDescriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InnersDescriptionCountArgs} args - Arguments to filter InnersDescriptions to count.
     * @example
     * // Count the number of InnersDescriptions
     * const count = await prisma.innersDescription.count({
     *   where: {
     *     // ... the filter for the InnersDescriptions we want to count
     *   }
     * })
    **/
    count<T extends InnersDescriptionCountArgs>(
      args?: Subset<T, InnersDescriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InnersDescriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InnersDescription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InnersDescriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InnersDescriptionAggregateArgs>(args: Subset<T, InnersDescriptionAggregateArgs>): Prisma.PrismaPromise<GetInnersDescriptionAggregateType<T>>

    /**
     * Group by InnersDescription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InnersDescriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InnersDescriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InnersDescriptionGroupByArgs['orderBy'] }
        : { orderBy?: InnersDescriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InnersDescriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInnersDescriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for InnersDescription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__InnersDescriptionClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    sleeveType<T extends SleeveTypeArgs<ExtArgs> = {}>(args?: Subset<T, SleeveTypeArgs<ExtArgs>>): Prisma__SleeveTypeClient<$Types.GetResult<SleeveTypePayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    neckType<T extends NeckTypeArgs<ExtArgs> = {}>(args?: Subset<T, NeckTypeArgs<ExtArgs>>): Prisma__NeckTypeClient<$Types.GetResult<NeckTypePayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    commonDescription<T extends CommonDescriptionArgs<ExtArgs> = {}>(args?: Subset<T, CommonDescriptionArgs<ExtArgs>>): Prisma__CommonDescriptionClient<$Types.GetResult<CommonDescriptionPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * InnersDescription base type for findUnique actions
   */
  export type InnersDescriptionFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InnersDescription
     */
    select?: InnersDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InnersDescriptionInclude<ExtArgs> | null
    /**
     * Filter, which InnersDescription to fetch.
     */
    where: InnersDescriptionWhereUniqueInput
  }

  /**
   * InnersDescription findUnique
   */
  export interface InnersDescriptionFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends InnersDescriptionFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * InnersDescription findUniqueOrThrow
   */
  export type InnersDescriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InnersDescription
     */
    select?: InnersDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InnersDescriptionInclude<ExtArgs> | null
    /**
     * Filter, which InnersDescription to fetch.
     */
    where: InnersDescriptionWhereUniqueInput
  }


  /**
   * InnersDescription base type for findFirst actions
   */
  export type InnersDescriptionFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InnersDescription
     */
    select?: InnersDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InnersDescriptionInclude<ExtArgs> | null
    /**
     * Filter, which InnersDescription to fetch.
     */
    where?: InnersDescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InnersDescriptions to fetch.
     */
    orderBy?: Enumerable<InnersDescriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InnersDescriptions.
     */
    cursor?: InnersDescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InnersDescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InnersDescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InnersDescriptions.
     */
    distinct?: Enumerable<InnersDescriptionScalarFieldEnum>
  }

  /**
   * InnersDescription findFirst
   */
  export interface InnersDescriptionFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends InnersDescriptionFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * InnersDescription findFirstOrThrow
   */
  export type InnersDescriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InnersDescription
     */
    select?: InnersDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InnersDescriptionInclude<ExtArgs> | null
    /**
     * Filter, which InnersDescription to fetch.
     */
    where?: InnersDescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InnersDescriptions to fetch.
     */
    orderBy?: Enumerable<InnersDescriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InnersDescriptions.
     */
    cursor?: InnersDescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InnersDescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InnersDescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InnersDescriptions.
     */
    distinct?: Enumerable<InnersDescriptionScalarFieldEnum>
  }


  /**
   * InnersDescription findMany
   */
  export type InnersDescriptionFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InnersDescription
     */
    select?: InnersDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InnersDescriptionInclude<ExtArgs> | null
    /**
     * Filter, which InnersDescriptions to fetch.
     */
    where?: InnersDescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InnersDescriptions to fetch.
     */
    orderBy?: Enumerable<InnersDescriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InnersDescriptions.
     */
    cursor?: InnersDescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InnersDescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InnersDescriptions.
     */
    skip?: number
    distinct?: Enumerable<InnersDescriptionScalarFieldEnum>
  }


  /**
   * InnersDescription create
   */
  export type InnersDescriptionCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InnersDescription
     */
    select?: InnersDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InnersDescriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a InnersDescription.
     */
    data: XOR<InnersDescriptionCreateInput, InnersDescriptionUncheckedCreateInput>
  }


  /**
   * InnersDescription createMany
   */
  export type InnersDescriptionCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InnersDescriptions.
     */
    data: Enumerable<InnersDescriptionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * InnersDescription update
   */
  export type InnersDescriptionUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InnersDescription
     */
    select?: InnersDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InnersDescriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a InnersDescription.
     */
    data: XOR<InnersDescriptionUpdateInput, InnersDescriptionUncheckedUpdateInput>
    /**
     * Choose, which InnersDescription to update.
     */
    where: InnersDescriptionWhereUniqueInput
  }


  /**
   * InnersDescription updateMany
   */
  export type InnersDescriptionUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InnersDescriptions.
     */
    data: XOR<InnersDescriptionUpdateManyMutationInput, InnersDescriptionUncheckedUpdateManyInput>
    /**
     * Filter which InnersDescriptions to update
     */
    where?: InnersDescriptionWhereInput
  }


  /**
   * InnersDescription upsert
   */
  export type InnersDescriptionUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InnersDescription
     */
    select?: InnersDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InnersDescriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the InnersDescription to update in case it exists.
     */
    where: InnersDescriptionWhereUniqueInput
    /**
     * In case the InnersDescription found by the `where` argument doesn't exist, create a new InnersDescription with this data.
     */
    create: XOR<InnersDescriptionCreateInput, InnersDescriptionUncheckedCreateInput>
    /**
     * In case the InnersDescription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InnersDescriptionUpdateInput, InnersDescriptionUncheckedUpdateInput>
  }


  /**
   * InnersDescription delete
   */
  export type InnersDescriptionDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InnersDescription
     */
    select?: InnersDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InnersDescriptionInclude<ExtArgs> | null
    /**
     * Filter which InnersDescription to delete.
     */
    where: InnersDescriptionWhereUniqueInput
  }


  /**
   * InnersDescription deleteMany
   */
  export type InnersDescriptionDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which InnersDescriptions to delete
     */
    where?: InnersDescriptionWhereInput
  }


  /**
   * InnersDescription without action
   */
  export type InnersDescriptionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InnersDescription
     */
    select?: InnersDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InnersDescriptionInclude<ExtArgs> | null
  }



  /**
   * Model Warranty
   */


  export type AggregateWarranty = {
    _count: WarrantyCountAggregateOutputType | null
    _avg: WarrantyAvgAggregateOutputType | null
    _sum: WarrantySumAggregateOutputType | null
    _min: WarrantyMinAggregateOutputType | null
    _max: WarrantyMaxAggregateOutputType | null
  }

  export type WarrantyAvgAggregateOutputType = {
    id: number | null
    shoesDescriptionId: number | null
    watchsId: number | null
    warrantyPeriod: number | null
  }

  export type WarrantySumAggregateOutputType = {
    id: number | null
    shoesDescriptionId: number | null
    watchsId: number | null
    warrantyPeriod: number | null
  }

  export type WarrantyMinAggregateOutputType = {
    id: number | null
    shoesDescriptionId: number | null
    watchsId: number | null
    warrantyPeriod: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type WarrantyMaxAggregateOutputType = {
    id: number | null
    shoesDescriptionId: number | null
    watchsId: number | null
    warrantyPeriod: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type WarrantyCountAggregateOutputType = {
    id: number
    shoesDescriptionId: number
    watchsId: number
    warrantyPeriod: number
    isActive: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type WarrantyAvgAggregateInputType = {
    id?: true
    shoesDescriptionId?: true
    watchsId?: true
    warrantyPeriod?: true
  }

  export type WarrantySumAggregateInputType = {
    id?: true
    shoesDescriptionId?: true
    watchsId?: true
    warrantyPeriod?: true
  }

  export type WarrantyMinAggregateInputType = {
    id?: true
    shoesDescriptionId?: true
    watchsId?: true
    warrantyPeriod?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type WarrantyMaxAggregateInputType = {
    id?: true
    shoesDescriptionId?: true
    watchsId?: true
    warrantyPeriod?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type WarrantyCountAggregateInputType = {
    id?: true
    shoesDescriptionId?: true
    watchsId?: true
    warrantyPeriod?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type WarrantyAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Warranty to aggregate.
     */
    where?: WarrantyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Warranties to fetch.
     */
    orderBy?: Enumerable<WarrantyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WarrantyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Warranties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Warranties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Warranties
    **/
    _count?: true | WarrantyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WarrantyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WarrantySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WarrantyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WarrantyMaxAggregateInputType
  }

  export type GetWarrantyAggregateType<T extends WarrantyAggregateArgs> = {
        [P in keyof T & keyof AggregateWarranty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWarranty[P]>
      : GetScalarType<T[P], AggregateWarranty[P]>
  }




  export type WarrantyGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: WarrantyWhereInput
    orderBy?: Enumerable<WarrantyOrderByWithAggregationInput>
    by: WarrantyScalarFieldEnum[]
    having?: WarrantyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WarrantyCountAggregateInputType | true
    _avg?: WarrantyAvgAggregateInputType
    _sum?: WarrantySumAggregateInputType
    _min?: WarrantyMinAggregateInputType
    _max?: WarrantyMaxAggregateInputType
  }


  export type WarrantyGroupByOutputType = {
    id: number
    shoesDescriptionId: number | null
    watchsId: number | null
    warrantyPeriod: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: WarrantyCountAggregateOutputType | null
    _avg: WarrantyAvgAggregateOutputType | null
    _sum: WarrantySumAggregateOutputType | null
    _min: WarrantyMinAggregateOutputType | null
    _max: WarrantyMaxAggregateOutputType | null
  }

  type GetWarrantyGroupByPayload<T extends WarrantyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<WarrantyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WarrantyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WarrantyGroupByOutputType[P]>
            : GetScalarType<T[P], WarrantyGroupByOutputType[P]>
        }
      >
    >


  export type WarrantySelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shoesDescriptionId?: boolean
    watchsId?: boolean
    warrantyPeriod?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    shoesDescription?: boolean | ShoesDescriptionArgs<ExtArgs>
    watches?: boolean | WatchesDescriptionArgs<ExtArgs>
  }, ExtArgs["result"]["warranty"]>

  export type WarrantySelectScalar = {
    id?: boolean
    shoesDescriptionId?: boolean
    watchsId?: boolean
    warrantyPeriod?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type WarrantyInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    shoesDescription?: boolean | ShoesDescriptionArgs<ExtArgs>
    watches?: boolean | WatchesDescriptionArgs<ExtArgs>
  }


  type WarrantyGetPayload<S extends boolean | null | undefined | WarrantyArgs> = $Types.GetResult<WarrantyPayload, S>

  type WarrantyCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<WarrantyFindManyArgs, 'select' | 'include'> & {
      select?: WarrantyCountAggregateInputType | true
    }

  export interface WarrantyDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Warranty'], meta: { name: 'Warranty' } }
    /**
     * Find zero or one Warranty that matches the filter.
     * @param {WarrantyFindUniqueArgs} args - Arguments to find a Warranty
     * @example
     * // Get one Warranty
     * const warranty = await prisma.warranty.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WarrantyFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, WarrantyFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Warranty'> extends True ? Prisma__WarrantyClient<$Types.GetResult<WarrantyPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__WarrantyClient<$Types.GetResult<WarrantyPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Warranty that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {WarrantyFindUniqueOrThrowArgs} args - Arguments to find a Warranty
     * @example
     * // Get one Warranty
     * const warranty = await prisma.warranty.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends WarrantyFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WarrantyFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__WarrantyClient<$Types.GetResult<WarrantyPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Warranty that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarrantyFindFirstArgs} args - Arguments to find a Warranty
     * @example
     * // Get one Warranty
     * const warranty = await prisma.warranty.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WarrantyFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, WarrantyFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Warranty'> extends True ? Prisma__WarrantyClient<$Types.GetResult<WarrantyPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__WarrantyClient<$Types.GetResult<WarrantyPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Warranty that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarrantyFindFirstOrThrowArgs} args - Arguments to find a Warranty
     * @example
     * // Get one Warranty
     * const warranty = await prisma.warranty.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends WarrantyFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WarrantyFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__WarrantyClient<$Types.GetResult<WarrantyPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Warranties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarrantyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Warranties
     * const warranties = await prisma.warranty.findMany()
     * 
     * // Get first 10 Warranties
     * const warranties = await prisma.warranty.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const warrantyWithIdOnly = await prisma.warranty.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WarrantyFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WarrantyFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<WarrantyPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Warranty.
     * @param {WarrantyCreateArgs} args - Arguments to create a Warranty.
     * @example
     * // Create one Warranty
     * const Warranty = await prisma.warranty.create({
     *   data: {
     *     // ... data to create a Warranty
     *   }
     * })
     * 
    **/
    create<T extends WarrantyCreateArgs<ExtArgs>>(
      args: SelectSubset<T, WarrantyCreateArgs<ExtArgs>>
    ): Prisma__WarrantyClient<$Types.GetResult<WarrantyPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Warranties.
     *     @param {WarrantyCreateManyArgs} args - Arguments to create many Warranties.
     *     @example
     *     // Create many Warranties
     *     const warranty = await prisma.warranty.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WarrantyCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WarrantyCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Warranty.
     * @param {WarrantyDeleteArgs} args - Arguments to delete one Warranty.
     * @example
     * // Delete one Warranty
     * const Warranty = await prisma.warranty.delete({
     *   where: {
     *     // ... filter to delete one Warranty
     *   }
     * })
     * 
    **/
    delete<T extends WarrantyDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, WarrantyDeleteArgs<ExtArgs>>
    ): Prisma__WarrantyClient<$Types.GetResult<WarrantyPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Warranty.
     * @param {WarrantyUpdateArgs} args - Arguments to update one Warranty.
     * @example
     * // Update one Warranty
     * const warranty = await prisma.warranty.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WarrantyUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, WarrantyUpdateArgs<ExtArgs>>
    ): Prisma__WarrantyClient<$Types.GetResult<WarrantyPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Warranties.
     * @param {WarrantyDeleteManyArgs} args - Arguments to filter Warranties to delete.
     * @example
     * // Delete a few Warranties
     * const { count } = await prisma.warranty.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WarrantyDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WarrantyDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Warranties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarrantyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Warranties
     * const warranty = await prisma.warranty.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WarrantyUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, WarrantyUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Warranty.
     * @param {WarrantyUpsertArgs} args - Arguments to update or create a Warranty.
     * @example
     * // Update or create a Warranty
     * const warranty = await prisma.warranty.upsert({
     *   create: {
     *     // ... data to create a Warranty
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Warranty we want to update
     *   }
     * })
    **/
    upsert<T extends WarrantyUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, WarrantyUpsertArgs<ExtArgs>>
    ): Prisma__WarrantyClient<$Types.GetResult<WarrantyPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Warranties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarrantyCountArgs} args - Arguments to filter Warranties to count.
     * @example
     * // Count the number of Warranties
     * const count = await prisma.warranty.count({
     *   where: {
     *     // ... the filter for the Warranties we want to count
     *   }
     * })
    **/
    count<T extends WarrantyCountArgs>(
      args?: Subset<T, WarrantyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WarrantyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Warranty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarrantyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WarrantyAggregateArgs>(args: Subset<T, WarrantyAggregateArgs>): Prisma.PrismaPromise<GetWarrantyAggregateType<T>>

    /**
     * Group by Warranty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarrantyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WarrantyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WarrantyGroupByArgs['orderBy'] }
        : { orderBy?: WarrantyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WarrantyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWarrantyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Warranty.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__WarrantyClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    shoesDescription<T extends ShoesDescriptionArgs<ExtArgs> = {}>(args?: Subset<T, ShoesDescriptionArgs<ExtArgs>>): Prisma__ShoesDescriptionClient<$Types.GetResult<ShoesDescriptionPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    watches<T extends WatchesDescriptionArgs<ExtArgs> = {}>(args?: Subset<T, WatchesDescriptionArgs<ExtArgs>>): Prisma__WatchesDescriptionClient<$Types.GetResult<WatchesDescriptionPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Warranty base type for findUnique actions
   */
  export type WarrantyFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warranty
     */
    select?: WarrantySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WarrantyInclude<ExtArgs> | null
    /**
     * Filter, which Warranty to fetch.
     */
    where: WarrantyWhereUniqueInput
  }

  /**
   * Warranty findUnique
   */
  export interface WarrantyFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends WarrantyFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Warranty findUniqueOrThrow
   */
  export type WarrantyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warranty
     */
    select?: WarrantySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WarrantyInclude<ExtArgs> | null
    /**
     * Filter, which Warranty to fetch.
     */
    where: WarrantyWhereUniqueInput
  }


  /**
   * Warranty base type for findFirst actions
   */
  export type WarrantyFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warranty
     */
    select?: WarrantySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WarrantyInclude<ExtArgs> | null
    /**
     * Filter, which Warranty to fetch.
     */
    where?: WarrantyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Warranties to fetch.
     */
    orderBy?: Enumerable<WarrantyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Warranties.
     */
    cursor?: WarrantyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Warranties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Warranties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Warranties.
     */
    distinct?: Enumerable<WarrantyScalarFieldEnum>
  }

  /**
   * Warranty findFirst
   */
  export interface WarrantyFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends WarrantyFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Warranty findFirstOrThrow
   */
  export type WarrantyFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warranty
     */
    select?: WarrantySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WarrantyInclude<ExtArgs> | null
    /**
     * Filter, which Warranty to fetch.
     */
    where?: WarrantyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Warranties to fetch.
     */
    orderBy?: Enumerable<WarrantyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Warranties.
     */
    cursor?: WarrantyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Warranties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Warranties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Warranties.
     */
    distinct?: Enumerable<WarrantyScalarFieldEnum>
  }


  /**
   * Warranty findMany
   */
  export type WarrantyFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warranty
     */
    select?: WarrantySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WarrantyInclude<ExtArgs> | null
    /**
     * Filter, which Warranties to fetch.
     */
    where?: WarrantyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Warranties to fetch.
     */
    orderBy?: Enumerable<WarrantyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Warranties.
     */
    cursor?: WarrantyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Warranties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Warranties.
     */
    skip?: number
    distinct?: Enumerable<WarrantyScalarFieldEnum>
  }


  /**
   * Warranty create
   */
  export type WarrantyCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warranty
     */
    select?: WarrantySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WarrantyInclude<ExtArgs> | null
    /**
     * The data needed to create a Warranty.
     */
    data: XOR<WarrantyCreateInput, WarrantyUncheckedCreateInput>
  }


  /**
   * Warranty createMany
   */
  export type WarrantyCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Warranties.
     */
    data: Enumerable<WarrantyCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Warranty update
   */
  export type WarrantyUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warranty
     */
    select?: WarrantySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WarrantyInclude<ExtArgs> | null
    /**
     * The data needed to update a Warranty.
     */
    data: XOR<WarrantyUpdateInput, WarrantyUncheckedUpdateInput>
    /**
     * Choose, which Warranty to update.
     */
    where: WarrantyWhereUniqueInput
  }


  /**
   * Warranty updateMany
   */
  export type WarrantyUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Warranties.
     */
    data: XOR<WarrantyUpdateManyMutationInput, WarrantyUncheckedUpdateManyInput>
    /**
     * Filter which Warranties to update
     */
    where?: WarrantyWhereInput
  }


  /**
   * Warranty upsert
   */
  export type WarrantyUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warranty
     */
    select?: WarrantySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WarrantyInclude<ExtArgs> | null
    /**
     * The filter to search for the Warranty to update in case it exists.
     */
    where: WarrantyWhereUniqueInput
    /**
     * In case the Warranty found by the `where` argument doesn't exist, create a new Warranty with this data.
     */
    create: XOR<WarrantyCreateInput, WarrantyUncheckedCreateInput>
    /**
     * In case the Warranty was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WarrantyUpdateInput, WarrantyUncheckedUpdateInput>
  }


  /**
   * Warranty delete
   */
  export type WarrantyDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warranty
     */
    select?: WarrantySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WarrantyInclude<ExtArgs> | null
    /**
     * Filter which Warranty to delete.
     */
    where: WarrantyWhereUniqueInput
  }


  /**
   * Warranty deleteMany
   */
  export type WarrantyDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Warranties to delete
     */
    where?: WarrantyWhereInput
  }


  /**
   * Warranty without action
   */
  export type WarrantyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warranty
     */
    select?: WarrantySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WarrantyInclude<ExtArgs> | null
  }



  /**
   * Model SleeveType
   */


  export type AggregateSleeveType = {
    _count: SleeveTypeCountAggregateOutputType | null
    _avg: SleeveTypeAvgAggregateOutputType | null
    _sum: SleeveTypeSumAggregateOutputType | null
    _min: SleeveTypeMinAggregateOutputType | null
    _max: SleeveTypeMaxAggregateOutputType | null
  }

  export type SleeveTypeAvgAggregateOutputType = {
    id: number | null
  }

  export type SleeveTypeSumAggregateOutputType = {
    id: number | null
  }

  export type SleeveTypeMinAggregateOutputType = {
    id: number | null
    name: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type SleeveTypeMaxAggregateOutputType = {
    id: number | null
    name: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type SleeveTypeCountAggregateOutputType = {
    id: number
    name: number
    isActive: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type SleeveTypeAvgAggregateInputType = {
    id?: true
  }

  export type SleeveTypeSumAggregateInputType = {
    id?: true
  }

  export type SleeveTypeMinAggregateInputType = {
    id?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type SleeveTypeMaxAggregateInputType = {
    id?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type SleeveTypeCountAggregateInputType = {
    id?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type SleeveTypeAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which SleeveType to aggregate.
     */
    where?: SleeveTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SleeveTypes to fetch.
     */
    orderBy?: Enumerable<SleeveTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SleeveTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SleeveTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SleeveTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SleeveTypes
    **/
    _count?: true | SleeveTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SleeveTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SleeveTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SleeveTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SleeveTypeMaxAggregateInputType
  }

  export type GetSleeveTypeAggregateType<T extends SleeveTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateSleeveType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSleeveType[P]>
      : GetScalarType<T[P], AggregateSleeveType[P]>
  }




  export type SleeveTypeGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: SleeveTypeWhereInput
    orderBy?: Enumerable<SleeveTypeOrderByWithAggregationInput>
    by: SleeveTypeScalarFieldEnum[]
    having?: SleeveTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SleeveTypeCountAggregateInputType | true
    _avg?: SleeveTypeAvgAggregateInputType
    _sum?: SleeveTypeSumAggregateInputType
    _min?: SleeveTypeMinAggregateInputType
    _max?: SleeveTypeMaxAggregateInputType
  }


  export type SleeveTypeGroupByOutputType = {
    id: number
    name: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: SleeveTypeCountAggregateOutputType | null
    _avg: SleeveTypeAvgAggregateOutputType | null
    _sum: SleeveTypeSumAggregateOutputType | null
    _min: SleeveTypeMinAggregateOutputType | null
    _max: SleeveTypeMaxAggregateOutputType | null
  }

  type GetSleeveTypeGroupByPayload<T extends SleeveTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<SleeveTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SleeveTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SleeveTypeGroupByOutputType[P]>
            : GetScalarType<T[P], SleeveTypeGroupByOutputType[P]>
        }
      >
    >


  export type SleeveTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    kurtasDescription?: boolean | SleeveType$kurtasDescriptionArgs<ExtArgs>
    innersDescription?: boolean | SleeveType$innersDescriptionArgs<ExtArgs>
    topDescription?: boolean | SleeveType$topDescriptionArgs<ExtArgs>
    _count?: boolean | SleeveTypeCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["sleeveType"]>

  export type SleeveTypeSelectScalar = {
    id?: boolean
    name?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type SleeveTypeInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    kurtasDescription?: boolean | SleeveType$kurtasDescriptionArgs<ExtArgs>
    innersDescription?: boolean | SleeveType$innersDescriptionArgs<ExtArgs>
    topDescription?: boolean | SleeveType$topDescriptionArgs<ExtArgs>
    _count?: boolean | SleeveTypeCountOutputTypeArgs<ExtArgs>
  }


  type SleeveTypeGetPayload<S extends boolean | null | undefined | SleeveTypeArgs> = $Types.GetResult<SleeveTypePayload, S>

  type SleeveTypeCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<SleeveTypeFindManyArgs, 'select' | 'include'> & {
      select?: SleeveTypeCountAggregateInputType | true
    }

  export interface SleeveTypeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SleeveType'], meta: { name: 'SleeveType' } }
    /**
     * Find zero or one SleeveType that matches the filter.
     * @param {SleeveTypeFindUniqueArgs} args - Arguments to find a SleeveType
     * @example
     * // Get one SleeveType
     * const sleeveType = await prisma.sleeveType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SleeveTypeFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SleeveTypeFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SleeveType'> extends True ? Prisma__SleeveTypeClient<$Types.GetResult<SleeveTypePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__SleeveTypeClient<$Types.GetResult<SleeveTypePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one SleeveType that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SleeveTypeFindUniqueOrThrowArgs} args - Arguments to find a SleeveType
     * @example
     * // Get one SleeveType
     * const sleeveType = await prisma.sleeveType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SleeveTypeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SleeveTypeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SleeveTypeClient<$Types.GetResult<SleeveTypePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first SleeveType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SleeveTypeFindFirstArgs} args - Arguments to find a SleeveType
     * @example
     * // Get one SleeveType
     * const sleeveType = await prisma.sleeveType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SleeveTypeFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SleeveTypeFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SleeveType'> extends True ? Prisma__SleeveTypeClient<$Types.GetResult<SleeveTypePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__SleeveTypeClient<$Types.GetResult<SleeveTypePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first SleeveType that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SleeveTypeFindFirstOrThrowArgs} args - Arguments to find a SleeveType
     * @example
     * // Get one SleeveType
     * const sleeveType = await prisma.sleeveType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SleeveTypeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SleeveTypeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SleeveTypeClient<$Types.GetResult<SleeveTypePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more SleeveTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SleeveTypeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SleeveTypes
     * const sleeveTypes = await prisma.sleeveType.findMany()
     * 
     * // Get first 10 SleeveTypes
     * const sleeveTypes = await prisma.sleeveType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sleeveTypeWithIdOnly = await prisma.sleeveType.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SleeveTypeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SleeveTypeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<SleeveTypePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a SleeveType.
     * @param {SleeveTypeCreateArgs} args - Arguments to create a SleeveType.
     * @example
     * // Create one SleeveType
     * const SleeveType = await prisma.sleeveType.create({
     *   data: {
     *     // ... data to create a SleeveType
     *   }
     * })
     * 
    **/
    create<T extends SleeveTypeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SleeveTypeCreateArgs<ExtArgs>>
    ): Prisma__SleeveTypeClient<$Types.GetResult<SleeveTypePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many SleeveTypes.
     *     @param {SleeveTypeCreateManyArgs} args - Arguments to create many SleeveTypes.
     *     @example
     *     // Create many SleeveTypes
     *     const sleeveType = await prisma.sleeveType.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SleeveTypeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SleeveTypeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SleeveType.
     * @param {SleeveTypeDeleteArgs} args - Arguments to delete one SleeveType.
     * @example
     * // Delete one SleeveType
     * const SleeveType = await prisma.sleeveType.delete({
     *   where: {
     *     // ... filter to delete one SleeveType
     *   }
     * })
     * 
    **/
    delete<T extends SleeveTypeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SleeveTypeDeleteArgs<ExtArgs>>
    ): Prisma__SleeveTypeClient<$Types.GetResult<SleeveTypePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one SleeveType.
     * @param {SleeveTypeUpdateArgs} args - Arguments to update one SleeveType.
     * @example
     * // Update one SleeveType
     * const sleeveType = await prisma.sleeveType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SleeveTypeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SleeveTypeUpdateArgs<ExtArgs>>
    ): Prisma__SleeveTypeClient<$Types.GetResult<SleeveTypePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more SleeveTypes.
     * @param {SleeveTypeDeleteManyArgs} args - Arguments to filter SleeveTypes to delete.
     * @example
     * // Delete a few SleeveTypes
     * const { count } = await prisma.sleeveType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SleeveTypeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SleeveTypeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SleeveTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SleeveTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SleeveTypes
     * const sleeveType = await prisma.sleeveType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SleeveTypeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SleeveTypeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SleeveType.
     * @param {SleeveTypeUpsertArgs} args - Arguments to update or create a SleeveType.
     * @example
     * // Update or create a SleeveType
     * const sleeveType = await prisma.sleeveType.upsert({
     *   create: {
     *     // ... data to create a SleeveType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SleeveType we want to update
     *   }
     * })
    **/
    upsert<T extends SleeveTypeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SleeveTypeUpsertArgs<ExtArgs>>
    ): Prisma__SleeveTypeClient<$Types.GetResult<SleeveTypePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of SleeveTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SleeveTypeCountArgs} args - Arguments to filter SleeveTypes to count.
     * @example
     * // Count the number of SleeveTypes
     * const count = await prisma.sleeveType.count({
     *   where: {
     *     // ... the filter for the SleeveTypes we want to count
     *   }
     * })
    **/
    count<T extends SleeveTypeCountArgs>(
      args?: Subset<T, SleeveTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SleeveTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SleeveType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SleeveTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SleeveTypeAggregateArgs>(args: Subset<T, SleeveTypeAggregateArgs>): Prisma.PrismaPromise<GetSleeveTypeAggregateType<T>>

    /**
     * Group by SleeveType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SleeveTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SleeveTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SleeveTypeGroupByArgs['orderBy'] }
        : { orderBy?: SleeveTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SleeveTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSleeveTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for SleeveType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SleeveTypeClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    kurtasDescription<T extends SleeveType$kurtasDescriptionArgs<ExtArgs> = {}>(args?: Subset<T, SleeveType$kurtasDescriptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<KurtasDescriptionPayload<ExtArgs>, T, 'findMany', never>| Null>;

    innersDescription<T extends SleeveType$innersDescriptionArgs<ExtArgs> = {}>(args?: Subset<T, SleeveType$innersDescriptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<InnersDescriptionPayload<ExtArgs>, T, 'findMany', never>| Null>;

    topDescription<T extends SleeveType$topDescriptionArgs<ExtArgs> = {}>(args?: Subset<T, SleeveType$topDescriptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<TopDescriptionPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * SleeveType base type for findUnique actions
   */
  export type SleeveTypeFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SleeveType
     */
    select?: SleeveTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SleeveTypeInclude<ExtArgs> | null
    /**
     * Filter, which SleeveType to fetch.
     */
    where: SleeveTypeWhereUniqueInput
  }

  /**
   * SleeveType findUnique
   */
  export interface SleeveTypeFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends SleeveTypeFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SleeveType findUniqueOrThrow
   */
  export type SleeveTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SleeveType
     */
    select?: SleeveTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SleeveTypeInclude<ExtArgs> | null
    /**
     * Filter, which SleeveType to fetch.
     */
    where: SleeveTypeWhereUniqueInput
  }


  /**
   * SleeveType base type for findFirst actions
   */
  export type SleeveTypeFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SleeveType
     */
    select?: SleeveTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SleeveTypeInclude<ExtArgs> | null
    /**
     * Filter, which SleeveType to fetch.
     */
    where?: SleeveTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SleeveTypes to fetch.
     */
    orderBy?: Enumerable<SleeveTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SleeveTypes.
     */
    cursor?: SleeveTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SleeveTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SleeveTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SleeveTypes.
     */
    distinct?: Enumerable<SleeveTypeScalarFieldEnum>
  }

  /**
   * SleeveType findFirst
   */
  export interface SleeveTypeFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends SleeveTypeFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SleeveType findFirstOrThrow
   */
  export type SleeveTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SleeveType
     */
    select?: SleeveTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SleeveTypeInclude<ExtArgs> | null
    /**
     * Filter, which SleeveType to fetch.
     */
    where?: SleeveTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SleeveTypes to fetch.
     */
    orderBy?: Enumerable<SleeveTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SleeveTypes.
     */
    cursor?: SleeveTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SleeveTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SleeveTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SleeveTypes.
     */
    distinct?: Enumerable<SleeveTypeScalarFieldEnum>
  }


  /**
   * SleeveType findMany
   */
  export type SleeveTypeFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SleeveType
     */
    select?: SleeveTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SleeveTypeInclude<ExtArgs> | null
    /**
     * Filter, which SleeveTypes to fetch.
     */
    where?: SleeveTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SleeveTypes to fetch.
     */
    orderBy?: Enumerable<SleeveTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SleeveTypes.
     */
    cursor?: SleeveTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SleeveTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SleeveTypes.
     */
    skip?: number
    distinct?: Enumerable<SleeveTypeScalarFieldEnum>
  }


  /**
   * SleeveType create
   */
  export type SleeveTypeCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SleeveType
     */
    select?: SleeveTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SleeveTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a SleeveType.
     */
    data: XOR<SleeveTypeCreateInput, SleeveTypeUncheckedCreateInput>
  }


  /**
   * SleeveType createMany
   */
  export type SleeveTypeCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SleeveTypes.
     */
    data: Enumerable<SleeveTypeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SleeveType update
   */
  export type SleeveTypeUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SleeveType
     */
    select?: SleeveTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SleeveTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a SleeveType.
     */
    data: XOR<SleeveTypeUpdateInput, SleeveTypeUncheckedUpdateInput>
    /**
     * Choose, which SleeveType to update.
     */
    where: SleeveTypeWhereUniqueInput
  }


  /**
   * SleeveType updateMany
   */
  export type SleeveTypeUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SleeveTypes.
     */
    data: XOR<SleeveTypeUpdateManyMutationInput, SleeveTypeUncheckedUpdateManyInput>
    /**
     * Filter which SleeveTypes to update
     */
    where?: SleeveTypeWhereInput
  }


  /**
   * SleeveType upsert
   */
  export type SleeveTypeUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SleeveType
     */
    select?: SleeveTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SleeveTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the SleeveType to update in case it exists.
     */
    where: SleeveTypeWhereUniqueInput
    /**
     * In case the SleeveType found by the `where` argument doesn't exist, create a new SleeveType with this data.
     */
    create: XOR<SleeveTypeCreateInput, SleeveTypeUncheckedCreateInput>
    /**
     * In case the SleeveType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SleeveTypeUpdateInput, SleeveTypeUncheckedUpdateInput>
  }


  /**
   * SleeveType delete
   */
  export type SleeveTypeDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SleeveType
     */
    select?: SleeveTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SleeveTypeInclude<ExtArgs> | null
    /**
     * Filter which SleeveType to delete.
     */
    where: SleeveTypeWhereUniqueInput
  }


  /**
   * SleeveType deleteMany
   */
  export type SleeveTypeDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which SleeveTypes to delete
     */
    where?: SleeveTypeWhereInput
  }


  /**
   * SleeveType.kurtasDescription
   */
  export type SleeveType$kurtasDescriptionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KurtasDescription
     */
    select?: KurtasDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KurtasDescriptionInclude<ExtArgs> | null
    where?: KurtasDescriptionWhereInput
    orderBy?: Enumerable<KurtasDescriptionOrderByWithRelationInput>
    cursor?: KurtasDescriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<KurtasDescriptionScalarFieldEnum>
  }


  /**
   * SleeveType.innersDescription
   */
  export type SleeveType$innersDescriptionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InnersDescription
     */
    select?: InnersDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InnersDescriptionInclude<ExtArgs> | null
    where?: InnersDescriptionWhereInput
    orderBy?: Enumerable<InnersDescriptionOrderByWithRelationInput>
    cursor?: InnersDescriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<InnersDescriptionScalarFieldEnum>
  }


  /**
   * SleeveType.topDescription
   */
  export type SleeveType$topDescriptionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopDescription
     */
    select?: TopDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TopDescriptionInclude<ExtArgs> | null
    where?: TopDescriptionWhereInput
    orderBy?: Enumerable<TopDescriptionOrderByWithRelationInput>
    cursor?: TopDescriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TopDescriptionScalarFieldEnum>
  }


  /**
   * SleeveType without action
   */
  export type SleeveTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SleeveType
     */
    select?: SleeveTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SleeveTypeInclude<ExtArgs> | null
  }



  /**
   * Model NeckType
   */


  export type AggregateNeckType = {
    _count: NeckTypeCountAggregateOutputType | null
    _avg: NeckTypeAvgAggregateOutputType | null
    _sum: NeckTypeSumAggregateOutputType | null
    _min: NeckTypeMinAggregateOutputType | null
    _max: NeckTypeMaxAggregateOutputType | null
  }

  export type NeckTypeAvgAggregateOutputType = {
    id: number | null
  }

  export type NeckTypeSumAggregateOutputType = {
    id: number | null
  }

  export type NeckTypeMinAggregateOutputType = {
    id: number | null
    name: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type NeckTypeMaxAggregateOutputType = {
    id: number | null
    name: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type NeckTypeCountAggregateOutputType = {
    id: number
    name: number
    isActive: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type NeckTypeAvgAggregateInputType = {
    id?: true
  }

  export type NeckTypeSumAggregateInputType = {
    id?: true
  }

  export type NeckTypeMinAggregateInputType = {
    id?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type NeckTypeMaxAggregateInputType = {
    id?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type NeckTypeCountAggregateInputType = {
    id?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type NeckTypeAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which NeckType to aggregate.
     */
    where?: NeckTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NeckTypes to fetch.
     */
    orderBy?: Enumerable<NeckTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NeckTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NeckTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NeckTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NeckTypes
    **/
    _count?: true | NeckTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NeckTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NeckTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NeckTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NeckTypeMaxAggregateInputType
  }

  export type GetNeckTypeAggregateType<T extends NeckTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateNeckType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNeckType[P]>
      : GetScalarType<T[P], AggregateNeckType[P]>
  }




  export type NeckTypeGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: NeckTypeWhereInput
    orderBy?: Enumerable<NeckTypeOrderByWithAggregationInput>
    by: NeckTypeScalarFieldEnum[]
    having?: NeckTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NeckTypeCountAggregateInputType | true
    _avg?: NeckTypeAvgAggregateInputType
    _sum?: NeckTypeSumAggregateInputType
    _min?: NeckTypeMinAggregateInputType
    _max?: NeckTypeMaxAggregateInputType
  }


  export type NeckTypeGroupByOutputType = {
    id: number
    name: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: NeckTypeCountAggregateOutputType | null
    _avg: NeckTypeAvgAggregateOutputType | null
    _sum: NeckTypeSumAggregateOutputType | null
    _min: NeckTypeMinAggregateOutputType | null
    _max: NeckTypeMaxAggregateOutputType | null
  }

  type GetNeckTypeGroupByPayload<T extends NeckTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<NeckTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NeckTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NeckTypeGroupByOutputType[P]>
            : GetScalarType<T[P], NeckTypeGroupByOutputType[P]>
        }
      >
    >


  export type NeckTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    kurtasDescription?: boolean | NeckType$kurtasDescriptionArgs<ExtArgs>
    innersDescription?: boolean | NeckType$innersDescriptionArgs<ExtArgs>
    topDescription?: boolean | NeckType$topDescriptionArgs<ExtArgs>
    _count?: boolean | NeckTypeCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["neckType"]>

  export type NeckTypeSelectScalar = {
    id?: boolean
    name?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type NeckTypeInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    kurtasDescription?: boolean | NeckType$kurtasDescriptionArgs<ExtArgs>
    innersDescription?: boolean | NeckType$innersDescriptionArgs<ExtArgs>
    topDescription?: boolean | NeckType$topDescriptionArgs<ExtArgs>
    _count?: boolean | NeckTypeCountOutputTypeArgs<ExtArgs>
  }


  type NeckTypeGetPayload<S extends boolean | null | undefined | NeckTypeArgs> = $Types.GetResult<NeckTypePayload, S>

  type NeckTypeCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<NeckTypeFindManyArgs, 'select' | 'include'> & {
      select?: NeckTypeCountAggregateInputType | true
    }

  export interface NeckTypeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NeckType'], meta: { name: 'NeckType' } }
    /**
     * Find zero or one NeckType that matches the filter.
     * @param {NeckTypeFindUniqueArgs} args - Arguments to find a NeckType
     * @example
     * // Get one NeckType
     * const neckType = await prisma.neckType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NeckTypeFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, NeckTypeFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'NeckType'> extends True ? Prisma__NeckTypeClient<$Types.GetResult<NeckTypePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__NeckTypeClient<$Types.GetResult<NeckTypePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one NeckType that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {NeckTypeFindUniqueOrThrowArgs} args - Arguments to find a NeckType
     * @example
     * // Get one NeckType
     * const neckType = await prisma.neckType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends NeckTypeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NeckTypeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__NeckTypeClient<$Types.GetResult<NeckTypePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first NeckType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NeckTypeFindFirstArgs} args - Arguments to find a NeckType
     * @example
     * // Get one NeckType
     * const neckType = await prisma.neckType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NeckTypeFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, NeckTypeFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'NeckType'> extends True ? Prisma__NeckTypeClient<$Types.GetResult<NeckTypePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__NeckTypeClient<$Types.GetResult<NeckTypePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first NeckType that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NeckTypeFindFirstOrThrowArgs} args - Arguments to find a NeckType
     * @example
     * // Get one NeckType
     * const neckType = await prisma.neckType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends NeckTypeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NeckTypeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__NeckTypeClient<$Types.GetResult<NeckTypePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more NeckTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NeckTypeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NeckTypes
     * const neckTypes = await prisma.neckType.findMany()
     * 
     * // Get first 10 NeckTypes
     * const neckTypes = await prisma.neckType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const neckTypeWithIdOnly = await prisma.neckType.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends NeckTypeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NeckTypeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<NeckTypePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a NeckType.
     * @param {NeckTypeCreateArgs} args - Arguments to create a NeckType.
     * @example
     * // Create one NeckType
     * const NeckType = await prisma.neckType.create({
     *   data: {
     *     // ... data to create a NeckType
     *   }
     * })
     * 
    **/
    create<T extends NeckTypeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, NeckTypeCreateArgs<ExtArgs>>
    ): Prisma__NeckTypeClient<$Types.GetResult<NeckTypePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many NeckTypes.
     *     @param {NeckTypeCreateManyArgs} args - Arguments to create many NeckTypes.
     *     @example
     *     // Create many NeckTypes
     *     const neckType = await prisma.neckType.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends NeckTypeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NeckTypeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a NeckType.
     * @param {NeckTypeDeleteArgs} args - Arguments to delete one NeckType.
     * @example
     * // Delete one NeckType
     * const NeckType = await prisma.neckType.delete({
     *   where: {
     *     // ... filter to delete one NeckType
     *   }
     * })
     * 
    **/
    delete<T extends NeckTypeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, NeckTypeDeleteArgs<ExtArgs>>
    ): Prisma__NeckTypeClient<$Types.GetResult<NeckTypePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one NeckType.
     * @param {NeckTypeUpdateArgs} args - Arguments to update one NeckType.
     * @example
     * // Update one NeckType
     * const neckType = await prisma.neckType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NeckTypeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, NeckTypeUpdateArgs<ExtArgs>>
    ): Prisma__NeckTypeClient<$Types.GetResult<NeckTypePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more NeckTypes.
     * @param {NeckTypeDeleteManyArgs} args - Arguments to filter NeckTypes to delete.
     * @example
     * // Delete a few NeckTypes
     * const { count } = await prisma.neckType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NeckTypeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NeckTypeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NeckTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NeckTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NeckTypes
     * const neckType = await prisma.neckType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NeckTypeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, NeckTypeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NeckType.
     * @param {NeckTypeUpsertArgs} args - Arguments to update or create a NeckType.
     * @example
     * // Update or create a NeckType
     * const neckType = await prisma.neckType.upsert({
     *   create: {
     *     // ... data to create a NeckType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NeckType we want to update
     *   }
     * })
    **/
    upsert<T extends NeckTypeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, NeckTypeUpsertArgs<ExtArgs>>
    ): Prisma__NeckTypeClient<$Types.GetResult<NeckTypePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of NeckTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NeckTypeCountArgs} args - Arguments to filter NeckTypes to count.
     * @example
     * // Count the number of NeckTypes
     * const count = await prisma.neckType.count({
     *   where: {
     *     // ... the filter for the NeckTypes we want to count
     *   }
     * })
    **/
    count<T extends NeckTypeCountArgs>(
      args?: Subset<T, NeckTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NeckTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NeckType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NeckTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NeckTypeAggregateArgs>(args: Subset<T, NeckTypeAggregateArgs>): Prisma.PrismaPromise<GetNeckTypeAggregateType<T>>

    /**
     * Group by NeckType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NeckTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NeckTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NeckTypeGroupByArgs['orderBy'] }
        : { orderBy?: NeckTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NeckTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNeckTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for NeckType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__NeckTypeClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    kurtasDescription<T extends NeckType$kurtasDescriptionArgs<ExtArgs> = {}>(args?: Subset<T, NeckType$kurtasDescriptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<KurtasDescriptionPayload<ExtArgs>, T, 'findMany', never>| Null>;

    innersDescription<T extends NeckType$innersDescriptionArgs<ExtArgs> = {}>(args?: Subset<T, NeckType$innersDescriptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<InnersDescriptionPayload<ExtArgs>, T, 'findMany', never>| Null>;

    topDescription<T extends NeckType$topDescriptionArgs<ExtArgs> = {}>(args?: Subset<T, NeckType$topDescriptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<TopDescriptionPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * NeckType base type for findUnique actions
   */
  export type NeckTypeFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NeckType
     */
    select?: NeckTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NeckTypeInclude<ExtArgs> | null
    /**
     * Filter, which NeckType to fetch.
     */
    where: NeckTypeWhereUniqueInput
  }

  /**
   * NeckType findUnique
   */
  export interface NeckTypeFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends NeckTypeFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * NeckType findUniqueOrThrow
   */
  export type NeckTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NeckType
     */
    select?: NeckTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NeckTypeInclude<ExtArgs> | null
    /**
     * Filter, which NeckType to fetch.
     */
    where: NeckTypeWhereUniqueInput
  }


  /**
   * NeckType base type for findFirst actions
   */
  export type NeckTypeFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NeckType
     */
    select?: NeckTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NeckTypeInclude<ExtArgs> | null
    /**
     * Filter, which NeckType to fetch.
     */
    where?: NeckTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NeckTypes to fetch.
     */
    orderBy?: Enumerable<NeckTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NeckTypes.
     */
    cursor?: NeckTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NeckTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NeckTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NeckTypes.
     */
    distinct?: Enumerable<NeckTypeScalarFieldEnum>
  }

  /**
   * NeckType findFirst
   */
  export interface NeckTypeFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends NeckTypeFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * NeckType findFirstOrThrow
   */
  export type NeckTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NeckType
     */
    select?: NeckTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NeckTypeInclude<ExtArgs> | null
    /**
     * Filter, which NeckType to fetch.
     */
    where?: NeckTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NeckTypes to fetch.
     */
    orderBy?: Enumerable<NeckTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NeckTypes.
     */
    cursor?: NeckTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NeckTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NeckTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NeckTypes.
     */
    distinct?: Enumerable<NeckTypeScalarFieldEnum>
  }


  /**
   * NeckType findMany
   */
  export type NeckTypeFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NeckType
     */
    select?: NeckTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NeckTypeInclude<ExtArgs> | null
    /**
     * Filter, which NeckTypes to fetch.
     */
    where?: NeckTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NeckTypes to fetch.
     */
    orderBy?: Enumerable<NeckTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NeckTypes.
     */
    cursor?: NeckTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NeckTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NeckTypes.
     */
    skip?: number
    distinct?: Enumerable<NeckTypeScalarFieldEnum>
  }


  /**
   * NeckType create
   */
  export type NeckTypeCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NeckType
     */
    select?: NeckTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NeckTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a NeckType.
     */
    data: XOR<NeckTypeCreateInput, NeckTypeUncheckedCreateInput>
  }


  /**
   * NeckType createMany
   */
  export type NeckTypeCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NeckTypes.
     */
    data: Enumerable<NeckTypeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * NeckType update
   */
  export type NeckTypeUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NeckType
     */
    select?: NeckTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NeckTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a NeckType.
     */
    data: XOR<NeckTypeUpdateInput, NeckTypeUncheckedUpdateInput>
    /**
     * Choose, which NeckType to update.
     */
    where: NeckTypeWhereUniqueInput
  }


  /**
   * NeckType updateMany
   */
  export type NeckTypeUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NeckTypes.
     */
    data: XOR<NeckTypeUpdateManyMutationInput, NeckTypeUncheckedUpdateManyInput>
    /**
     * Filter which NeckTypes to update
     */
    where?: NeckTypeWhereInput
  }


  /**
   * NeckType upsert
   */
  export type NeckTypeUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NeckType
     */
    select?: NeckTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NeckTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the NeckType to update in case it exists.
     */
    where: NeckTypeWhereUniqueInput
    /**
     * In case the NeckType found by the `where` argument doesn't exist, create a new NeckType with this data.
     */
    create: XOR<NeckTypeCreateInput, NeckTypeUncheckedCreateInput>
    /**
     * In case the NeckType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NeckTypeUpdateInput, NeckTypeUncheckedUpdateInput>
  }


  /**
   * NeckType delete
   */
  export type NeckTypeDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NeckType
     */
    select?: NeckTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NeckTypeInclude<ExtArgs> | null
    /**
     * Filter which NeckType to delete.
     */
    where: NeckTypeWhereUniqueInput
  }


  /**
   * NeckType deleteMany
   */
  export type NeckTypeDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which NeckTypes to delete
     */
    where?: NeckTypeWhereInput
  }


  /**
   * NeckType.kurtasDescription
   */
  export type NeckType$kurtasDescriptionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KurtasDescription
     */
    select?: KurtasDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KurtasDescriptionInclude<ExtArgs> | null
    where?: KurtasDescriptionWhereInput
    orderBy?: Enumerable<KurtasDescriptionOrderByWithRelationInput>
    cursor?: KurtasDescriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<KurtasDescriptionScalarFieldEnum>
  }


  /**
   * NeckType.innersDescription
   */
  export type NeckType$innersDescriptionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InnersDescription
     */
    select?: InnersDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InnersDescriptionInclude<ExtArgs> | null
    where?: InnersDescriptionWhereInput
    orderBy?: Enumerable<InnersDescriptionOrderByWithRelationInput>
    cursor?: InnersDescriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<InnersDescriptionScalarFieldEnum>
  }


  /**
   * NeckType.topDescription
   */
  export type NeckType$topDescriptionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopDescription
     */
    select?: TopDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TopDescriptionInclude<ExtArgs> | null
    where?: TopDescriptionWhereInput
    orderBy?: Enumerable<TopDescriptionOrderByWithRelationInput>
    cursor?: TopDescriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TopDescriptionScalarFieldEnum>
  }


  /**
   * NeckType without action
   */
  export type NeckTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NeckType
     */
    select?: NeckTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NeckTypeInclude<ExtArgs> | null
  }



  /**
   * Model KurtasLengthType
   */


  export type AggregateKurtasLengthType = {
    _count: KurtasLengthTypeCountAggregateOutputType | null
    _avg: KurtasLengthTypeAvgAggregateOutputType | null
    _sum: KurtasLengthTypeSumAggregateOutputType | null
    _min: KurtasLengthTypeMinAggregateOutputType | null
    _max: KurtasLengthTypeMaxAggregateOutputType | null
  }

  export type KurtasLengthTypeAvgAggregateOutputType = {
    id: number | null
  }

  export type KurtasLengthTypeSumAggregateOutputType = {
    id: number | null
  }

  export type KurtasLengthTypeMinAggregateOutputType = {
    id: number | null
    name: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type KurtasLengthTypeMaxAggregateOutputType = {
    id: number | null
    name: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type KurtasLengthTypeCountAggregateOutputType = {
    id: number
    name: number
    isActive: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type KurtasLengthTypeAvgAggregateInputType = {
    id?: true
  }

  export type KurtasLengthTypeSumAggregateInputType = {
    id?: true
  }

  export type KurtasLengthTypeMinAggregateInputType = {
    id?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type KurtasLengthTypeMaxAggregateInputType = {
    id?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type KurtasLengthTypeCountAggregateInputType = {
    id?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type KurtasLengthTypeAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which KurtasLengthType to aggregate.
     */
    where?: KurtasLengthTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KurtasLengthTypes to fetch.
     */
    orderBy?: Enumerable<KurtasLengthTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KurtasLengthTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KurtasLengthTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KurtasLengthTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KurtasLengthTypes
    **/
    _count?: true | KurtasLengthTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KurtasLengthTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KurtasLengthTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KurtasLengthTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KurtasLengthTypeMaxAggregateInputType
  }

  export type GetKurtasLengthTypeAggregateType<T extends KurtasLengthTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateKurtasLengthType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKurtasLengthType[P]>
      : GetScalarType<T[P], AggregateKurtasLengthType[P]>
  }




  export type KurtasLengthTypeGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: KurtasLengthTypeWhereInput
    orderBy?: Enumerable<KurtasLengthTypeOrderByWithAggregationInput>
    by: KurtasLengthTypeScalarFieldEnum[]
    having?: KurtasLengthTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KurtasLengthTypeCountAggregateInputType | true
    _avg?: KurtasLengthTypeAvgAggregateInputType
    _sum?: KurtasLengthTypeSumAggregateInputType
    _min?: KurtasLengthTypeMinAggregateInputType
    _max?: KurtasLengthTypeMaxAggregateInputType
  }


  export type KurtasLengthTypeGroupByOutputType = {
    id: number
    name: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: KurtasLengthTypeCountAggregateOutputType | null
    _avg: KurtasLengthTypeAvgAggregateOutputType | null
    _sum: KurtasLengthTypeSumAggregateOutputType | null
    _min: KurtasLengthTypeMinAggregateOutputType | null
    _max: KurtasLengthTypeMaxAggregateOutputType | null
  }

  type GetKurtasLengthTypeGroupByPayload<T extends KurtasLengthTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<KurtasLengthTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KurtasLengthTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KurtasLengthTypeGroupByOutputType[P]>
            : GetScalarType<T[P], KurtasLengthTypeGroupByOutputType[P]>
        }
      >
    >


  export type KurtasLengthTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    kurtasDescription?: boolean | KurtasLengthType$kurtasDescriptionArgs<ExtArgs>
    _count?: boolean | KurtasLengthTypeCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["kurtasLengthType"]>

  export type KurtasLengthTypeSelectScalar = {
    id?: boolean
    name?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type KurtasLengthTypeInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    kurtasDescription?: boolean | KurtasLengthType$kurtasDescriptionArgs<ExtArgs>
    _count?: boolean | KurtasLengthTypeCountOutputTypeArgs<ExtArgs>
  }


  type KurtasLengthTypeGetPayload<S extends boolean | null | undefined | KurtasLengthTypeArgs> = $Types.GetResult<KurtasLengthTypePayload, S>

  type KurtasLengthTypeCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<KurtasLengthTypeFindManyArgs, 'select' | 'include'> & {
      select?: KurtasLengthTypeCountAggregateInputType | true
    }

  export interface KurtasLengthTypeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KurtasLengthType'], meta: { name: 'KurtasLengthType' } }
    /**
     * Find zero or one KurtasLengthType that matches the filter.
     * @param {KurtasLengthTypeFindUniqueArgs} args - Arguments to find a KurtasLengthType
     * @example
     * // Get one KurtasLengthType
     * const kurtasLengthType = await prisma.kurtasLengthType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends KurtasLengthTypeFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, KurtasLengthTypeFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'KurtasLengthType'> extends True ? Prisma__KurtasLengthTypeClient<$Types.GetResult<KurtasLengthTypePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__KurtasLengthTypeClient<$Types.GetResult<KurtasLengthTypePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one KurtasLengthType that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {KurtasLengthTypeFindUniqueOrThrowArgs} args - Arguments to find a KurtasLengthType
     * @example
     * // Get one KurtasLengthType
     * const kurtasLengthType = await prisma.kurtasLengthType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends KurtasLengthTypeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, KurtasLengthTypeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__KurtasLengthTypeClient<$Types.GetResult<KurtasLengthTypePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first KurtasLengthType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KurtasLengthTypeFindFirstArgs} args - Arguments to find a KurtasLengthType
     * @example
     * // Get one KurtasLengthType
     * const kurtasLengthType = await prisma.kurtasLengthType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends KurtasLengthTypeFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, KurtasLengthTypeFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'KurtasLengthType'> extends True ? Prisma__KurtasLengthTypeClient<$Types.GetResult<KurtasLengthTypePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__KurtasLengthTypeClient<$Types.GetResult<KurtasLengthTypePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first KurtasLengthType that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KurtasLengthTypeFindFirstOrThrowArgs} args - Arguments to find a KurtasLengthType
     * @example
     * // Get one KurtasLengthType
     * const kurtasLengthType = await prisma.kurtasLengthType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends KurtasLengthTypeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, KurtasLengthTypeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__KurtasLengthTypeClient<$Types.GetResult<KurtasLengthTypePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more KurtasLengthTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KurtasLengthTypeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KurtasLengthTypes
     * const kurtasLengthTypes = await prisma.kurtasLengthType.findMany()
     * 
     * // Get first 10 KurtasLengthTypes
     * const kurtasLengthTypes = await prisma.kurtasLengthType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kurtasLengthTypeWithIdOnly = await prisma.kurtasLengthType.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends KurtasLengthTypeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, KurtasLengthTypeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<KurtasLengthTypePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a KurtasLengthType.
     * @param {KurtasLengthTypeCreateArgs} args - Arguments to create a KurtasLengthType.
     * @example
     * // Create one KurtasLengthType
     * const KurtasLengthType = await prisma.kurtasLengthType.create({
     *   data: {
     *     // ... data to create a KurtasLengthType
     *   }
     * })
     * 
    **/
    create<T extends KurtasLengthTypeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, KurtasLengthTypeCreateArgs<ExtArgs>>
    ): Prisma__KurtasLengthTypeClient<$Types.GetResult<KurtasLengthTypePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many KurtasLengthTypes.
     *     @param {KurtasLengthTypeCreateManyArgs} args - Arguments to create many KurtasLengthTypes.
     *     @example
     *     // Create many KurtasLengthTypes
     *     const kurtasLengthType = await prisma.kurtasLengthType.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends KurtasLengthTypeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, KurtasLengthTypeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a KurtasLengthType.
     * @param {KurtasLengthTypeDeleteArgs} args - Arguments to delete one KurtasLengthType.
     * @example
     * // Delete one KurtasLengthType
     * const KurtasLengthType = await prisma.kurtasLengthType.delete({
     *   where: {
     *     // ... filter to delete one KurtasLengthType
     *   }
     * })
     * 
    **/
    delete<T extends KurtasLengthTypeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, KurtasLengthTypeDeleteArgs<ExtArgs>>
    ): Prisma__KurtasLengthTypeClient<$Types.GetResult<KurtasLengthTypePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one KurtasLengthType.
     * @param {KurtasLengthTypeUpdateArgs} args - Arguments to update one KurtasLengthType.
     * @example
     * // Update one KurtasLengthType
     * const kurtasLengthType = await prisma.kurtasLengthType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends KurtasLengthTypeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, KurtasLengthTypeUpdateArgs<ExtArgs>>
    ): Prisma__KurtasLengthTypeClient<$Types.GetResult<KurtasLengthTypePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more KurtasLengthTypes.
     * @param {KurtasLengthTypeDeleteManyArgs} args - Arguments to filter KurtasLengthTypes to delete.
     * @example
     * // Delete a few KurtasLengthTypes
     * const { count } = await prisma.kurtasLengthType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends KurtasLengthTypeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, KurtasLengthTypeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KurtasLengthTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KurtasLengthTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KurtasLengthTypes
     * const kurtasLengthType = await prisma.kurtasLengthType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends KurtasLengthTypeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, KurtasLengthTypeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one KurtasLengthType.
     * @param {KurtasLengthTypeUpsertArgs} args - Arguments to update or create a KurtasLengthType.
     * @example
     * // Update or create a KurtasLengthType
     * const kurtasLengthType = await prisma.kurtasLengthType.upsert({
     *   create: {
     *     // ... data to create a KurtasLengthType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KurtasLengthType we want to update
     *   }
     * })
    **/
    upsert<T extends KurtasLengthTypeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, KurtasLengthTypeUpsertArgs<ExtArgs>>
    ): Prisma__KurtasLengthTypeClient<$Types.GetResult<KurtasLengthTypePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of KurtasLengthTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KurtasLengthTypeCountArgs} args - Arguments to filter KurtasLengthTypes to count.
     * @example
     * // Count the number of KurtasLengthTypes
     * const count = await prisma.kurtasLengthType.count({
     *   where: {
     *     // ... the filter for the KurtasLengthTypes we want to count
     *   }
     * })
    **/
    count<T extends KurtasLengthTypeCountArgs>(
      args?: Subset<T, KurtasLengthTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KurtasLengthTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KurtasLengthType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KurtasLengthTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KurtasLengthTypeAggregateArgs>(args: Subset<T, KurtasLengthTypeAggregateArgs>): Prisma.PrismaPromise<GetKurtasLengthTypeAggregateType<T>>

    /**
     * Group by KurtasLengthType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KurtasLengthTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KurtasLengthTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KurtasLengthTypeGroupByArgs['orderBy'] }
        : { orderBy?: KurtasLengthTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KurtasLengthTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKurtasLengthTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for KurtasLengthType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__KurtasLengthTypeClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    kurtasDescription<T extends KurtasLengthType$kurtasDescriptionArgs<ExtArgs> = {}>(args?: Subset<T, KurtasLengthType$kurtasDescriptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<KurtasDescriptionPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * KurtasLengthType base type for findUnique actions
   */
  export type KurtasLengthTypeFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KurtasLengthType
     */
    select?: KurtasLengthTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KurtasLengthTypeInclude<ExtArgs> | null
    /**
     * Filter, which KurtasLengthType to fetch.
     */
    where: KurtasLengthTypeWhereUniqueInput
  }

  /**
   * KurtasLengthType findUnique
   */
  export interface KurtasLengthTypeFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends KurtasLengthTypeFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * KurtasLengthType findUniqueOrThrow
   */
  export type KurtasLengthTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KurtasLengthType
     */
    select?: KurtasLengthTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KurtasLengthTypeInclude<ExtArgs> | null
    /**
     * Filter, which KurtasLengthType to fetch.
     */
    where: KurtasLengthTypeWhereUniqueInput
  }


  /**
   * KurtasLengthType base type for findFirst actions
   */
  export type KurtasLengthTypeFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KurtasLengthType
     */
    select?: KurtasLengthTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KurtasLengthTypeInclude<ExtArgs> | null
    /**
     * Filter, which KurtasLengthType to fetch.
     */
    where?: KurtasLengthTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KurtasLengthTypes to fetch.
     */
    orderBy?: Enumerable<KurtasLengthTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KurtasLengthTypes.
     */
    cursor?: KurtasLengthTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KurtasLengthTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KurtasLengthTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KurtasLengthTypes.
     */
    distinct?: Enumerable<KurtasLengthTypeScalarFieldEnum>
  }

  /**
   * KurtasLengthType findFirst
   */
  export interface KurtasLengthTypeFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends KurtasLengthTypeFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * KurtasLengthType findFirstOrThrow
   */
  export type KurtasLengthTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KurtasLengthType
     */
    select?: KurtasLengthTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KurtasLengthTypeInclude<ExtArgs> | null
    /**
     * Filter, which KurtasLengthType to fetch.
     */
    where?: KurtasLengthTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KurtasLengthTypes to fetch.
     */
    orderBy?: Enumerable<KurtasLengthTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KurtasLengthTypes.
     */
    cursor?: KurtasLengthTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KurtasLengthTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KurtasLengthTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KurtasLengthTypes.
     */
    distinct?: Enumerable<KurtasLengthTypeScalarFieldEnum>
  }


  /**
   * KurtasLengthType findMany
   */
  export type KurtasLengthTypeFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KurtasLengthType
     */
    select?: KurtasLengthTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KurtasLengthTypeInclude<ExtArgs> | null
    /**
     * Filter, which KurtasLengthTypes to fetch.
     */
    where?: KurtasLengthTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KurtasLengthTypes to fetch.
     */
    orderBy?: Enumerable<KurtasLengthTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KurtasLengthTypes.
     */
    cursor?: KurtasLengthTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KurtasLengthTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KurtasLengthTypes.
     */
    skip?: number
    distinct?: Enumerable<KurtasLengthTypeScalarFieldEnum>
  }


  /**
   * KurtasLengthType create
   */
  export type KurtasLengthTypeCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KurtasLengthType
     */
    select?: KurtasLengthTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KurtasLengthTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a KurtasLengthType.
     */
    data: XOR<KurtasLengthTypeCreateInput, KurtasLengthTypeUncheckedCreateInput>
  }


  /**
   * KurtasLengthType createMany
   */
  export type KurtasLengthTypeCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KurtasLengthTypes.
     */
    data: Enumerable<KurtasLengthTypeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * KurtasLengthType update
   */
  export type KurtasLengthTypeUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KurtasLengthType
     */
    select?: KurtasLengthTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KurtasLengthTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a KurtasLengthType.
     */
    data: XOR<KurtasLengthTypeUpdateInput, KurtasLengthTypeUncheckedUpdateInput>
    /**
     * Choose, which KurtasLengthType to update.
     */
    where: KurtasLengthTypeWhereUniqueInput
  }


  /**
   * KurtasLengthType updateMany
   */
  export type KurtasLengthTypeUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KurtasLengthTypes.
     */
    data: XOR<KurtasLengthTypeUpdateManyMutationInput, KurtasLengthTypeUncheckedUpdateManyInput>
    /**
     * Filter which KurtasLengthTypes to update
     */
    where?: KurtasLengthTypeWhereInput
  }


  /**
   * KurtasLengthType upsert
   */
  export type KurtasLengthTypeUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KurtasLengthType
     */
    select?: KurtasLengthTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KurtasLengthTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the KurtasLengthType to update in case it exists.
     */
    where: KurtasLengthTypeWhereUniqueInput
    /**
     * In case the KurtasLengthType found by the `where` argument doesn't exist, create a new KurtasLengthType with this data.
     */
    create: XOR<KurtasLengthTypeCreateInput, KurtasLengthTypeUncheckedCreateInput>
    /**
     * In case the KurtasLengthType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KurtasLengthTypeUpdateInput, KurtasLengthTypeUncheckedUpdateInput>
  }


  /**
   * KurtasLengthType delete
   */
  export type KurtasLengthTypeDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KurtasLengthType
     */
    select?: KurtasLengthTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KurtasLengthTypeInclude<ExtArgs> | null
    /**
     * Filter which KurtasLengthType to delete.
     */
    where: KurtasLengthTypeWhereUniqueInput
  }


  /**
   * KurtasLengthType deleteMany
   */
  export type KurtasLengthTypeDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which KurtasLengthTypes to delete
     */
    where?: KurtasLengthTypeWhereInput
  }


  /**
   * KurtasLengthType.kurtasDescription
   */
  export type KurtasLengthType$kurtasDescriptionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KurtasDescription
     */
    select?: KurtasDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KurtasDescriptionInclude<ExtArgs> | null
    where?: KurtasDescriptionWhereInput
    orderBy?: Enumerable<KurtasDescriptionOrderByWithRelationInput>
    cursor?: KurtasDescriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<KurtasDescriptionScalarFieldEnum>
  }


  /**
   * KurtasLengthType without action
   */
  export type KurtasLengthTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KurtasLengthType
     */
    select?: KurtasLengthTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: KurtasLengthTypeInclude<ExtArgs> | null
  }



  /**
   * Model TypesOfBottom
   */


  export type AggregateTypesOfBottom = {
    _count: TypesOfBottomCountAggregateOutputType | null
    _avg: TypesOfBottomAvgAggregateOutputType | null
    _sum: TypesOfBottomSumAggregateOutputType | null
    _min: TypesOfBottomMinAggregateOutputType | null
    _max: TypesOfBottomMaxAggregateOutputType | null
  }

  export type TypesOfBottomAvgAggregateOutputType = {
    id: number | null
  }

  export type TypesOfBottomSumAggregateOutputType = {
    id: number | null
  }

  export type TypesOfBottomMinAggregateOutputType = {
    id: number | null
    name: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type TypesOfBottomMaxAggregateOutputType = {
    id: number | null
    name: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type TypesOfBottomCountAggregateOutputType = {
    id: number
    name: number
    isActive: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type TypesOfBottomAvgAggregateInputType = {
    id?: true
  }

  export type TypesOfBottomSumAggregateInputType = {
    id?: true
  }

  export type TypesOfBottomMinAggregateInputType = {
    id?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type TypesOfBottomMaxAggregateInputType = {
    id?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type TypesOfBottomCountAggregateInputType = {
    id?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type TypesOfBottomAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which TypesOfBottom to aggregate.
     */
    where?: TypesOfBottomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TypesOfBottoms to fetch.
     */
    orderBy?: Enumerable<TypesOfBottomOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TypesOfBottomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TypesOfBottoms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TypesOfBottoms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TypesOfBottoms
    **/
    _count?: true | TypesOfBottomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TypesOfBottomAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TypesOfBottomSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TypesOfBottomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TypesOfBottomMaxAggregateInputType
  }

  export type GetTypesOfBottomAggregateType<T extends TypesOfBottomAggregateArgs> = {
        [P in keyof T & keyof AggregateTypesOfBottom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTypesOfBottom[P]>
      : GetScalarType<T[P], AggregateTypesOfBottom[P]>
  }




  export type TypesOfBottomGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: TypesOfBottomWhereInput
    orderBy?: Enumerable<TypesOfBottomOrderByWithAggregationInput>
    by: TypesOfBottomScalarFieldEnum[]
    having?: TypesOfBottomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TypesOfBottomCountAggregateInputType | true
    _avg?: TypesOfBottomAvgAggregateInputType
    _sum?: TypesOfBottomSumAggregateInputType
    _min?: TypesOfBottomMinAggregateInputType
    _max?: TypesOfBottomMaxAggregateInputType
  }


  export type TypesOfBottomGroupByOutputType = {
    id: number
    name: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: TypesOfBottomCountAggregateOutputType | null
    _avg: TypesOfBottomAvgAggregateOutputType | null
    _sum: TypesOfBottomSumAggregateOutputType | null
    _min: TypesOfBottomMinAggregateOutputType | null
    _max: TypesOfBottomMaxAggregateOutputType | null
  }

  type GetTypesOfBottomGroupByPayload<T extends TypesOfBottomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TypesOfBottomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TypesOfBottomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TypesOfBottomGroupByOutputType[P]>
            : GetScalarType<T[P], TypesOfBottomGroupByOutputType[P]>
        }
      >
    >


  export type TypesOfBottomSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    description?: boolean | TypesOfBottom$descriptionArgs<ExtArgs>
    _count?: boolean | TypesOfBottomCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["typesOfBottom"]>

  export type TypesOfBottomSelectScalar = {
    id?: boolean
    name?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type TypesOfBottomInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    description?: boolean | TypesOfBottom$descriptionArgs<ExtArgs>
    _count?: boolean | TypesOfBottomCountOutputTypeArgs<ExtArgs>
  }


  type TypesOfBottomGetPayload<S extends boolean | null | undefined | TypesOfBottomArgs> = $Types.GetResult<TypesOfBottomPayload, S>

  type TypesOfBottomCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<TypesOfBottomFindManyArgs, 'select' | 'include'> & {
      select?: TypesOfBottomCountAggregateInputType | true
    }

  export interface TypesOfBottomDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TypesOfBottom'], meta: { name: 'TypesOfBottom' } }
    /**
     * Find zero or one TypesOfBottom that matches the filter.
     * @param {TypesOfBottomFindUniqueArgs} args - Arguments to find a TypesOfBottom
     * @example
     * // Get one TypesOfBottom
     * const typesOfBottom = await prisma.typesOfBottom.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TypesOfBottomFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TypesOfBottomFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TypesOfBottom'> extends True ? Prisma__TypesOfBottomClient<$Types.GetResult<TypesOfBottomPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__TypesOfBottomClient<$Types.GetResult<TypesOfBottomPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one TypesOfBottom that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TypesOfBottomFindUniqueOrThrowArgs} args - Arguments to find a TypesOfBottom
     * @example
     * // Get one TypesOfBottom
     * const typesOfBottom = await prisma.typesOfBottom.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TypesOfBottomFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TypesOfBottomFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TypesOfBottomClient<$Types.GetResult<TypesOfBottomPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first TypesOfBottom that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypesOfBottomFindFirstArgs} args - Arguments to find a TypesOfBottom
     * @example
     * // Get one TypesOfBottom
     * const typesOfBottom = await prisma.typesOfBottom.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TypesOfBottomFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TypesOfBottomFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TypesOfBottom'> extends True ? Prisma__TypesOfBottomClient<$Types.GetResult<TypesOfBottomPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__TypesOfBottomClient<$Types.GetResult<TypesOfBottomPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first TypesOfBottom that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypesOfBottomFindFirstOrThrowArgs} args - Arguments to find a TypesOfBottom
     * @example
     * // Get one TypesOfBottom
     * const typesOfBottom = await prisma.typesOfBottom.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TypesOfBottomFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TypesOfBottomFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TypesOfBottomClient<$Types.GetResult<TypesOfBottomPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more TypesOfBottoms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypesOfBottomFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TypesOfBottoms
     * const typesOfBottoms = await prisma.typesOfBottom.findMany()
     * 
     * // Get first 10 TypesOfBottoms
     * const typesOfBottoms = await prisma.typesOfBottom.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const typesOfBottomWithIdOnly = await prisma.typesOfBottom.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TypesOfBottomFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TypesOfBottomFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<TypesOfBottomPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a TypesOfBottom.
     * @param {TypesOfBottomCreateArgs} args - Arguments to create a TypesOfBottom.
     * @example
     * // Create one TypesOfBottom
     * const TypesOfBottom = await prisma.typesOfBottom.create({
     *   data: {
     *     // ... data to create a TypesOfBottom
     *   }
     * })
     * 
    **/
    create<T extends TypesOfBottomCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TypesOfBottomCreateArgs<ExtArgs>>
    ): Prisma__TypesOfBottomClient<$Types.GetResult<TypesOfBottomPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many TypesOfBottoms.
     *     @param {TypesOfBottomCreateManyArgs} args - Arguments to create many TypesOfBottoms.
     *     @example
     *     // Create many TypesOfBottoms
     *     const typesOfBottom = await prisma.typesOfBottom.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TypesOfBottomCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TypesOfBottomCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TypesOfBottom.
     * @param {TypesOfBottomDeleteArgs} args - Arguments to delete one TypesOfBottom.
     * @example
     * // Delete one TypesOfBottom
     * const TypesOfBottom = await prisma.typesOfBottom.delete({
     *   where: {
     *     // ... filter to delete one TypesOfBottom
     *   }
     * })
     * 
    **/
    delete<T extends TypesOfBottomDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TypesOfBottomDeleteArgs<ExtArgs>>
    ): Prisma__TypesOfBottomClient<$Types.GetResult<TypesOfBottomPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one TypesOfBottom.
     * @param {TypesOfBottomUpdateArgs} args - Arguments to update one TypesOfBottom.
     * @example
     * // Update one TypesOfBottom
     * const typesOfBottom = await prisma.typesOfBottom.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TypesOfBottomUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TypesOfBottomUpdateArgs<ExtArgs>>
    ): Prisma__TypesOfBottomClient<$Types.GetResult<TypesOfBottomPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more TypesOfBottoms.
     * @param {TypesOfBottomDeleteManyArgs} args - Arguments to filter TypesOfBottoms to delete.
     * @example
     * // Delete a few TypesOfBottoms
     * const { count } = await prisma.typesOfBottom.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TypesOfBottomDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TypesOfBottomDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TypesOfBottoms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypesOfBottomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TypesOfBottoms
     * const typesOfBottom = await prisma.typesOfBottom.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TypesOfBottomUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TypesOfBottomUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TypesOfBottom.
     * @param {TypesOfBottomUpsertArgs} args - Arguments to update or create a TypesOfBottom.
     * @example
     * // Update or create a TypesOfBottom
     * const typesOfBottom = await prisma.typesOfBottom.upsert({
     *   create: {
     *     // ... data to create a TypesOfBottom
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TypesOfBottom we want to update
     *   }
     * })
    **/
    upsert<T extends TypesOfBottomUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TypesOfBottomUpsertArgs<ExtArgs>>
    ): Prisma__TypesOfBottomClient<$Types.GetResult<TypesOfBottomPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of TypesOfBottoms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypesOfBottomCountArgs} args - Arguments to filter TypesOfBottoms to count.
     * @example
     * // Count the number of TypesOfBottoms
     * const count = await prisma.typesOfBottom.count({
     *   where: {
     *     // ... the filter for the TypesOfBottoms we want to count
     *   }
     * })
    **/
    count<T extends TypesOfBottomCountArgs>(
      args?: Subset<T, TypesOfBottomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TypesOfBottomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TypesOfBottom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypesOfBottomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TypesOfBottomAggregateArgs>(args: Subset<T, TypesOfBottomAggregateArgs>): Prisma.PrismaPromise<GetTypesOfBottomAggregateType<T>>

    /**
     * Group by TypesOfBottom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypesOfBottomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TypesOfBottomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TypesOfBottomGroupByArgs['orderBy'] }
        : { orderBy?: TypesOfBottomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TypesOfBottomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTypesOfBottomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TypesOfBottom.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TypesOfBottomClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    description<T extends TypesOfBottom$descriptionArgs<ExtArgs> = {}>(args?: Subset<T, TypesOfBottom$descriptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<BottomDescriptionPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TypesOfBottom base type for findUnique actions
   */
  export type TypesOfBottomFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypesOfBottom
     */
    select?: TypesOfBottomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TypesOfBottomInclude<ExtArgs> | null
    /**
     * Filter, which TypesOfBottom to fetch.
     */
    where: TypesOfBottomWhereUniqueInput
  }

  /**
   * TypesOfBottom findUnique
   */
  export interface TypesOfBottomFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends TypesOfBottomFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TypesOfBottom findUniqueOrThrow
   */
  export type TypesOfBottomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypesOfBottom
     */
    select?: TypesOfBottomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TypesOfBottomInclude<ExtArgs> | null
    /**
     * Filter, which TypesOfBottom to fetch.
     */
    where: TypesOfBottomWhereUniqueInput
  }


  /**
   * TypesOfBottom base type for findFirst actions
   */
  export type TypesOfBottomFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypesOfBottom
     */
    select?: TypesOfBottomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TypesOfBottomInclude<ExtArgs> | null
    /**
     * Filter, which TypesOfBottom to fetch.
     */
    where?: TypesOfBottomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TypesOfBottoms to fetch.
     */
    orderBy?: Enumerable<TypesOfBottomOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TypesOfBottoms.
     */
    cursor?: TypesOfBottomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TypesOfBottoms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TypesOfBottoms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TypesOfBottoms.
     */
    distinct?: Enumerable<TypesOfBottomScalarFieldEnum>
  }

  /**
   * TypesOfBottom findFirst
   */
  export interface TypesOfBottomFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends TypesOfBottomFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TypesOfBottom findFirstOrThrow
   */
  export type TypesOfBottomFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypesOfBottom
     */
    select?: TypesOfBottomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TypesOfBottomInclude<ExtArgs> | null
    /**
     * Filter, which TypesOfBottom to fetch.
     */
    where?: TypesOfBottomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TypesOfBottoms to fetch.
     */
    orderBy?: Enumerable<TypesOfBottomOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TypesOfBottoms.
     */
    cursor?: TypesOfBottomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TypesOfBottoms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TypesOfBottoms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TypesOfBottoms.
     */
    distinct?: Enumerable<TypesOfBottomScalarFieldEnum>
  }


  /**
   * TypesOfBottom findMany
   */
  export type TypesOfBottomFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypesOfBottom
     */
    select?: TypesOfBottomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TypesOfBottomInclude<ExtArgs> | null
    /**
     * Filter, which TypesOfBottoms to fetch.
     */
    where?: TypesOfBottomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TypesOfBottoms to fetch.
     */
    orderBy?: Enumerable<TypesOfBottomOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TypesOfBottoms.
     */
    cursor?: TypesOfBottomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TypesOfBottoms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TypesOfBottoms.
     */
    skip?: number
    distinct?: Enumerable<TypesOfBottomScalarFieldEnum>
  }


  /**
   * TypesOfBottom create
   */
  export type TypesOfBottomCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypesOfBottom
     */
    select?: TypesOfBottomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TypesOfBottomInclude<ExtArgs> | null
    /**
     * The data needed to create a TypesOfBottom.
     */
    data: XOR<TypesOfBottomCreateInput, TypesOfBottomUncheckedCreateInput>
  }


  /**
   * TypesOfBottom createMany
   */
  export type TypesOfBottomCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TypesOfBottoms.
     */
    data: Enumerable<TypesOfBottomCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TypesOfBottom update
   */
  export type TypesOfBottomUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypesOfBottom
     */
    select?: TypesOfBottomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TypesOfBottomInclude<ExtArgs> | null
    /**
     * The data needed to update a TypesOfBottom.
     */
    data: XOR<TypesOfBottomUpdateInput, TypesOfBottomUncheckedUpdateInput>
    /**
     * Choose, which TypesOfBottom to update.
     */
    where: TypesOfBottomWhereUniqueInput
  }


  /**
   * TypesOfBottom updateMany
   */
  export type TypesOfBottomUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TypesOfBottoms.
     */
    data: XOR<TypesOfBottomUpdateManyMutationInput, TypesOfBottomUncheckedUpdateManyInput>
    /**
     * Filter which TypesOfBottoms to update
     */
    where?: TypesOfBottomWhereInput
  }


  /**
   * TypesOfBottom upsert
   */
  export type TypesOfBottomUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypesOfBottom
     */
    select?: TypesOfBottomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TypesOfBottomInclude<ExtArgs> | null
    /**
     * The filter to search for the TypesOfBottom to update in case it exists.
     */
    where: TypesOfBottomWhereUniqueInput
    /**
     * In case the TypesOfBottom found by the `where` argument doesn't exist, create a new TypesOfBottom with this data.
     */
    create: XOR<TypesOfBottomCreateInput, TypesOfBottomUncheckedCreateInput>
    /**
     * In case the TypesOfBottom was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TypesOfBottomUpdateInput, TypesOfBottomUncheckedUpdateInput>
  }


  /**
   * TypesOfBottom delete
   */
  export type TypesOfBottomDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypesOfBottom
     */
    select?: TypesOfBottomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TypesOfBottomInclude<ExtArgs> | null
    /**
     * Filter which TypesOfBottom to delete.
     */
    where: TypesOfBottomWhereUniqueInput
  }


  /**
   * TypesOfBottom deleteMany
   */
  export type TypesOfBottomDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which TypesOfBottoms to delete
     */
    where?: TypesOfBottomWhereInput
  }


  /**
   * TypesOfBottom.description
   */
  export type TypesOfBottom$descriptionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BottomDescription
     */
    select?: BottomDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BottomDescriptionInclude<ExtArgs> | null
    where?: BottomDescriptionWhereInput
    orderBy?: Enumerable<BottomDescriptionOrderByWithRelationInput>
    cursor?: BottomDescriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BottomDescriptionScalarFieldEnum>
  }


  /**
   * TypesOfBottom without action
   */
  export type TypesOfBottomArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypesOfBottom
     */
    select?: TypesOfBottomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TypesOfBottomInclude<ExtArgs> | null
  }



  /**
   * Model TypesOfPleats
   */


  export type AggregateTypesOfPleats = {
    _count: TypesOfPleatsCountAggregateOutputType | null
    _avg: TypesOfPleatsAvgAggregateOutputType | null
    _sum: TypesOfPleatsSumAggregateOutputType | null
    _min: TypesOfPleatsMinAggregateOutputType | null
    _max: TypesOfPleatsMaxAggregateOutputType | null
  }

  export type TypesOfPleatsAvgAggregateOutputType = {
    id: number | null
  }

  export type TypesOfPleatsSumAggregateOutputType = {
    id: number | null
  }

  export type TypesOfPleatsMinAggregateOutputType = {
    id: number | null
    name: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type TypesOfPleatsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type TypesOfPleatsCountAggregateOutputType = {
    id: number
    name: number
    isActive: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type TypesOfPleatsAvgAggregateInputType = {
    id?: true
  }

  export type TypesOfPleatsSumAggregateInputType = {
    id?: true
  }

  export type TypesOfPleatsMinAggregateInputType = {
    id?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type TypesOfPleatsMaxAggregateInputType = {
    id?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type TypesOfPleatsCountAggregateInputType = {
    id?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type TypesOfPleatsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which TypesOfPleats to aggregate.
     */
    where?: TypesOfPleatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TypesOfPleats to fetch.
     */
    orderBy?: Enumerable<TypesOfPleatsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TypesOfPleatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TypesOfPleats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TypesOfPleats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TypesOfPleats
    **/
    _count?: true | TypesOfPleatsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TypesOfPleatsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TypesOfPleatsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TypesOfPleatsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TypesOfPleatsMaxAggregateInputType
  }

  export type GetTypesOfPleatsAggregateType<T extends TypesOfPleatsAggregateArgs> = {
        [P in keyof T & keyof AggregateTypesOfPleats]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTypesOfPleats[P]>
      : GetScalarType<T[P], AggregateTypesOfPleats[P]>
  }




  export type TypesOfPleatsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: TypesOfPleatsWhereInput
    orderBy?: Enumerable<TypesOfPleatsOrderByWithAggregationInput>
    by: TypesOfPleatsScalarFieldEnum[]
    having?: TypesOfPleatsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TypesOfPleatsCountAggregateInputType | true
    _avg?: TypesOfPleatsAvgAggregateInputType
    _sum?: TypesOfPleatsSumAggregateInputType
    _min?: TypesOfPleatsMinAggregateInputType
    _max?: TypesOfPleatsMaxAggregateInputType
  }


  export type TypesOfPleatsGroupByOutputType = {
    id: number
    name: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: TypesOfPleatsCountAggregateOutputType | null
    _avg: TypesOfPleatsAvgAggregateOutputType | null
    _sum: TypesOfPleatsSumAggregateOutputType | null
    _min: TypesOfPleatsMinAggregateOutputType | null
    _max: TypesOfPleatsMaxAggregateOutputType | null
  }

  type GetTypesOfPleatsGroupByPayload<T extends TypesOfPleatsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TypesOfPleatsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TypesOfPleatsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TypesOfPleatsGroupByOutputType[P]>
            : GetScalarType<T[P], TypesOfPleatsGroupByOutputType[P]>
        }
      >
    >


  export type TypesOfPleatsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    description?: boolean | TypesOfPleats$descriptionArgs<ExtArgs>
    _count?: boolean | TypesOfPleatsCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["typesOfPleats"]>

  export type TypesOfPleatsSelectScalar = {
    id?: boolean
    name?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type TypesOfPleatsInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    description?: boolean | TypesOfPleats$descriptionArgs<ExtArgs>
    _count?: boolean | TypesOfPleatsCountOutputTypeArgs<ExtArgs>
  }


  type TypesOfPleatsGetPayload<S extends boolean | null | undefined | TypesOfPleatsArgs> = $Types.GetResult<TypesOfPleatsPayload, S>

  type TypesOfPleatsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<TypesOfPleatsFindManyArgs, 'select' | 'include'> & {
      select?: TypesOfPleatsCountAggregateInputType | true
    }

  export interface TypesOfPleatsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TypesOfPleats'], meta: { name: 'TypesOfPleats' } }
    /**
     * Find zero or one TypesOfPleats that matches the filter.
     * @param {TypesOfPleatsFindUniqueArgs} args - Arguments to find a TypesOfPleats
     * @example
     * // Get one TypesOfPleats
     * const typesOfPleats = await prisma.typesOfPleats.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TypesOfPleatsFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TypesOfPleatsFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TypesOfPleats'> extends True ? Prisma__TypesOfPleatsClient<$Types.GetResult<TypesOfPleatsPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__TypesOfPleatsClient<$Types.GetResult<TypesOfPleatsPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one TypesOfPleats that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TypesOfPleatsFindUniqueOrThrowArgs} args - Arguments to find a TypesOfPleats
     * @example
     * // Get one TypesOfPleats
     * const typesOfPleats = await prisma.typesOfPleats.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TypesOfPleatsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TypesOfPleatsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TypesOfPleatsClient<$Types.GetResult<TypesOfPleatsPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first TypesOfPleats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypesOfPleatsFindFirstArgs} args - Arguments to find a TypesOfPleats
     * @example
     * // Get one TypesOfPleats
     * const typesOfPleats = await prisma.typesOfPleats.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TypesOfPleatsFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TypesOfPleatsFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TypesOfPleats'> extends True ? Prisma__TypesOfPleatsClient<$Types.GetResult<TypesOfPleatsPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__TypesOfPleatsClient<$Types.GetResult<TypesOfPleatsPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first TypesOfPleats that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypesOfPleatsFindFirstOrThrowArgs} args - Arguments to find a TypesOfPleats
     * @example
     * // Get one TypesOfPleats
     * const typesOfPleats = await prisma.typesOfPleats.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TypesOfPleatsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TypesOfPleatsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TypesOfPleatsClient<$Types.GetResult<TypesOfPleatsPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more TypesOfPleats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypesOfPleatsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TypesOfPleats
     * const typesOfPleats = await prisma.typesOfPleats.findMany()
     * 
     * // Get first 10 TypesOfPleats
     * const typesOfPleats = await prisma.typesOfPleats.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const typesOfPleatsWithIdOnly = await prisma.typesOfPleats.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TypesOfPleatsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TypesOfPleatsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<TypesOfPleatsPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a TypesOfPleats.
     * @param {TypesOfPleatsCreateArgs} args - Arguments to create a TypesOfPleats.
     * @example
     * // Create one TypesOfPleats
     * const TypesOfPleats = await prisma.typesOfPleats.create({
     *   data: {
     *     // ... data to create a TypesOfPleats
     *   }
     * })
     * 
    **/
    create<T extends TypesOfPleatsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TypesOfPleatsCreateArgs<ExtArgs>>
    ): Prisma__TypesOfPleatsClient<$Types.GetResult<TypesOfPleatsPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many TypesOfPleats.
     *     @param {TypesOfPleatsCreateManyArgs} args - Arguments to create many TypesOfPleats.
     *     @example
     *     // Create many TypesOfPleats
     *     const typesOfPleats = await prisma.typesOfPleats.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TypesOfPleatsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TypesOfPleatsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TypesOfPleats.
     * @param {TypesOfPleatsDeleteArgs} args - Arguments to delete one TypesOfPleats.
     * @example
     * // Delete one TypesOfPleats
     * const TypesOfPleats = await prisma.typesOfPleats.delete({
     *   where: {
     *     // ... filter to delete one TypesOfPleats
     *   }
     * })
     * 
    **/
    delete<T extends TypesOfPleatsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TypesOfPleatsDeleteArgs<ExtArgs>>
    ): Prisma__TypesOfPleatsClient<$Types.GetResult<TypesOfPleatsPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one TypesOfPleats.
     * @param {TypesOfPleatsUpdateArgs} args - Arguments to update one TypesOfPleats.
     * @example
     * // Update one TypesOfPleats
     * const typesOfPleats = await prisma.typesOfPleats.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TypesOfPleatsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TypesOfPleatsUpdateArgs<ExtArgs>>
    ): Prisma__TypesOfPleatsClient<$Types.GetResult<TypesOfPleatsPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more TypesOfPleats.
     * @param {TypesOfPleatsDeleteManyArgs} args - Arguments to filter TypesOfPleats to delete.
     * @example
     * // Delete a few TypesOfPleats
     * const { count } = await prisma.typesOfPleats.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TypesOfPleatsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TypesOfPleatsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TypesOfPleats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypesOfPleatsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TypesOfPleats
     * const typesOfPleats = await prisma.typesOfPleats.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TypesOfPleatsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TypesOfPleatsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TypesOfPleats.
     * @param {TypesOfPleatsUpsertArgs} args - Arguments to update or create a TypesOfPleats.
     * @example
     * // Update or create a TypesOfPleats
     * const typesOfPleats = await prisma.typesOfPleats.upsert({
     *   create: {
     *     // ... data to create a TypesOfPleats
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TypesOfPleats we want to update
     *   }
     * })
    **/
    upsert<T extends TypesOfPleatsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TypesOfPleatsUpsertArgs<ExtArgs>>
    ): Prisma__TypesOfPleatsClient<$Types.GetResult<TypesOfPleatsPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of TypesOfPleats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypesOfPleatsCountArgs} args - Arguments to filter TypesOfPleats to count.
     * @example
     * // Count the number of TypesOfPleats
     * const count = await prisma.typesOfPleats.count({
     *   where: {
     *     // ... the filter for the TypesOfPleats we want to count
     *   }
     * })
    **/
    count<T extends TypesOfPleatsCountArgs>(
      args?: Subset<T, TypesOfPleatsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TypesOfPleatsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TypesOfPleats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypesOfPleatsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TypesOfPleatsAggregateArgs>(args: Subset<T, TypesOfPleatsAggregateArgs>): Prisma.PrismaPromise<GetTypesOfPleatsAggregateType<T>>

    /**
     * Group by TypesOfPleats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypesOfPleatsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TypesOfPleatsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TypesOfPleatsGroupByArgs['orderBy'] }
        : { orderBy?: TypesOfPleatsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TypesOfPleatsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTypesOfPleatsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TypesOfPleats.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TypesOfPleatsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    description<T extends TypesOfPleats$descriptionArgs<ExtArgs> = {}>(args?: Subset<T, TypesOfPleats$descriptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<BottomDescriptionPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TypesOfPleats base type for findUnique actions
   */
  export type TypesOfPleatsFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypesOfPleats
     */
    select?: TypesOfPleatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TypesOfPleatsInclude<ExtArgs> | null
    /**
     * Filter, which TypesOfPleats to fetch.
     */
    where: TypesOfPleatsWhereUniqueInput
  }

  /**
   * TypesOfPleats findUnique
   */
  export interface TypesOfPleatsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends TypesOfPleatsFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TypesOfPleats findUniqueOrThrow
   */
  export type TypesOfPleatsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypesOfPleats
     */
    select?: TypesOfPleatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TypesOfPleatsInclude<ExtArgs> | null
    /**
     * Filter, which TypesOfPleats to fetch.
     */
    where: TypesOfPleatsWhereUniqueInput
  }


  /**
   * TypesOfPleats base type for findFirst actions
   */
  export type TypesOfPleatsFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypesOfPleats
     */
    select?: TypesOfPleatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TypesOfPleatsInclude<ExtArgs> | null
    /**
     * Filter, which TypesOfPleats to fetch.
     */
    where?: TypesOfPleatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TypesOfPleats to fetch.
     */
    orderBy?: Enumerable<TypesOfPleatsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TypesOfPleats.
     */
    cursor?: TypesOfPleatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TypesOfPleats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TypesOfPleats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TypesOfPleats.
     */
    distinct?: Enumerable<TypesOfPleatsScalarFieldEnum>
  }

  /**
   * TypesOfPleats findFirst
   */
  export interface TypesOfPleatsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends TypesOfPleatsFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TypesOfPleats findFirstOrThrow
   */
  export type TypesOfPleatsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypesOfPleats
     */
    select?: TypesOfPleatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TypesOfPleatsInclude<ExtArgs> | null
    /**
     * Filter, which TypesOfPleats to fetch.
     */
    where?: TypesOfPleatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TypesOfPleats to fetch.
     */
    orderBy?: Enumerable<TypesOfPleatsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TypesOfPleats.
     */
    cursor?: TypesOfPleatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TypesOfPleats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TypesOfPleats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TypesOfPleats.
     */
    distinct?: Enumerable<TypesOfPleatsScalarFieldEnum>
  }


  /**
   * TypesOfPleats findMany
   */
  export type TypesOfPleatsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypesOfPleats
     */
    select?: TypesOfPleatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TypesOfPleatsInclude<ExtArgs> | null
    /**
     * Filter, which TypesOfPleats to fetch.
     */
    where?: TypesOfPleatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TypesOfPleats to fetch.
     */
    orderBy?: Enumerable<TypesOfPleatsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TypesOfPleats.
     */
    cursor?: TypesOfPleatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TypesOfPleats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TypesOfPleats.
     */
    skip?: number
    distinct?: Enumerable<TypesOfPleatsScalarFieldEnum>
  }


  /**
   * TypesOfPleats create
   */
  export type TypesOfPleatsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypesOfPleats
     */
    select?: TypesOfPleatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TypesOfPleatsInclude<ExtArgs> | null
    /**
     * The data needed to create a TypesOfPleats.
     */
    data: XOR<TypesOfPleatsCreateInput, TypesOfPleatsUncheckedCreateInput>
  }


  /**
   * TypesOfPleats createMany
   */
  export type TypesOfPleatsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TypesOfPleats.
     */
    data: Enumerable<TypesOfPleatsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TypesOfPleats update
   */
  export type TypesOfPleatsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypesOfPleats
     */
    select?: TypesOfPleatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TypesOfPleatsInclude<ExtArgs> | null
    /**
     * The data needed to update a TypesOfPleats.
     */
    data: XOR<TypesOfPleatsUpdateInput, TypesOfPleatsUncheckedUpdateInput>
    /**
     * Choose, which TypesOfPleats to update.
     */
    where: TypesOfPleatsWhereUniqueInput
  }


  /**
   * TypesOfPleats updateMany
   */
  export type TypesOfPleatsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TypesOfPleats.
     */
    data: XOR<TypesOfPleatsUpdateManyMutationInput, TypesOfPleatsUncheckedUpdateManyInput>
    /**
     * Filter which TypesOfPleats to update
     */
    where?: TypesOfPleatsWhereInput
  }


  /**
   * TypesOfPleats upsert
   */
  export type TypesOfPleatsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypesOfPleats
     */
    select?: TypesOfPleatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TypesOfPleatsInclude<ExtArgs> | null
    /**
     * The filter to search for the TypesOfPleats to update in case it exists.
     */
    where: TypesOfPleatsWhereUniqueInput
    /**
     * In case the TypesOfPleats found by the `where` argument doesn't exist, create a new TypesOfPleats with this data.
     */
    create: XOR<TypesOfPleatsCreateInput, TypesOfPleatsUncheckedCreateInput>
    /**
     * In case the TypesOfPleats was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TypesOfPleatsUpdateInput, TypesOfPleatsUncheckedUpdateInput>
  }


  /**
   * TypesOfPleats delete
   */
  export type TypesOfPleatsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypesOfPleats
     */
    select?: TypesOfPleatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TypesOfPleatsInclude<ExtArgs> | null
    /**
     * Filter which TypesOfPleats to delete.
     */
    where: TypesOfPleatsWhereUniqueInput
  }


  /**
   * TypesOfPleats deleteMany
   */
  export type TypesOfPleatsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which TypesOfPleats to delete
     */
    where?: TypesOfPleatsWhereInput
  }


  /**
   * TypesOfPleats.description
   */
  export type TypesOfPleats$descriptionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BottomDescription
     */
    select?: BottomDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BottomDescriptionInclude<ExtArgs> | null
    where?: BottomDescriptionWhereInput
    orderBy?: Enumerable<BottomDescriptionOrderByWithRelationInput>
    cursor?: BottomDescriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BottomDescriptionScalarFieldEnum>
  }


  /**
   * TypesOfPleats without action
   */
  export type TypesOfPleatsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypesOfPleats
     */
    select?: TypesOfPleatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TypesOfPleatsInclude<ExtArgs> | null
  }



  /**
   * Model TypesOfLengthBottom
   */


  export type AggregateTypesOfLengthBottom = {
    _count: TypesOfLengthBottomCountAggregateOutputType | null
    _avg: TypesOfLengthBottomAvgAggregateOutputType | null
    _sum: TypesOfLengthBottomSumAggregateOutputType | null
    _min: TypesOfLengthBottomMinAggregateOutputType | null
    _max: TypesOfLengthBottomMaxAggregateOutputType | null
  }

  export type TypesOfLengthBottomAvgAggregateOutputType = {
    id: number | null
  }

  export type TypesOfLengthBottomSumAggregateOutputType = {
    id: number | null
  }

  export type TypesOfLengthBottomMinAggregateOutputType = {
    id: number | null
    name: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type TypesOfLengthBottomMaxAggregateOutputType = {
    id: number | null
    name: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type TypesOfLengthBottomCountAggregateOutputType = {
    id: number
    name: number
    isActive: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type TypesOfLengthBottomAvgAggregateInputType = {
    id?: true
  }

  export type TypesOfLengthBottomSumAggregateInputType = {
    id?: true
  }

  export type TypesOfLengthBottomMinAggregateInputType = {
    id?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type TypesOfLengthBottomMaxAggregateInputType = {
    id?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type TypesOfLengthBottomCountAggregateInputType = {
    id?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type TypesOfLengthBottomAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which TypesOfLengthBottom to aggregate.
     */
    where?: TypesOfLengthBottomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TypesOfLengthBottoms to fetch.
     */
    orderBy?: Enumerable<TypesOfLengthBottomOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TypesOfLengthBottomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TypesOfLengthBottoms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TypesOfLengthBottoms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TypesOfLengthBottoms
    **/
    _count?: true | TypesOfLengthBottomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TypesOfLengthBottomAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TypesOfLengthBottomSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TypesOfLengthBottomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TypesOfLengthBottomMaxAggregateInputType
  }

  export type GetTypesOfLengthBottomAggregateType<T extends TypesOfLengthBottomAggregateArgs> = {
        [P in keyof T & keyof AggregateTypesOfLengthBottom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTypesOfLengthBottom[P]>
      : GetScalarType<T[P], AggregateTypesOfLengthBottom[P]>
  }




  export type TypesOfLengthBottomGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: TypesOfLengthBottomWhereInput
    orderBy?: Enumerable<TypesOfLengthBottomOrderByWithAggregationInput>
    by: TypesOfLengthBottomScalarFieldEnum[]
    having?: TypesOfLengthBottomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TypesOfLengthBottomCountAggregateInputType | true
    _avg?: TypesOfLengthBottomAvgAggregateInputType
    _sum?: TypesOfLengthBottomSumAggregateInputType
    _min?: TypesOfLengthBottomMinAggregateInputType
    _max?: TypesOfLengthBottomMaxAggregateInputType
  }


  export type TypesOfLengthBottomGroupByOutputType = {
    id: number
    name: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: TypesOfLengthBottomCountAggregateOutputType | null
    _avg: TypesOfLengthBottomAvgAggregateOutputType | null
    _sum: TypesOfLengthBottomSumAggregateOutputType | null
    _min: TypesOfLengthBottomMinAggregateOutputType | null
    _max: TypesOfLengthBottomMaxAggregateOutputType | null
  }

  type GetTypesOfLengthBottomGroupByPayload<T extends TypesOfLengthBottomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TypesOfLengthBottomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TypesOfLengthBottomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TypesOfLengthBottomGroupByOutputType[P]>
            : GetScalarType<T[P], TypesOfLengthBottomGroupByOutputType[P]>
        }
      >
    >


  export type TypesOfLengthBottomSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    description?: boolean | TypesOfLengthBottom$descriptionArgs<ExtArgs>
    _count?: boolean | TypesOfLengthBottomCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["typesOfLengthBottom"]>

  export type TypesOfLengthBottomSelectScalar = {
    id?: boolean
    name?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type TypesOfLengthBottomInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    description?: boolean | TypesOfLengthBottom$descriptionArgs<ExtArgs>
    _count?: boolean | TypesOfLengthBottomCountOutputTypeArgs<ExtArgs>
  }


  type TypesOfLengthBottomGetPayload<S extends boolean | null | undefined | TypesOfLengthBottomArgs> = $Types.GetResult<TypesOfLengthBottomPayload, S>

  type TypesOfLengthBottomCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<TypesOfLengthBottomFindManyArgs, 'select' | 'include'> & {
      select?: TypesOfLengthBottomCountAggregateInputType | true
    }

  export interface TypesOfLengthBottomDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TypesOfLengthBottom'], meta: { name: 'TypesOfLengthBottom' } }
    /**
     * Find zero or one TypesOfLengthBottom that matches the filter.
     * @param {TypesOfLengthBottomFindUniqueArgs} args - Arguments to find a TypesOfLengthBottom
     * @example
     * // Get one TypesOfLengthBottom
     * const typesOfLengthBottom = await prisma.typesOfLengthBottom.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TypesOfLengthBottomFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TypesOfLengthBottomFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TypesOfLengthBottom'> extends True ? Prisma__TypesOfLengthBottomClient<$Types.GetResult<TypesOfLengthBottomPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__TypesOfLengthBottomClient<$Types.GetResult<TypesOfLengthBottomPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one TypesOfLengthBottom that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TypesOfLengthBottomFindUniqueOrThrowArgs} args - Arguments to find a TypesOfLengthBottom
     * @example
     * // Get one TypesOfLengthBottom
     * const typesOfLengthBottom = await prisma.typesOfLengthBottom.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TypesOfLengthBottomFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TypesOfLengthBottomFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TypesOfLengthBottomClient<$Types.GetResult<TypesOfLengthBottomPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first TypesOfLengthBottom that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypesOfLengthBottomFindFirstArgs} args - Arguments to find a TypesOfLengthBottom
     * @example
     * // Get one TypesOfLengthBottom
     * const typesOfLengthBottom = await prisma.typesOfLengthBottom.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TypesOfLengthBottomFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TypesOfLengthBottomFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TypesOfLengthBottom'> extends True ? Prisma__TypesOfLengthBottomClient<$Types.GetResult<TypesOfLengthBottomPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__TypesOfLengthBottomClient<$Types.GetResult<TypesOfLengthBottomPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first TypesOfLengthBottom that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypesOfLengthBottomFindFirstOrThrowArgs} args - Arguments to find a TypesOfLengthBottom
     * @example
     * // Get one TypesOfLengthBottom
     * const typesOfLengthBottom = await prisma.typesOfLengthBottom.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TypesOfLengthBottomFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TypesOfLengthBottomFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TypesOfLengthBottomClient<$Types.GetResult<TypesOfLengthBottomPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more TypesOfLengthBottoms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypesOfLengthBottomFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TypesOfLengthBottoms
     * const typesOfLengthBottoms = await prisma.typesOfLengthBottom.findMany()
     * 
     * // Get first 10 TypesOfLengthBottoms
     * const typesOfLengthBottoms = await prisma.typesOfLengthBottom.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const typesOfLengthBottomWithIdOnly = await prisma.typesOfLengthBottom.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TypesOfLengthBottomFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TypesOfLengthBottomFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<TypesOfLengthBottomPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a TypesOfLengthBottom.
     * @param {TypesOfLengthBottomCreateArgs} args - Arguments to create a TypesOfLengthBottom.
     * @example
     * // Create one TypesOfLengthBottom
     * const TypesOfLengthBottom = await prisma.typesOfLengthBottom.create({
     *   data: {
     *     // ... data to create a TypesOfLengthBottom
     *   }
     * })
     * 
    **/
    create<T extends TypesOfLengthBottomCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TypesOfLengthBottomCreateArgs<ExtArgs>>
    ): Prisma__TypesOfLengthBottomClient<$Types.GetResult<TypesOfLengthBottomPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many TypesOfLengthBottoms.
     *     @param {TypesOfLengthBottomCreateManyArgs} args - Arguments to create many TypesOfLengthBottoms.
     *     @example
     *     // Create many TypesOfLengthBottoms
     *     const typesOfLengthBottom = await prisma.typesOfLengthBottom.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TypesOfLengthBottomCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TypesOfLengthBottomCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TypesOfLengthBottom.
     * @param {TypesOfLengthBottomDeleteArgs} args - Arguments to delete one TypesOfLengthBottom.
     * @example
     * // Delete one TypesOfLengthBottom
     * const TypesOfLengthBottom = await prisma.typesOfLengthBottom.delete({
     *   where: {
     *     // ... filter to delete one TypesOfLengthBottom
     *   }
     * })
     * 
    **/
    delete<T extends TypesOfLengthBottomDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TypesOfLengthBottomDeleteArgs<ExtArgs>>
    ): Prisma__TypesOfLengthBottomClient<$Types.GetResult<TypesOfLengthBottomPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one TypesOfLengthBottom.
     * @param {TypesOfLengthBottomUpdateArgs} args - Arguments to update one TypesOfLengthBottom.
     * @example
     * // Update one TypesOfLengthBottom
     * const typesOfLengthBottom = await prisma.typesOfLengthBottom.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TypesOfLengthBottomUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TypesOfLengthBottomUpdateArgs<ExtArgs>>
    ): Prisma__TypesOfLengthBottomClient<$Types.GetResult<TypesOfLengthBottomPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more TypesOfLengthBottoms.
     * @param {TypesOfLengthBottomDeleteManyArgs} args - Arguments to filter TypesOfLengthBottoms to delete.
     * @example
     * // Delete a few TypesOfLengthBottoms
     * const { count } = await prisma.typesOfLengthBottom.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TypesOfLengthBottomDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TypesOfLengthBottomDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TypesOfLengthBottoms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypesOfLengthBottomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TypesOfLengthBottoms
     * const typesOfLengthBottom = await prisma.typesOfLengthBottom.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TypesOfLengthBottomUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TypesOfLengthBottomUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TypesOfLengthBottom.
     * @param {TypesOfLengthBottomUpsertArgs} args - Arguments to update or create a TypesOfLengthBottom.
     * @example
     * // Update or create a TypesOfLengthBottom
     * const typesOfLengthBottom = await prisma.typesOfLengthBottom.upsert({
     *   create: {
     *     // ... data to create a TypesOfLengthBottom
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TypesOfLengthBottom we want to update
     *   }
     * })
    **/
    upsert<T extends TypesOfLengthBottomUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TypesOfLengthBottomUpsertArgs<ExtArgs>>
    ): Prisma__TypesOfLengthBottomClient<$Types.GetResult<TypesOfLengthBottomPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of TypesOfLengthBottoms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypesOfLengthBottomCountArgs} args - Arguments to filter TypesOfLengthBottoms to count.
     * @example
     * // Count the number of TypesOfLengthBottoms
     * const count = await prisma.typesOfLengthBottom.count({
     *   where: {
     *     // ... the filter for the TypesOfLengthBottoms we want to count
     *   }
     * })
    **/
    count<T extends TypesOfLengthBottomCountArgs>(
      args?: Subset<T, TypesOfLengthBottomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TypesOfLengthBottomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TypesOfLengthBottom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypesOfLengthBottomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TypesOfLengthBottomAggregateArgs>(args: Subset<T, TypesOfLengthBottomAggregateArgs>): Prisma.PrismaPromise<GetTypesOfLengthBottomAggregateType<T>>

    /**
     * Group by TypesOfLengthBottom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypesOfLengthBottomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TypesOfLengthBottomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TypesOfLengthBottomGroupByArgs['orderBy'] }
        : { orderBy?: TypesOfLengthBottomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TypesOfLengthBottomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTypesOfLengthBottomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TypesOfLengthBottom.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TypesOfLengthBottomClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    description<T extends TypesOfLengthBottom$descriptionArgs<ExtArgs> = {}>(args?: Subset<T, TypesOfLengthBottom$descriptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<BottomDescriptionPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TypesOfLengthBottom base type for findUnique actions
   */
  export type TypesOfLengthBottomFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypesOfLengthBottom
     */
    select?: TypesOfLengthBottomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TypesOfLengthBottomInclude<ExtArgs> | null
    /**
     * Filter, which TypesOfLengthBottom to fetch.
     */
    where: TypesOfLengthBottomWhereUniqueInput
  }

  /**
   * TypesOfLengthBottom findUnique
   */
  export interface TypesOfLengthBottomFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends TypesOfLengthBottomFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TypesOfLengthBottom findUniqueOrThrow
   */
  export type TypesOfLengthBottomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypesOfLengthBottom
     */
    select?: TypesOfLengthBottomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TypesOfLengthBottomInclude<ExtArgs> | null
    /**
     * Filter, which TypesOfLengthBottom to fetch.
     */
    where: TypesOfLengthBottomWhereUniqueInput
  }


  /**
   * TypesOfLengthBottom base type for findFirst actions
   */
  export type TypesOfLengthBottomFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypesOfLengthBottom
     */
    select?: TypesOfLengthBottomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TypesOfLengthBottomInclude<ExtArgs> | null
    /**
     * Filter, which TypesOfLengthBottom to fetch.
     */
    where?: TypesOfLengthBottomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TypesOfLengthBottoms to fetch.
     */
    orderBy?: Enumerable<TypesOfLengthBottomOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TypesOfLengthBottoms.
     */
    cursor?: TypesOfLengthBottomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TypesOfLengthBottoms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TypesOfLengthBottoms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TypesOfLengthBottoms.
     */
    distinct?: Enumerable<TypesOfLengthBottomScalarFieldEnum>
  }

  /**
   * TypesOfLengthBottom findFirst
   */
  export interface TypesOfLengthBottomFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends TypesOfLengthBottomFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TypesOfLengthBottom findFirstOrThrow
   */
  export type TypesOfLengthBottomFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypesOfLengthBottom
     */
    select?: TypesOfLengthBottomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TypesOfLengthBottomInclude<ExtArgs> | null
    /**
     * Filter, which TypesOfLengthBottom to fetch.
     */
    where?: TypesOfLengthBottomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TypesOfLengthBottoms to fetch.
     */
    orderBy?: Enumerable<TypesOfLengthBottomOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TypesOfLengthBottoms.
     */
    cursor?: TypesOfLengthBottomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TypesOfLengthBottoms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TypesOfLengthBottoms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TypesOfLengthBottoms.
     */
    distinct?: Enumerable<TypesOfLengthBottomScalarFieldEnum>
  }


  /**
   * TypesOfLengthBottom findMany
   */
  export type TypesOfLengthBottomFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypesOfLengthBottom
     */
    select?: TypesOfLengthBottomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TypesOfLengthBottomInclude<ExtArgs> | null
    /**
     * Filter, which TypesOfLengthBottoms to fetch.
     */
    where?: TypesOfLengthBottomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TypesOfLengthBottoms to fetch.
     */
    orderBy?: Enumerable<TypesOfLengthBottomOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TypesOfLengthBottoms.
     */
    cursor?: TypesOfLengthBottomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TypesOfLengthBottoms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TypesOfLengthBottoms.
     */
    skip?: number
    distinct?: Enumerable<TypesOfLengthBottomScalarFieldEnum>
  }


  /**
   * TypesOfLengthBottom create
   */
  export type TypesOfLengthBottomCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypesOfLengthBottom
     */
    select?: TypesOfLengthBottomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TypesOfLengthBottomInclude<ExtArgs> | null
    /**
     * The data needed to create a TypesOfLengthBottom.
     */
    data: XOR<TypesOfLengthBottomCreateInput, TypesOfLengthBottomUncheckedCreateInput>
  }


  /**
   * TypesOfLengthBottom createMany
   */
  export type TypesOfLengthBottomCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TypesOfLengthBottoms.
     */
    data: Enumerable<TypesOfLengthBottomCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TypesOfLengthBottom update
   */
  export type TypesOfLengthBottomUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypesOfLengthBottom
     */
    select?: TypesOfLengthBottomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TypesOfLengthBottomInclude<ExtArgs> | null
    /**
     * The data needed to update a TypesOfLengthBottom.
     */
    data: XOR<TypesOfLengthBottomUpdateInput, TypesOfLengthBottomUncheckedUpdateInput>
    /**
     * Choose, which TypesOfLengthBottom to update.
     */
    where: TypesOfLengthBottomWhereUniqueInput
  }


  /**
   * TypesOfLengthBottom updateMany
   */
  export type TypesOfLengthBottomUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TypesOfLengthBottoms.
     */
    data: XOR<TypesOfLengthBottomUpdateManyMutationInput, TypesOfLengthBottomUncheckedUpdateManyInput>
    /**
     * Filter which TypesOfLengthBottoms to update
     */
    where?: TypesOfLengthBottomWhereInput
  }


  /**
   * TypesOfLengthBottom upsert
   */
  export type TypesOfLengthBottomUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypesOfLengthBottom
     */
    select?: TypesOfLengthBottomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TypesOfLengthBottomInclude<ExtArgs> | null
    /**
     * The filter to search for the TypesOfLengthBottom to update in case it exists.
     */
    where: TypesOfLengthBottomWhereUniqueInput
    /**
     * In case the TypesOfLengthBottom found by the `where` argument doesn't exist, create a new TypesOfLengthBottom with this data.
     */
    create: XOR<TypesOfLengthBottomCreateInput, TypesOfLengthBottomUncheckedCreateInput>
    /**
     * In case the TypesOfLengthBottom was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TypesOfLengthBottomUpdateInput, TypesOfLengthBottomUncheckedUpdateInput>
  }


  /**
   * TypesOfLengthBottom delete
   */
  export type TypesOfLengthBottomDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypesOfLengthBottom
     */
    select?: TypesOfLengthBottomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TypesOfLengthBottomInclude<ExtArgs> | null
    /**
     * Filter which TypesOfLengthBottom to delete.
     */
    where: TypesOfLengthBottomWhereUniqueInput
  }


  /**
   * TypesOfLengthBottom deleteMany
   */
  export type TypesOfLengthBottomDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which TypesOfLengthBottoms to delete
     */
    where?: TypesOfLengthBottomWhereInput
  }


  /**
   * TypesOfLengthBottom.description
   */
  export type TypesOfLengthBottom$descriptionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BottomDescription
     */
    select?: BottomDescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BottomDescriptionInclude<ExtArgs> | null
    where?: BottomDescriptionWhereInput
    orderBy?: Enumerable<BottomDescriptionOrderByWithRelationInput>
    cursor?: BottomDescriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BottomDescriptionScalarFieldEnum>
  }


  /**
   * TypesOfLengthBottom without action
   */
  export type TypesOfLengthBottomArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypesOfLengthBottom
     */
    select?: TypesOfLengthBottomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TypesOfLengthBottomInclude<ExtArgs> | null
  }



  /**
   * Model QuantityHistory
   */


  export type AggregateQuantityHistory = {
    _count: QuantityHistoryCountAggregateOutputType | null
    _avg: QuantityHistoryAvgAggregateOutputType | null
    _sum: QuantityHistorySumAggregateOutputType | null
    _min: QuantityHistoryMinAggregateOutputType | null
    _max: QuantityHistoryMaxAggregateOutputType | null
  }

  export type QuantityHistoryAvgAggregateOutputType = {
    id: number | null
    quantity: number | null
    productAviableSizesId: number | null
  }

  export type QuantityHistorySumAggregateOutputType = {
    id: number | null
    quantity: number | null
    productAviableSizesId: number | null
  }

  export type QuantityHistoryMinAggregateOutputType = {
    id: number | null
    quantity: number | null
    productAviableSizesId: number | null
    timestamp: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type QuantityHistoryMaxAggregateOutputType = {
    id: number | null
    quantity: number | null
    productAviableSizesId: number | null
    timestamp: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type QuantityHistoryCountAggregateOutputType = {
    id: number
    quantity: number
    productAviableSizesId: number
    timestamp: number
    isActive: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type QuantityHistoryAvgAggregateInputType = {
    id?: true
    quantity?: true
    productAviableSizesId?: true
  }

  export type QuantityHistorySumAggregateInputType = {
    id?: true
    quantity?: true
    productAviableSizesId?: true
  }

  export type QuantityHistoryMinAggregateInputType = {
    id?: true
    quantity?: true
    productAviableSizesId?: true
    timestamp?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type QuantityHistoryMaxAggregateInputType = {
    id?: true
    quantity?: true
    productAviableSizesId?: true
    timestamp?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type QuantityHistoryCountAggregateInputType = {
    id?: true
    quantity?: true
    productAviableSizesId?: true
    timestamp?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type QuantityHistoryAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuantityHistory to aggregate.
     */
    where?: QuantityHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuantityHistories to fetch.
     */
    orderBy?: Enumerable<QuantityHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuantityHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuantityHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuantityHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuantityHistories
    **/
    _count?: true | QuantityHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuantityHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuantityHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuantityHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuantityHistoryMaxAggregateInputType
  }

  export type GetQuantityHistoryAggregateType<T extends QuantityHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateQuantityHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuantityHistory[P]>
      : GetScalarType<T[P], AggregateQuantityHistory[P]>
  }




  export type QuantityHistoryGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: QuantityHistoryWhereInput
    orderBy?: Enumerable<QuantityHistoryOrderByWithAggregationInput>
    by: QuantityHistoryScalarFieldEnum[]
    having?: QuantityHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuantityHistoryCountAggregateInputType | true
    _avg?: QuantityHistoryAvgAggregateInputType
    _sum?: QuantityHistorySumAggregateInputType
    _min?: QuantityHistoryMinAggregateInputType
    _max?: QuantityHistoryMaxAggregateInputType
  }


  export type QuantityHistoryGroupByOutputType = {
    id: number
    quantity: number
    productAviableSizesId: number
    timestamp: Date
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: QuantityHistoryCountAggregateOutputType | null
    _avg: QuantityHistoryAvgAggregateOutputType | null
    _sum: QuantityHistorySumAggregateOutputType | null
    _min: QuantityHistoryMinAggregateOutputType | null
    _max: QuantityHistoryMaxAggregateOutputType | null
  }

  type GetQuantityHistoryGroupByPayload<T extends QuantityHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<QuantityHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuantityHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuantityHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], QuantityHistoryGroupByOutputType[P]>
        }
      >
    >


  export type QuantityHistorySelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quantity?: boolean
    productAviableSizesId?: boolean
    timestamp?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    productAviableSizes?: boolean | ProductAviableSizesArgs<ExtArgs>
  }, ExtArgs["result"]["quantityHistory"]>

  export type QuantityHistorySelectScalar = {
    id?: boolean
    quantity?: boolean
    productAviableSizesId?: boolean
    timestamp?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type QuantityHistoryInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    productAviableSizes?: boolean | ProductAviableSizesArgs<ExtArgs>
  }


  type QuantityHistoryGetPayload<S extends boolean | null | undefined | QuantityHistoryArgs> = $Types.GetResult<QuantityHistoryPayload, S>

  type QuantityHistoryCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<QuantityHistoryFindManyArgs, 'select' | 'include'> & {
      select?: QuantityHistoryCountAggregateInputType | true
    }

  export interface QuantityHistoryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuantityHistory'], meta: { name: 'QuantityHistory' } }
    /**
     * Find zero or one QuantityHistory that matches the filter.
     * @param {QuantityHistoryFindUniqueArgs} args - Arguments to find a QuantityHistory
     * @example
     * // Get one QuantityHistory
     * const quantityHistory = await prisma.quantityHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends QuantityHistoryFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, QuantityHistoryFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'QuantityHistory'> extends True ? Prisma__QuantityHistoryClient<$Types.GetResult<QuantityHistoryPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__QuantityHistoryClient<$Types.GetResult<QuantityHistoryPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one QuantityHistory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {QuantityHistoryFindUniqueOrThrowArgs} args - Arguments to find a QuantityHistory
     * @example
     * // Get one QuantityHistory
     * const quantityHistory = await prisma.quantityHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends QuantityHistoryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, QuantityHistoryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__QuantityHistoryClient<$Types.GetResult<QuantityHistoryPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first QuantityHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuantityHistoryFindFirstArgs} args - Arguments to find a QuantityHistory
     * @example
     * // Get one QuantityHistory
     * const quantityHistory = await prisma.quantityHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends QuantityHistoryFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, QuantityHistoryFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'QuantityHistory'> extends True ? Prisma__QuantityHistoryClient<$Types.GetResult<QuantityHistoryPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__QuantityHistoryClient<$Types.GetResult<QuantityHistoryPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first QuantityHistory that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuantityHistoryFindFirstOrThrowArgs} args - Arguments to find a QuantityHistory
     * @example
     * // Get one QuantityHistory
     * const quantityHistory = await prisma.quantityHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends QuantityHistoryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, QuantityHistoryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__QuantityHistoryClient<$Types.GetResult<QuantityHistoryPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more QuantityHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuantityHistoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuantityHistories
     * const quantityHistories = await prisma.quantityHistory.findMany()
     * 
     * // Get first 10 QuantityHistories
     * const quantityHistories = await prisma.quantityHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quantityHistoryWithIdOnly = await prisma.quantityHistory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends QuantityHistoryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, QuantityHistoryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<QuantityHistoryPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a QuantityHistory.
     * @param {QuantityHistoryCreateArgs} args - Arguments to create a QuantityHistory.
     * @example
     * // Create one QuantityHistory
     * const QuantityHistory = await prisma.quantityHistory.create({
     *   data: {
     *     // ... data to create a QuantityHistory
     *   }
     * })
     * 
    **/
    create<T extends QuantityHistoryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, QuantityHistoryCreateArgs<ExtArgs>>
    ): Prisma__QuantityHistoryClient<$Types.GetResult<QuantityHistoryPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many QuantityHistories.
     *     @param {QuantityHistoryCreateManyArgs} args - Arguments to create many QuantityHistories.
     *     @example
     *     // Create many QuantityHistories
     *     const quantityHistory = await prisma.quantityHistory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends QuantityHistoryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, QuantityHistoryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a QuantityHistory.
     * @param {QuantityHistoryDeleteArgs} args - Arguments to delete one QuantityHistory.
     * @example
     * // Delete one QuantityHistory
     * const QuantityHistory = await prisma.quantityHistory.delete({
     *   where: {
     *     // ... filter to delete one QuantityHistory
     *   }
     * })
     * 
    **/
    delete<T extends QuantityHistoryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, QuantityHistoryDeleteArgs<ExtArgs>>
    ): Prisma__QuantityHistoryClient<$Types.GetResult<QuantityHistoryPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one QuantityHistory.
     * @param {QuantityHistoryUpdateArgs} args - Arguments to update one QuantityHistory.
     * @example
     * // Update one QuantityHistory
     * const quantityHistory = await prisma.quantityHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends QuantityHistoryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, QuantityHistoryUpdateArgs<ExtArgs>>
    ): Prisma__QuantityHistoryClient<$Types.GetResult<QuantityHistoryPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more QuantityHistories.
     * @param {QuantityHistoryDeleteManyArgs} args - Arguments to filter QuantityHistories to delete.
     * @example
     * // Delete a few QuantityHistories
     * const { count } = await prisma.quantityHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends QuantityHistoryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, QuantityHistoryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuantityHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuantityHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuantityHistories
     * const quantityHistory = await prisma.quantityHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends QuantityHistoryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, QuantityHistoryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QuantityHistory.
     * @param {QuantityHistoryUpsertArgs} args - Arguments to update or create a QuantityHistory.
     * @example
     * // Update or create a QuantityHistory
     * const quantityHistory = await prisma.quantityHistory.upsert({
     *   create: {
     *     // ... data to create a QuantityHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuantityHistory we want to update
     *   }
     * })
    **/
    upsert<T extends QuantityHistoryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, QuantityHistoryUpsertArgs<ExtArgs>>
    ): Prisma__QuantityHistoryClient<$Types.GetResult<QuantityHistoryPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of QuantityHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuantityHistoryCountArgs} args - Arguments to filter QuantityHistories to count.
     * @example
     * // Count the number of QuantityHistories
     * const count = await prisma.quantityHistory.count({
     *   where: {
     *     // ... the filter for the QuantityHistories we want to count
     *   }
     * })
    **/
    count<T extends QuantityHistoryCountArgs>(
      args?: Subset<T, QuantityHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuantityHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuantityHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuantityHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuantityHistoryAggregateArgs>(args: Subset<T, QuantityHistoryAggregateArgs>): Prisma.PrismaPromise<GetQuantityHistoryAggregateType<T>>

    /**
     * Group by QuantityHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuantityHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuantityHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuantityHistoryGroupByArgs['orderBy'] }
        : { orderBy?: QuantityHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuantityHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuantityHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for QuantityHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__QuantityHistoryClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    productAviableSizes<T extends ProductAviableSizesArgs<ExtArgs> = {}>(args?: Subset<T, ProductAviableSizesArgs<ExtArgs>>): Prisma__ProductAviableSizesClient<$Types.GetResult<ProductAviableSizesPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * QuantityHistory base type for findUnique actions
   */
  export type QuantityHistoryFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuantityHistory
     */
    select?: QuantityHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuantityHistoryInclude<ExtArgs> | null
    /**
     * Filter, which QuantityHistory to fetch.
     */
    where: QuantityHistoryWhereUniqueInput
  }

  /**
   * QuantityHistory findUnique
   */
  export interface QuantityHistoryFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends QuantityHistoryFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * QuantityHistory findUniqueOrThrow
   */
  export type QuantityHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuantityHistory
     */
    select?: QuantityHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuantityHistoryInclude<ExtArgs> | null
    /**
     * Filter, which QuantityHistory to fetch.
     */
    where: QuantityHistoryWhereUniqueInput
  }


  /**
   * QuantityHistory base type for findFirst actions
   */
  export type QuantityHistoryFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuantityHistory
     */
    select?: QuantityHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuantityHistoryInclude<ExtArgs> | null
    /**
     * Filter, which QuantityHistory to fetch.
     */
    where?: QuantityHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuantityHistories to fetch.
     */
    orderBy?: Enumerable<QuantityHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuantityHistories.
     */
    cursor?: QuantityHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuantityHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuantityHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuantityHistories.
     */
    distinct?: Enumerable<QuantityHistoryScalarFieldEnum>
  }

  /**
   * QuantityHistory findFirst
   */
  export interface QuantityHistoryFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends QuantityHistoryFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * QuantityHistory findFirstOrThrow
   */
  export type QuantityHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuantityHistory
     */
    select?: QuantityHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuantityHistoryInclude<ExtArgs> | null
    /**
     * Filter, which QuantityHistory to fetch.
     */
    where?: QuantityHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuantityHistories to fetch.
     */
    orderBy?: Enumerable<QuantityHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuantityHistories.
     */
    cursor?: QuantityHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuantityHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuantityHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuantityHistories.
     */
    distinct?: Enumerable<QuantityHistoryScalarFieldEnum>
  }


  /**
   * QuantityHistory findMany
   */
  export type QuantityHistoryFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuantityHistory
     */
    select?: QuantityHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuantityHistoryInclude<ExtArgs> | null
    /**
     * Filter, which QuantityHistories to fetch.
     */
    where?: QuantityHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuantityHistories to fetch.
     */
    orderBy?: Enumerable<QuantityHistoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuantityHistories.
     */
    cursor?: QuantityHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuantityHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuantityHistories.
     */
    skip?: number
    distinct?: Enumerable<QuantityHistoryScalarFieldEnum>
  }


  /**
   * QuantityHistory create
   */
  export type QuantityHistoryCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuantityHistory
     */
    select?: QuantityHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuantityHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a QuantityHistory.
     */
    data: XOR<QuantityHistoryCreateInput, QuantityHistoryUncheckedCreateInput>
  }


  /**
   * QuantityHistory createMany
   */
  export type QuantityHistoryCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuantityHistories.
     */
    data: Enumerable<QuantityHistoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * QuantityHistory update
   */
  export type QuantityHistoryUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuantityHistory
     */
    select?: QuantityHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuantityHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a QuantityHistory.
     */
    data: XOR<QuantityHistoryUpdateInput, QuantityHistoryUncheckedUpdateInput>
    /**
     * Choose, which QuantityHistory to update.
     */
    where: QuantityHistoryWhereUniqueInput
  }


  /**
   * QuantityHistory updateMany
   */
  export type QuantityHistoryUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuantityHistories.
     */
    data: XOR<QuantityHistoryUpdateManyMutationInput, QuantityHistoryUncheckedUpdateManyInput>
    /**
     * Filter which QuantityHistories to update
     */
    where?: QuantityHistoryWhereInput
  }


  /**
   * QuantityHistory upsert
   */
  export type QuantityHistoryUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuantityHistory
     */
    select?: QuantityHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuantityHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the QuantityHistory to update in case it exists.
     */
    where: QuantityHistoryWhereUniqueInput
    /**
     * In case the QuantityHistory found by the `where` argument doesn't exist, create a new QuantityHistory with this data.
     */
    create: XOR<QuantityHistoryCreateInput, QuantityHistoryUncheckedCreateInput>
    /**
     * In case the QuantityHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuantityHistoryUpdateInput, QuantityHistoryUncheckedUpdateInput>
  }


  /**
   * QuantityHistory delete
   */
  export type QuantityHistoryDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuantityHistory
     */
    select?: QuantityHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuantityHistoryInclude<ExtArgs> | null
    /**
     * Filter which QuantityHistory to delete.
     */
    where: QuantityHistoryWhereUniqueInput
  }


  /**
   * QuantityHistory deleteMany
   */
  export type QuantityHistoryDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuantityHistories to delete
     */
    where?: QuantityHistoryWhereInput
  }


  /**
   * QuantityHistory without action
   */
  export type QuantityHistoryArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuantityHistory
     */
    select?: QuantityHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: QuantityHistoryInclude<ExtArgs> | null
  }



  /**
   * Model Offer
   */


  export type AggregateOffer = {
    _count: OfferCountAggregateOutputType | null
    _avg: OfferAvgAggregateOutputType | null
    _sum: OfferSumAggregateOutputType | null
    _min: OfferMinAggregateOutputType | null
    _max: OfferMaxAggregateOutputType | null
  }

  export type OfferAvgAggregateOutputType = {
    id: number | null
    productId: number | null
    offerPercntage: number | null
    offerPrice: number | null
    currentPrice: number | null
    offerQuantity: number | null
    currentQuantity: number | null
  }

  export type OfferSumAggregateOutputType = {
    id: number | null
    productId: number | null
    offerPercntage: number | null
    offerPrice: number | null
    currentPrice: number | null
    offerQuantity: number | null
    currentQuantity: number | null
  }

  export type OfferMinAggregateOutputType = {
    id: number | null
    productId: number | null
    offerPercntage: number | null
    offerPrice: number | null
    currentPrice: number | null
    offerQuantity: number | null
    currentQuantity: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type OfferMaxAggregateOutputType = {
    id: number | null
    productId: number | null
    offerPercntage: number | null
    offerPrice: number | null
    currentPrice: number | null
    offerQuantity: number | null
    currentQuantity: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type OfferCountAggregateOutputType = {
    id: number
    productId: number
    offerPercntage: number
    offerPrice: number
    currentPrice: number
    offerQuantity: number
    currentQuantity: number
    isActive: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type OfferAvgAggregateInputType = {
    id?: true
    productId?: true
    offerPercntage?: true
    offerPrice?: true
    currentPrice?: true
    offerQuantity?: true
    currentQuantity?: true
  }

  export type OfferSumAggregateInputType = {
    id?: true
    productId?: true
    offerPercntage?: true
    offerPrice?: true
    currentPrice?: true
    offerQuantity?: true
    currentQuantity?: true
  }

  export type OfferMinAggregateInputType = {
    id?: true
    productId?: true
    offerPercntage?: true
    offerPrice?: true
    currentPrice?: true
    offerQuantity?: true
    currentQuantity?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type OfferMaxAggregateInputType = {
    id?: true
    productId?: true
    offerPercntage?: true
    offerPrice?: true
    currentPrice?: true
    offerQuantity?: true
    currentQuantity?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type OfferCountAggregateInputType = {
    id?: true
    productId?: true
    offerPercntage?: true
    offerPrice?: true
    currentPrice?: true
    offerQuantity?: true
    currentQuantity?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type OfferAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Offer to aggregate.
     */
    where?: OfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Offers to fetch.
     */
    orderBy?: Enumerable<OfferOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Offers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Offers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Offers
    **/
    _count?: true | OfferCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OfferAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OfferSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OfferMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OfferMaxAggregateInputType
  }

  export type GetOfferAggregateType<T extends OfferAggregateArgs> = {
        [P in keyof T & keyof AggregateOffer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOffer[P]>
      : GetScalarType<T[P], AggregateOffer[P]>
  }




  export type OfferGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OfferWhereInput
    orderBy?: Enumerable<OfferOrderByWithAggregationInput>
    by: OfferScalarFieldEnum[]
    having?: OfferScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OfferCountAggregateInputType | true
    _avg?: OfferAvgAggregateInputType
    _sum?: OfferSumAggregateInputType
    _min?: OfferMinAggregateInputType
    _max?: OfferMaxAggregateInputType
  }


  export type OfferGroupByOutputType = {
    id: number
    productId: number
    offerPercntage: number
    offerPrice: number
    currentPrice: number
    offerQuantity: number
    currentQuantity: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: OfferCountAggregateOutputType | null
    _avg: OfferAvgAggregateOutputType | null
    _sum: OfferSumAggregateOutputType | null
    _min: OfferMinAggregateOutputType | null
    _max: OfferMaxAggregateOutputType | null
  }

  type GetOfferGroupByPayload<T extends OfferGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<OfferGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OfferGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OfferGroupByOutputType[P]>
            : GetScalarType<T[P], OfferGroupByOutputType[P]>
        }
      >
    >


  export type OfferSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    offerPercntage?: boolean
    offerPrice?: boolean
    currentPrice?: boolean
    offerQuantity?: boolean
    currentQuantity?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    product?: boolean | ProductArgs<ExtArgs>
    offerValidity?: boolean | Offer$offerValidityArgs<ExtArgs>
    _count?: boolean | OfferCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["offer"]>

  export type OfferSelectScalar = {
    id?: boolean
    productId?: boolean
    offerPercntage?: boolean
    offerPrice?: boolean
    currentPrice?: boolean
    offerQuantity?: boolean
    currentQuantity?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type OfferInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    product?: boolean | ProductArgs<ExtArgs>
    offerValidity?: boolean | Offer$offerValidityArgs<ExtArgs>
    _count?: boolean | OfferCountOutputTypeArgs<ExtArgs>
  }


  type OfferGetPayload<S extends boolean | null | undefined | OfferArgs> = $Types.GetResult<OfferPayload, S>

  type OfferCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<OfferFindManyArgs, 'select' | 'include'> & {
      select?: OfferCountAggregateInputType | true
    }

  export interface OfferDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Offer'], meta: { name: 'Offer' } }
    /**
     * Find zero or one Offer that matches the filter.
     * @param {OfferFindUniqueArgs} args - Arguments to find a Offer
     * @example
     * // Get one Offer
     * const offer = await prisma.offer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OfferFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OfferFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Offer'> extends True ? Prisma__OfferClient<$Types.GetResult<OfferPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__OfferClient<$Types.GetResult<OfferPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Offer that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OfferFindUniqueOrThrowArgs} args - Arguments to find a Offer
     * @example
     * // Get one Offer
     * const offer = await prisma.offer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OfferFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OfferFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OfferClient<$Types.GetResult<OfferPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Offer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferFindFirstArgs} args - Arguments to find a Offer
     * @example
     * // Get one Offer
     * const offer = await prisma.offer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OfferFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OfferFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Offer'> extends True ? Prisma__OfferClient<$Types.GetResult<OfferPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__OfferClient<$Types.GetResult<OfferPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Offer that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferFindFirstOrThrowArgs} args - Arguments to find a Offer
     * @example
     * // Get one Offer
     * const offer = await prisma.offer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OfferFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OfferFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OfferClient<$Types.GetResult<OfferPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Offers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Offers
     * const offers = await prisma.offer.findMany()
     * 
     * // Get first 10 Offers
     * const offers = await prisma.offer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const offerWithIdOnly = await prisma.offer.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OfferFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OfferFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<OfferPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Offer.
     * @param {OfferCreateArgs} args - Arguments to create a Offer.
     * @example
     * // Create one Offer
     * const Offer = await prisma.offer.create({
     *   data: {
     *     // ... data to create a Offer
     *   }
     * })
     * 
    **/
    create<T extends OfferCreateArgs<ExtArgs>>(
      args: SelectSubset<T, OfferCreateArgs<ExtArgs>>
    ): Prisma__OfferClient<$Types.GetResult<OfferPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Offers.
     *     @param {OfferCreateManyArgs} args - Arguments to create many Offers.
     *     @example
     *     // Create many Offers
     *     const offer = await prisma.offer.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OfferCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OfferCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Offer.
     * @param {OfferDeleteArgs} args - Arguments to delete one Offer.
     * @example
     * // Delete one Offer
     * const Offer = await prisma.offer.delete({
     *   where: {
     *     // ... filter to delete one Offer
     *   }
     * })
     * 
    **/
    delete<T extends OfferDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, OfferDeleteArgs<ExtArgs>>
    ): Prisma__OfferClient<$Types.GetResult<OfferPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Offer.
     * @param {OfferUpdateArgs} args - Arguments to update one Offer.
     * @example
     * // Update one Offer
     * const offer = await prisma.offer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OfferUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, OfferUpdateArgs<ExtArgs>>
    ): Prisma__OfferClient<$Types.GetResult<OfferPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Offers.
     * @param {OfferDeleteManyArgs} args - Arguments to filter Offers to delete.
     * @example
     * // Delete a few Offers
     * const { count } = await prisma.offer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OfferDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OfferDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Offers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Offers
     * const offer = await prisma.offer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OfferUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, OfferUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Offer.
     * @param {OfferUpsertArgs} args - Arguments to update or create a Offer.
     * @example
     * // Update or create a Offer
     * const offer = await prisma.offer.upsert({
     *   create: {
     *     // ... data to create a Offer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Offer we want to update
     *   }
     * })
    **/
    upsert<T extends OfferUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, OfferUpsertArgs<ExtArgs>>
    ): Prisma__OfferClient<$Types.GetResult<OfferPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Offers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferCountArgs} args - Arguments to filter Offers to count.
     * @example
     * // Count the number of Offers
     * const count = await prisma.offer.count({
     *   where: {
     *     // ... the filter for the Offers we want to count
     *   }
     * })
    **/
    count<T extends OfferCountArgs>(
      args?: Subset<T, OfferCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OfferCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Offer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OfferAggregateArgs>(args: Subset<T, OfferAggregateArgs>): Prisma.PrismaPromise<GetOfferAggregateType<T>>

    /**
     * Group by Offer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OfferGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OfferGroupByArgs['orderBy'] }
        : { orderBy?: OfferGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OfferGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOfferGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Offer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OfferClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    product<T extends ProductArgs<ExtArgs> = {}>(args?: Subset<T, ProductArgs<ExtArgs>>): Prisma__ProductClient<$Types.GetResult<ProductPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    offerValidity<T extends Offer$offerValidityArgs<ExtArgs> = {}>(args?: Subset<T, Offer$offerValidityArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<OfferValidityPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Offer base type for findUnique actions
   */
  export type OfferFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * Filter, which Offer to fetch.
     */
    where: OfferWhereUniqueInput
  }

  /**
   * Offer findUnique
   */
  export interface OfferFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends OfferFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Offer findUniqueOrThrow
   */
  export type OfferFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * Filter, which Offer to fetch.
     */
    where: OfferWhereUniqueInput
  }


  /**
   * Offer base type for findFirst actions
   */
  export type OfferFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * Filter, which Offer to fetch.
     */
    where?: OfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Offers to fetch.
     */
    orderBy?: Enumerable<OfferOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Offers.
     */
    cursor?: OfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Offers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Offers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Offers.
     */
    distinct?: Enumerable<OfferScalarFieldEnum>
  }

  /**
   * Offer findFirst
   */
  export interface OfferFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends OfferFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Offer findFirstOrThrow
   */
  export type OfferFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * Filter, which Offer to fetch.
     */
    where?: OfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Offers to fetch.
     */
    orderBy?: Enumerable<OfferOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Offers.
     */
    cursor?: OfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Offers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Offers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Offers.
     */
    distinct?: Enumerable<OfferScalarFieldEnum>
  }


  /**
   * Offer findMany
   */
  export type OfferFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * Filter, which Offers to fetch.
     */
    where?: OfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Offers to fetch.
     */
    orderBy?: Enumerable<OfferOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Offers.
     */
    cursor?: OfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Offers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Offers.
     */
    skip?: number
    distinct?: Enumerable<OfferScalarFieldEnum>
  }


  /**
   * Offer create
   */
  export type OfferCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * The data needed to create a Offer.
     */
    data: XOR<OfferCreateInput, OfferUncheckedCreateInput>
  }


  /**
   * Offer createMany
   */
  export type OfferCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Offers.
     */
    data: Enumerable<OfferCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Offer update
   */
  export type OfferUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * The data needed to update a Offer.
     */
    data: XOR<OfferUpdateInput, OfferUncheckedUpdateInput>
    /**
     * Choose, which Offer to update.
     */
    where: OfferWhereUniqueInput
  }


  /**
   * Offer updateMany
   */
  export type OfferUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Offers.
     */
    data: XOR<OfferUpdateManyMutationInput, OfferUncheckedUpdateManyInput>
    /**
     * Filter which Offers to update
     */
    where?: OfferWhereInput
  }


  /**
   * Offer upsert
   */
  export type OfferUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * The filter to search for the Offer to update in case it exists.
     */
    where: OfferWhereUniqueInput
    /**
     * In case the Offer found by the `where` argument doesn't exist, create a new Offer with this data.
     */
    create: XOR<OfferCreateInput, OfferUncheckedCreateInput>
    /**
     * In case the Offer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OfferUpdateInput, OfferUncheckedUpdateInput>
  }


  /**
   * Offer delete
   */
  export type OfferDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * Filter which Offer to delete.
     */
    where: OfferWhereUniqueInput
  }


  /**
   * Offer deleteMany
   */
  export type OfferDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Offers to delete
     */
    where?: OfferWhereInput
  }


  /**
   * Offer.offerValidity
   */
  export type Offer$offerValidityArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferValidity
     */
    select?: OfferValiditySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferValidityInclude<ExtArgs> | null
    where?: OfferValidityWhereInput
    orderBy?: Enumerable<OfferValidityOrderByWithRelationInput>
    cursor?: OfferValidityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<OfferValidityScalarFieldEnum>
  }


  /**
   * Offer without action
   */
  export type OfferArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferInclude<ExtArgs> | null
  }



  /**
   * Model OfferValidity
   */


  export type AggregateOfferValidity = {
    _count: OfferValidityCountAggregateOutputType | null
    _avg: OfferValidityAvgAggregateOutputType | null
    _sum: OfferValiditySumAggregateOutputType | null
    _min: OfferValidityMinAggregateOutputType | null
    _max: OfferValidityMaxAggregateOutputType | null
  }

  export type OfferValidityAvgAggregateOutputType = {
    id: number | null
    offerId: number | null
    offerPromotionPeriodId: number | null
  }

  export type OfferValiditySumAggregateOutputType = {
    id: number | null
    offerId: number | null
    offerPromotionPeriodId: number | null
  }

  export type OfferValidityMinAggregateOutputType = {
    id: number | null
    fromDate: Date | null
    toDate: Date | null
    fromTime: Date | null
    toTime: Date | null
    monday: boolean | null
    tuesday: boolean | null
    wednesday: boolean | null
    thursday: boolean | null
    friday: boolean | null
    saturday: boolean | null
    sunday: boolean | null
    offerId: number | null
    offerPromotionPeriodId: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type OfferValidityMaxAggregateOutputType = {
    id: number | null
    fromDate: Date | null
    toDate: Date | null
    fromTime: Date | null
    toTime: Date | null
    monday: boolean | null
    tuesday: boolean | null
    wednesday: boolean | null
    thursday: boolean | null
    friday: boolean | null
    saturday: boolean | null
    sunday: boolean | null
    offerId: number | null
    offerPromotionPeriodId: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type OfferValidityCountAggregateOutputType = {
    id: number
    fromDate: number
    toDate: number
    fromTime: number
    toTime: number
    monday: number
    tuesday: number
    wednesday: number
    thursday: number
    friday: number
    saturday: number
    sunday: number
    offerId: number
    offerPromotionPeriodId: number
    isActive: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type OfferValidityAvgAggregateInputType = {
    id?: true
    offerId?: true
    offerPromotionPeriodId?: true
  }

  export type OfferValiditySumAggregateInputType = {
    id?: true
    offerId?: true
    offerPromotionPeriodId?: true
  }

  export type OfferValidityMinAggregateInputType = {
    id?: true
    fromDate?: true
    toDate?: true
    fromTime?: true
    toTime?: true
    monday?: true
    tuesday?: true
    wednesday?: true
    thursday?: true
    friday?: true
    saturday?: true
    sunday?: true
    offerId?: true
    offerPromotionPeriodId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type OfferValidityMaxAggregateInputType = {
    id?: true
    fromDate?: true
    toDate?: true
    fromTime?: true
    toTime?: true
    monday?: true
    tuesday?: true
    wednesday?: true
    thursday?: true
    friday?: true
    saturday?: true
    sunday?: true
    offerId?: true
    offerPromotionPeriodId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type OfferValidityCountAggregateInputType = {
    id?: true
    fromDate?: true
    toDate?: true
    fromTime?: true
    toTime?: true
    monday?: true
    tuesday?: true
    wednesday?: true
    thursday?: true
    friday?: true
    saturday?: true
    sunday?: true
    offerId?: true
    offerPromotionPeriodId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type OfferValidityAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which OfferValidity to aggregate.
     */
    where?: OfferValidityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfferValidities to fetch.
     */
    orderBy?: Enumerable<OfferValidityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OfferValidityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfferValidities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfferValidities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OfferValidities
    **/
    _count?: true | OfferValidityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OfferValidityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OfferValiditySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OfferValidityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OfferValidityMaxAggregateInputType
  }

  export type GetOfferValidityAggregateType<T extends OfferValidityAggregateArgs> = {
        [P in keyof T & keyof AggregateOfferValidity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOfferValidity[P]>
      : GetScalarType<T[P], AggregateOfferValidity[P]>
  }




  export type OfferValidityGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OfferValidityWhereInput
    orderBy?: Enumerable<OfferValidityOrderByWithAggregationInput>
    by: OfferValidityScalarFieldEnum[]
    having?: OfferValidityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OfferValidityCountAggregateInputType | true
    _avg?: OfferValidityAvgAggregateInputType
    _sum?: OfferValiditySumAggregateInputType
    _min?: OfferValidityMinAggregateInputType
    _max?: OfferValidityMaxAggregateInputType
  }


  export type OfferValidityGroupByOutputType = {
    id: number
    fromDate: Date
    toDate: Date
    fromTime: Date
    toTime: Date
    monday: boolean
    tuesday: boolean
    wednesday: boolean
    thursday: boolean
    friday: boolean
    saturday: boolean
    sunday: boolean
    offerId: number
    offerPromotionPeriodId: number | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: OfferValidityCountAggregateOutputType | null
    _avg: OfferValidityAvgAggregateOutputType | null
    _sum: OfferValiditySumAggregateOutputType | null
    _min: OfferValidityMinAggregateOutputType | null
    _max: OfferValidityMaxAggregateOutputType | null
  }

  type GetOfferValidityGroupByPayload<T extends OfferValidityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<OfferValidityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OfferValidityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OfferValidityGroupByOutputType[P]>
            : GetScalarType<T[P], OfferValidityGroupByOutputType[P]>
        }
      >
    >


  export type OfferValiditySelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fromDate?: boolean
    toDate?: boolean
    fromTime?: boolean
    toTime?: boolean
    monday?: boolean
    tuesday?: boolean
    wednesday?: boolean
    thursday?: boolean
    friday?: boolean
    saturday?: boolean
    sunday?: boolean
    offerId?: boolean
    offerPromotionPeriodId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    offer?: boolean | OfferArgs<ExtArgs>
    offerPromotionPeriod?: boolean | OfferPromotionPeriodsArgs<ExtArgs>
  }, ExtArgs["result"]["offerValidity"]>

  export type OfferValiditySelectScalar = {
    id?: boolean
    fromDate?: boolean
    toDate?: boolean
    fromTime?: boolean
    toTime?: boolean
    monday?: boolean
    tuesday?: boolean
    wednesday?: boolean
    thursday?: boolean
    friday?: boolean
    saturday?: boolean
    sunday?: boolean
    offerId?: boolean
    offerPromotionPeriodId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type OfferValidityInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    offer?: boolean | OfferArgs<ExtArgs>
    offerPromotionPeriod?: boolean | OfferPromotionPeriodsArgs<ExtArgs>
  }


  type OfferValidityGetPayload<S extends boolean | null | undefined | OfferValidityArgs> = $Types.GetResult<OfferValidityPayload, S>

  type OfferValidityCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<OfferValidityFindManyArgs, 'select' | 'include'> & {
      select?: OfferValidityCountAggregateInputType | true
    }

  export interface OfferValidityDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OfferValidity'], meta: { name: 'OfferValidity' } }
    /**
     * Find zero or one OfferValidity that matches the filter.
     * @param {OfferValidityFindUniqueArgs} args - Arguments to find a OfferValidity
     * @example
     * // Get one OfferValidity
     * const offerValidity = await prisma.offerValidity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OfferValidityFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OfferValidityFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'OfferValidity'> extends True ? Prisma__OfferValidityClient<$Types.GetResult<OfferValidityPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__OfferValidityClient<$Types.GetResult<OfferValidityPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one OfferValidity that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OfferValidityFindUniqueOrThrowArgs} args - Arguments to find a OfferValidity
     * @example
     * // Get one OfferValidity
     * const offerValidity = await prisma.offerValidity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OfferValidityFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OfferValidityFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OfferValidityClient<$Types.GetResult<OfferValidityPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first OfferValidity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferValidityFindFirstArgs} args - Arguments to find a OfferValidity
     * @example
     * // Get one OfferValidity
     * const offerValidity = await prisma.offerValidity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OfferValidityFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OfferValidityFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'OfferValidity'> extends True ? Prisma__OfferValidityClient<$Types.GetResult<OfferValidityPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__OfferValidityClient<$Types.GetResult<OfferValidityPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first OfferValidity that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferValidityFindFirstOrThrowArgs} args - Arguments to find a OfferValidity
     * @example
     * // Get one OfferValidity
     * const offerValidity = await prisma.offerValidity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OfferValidityFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OfferValidityFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OfferValidityClient<$Types.GetResult<OfferValidityPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more OfferValidities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferValidityFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OfferValidities
     * const offerValidities = await prisma.offerValidity.findMany()
     * 
     * // Get first 10 OfferValidities
     * const offerValidities = await prisma.offerValidity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const offerValidityWithIdOnly = await prisma.offerValidity.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OfferValidityFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OfferValidityFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<OfferValidityPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a OfferValidity.
     * @param {OfferValidityCreateArgs} args - Arguments to create a OfferValidity.
     * @example
     * // Create one OfferValidity
     * const OfferValidity = await prisma.offerValidity.create({
     *   data: {
     *     // ... data to create a OfferValidity
     *   }
     * })
     * 
    **/
    create<T extends OfferValidityCreateArgs<ExtArgs>>(
      args: SelectSubset<T, OfferValidityCreateArgs<ExtArgs>>
    ): Prisma__OfferValidityClient<$Types.GetResult<OfferValidityPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many OfferValidities.
     *     @param {OfferValidityCreateManyArgs} args - Arguments to create many OfferValidities.
     *     @example
     *     // Create many OfferValidities
     *     const offerValidity = await prisma.offerValidity.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OfferValidityCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OfferValidityCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OfferValidity.
     * @param {OfferValidityDeleteArgs} args - Arguments to delete one OfferValidity.
     * @example
     * // Delete one OfferValidity
     * const OfferValidity = await prisma.offerValidity.delete({
     *   where: {
     *     // ... filter to delete one OfferValidity
     *   }
     * })
     * 
    **/
    delete<T extends OfferValidityDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, OfferValidityDeleteArgs<ExtArgs>>
    ): Prisma__OfferValidityClient<$Types.GetResult<OfferValidityPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one OfferValidity.
     * @param {OfferValidityUpdateArgs} args - Arguments to update one OfferValidity.
     * @example
     * // Update one OfferValidity
     * const offerValidity = await prisma.offerValidity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OfferValidityUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, OfferValidityUpdateArgs<ExtArgs>>
    ): Prisma__OfferValidityClient<$Types.GetResult<OfferValidityPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more OfferValidities.
     * @param {OfferValidityDeleteManyArgs} args - Arguments to filter OfferValidities to delete.
     * @example
     * // Delete a few OfferValidities
     * const { count } = await prisma.offerValidity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OfferValidityDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OfferValidityDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OfferValidities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferValidityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OfferValidities
     * const offerValidity = await prisma.offerValidity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OfferValidityUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, OfferValidityUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OfferValidity.
     * @param {OfferValidityUpsertArgs} args - Arguments to update or create a OfferValidity.
     * @example
     * // Update or create a OfferValidity
     * const offerValidity = await prisma.offerValidity.upsert({
     *   create: {
     *     // ... data to create a OfferValidity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OfferValidity we want to update
     *   }
     * })
    **/
    upsert<T extends OfferValidityUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, OfferValidityUpsertArgs<ExtArgs>>
    ): Prisma__OfferValidityClient<$Types.GetResult<OfferValidityPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of OfferValidities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferValidityCountArgs} args - Arguments to filter OfferValidities to count.
     * @example
     * // Count the number of OfferValidities
     * const count = await prisma.offerValidity.count({
     *   where: {
     *     // ... the filter for the OfferValidities we want to count
     *   }
     * })
    **/
    count<T extends OfferValidityCountArgs>(
      args?: Subset<T, OfferValidityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OfferValidityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OfferValidity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferValidityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OfferValidityAggregateArgs>(args: Subset<T, OfferValidityAggregateArgs>): Prisma.PrismaPromise<GetOfferValidityAggregateType<T>>

    /**
     * Group by OfferValidity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferValidityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OfferValidityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OfferValidityGroupByArgs['orderBy'] }
        : { orderBy?: OfferValidityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OfferValidityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOfferValidityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for OfferValidity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OfferValidityClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    offer<T extends OfferArgs<ExtArgs> = {}>(args?: Subset<T, OfferArgs<ExtArgs>>): Prisma__OfferClient<$Types.GetResult<OfferPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    offerPromotionPeriod<T extends OfferPromotionPeriodsArgs<ExtArgs> = {}>(args?: Subset<T, OfferPromotionPeriodsArgs<ExtArgs>>): Prisma__OfferPromotionPeriodsClient<$Types.GetResult<OfferPromotionPeriodsPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * OfferValidity base type for findUnique actions
   */
  export type OfferValidityFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferValidity
     */
    select?: OfferValiditySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferValidityInclude<ExtArgs> | null
    /**
     * Filter, which OfferValidity to fetch.
     */
    where: OfferValidityWhereUniqueInput
  }

  /**
   * OfferValidity findUnique
   */
  export interface OfferValidityFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends OfferValidityFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OfferValidity findUniqueOrThrow
   */
  export type OfferValidityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferValidity
     */
    select?: OfferValiditySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferValidityInclude<ExtArgs> | null
    /**
     * Filter, which OfferValidity to fetch.
     */
    where: OfferValidityWhereUniqueInput
  }


  /**
   * OfferValidity base type for findFirst actions
   */
  export type OfferValidityFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferValidity
     */
    select?: OfferValiditySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferValidityInclude<ExtArgs> | null
    /**
     * Filter, which OfferValidity to fetch.
     */
    where?: OfferValidityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfferValidities to fetch.
     */
    orderBy?: Enumerable<OfferValidityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OfferValidities.
     */
    cursor?: OfferValidityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfferValidities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfferValidities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OfferValidities.
     */
    distinct?: Enumerable<OfferValidityScalarFieldEnum>
  }

  /**
   * OfferValidity findFirst
   */
  export interface OfferValidityFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends OfferValidityFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OfferValidity findFirstOrThrow
   */
  export type OfferValidityFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferValidity
     */
    select?: OfferValiditySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferValidityInclude<ExtArgs> | null
    /**
     * Filter, which OfferValidity to fetch.
     */
    where?: OfferValidityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfferValidities to fetch.
     */
    orderBy?: Enumerable<OfferValidityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OfferValidities.
     */
    cursor?: OfferValidityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfferValidities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfferValidities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OfferValidities.
     */
    distinct?: Enumerable<OfferValidityScalarFieldEnum>
  }


  /**
   * OfferValidity findMany
   */
  export type OfferValidityFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferValidity
     */
    select?: OfferValiditySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferValidityInclude<ExtArgs> | null
    /**
     * Filter, which OfferValidities to fetch.
     */
    where?: OfferValidityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfferValidities to fetch.
     */
    orderBy?: Enumerable<OfferValidityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OfferValidities.
     */
    cursor?: OfferValidityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfferValidities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfferValidities.
     */
    skip?: number
    distinct?: Enumerable<OfferValidityScalarFieldEnum>
  }


  /**
   * OfferValidity create
   */
  export type OfferValidityCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferValidity
     */
    select?: OfferValiditySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferValidityInclude<ExtArgs> | null
    /**
     * The data needed to create a OfferValidity.
     */
    data: XOR<OfferValidityCreateInput, OfferValidityUncheckedCreateInput>
  }


  /**
   * OfferValidity createMany
   */
  export type OfferValidityCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OfferValidities.
     */
    data: Enumerable<OfferValidityCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * OfferValidity update
   */
  export type OfferValidityUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferValidity
     */
    select?: OfferValiditySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferValidityInclude<ExtArgs> | null
    /**
     * The data needed to update a OfferValidity.
     */
    data: XOR<OfferValidityUpdateInput, OfferValidityUncheckedUpdateInput>
    /**
     * Choose, which OfferValidity to update.
     */
    where: OfferValidityWhereUniqueInput
  }


  /**
   * OfferValidity updateMany
   */
  export type OfferValidityUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OfferValidities.
     */
    data: XOR<OfferValidityUpdateManyMutationInput, OfferValidityUncheckedUpdateManyInput>
    /**
     * Filter which OfferValidities to update
     */
    where?: OfferValidityWhereInput
  }


  /**
   * OfferValidity upsert
   */
  export type OfferValidityUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferValidity
     */
    select?: OfferValiditySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferValidityInclude<ExtArgs> | null
    /**
     * The filter to search for the OfferValidity to update in case it exists.
     */
    where: OfferValidityWhereUniqueInput
    /**
     * In case the OfferValidity found by the `where` argument doesn't exist, create a new OfferValidity with this data.
     */
    create: XOR<OfferValidityCreateInput, OfferValidityUncheckedCreateInput>
    /**
     * In case the OfferValidity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OfferValidityUpdateInput, OfferValidityUncheckedUpdateInput>
  }


  /**
   * OfferValidity delete
   */
  export type OfferValidityDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferValidity
     */
    select?: OfferValiditySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferValidityInclude<ExtArgs> | null
    /**
     * Filter which OfferValidity to delete.
     */
    where: OfferValidityWhereUniqueInput
  }


  /**
   * OfferValidity deleteMany
   */
  export type OfferValidityDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which OfferValidities to delete
     */
    where?: OfferValidityWhereInput
  }


  /**
   * OfferValidity without action
   */
  export type OfferValidityArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferValidity
     */
    select?: OfferValiditySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferValidityInclude<ExtArgs> | null
  }



  /**
   * Model OfferPromotionPeriods
   */


  export type AggregateOfferPromotionPeriods = {
    _count: OfferPromotionPeriodsCountAggregateOutputType | null
    _avg: OfferPromotionPeriodsAvgAggregateOutputType | null
    _sum: OfferPromotionPeriodsSumAggregateOutputType | null
    _min: OfferPromotionPeriodsMinAggregateOutputType | null
    _max: OfferPromotionPeriodsMaxAggregateOutputType | null
  }

  export type OfferPromotionPeriodsAvgAggregateOutputType = {
    id: number | null
  }

  export type OfferPromotionPeriodsSumAggregateOutputType = {
    id: number | null
  }

  export type OfferPromotionPeriodsMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type OfferPromotionPeriodsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type OfferPromotionPeriodsCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type OfferPromotionPeriodsAvgAggregateInputType = {
    id?: true
  }

  export type OfferPromotionPeriodsSumAggregateInputType = {
    id?: true
  }

  export type OfferPromotionPeriodsMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type OfferPromotionPeriodsMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type OfferPromotionPeriodsCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type OfferPromotionPeriodsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which OfferPromotionPeriods to aggregate.
     */
    where?: OfferPromotionPeriodsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfferPromotionPeriods to fetch.
     */
    orderBy?: Enumerable<OfferPromotionPeriodsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OfferPromotionPeriodsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfferPromotionPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfferPromotionPeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OfferPromotionPeriods
    **/
    _count?: true | OfferPromotionPeriodsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OfferPromotionPeriodsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OfferPromotionPeriodsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OfferPromotionPeriodsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OfferPromotionPeriodsMaxAggregateInputType
  }

  export type GetOfferPromotionPeriodsAggregateType<T extends OfferPromotionPeriodsAggregateArgs> = {
        [P in keyof T & keyof AggregateOfferPromotionPeriods]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOfferPromotionPeriods[P]>
      : GetScalarType<T[P], AggregateOfferPromotionPeriods[P]>
  }




  export type OfferPromotionPeriodsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OfferPromotionPeriodsWhereInput
    orderBy?: Enumerable<OfferPromotionPeriodsOrderByWithAggregationInput>
    by: OfferPromotionPeriodsScalarFieldEnum[]
    having?: OfferPromotionPeriodsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OfferPromotionPeriodsCountAggregateInputType | true
    _avg?: OfferPromotionPeriodsAvgAggregateInputType
    _sum?: OfferPromotionPeriodsSumAggregateInputType
    _min?: OfferPromotionPeriodsMinAggregateInputType
    _max?: OfferPromotionPeriodsMaxAggregateInputType
  }


  export type OfferPromotionPeriodsGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: OfferPromotionPeriodsCountAggregateOutputType | null
    _avg: OfferPromotionPeriodsAvgAggregateOutputType | null
    _sum: OfferPromotionPeriodsSumAggregateOutputType | null
    _min: OfferPromotionPeriodsMinAggregateOutputType | null
    _max: OfferPromotionPeriodsMaxAggregateOutputType | null
  }

  type GetOfferPromotionPeriodsGroupByPayload<T extends OfferPromotionPeriodsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<OfferPromotionPeriodsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OfferPromotionPeriodsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OfferPromotionPeriodsGroupByOutputType[P]>
            : GetScalarType<T[P], OfferPromotionPeriodsGroupByOutputType[P]>
        }
      >
    >


  export type OfferPromotionPeriodsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    offerValidity?: boolean | OfferValidityArgs<ExtArgs>
  }, ExtArgs["result"]["offerPromotionPeriods"]>

  export type OfferPromotionPeriodsSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type OfferPromotionPeriodsInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    offerValidity?: boolean | OfferValidityArgs<ExtArgs>
  }


  type OfferPromotionPeriodsGetPayload<S extends boolean | null | undefined | OfferPromotionPeriodsArgs> = $Types.GetResult<OfferPromotionPeriodsPayload, S>

  type OfferPromotionPeriodsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<OfferPromotionPeriodsFindManyArgs, 'select' | 'include'> & {
      select?: OfferPromotionPeriodsCountAggregateInputType | true
    }

  export interface OfferPromotionPeriodsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OfferPromotionPeriods'], meta: { name: 'OfferPromotionPeriods' } }
    /**
     * Find zero or one OfferPromotionPeriods that matches the filter.
     * @param {OfferPromotionPeriodsFindUniqueArgs} args - Arguments to find a OfferPromotionPeriods
     * @example
     * // Get one OfferPromotionPeriods
     * const offerPromotionPeriods = await prisma.offerPromotionPeriods.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OfferPromotionPeriodsFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OfferPromotionPeriodsFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'OfferPromotionPeriods'> extends True ? Prisma__OfferPromotionPeriodsClient<$Types.GetResult<OfferPromotionPeriodsPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__OfferPromotionPeriodsClient<$Types.GetResult<OfferPromotionPeriodsPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one OfferPromotionPeriods that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OfferPromotionPeriodsFindUniqueOrThrowArgs} args - Arguments to find a OfferPromotionPeriods
     * @example
     * // Get one OfferPromotionPeriods
     * const offerPromotionPeriods = await prisma.offerPromotionPeriods.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OfferPromotionPeriodsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OfferPromotionPeriodsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OfferPromotionPeriodsClient<$Types.GetResult<OfferPromotionPeriodsPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first OfferPromotionPeriods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferPromotionPeriodsFindFirstArgs} args - Arguments to find a OfferPromotionPeriods
     * @example
     * // Get one OfferPromotionPeriods
     * const offerPromotionPeriods = await prisma.offerPromotionPeriods.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OfferPromotionPeriodsFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OfferPromotionPeriodsFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'OfferPromotionPeriods'> extends True ? Prisma__OfferPromotionPeriodsClient<$Types.GetResult<OfferPromotionPeriodsPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__OfferPromotionPeriodsClient<$Types.GetResult<OfferPromotionPeriodsPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first OfferPromotionPeriods that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferPromotionPeriodsFindFirstOrThrowArgs} args - Arguments to find a OfferPromotionPeriods
     * @example
     * // Get one OfferPromotionPeriods
     * const offerPromotionPeriods = await prisma.offerPromotionPeriods.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OfferPromotionPeriodsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OfferPromotionPeriodsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OfferPromotionPeriodsClient<$Types.GetResult<OfferPromotionPeriodsPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more OfferPromotionPeriods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferPromotionPeriodsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OfferPromotionPeriods
     * const offerPromotionPeriods = await prisma.offerPromotionPeriods.findMany()
     * 
     * // Get first 10 OfferPromotionPeriods
     * const offerPromotionPeriods = await prisma.offerPromotionPeriods.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const offerPromotionPeriodsWithIdOnly = await prisma.offerPromotionPeriods.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OfferPromotionPeriodsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OfferPromotionPeriodsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<OfferPromotionPeriodsPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a OfferPromotionPeriods.
     * @param {OfferPromotionPeriodsCreateArgs} args - Arguments to create a OfferPromotionPeriods.
     * @example
     * // Create one OfferPromotionPeriods
     * const OfferPromotionPeriods = await prisma.offerPromotionPeriods.create({
     *   data: {
     *     // ... data to create a OfferPromotionPeriods
     *   }
     * })
     * 
    **/
    create<T extends OfferPromotionPeriodsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, OfferPromotionPeriodsCreateArgs<ExtArgs>>
    ): Prisma__OfferPromotionPeriodsClient<$Types.GetResult<OfferPromotionPeriodsPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many OfferPromotionPeriods.
     *     @param {OfferPromotionPeriodsCreateManyArgs} args - Arguments to create many OfferPromotionPeriods.
     *     @example
     *     // Create many OfferPromotionPeriods
     *     const offerPromotionPeriods = await prisma.offerPromotionPeriods.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OfferPromotionPeriodsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OfferPromotionPeriodsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OfferPromotionPeriods.
     * @param {OfferPromotionPeriodsDeleteArgs} args - Arguments to delete one OfferPromotionPeriods.
     * @example
     * // Delete one OfferPromotionPeriods
     * const OfferPromotionPeriods = await prisma.offerPromotionPeriods.delete({
     *   where: {
     *     // ... filter to delete one OfferPromotionPeriods
     *   }
     * })
     * 
    **/
    delete<T extends OfferPromotionPeriodsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, OfferPromotionPeriodsDeleteArgs<ExtArgs>>
    ): Prisma__OfferPromotionPeriodsClient<$Types.GetResult<OfferPromotionPeriodsPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one OfferPromotionPeriods.
     * @param {OfferPromotionPeriodsUpdateArgs} args - Arguments to update one OfferPromotionPeriods.
     * @example
     * // Update one OfferPromotionPeriods
     * const offerPromotionPeriods = await prisma.offerPromotionPeriods.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OfferPromotionPeriodsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, OfferPromotionPeriodsUpdateArgs<ExtArgs>>
    ): Prisma__OfferPromotionPeriodsClient<$Types.GetResult<OfferPromotionPeriodsPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more OfferPromotionPeriods.
     * @param {OfferPromotionPeriodsDeleteManyArgs} args - Arguments to filter OfferPromotionPeriods to delete.
     * @example
     * // Delete a few OfferPromotionPeriods
     * const { count } = await prisma.offerPromotionPeriods.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OfferPromotionPeriodsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OfferPromotionPeriodsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OfferPromotionPeriods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferPromotionPeriodsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OfferPromotionPeriods
     * const offerPromotionPeriods = await prisma.offerPromotionPeriods.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OfferPromotionPeriodsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, OfferPromotionPeriodsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OfferPromotionPeriods.
     * @param {OfferPromotionPeriodsUpsertArgs} args - Arguments to update or create a OfferPromotionPeriods.
     * @example
     * // Update or create a OfferPromotionPeriods
     * const offerPromotionPeriods = await prisma.offerPromotionPeriods.upsert({
     *   create: {
     *     // ... data to create a OfferPromotionPeriods
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OfferPromotionPeriods we want to update
     *   }
     * })
    **/
    upsert<T extends OfferPromotionPeriodsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, OfferPromotionPeriodsUpsertArgs<ExtArgs>>
    ): Prisma__OfferPromotionPeriodsClient<$Types.GetResult<OfferPromotionPeriodsPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of OfferPromotionPeriods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferPromotionPeriodsCountArgs} args - Arguments to filter OfferPromotionPeriods to count.
     * @example
     * // Count the number of OfferPromotionPeriods
     * const count = await prisma.offerPromotionPeriods.count({
     *   where: {
     *     // ... the filter for the OfferPromotionPeriods we want to count
     *   }
     * })
    **/
    count<T extends OfferPromotionPeriodsCountArgs>(
      args?: Subset<T, OfferPromotionPeriodsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OfferPromotionPeriodsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OfferPromotionPeriods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferPromotionPeriodsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OfferPromotionPeriodsAggregateArgs>(args: Subset<T, OfferPromotionPeriodsAggregateArgs>): Prisma.PrismaPromise<GetOfferPromotionPeriodsAggregateType<T>>

    /**
     * Group by OfferPromotionPeriods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferPromotionPeriodsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OfferPromotionPeriodsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OfferPromotionPeriodsGroupByArgs['orderBy'] }
        : { orderBy?: OfferPromotionPeriodsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OfferPromotionPeriodsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOfferPromotionPeriodsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for OfferPromotionPeriods.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OfferPromotionPeriodsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    offerValidity<T extends OfferValidityArgs<ExtArgs> = {}>(args?: Subset<T, OfferValidityArgs<ExtArgs>>): Prisma__OfferValidityClient<$Types.GetResult<OfferValidityPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * OfferPromotionPeriods base type for findUnique actions
   */
  export type OfferPromotionPeriodsFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferPromotionPeriods
     */
    select?: OfferPromotionPeriodsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferPromotionPeriodsInclude<ExtArgs> | null
    /**
     * Filter, which OfferPromotionPeriods to fetch.
     */
    where: OfferPromotionPeriodsWhereUniqueInput
  }

  /**
   * OfferPromotionPeriods findUnique
   */
  export interface OfferPromotionPeriodsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends OfferPromotionPeriodsFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OfferPromotionPeriods findUniqueOrThrow
   */
  export type OfferPromotionPeriodsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferPromotionPeriods
     */
    select?: OfferPromotionPeriodsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferPromotionPeriodsInclude<ExtArgs> | null
    /**
     * Filter, which OfferPromotionPeriods to fetch.
     */
    where: OfferPromotionPeriodsWhereUniqueInput
  }


  /**
   * OfferPromotionPeriods base type for findFirst actions
   */
  export type OfferPromotionPeriodsFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferPromotionPeriods
     */
    select?: OfferPromotionPeriodsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferPromotionPeriodsInclude<ExtArgs> | null
    /**
     * Filter, which OfferPromotionPeriods to fetch.
     */
    where?: OfferPromotionPeriodsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfferPromotionPeriods to fetch.
     */
    orderBy?: Enumerable<OfferPromotionPeriodsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OfferPromotionPeriods.
     */
    cursor?: OfferPromotionPeriodsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfferPromotionPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfferPromotionPeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OfferPromotionPeriods.
     */
    distinct?: Enumerable<OfferPromotionPeriodsScalarFieldEnum>
  }

  /**
   * OfferPromotionPeriods findFirst
   */
  export interface OfferPromotionPeriodsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends OfferPromotionPeriodsFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * OfferPromotionPeriods findFirstOrThrow
   */
  export type OfferPromotionPeriodsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferPromotionPeriods
     */
    select?: OfferPromotionPeriodsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferPromotionPeriodsInclude<ExtArgs> | null
    /**
     * Filter, which OfferPromotionPeriods to fetch.
     */
    where?: OfferPromotionPeriodsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfferPromotionPeriods to fetch.
     */
    orderBy?: Enumerable<OfferPromotionPeriodsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OfferPromotionPeriods.
     */
    cursor?: OfferPromotionPeriodsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfferPromotionPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfferPromotionPeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OfferPromotionPeriods.
     */
    distinct?: Enumerable<OfferPromotionPeriodsScalarFieldEnum>
  }


  /**
   * OfferPromotionPeriods findMany
   */
  export type OfferPromotionPeriodsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferPromotionPeriods
     */
    select?: OfferPromotionPeriodsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferPromotionPeriodsInclude<ExtArgs> | null
    /**
     * Filter, which OfferPromotionPeriods to fetch.
     */
    where?: OfferPromotionPeriodsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfferPromotionPeriods to fetch.
     */
    orderBy?: Enumerable<OfferPromotionPeriodsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OfferPromotionPeriods.
     */
    cursor?: OfferPromotionPeriodsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfferPromotionPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfferPromotionPeriods.
     */
    skip?: number
    distinct?: Enumerable<OfferPromotionPeriodsScalarFieldEnum>
  }


  /**
   * OfferPromotionPeriods create
   */
  export type OfferPromotionPeriodsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferPromotionPeriods
     */
    select?: OfferPromotionPeriodsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferPromotionPeriodsInclude<ExtArgs> | null
    /**
     * The data needed to create a OfferPromotionPeriods.
     */
    data: XOR<OfferPromotionPeriodsCreateInput, OfferPromotionPeriodsUncheckedCreateInput>
  }


  /**
   * OfferPromotionPeriods createMany
   */
  export type OfferPromotionPeriodsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OfferPromotionPeriods.
     */
    data: Enumerable<OfferPromotionPeriodsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * OfferPromotionPeriods update
   */
  export type OfferPromotionPeriodsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferPromotionPeriods
     */
    select?: OfferPromotionPeriodsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferPromotionPeriodsInclude<ExtArgs> | null
    /**
     * The data needed to update a OfferPromotionPeriods.
     */
    data: XOR<OfferPromotionPeriodsUpdateInput, OfferPromotionPeriodsUncheckedUpdateInput>
    /**
     * Choose, which OfferPromotionPeriods to update.
     */
    where: OfferPromotionPeriodsWhereUniqueInput
  }


  /**
   * OfferPromotionPeriods updateMany
   */
  export type OfferPromotionPeriodsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OfferPromotionPeriods.
     */
    data: XOR<OfferPromotionPeriodsUpdateManyMutationInput, OfferPromotionPeriodsUncheckedUpdateManyInput>
    /**
     * Filter which OfferPromotionPeriods to update
     */
    where?: OfferPromotionPeriodsWhereInput
  }


  /**
   * OfferPromotionPeriods upsert
   */
  export type OfferPromotionPeriodsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferPromotionPeriods
     */
    select?: OfferPromotionPeriodsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferPromotionPeriodsInclude<ExtArgs> | null
    /**
     * The filter to search for the OfferPromotionPeriods to update in case it exists.
     */
    where: OfferPromotionPeriodsWhereUniqueInput
    /**
     * In case the OfferPromotionPeriods found by the `where` argument doesn't exist, create a new OfferPromotionPeriods with this data.
     */
    create: XOR<OfferPromotionPeriodsCreateInput, OfferPromotionPeriodsUncheckedCreateInput>
    /**
     * In case the OfferPromotionPeriods was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OfferPromotionPeriodsUpdateInput, OfferPromotionPeriodsUncheckedUpdateInput>
  }


  /**
   * OfferPromotionPeriods delete
   */
  export type OfferPromotionPeriodsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferPromotionPeriods
     */
    select?: OfferPromotionPeriodsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferPromotionPeriodsInclude<ExtArgs> | null
    /**
     * Filter which OfferPromotionPeriods to delete.
     */
    where: OfferPromotionPeriodsWhereUniqueInput
  }


  /**
   * OfferPromotionPeriods deleteMany
   */
  export type OfferPromotionPeriodsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which OfferPromotionPeriods to delete
     */
    where?: OfferPromotionPeriodsWhereInput
  }


  /**
   * OfferPromotionPeriods without action
   */
  export type OfferPromotionPeriodsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferPromotionPeriods
     */
    select?: OfferPromotionPeriodsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferPromotionPeriodsInclude<ExtArgs> | null
  }



  /**
   * Model Cart
   */


  export type AggregateCart = {
    _count: CartCountAggregateOutputType | null
    _avg: CartAvgAggregateOutputType | null
    _sum: CartSumAggregateOutputType | null
    _min: CartMinAggregateOutputType | null
    _max: CartMaxAggregateOutputType | null
  }

  export type CartAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    productId: number | null
  }

  export type CartSumAggregateOutputType = {
    id: number | null
    userId: number | null
    productId: number | null
  }

  export type CartMinAggregateOutputType = {
    id: number | null
    userId: number | null
    productId: number | null
    isCheckedOut: boolean | null
    isRemoved: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type CartMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    productId: number | null
    isCheckedOut: boolean | null
    isRemoved: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type CartCountAggregateOutputType = {
    id: number
    userId: number
    productId: number
    isCheckedOut: number
    isRemoved: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type CartAvgAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
  }

  export type CartSumAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
  }

  export type CartMinAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    isCheckedOut?: true
    isRemoved?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type CartMaxAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    isCheckedOut?: true
    isRemoved?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type CartCountAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    isCheckedOut?: true
    isRemoved?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type CartAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cart to aggregate.
     */
    where?: CartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carts to fetch.
     */
    orderBy?: Enumerable<CartOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Carts
    **/
    _count?: true | CartCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CartAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CartSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CartMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CartMaxAggregateInputType
  }

  export type GetCartAggregateType<T extends CartAggregateArgs> = {
        [P in keyof T & keyof AggregateCart]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCart[P]>
      : GetScalarType<T[P], AggregateCart[P]>
  }




  export type CartGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CartWhereInput
    orderBy?: Enumerable<CartOrderByWithAggregationInput>
    by: CartScalarFieldEnum[]
    having?: CartScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CartCountAggregateInputType | true
    _avg?: CartAvgAggregateInputType
    _sum?: CartSumAggregateInputType
    _min?: CartMinAggregateInputType
    _max?: CartMaxAggregateInputType
  }


  export type CartGroupByOutputType = {
    id: number
    userId: number
    productId: number
    isCheckedOut: boolean
    isRemoved: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: CartCountAggregateOutputType | null
    _avg: CartAvgAggregateOutputType | null
    _sum: CartSumAggregateOutputType | null
    _min: CartMinAggregateOutputType | null
    _max: CartMaxAggregateOutputType | null
  }

  type GetCartGroupByPayload<T extends CartGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CartGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CartGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CartGroupByOutputType[P]>
            : GetScalarType<T[P], CartGroupByOutputType[P]>
        }
      >
    >


  export type CartSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    productId?: boolean
    isCheckedOut?: boolean
    isRemoved?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserArgs<ExtArgs>
    product?: boolean | ProductArgs<ExtArgs>
  }, ExtArgs["result"]["cart"]>

  export type CartSelectScalar = {
    id?: boolean
    userId?: boolean
    productId?: boolean
    isCheckedOut?: boolean
    isRemoved?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type CartInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
    product?: boolean | ProductArgs<ExtArgs>
  }


  type CartGetPayload<S extends boolean | null | undefined | CartArgs> = $Types.GetResult<CartPayload, S>

  type CartCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<CartFindManyArgs, 'select' | 'include'> & {
      select?: CartCountAggregateInputType | true
    }

  export interface CartDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cart'], meta: { name: 'Cart' } }
    /**
     * Find zero or one Cart that matches the filter.
     * @param {CartFindUniqueArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CartFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CartFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Cart'> extends True ? Prisma__CartClient<$Types.GetResult<CartPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__CartClient<$Types.GetResult<CartPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Cart that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CartFindUniqueOrThrowArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CartFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CartFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CartClient<$Types.GetResult<CartPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Cart that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartFindFirstArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CartFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CartFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Cart'> extends True ? Prisma__CartClient<$Types.GetResult<CartPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__CartClient<$Types.GetResult<CartPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Cart that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartFindFirstOrThrowArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CartFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CartFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CartClient<$Types.GetResult<CartPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Carts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Carts
     * const carts = await prisma.cart.findMany()
     * 
     * // Get first 10 Carts
     * const carts = await prisma.cart.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cartWithIdOnly = await prisma.cart.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CartFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CartFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<CartPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Cart.
     * @param {CartCreateArgs} args - Arguments to create a Cart.
     * @example
     * // Create one Cart
     * const Cart = await prisma.cart.create({
     *   data: {
     *     // ... data to create a Cart
     *   }
     * })
     * 
    **/
    create<T extends CartCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CartCreateArgs<ExtArgs>>
    ): Prisma__CartClient<$Types.GetResult<CartPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Carts.
     *     @param {CartCreateManyArgs} args - Arguments to create many Carts.
     *     @example
     *     // Create many Carts
     *     const cart = await prisma.cart.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CartCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CartCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Cart.
     * @param {CartDeleteArgs} args - Arguments to delete one Cart.
     * @example
     * // Delete one Cart
     * const Cart = await prisma.cart.delete({
     *   where: {
     *     // ... filter to delete one Cart
     *   }
     * })
     * 
    **/
    delete<T extends CartDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CartDeleteArgs<ExtArgs>>
    ): Prisma__CartClient<$Types.GetResult<CartPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Cart.
     * @param {CartUpdateArgs} args - Arguments to update one Cart.
     * @example
     * // Update one Cart
     * const cart = await prisma.cart.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CartUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CartUpdateArgs<ExtArgs>>
    ): Prisma__CartClient<$Types.GetResult<CartPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Carts.
     * @param {CartDeleteManyArgs} args - Arguments to filter Carts to delete.
     * @example
     * // Delete a few Carts
     * const { count } = await prisma.cart.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CartDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CartDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Carts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Carts
     * const cart = await prisma.cart.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CartUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CartUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cart.
     * @param {CartUpsertArgs} args - Arguments to update or create a Cart.
     * @example
     * // Update or create a Cart
     * const cart = await prisma.cart.upsert({
     *   create: {
     *     // ... data to create a Cart
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cart we want to update
     *   }
     * })
    **/
    upsert<T extends CartUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CartUpsertArgs<ExtArgs>>
    ): Prisma__CartClient<$Types.GetResult<CartPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Carts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartCountArgs} args - Arguments to filter Carts to count.
     * @example
     * // Count the number of Carts
     * const count = await prisma.cart.count({
     *   where: {
     *     // ... the filter for the Carts we want to count
     *   }
     * })
    **/
    count<T extends CartCountArgs>(
      args?: Subset<T, CartCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CartCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CartAggregateArgs>(args: Subset<T, CartAggregateArgs>): Prisma.PrismaPromise<GetCartAggregateType<T>>

    /**
     * Group by Cart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CartGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CartGroupByArgs['orderBy'] }
        : { orderBy?: CartGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CartGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCartGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Cart.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CartClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    product<T extends ProductArgs<ExtArgs> = {}>(args?: Subset<T, ProductArgs<ExtArgs>>): Prisma__ProductClient<$Types.GetResult<ProductPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Cart base type for findUnique actions
   */
  export type CartFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Cart to fetch.
     */
    where: CartWhereUniqueInput
  }

  /**
   * Cart findUnique
   */
  export interface CartFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends CartFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Cart findUniqueOrThrow
   */
  export type CartFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Cart to fetch.
     */
    where: CartWhereUniqueInput
  }


  /**
   * Cart base type for findFirst actions
   */
  export type CartFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Cart to fetch.
     */
    where?: CartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carts to fetch.
     */
    orderBy?: Enumerable<CartOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Carts.
     */
    cursor?: CartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Carts.
     */
    distinct?: Enumerable<CartScalarFieldEnum>
  }

  /**
   * Cart findFirst
   */
  export interface CartFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends CartFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Cart findFirstOrThrow
   */
  export type CartFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Cart to fetch.
     */
    where?: CartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carts to fetch.
     */
    orderBy?: Enumerable<CartOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Carts.
     */
    cursor?: CartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Carts.
     */
    distinct?: Enumerable<CartScalarFieldEnum>
  }


  /**
   * Cart findMany
   */
  export type CartFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Carts to fetch.
     */
    where?: CartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carts to fetch.
     */
    orderBy?: Enumerable<CartOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Carts.
     */
    cursor?: CartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carts.
     */
    skip?: number
    distinct?: Enumerable<CartScalarFieldEnum>
  }


  /**
   * Cart create
   */
  export type CartCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * The data needed to create a Cart.
     */
    data: XOR<CartCreateInput, CartUncheckedCreateInput>
  }


  /**
   * Cart createMany
   */
  export type CartCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Carts.
     */
    data: Enumerable<CartCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Cart update
   */
  export type CartUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * The data needed to update a Cart.
     */
    data: XOR<CartUpdateInput, CartUncheckedUpdateInput>
    /**
     * Choose, which Cart to update.
     */
    where: CartWhereUniqueInput
  }


  /**
   * Cart updateMany
   */
  export type CartUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Carts.
     */
    data: XOR<CartUpdateManyMutationInput, CartUncheckedUpdateManyInput>
    /**
     * Filter which Carts to update
     */
    where?: CartWhereInput
  }


  /**
   * Cart upsert
   */
  export type CartUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * The filter to search for the Cart to update in case it exists.
     */
    where: CartWhereUniqueInput
    /**
     * In case the Cart found by the `where` argument doesn't exist, create a new Cart with this data.
     */
    create: XOR<CartCreateInput, CartUncheckedCreateInput>
    /**
     * In case the Cart was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CartUpdateInput, CartUncheckedUpdateInput>
  }


  /**
   * Cart delete
   */
  export type CartDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter which Cart to delete.
     */
    where: CartWhereUniqueInput
  }


  /**
   * Cart deleteMany
   */
  export type CartDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Carts to delete
     */
    where?: CartWhereInput
  }


  /**
   * Cart without action
   */
  export type CartArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CartInclude<ExtArgs> | null
  }



  /**
   * Model Wishlist
   */


  export type AggregateWishlist = {
    _count: WishlistCountAggregateOutputType | null
    _avg: WishlistAvgAggregateOutputType | null
    _sum: WishlistSumAggregateOutputType | null
    _min: WishlistMinAggregateOutputType | null
    _max: WishlistMaxAggregateOutputType | null
  }

  export type WishlistAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type WishlistSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type WishlistMinAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type WishlistMaxAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type WishlistCountAggregateOutputType = {
    id: number
    userId: number
    _all: number
  }


  export type WishlistAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type WishlistSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type WishlistMinAggregateInputType = {
    id?: true
    userId?: true
  }

  export type WishlistMaxAggregateInputType = {
    id?: true
    userId?: true
  }

  export type WishlistCountAggregateInputType = {
    id?: true
    userId?: true
    _all?: true
  }

  export type WishlistAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Wishlist to aggregate.
     */
    where?: WishlistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wishlists to fetch.
     */
    orderBy?: Enumerable<WishlistOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WishlistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wishlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wishlists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Wishlists
    **/
    _count?: true | WishlistCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WishlistAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WishlistSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WishlistMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WishlistMaxAggregateInputType
  }

  export type GetWishlistAggregateType<T extends WishlistAggregateArgs> = {
        [P in keyof T & keyof AggregateWishlist]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWishlist[P]>
      : GetScalarType<T[P], AggregateWishlist[P]>
  }




  export type WishlistGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: WishlistWhereInput
    orderBy?: Enumerable<WishlistOrderByWithAggregationInput>
    by: WishlistScalarFieldEnum[]
    having?: WishlistScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WishlistCountAggregateInputType | true
    _avg?: WishlistAvgAggregateInputType
    _sum?: WishlistSumAggregateInputType
    _min?: WishlistMinAggregateInputType
    _max?: WishlistMaxAggregateInputType
  }


  export type WishlistGroupByOutputType = {
    id: number
    userId: number
    _count: WishlistCountAggregateOutputType | null
    _avg: WishlistAvgAggregateOutputType | null
    _sum: WishlistSumAggregateOutputType | null
    _min: WishlistMinAggregateOutputType | null
    _max: WishlistMaxAggregateOutputType | null
  }

  type GetWishlistGroupByPayload<T extends WishlistGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<WishlistGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WishlistGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WishlistGroupByOutputType[P]>
            : GetScalarType<T[P], WishlistGroupByOutputType[P]>
        }
      >
    >


  export type WishlistSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    items?: boolean | Wishlist$itemsArgs<ExtArgs>
    user?: boolean | UserArgs<ExtArgs>
    _count?: boolean | WishlistCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["wishlist"]>

  export type WishlistSelectScalar = {
    id?: boolean
    userId?: boolean
  }

  export type WishlistInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    items?: boolean | Wishlist$itemsArgs<ExtArgs>
    user?: boolean | UserArgs<ExtArgs>
    _count?: boolean | WishlistCountOutputTypeArgs<ExtArgs>
  }


  type WishlistGetPayload<S extends boolean | null | undefined | WishlistArgs> = $Types.GetResult<WishlistPayload, S>

  type WishlistCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<WishlistFindManyArgs, 'select' | 'include'> & {
      select?: WishlistCountAggregateInputType | true
    }

  export interface WishlistDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Wishlist'], meta: { name: 'Wishlist' } }
    /**
     * Find zero or one Wishlist that matches the filter.
     * @param {WishlistFindUniqueArgs} args - Arguments to find a Wishlist
     * @example
     * // Get one Wishlist
     * const wishlist = await prisma.wishlist.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WishlistFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, WishlistFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Wishlist'> extends True ? Prisma__WishlistClient<$Types.GetResult<WishlistPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__WishlistClient<$Types.GetResult<WishlistPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Wishlist that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {WishlistFindUniqueOrThrowArgs} args - Arguments to find a Wishlist
     * @example
     * // Get one Wishlist
     * const wishlist = await prisma.wishlist.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends WishlistFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WishlistFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__WishlistClient<$Types.GetResult<WishlistPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Wishlist that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistFindFirstArgs} args - Arguments to find a Wishlist
     * @example
     * // Get one Wishlist
     * const wishlist = await prisma.wishlist.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WishlistFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, WishlistFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Wishlist'> extends True ? Prisma__WishlistClient<$Types.GetResult<WishlistPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__WishlistClient<$Types.GetResult<WishlistPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Wishlist that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistFindFirstOrThrowArgs} args - Arguments to find a Wishlist
     * @example
     * // Get one Wishlist
     * const wishlist = await prisma.wishlist.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends WishlistFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WishlistFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__WishlistClient<$Types.GetResult<WishlistPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Wishlists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Wishlists
     * const wishlists = await prisma.wishlist.findMany()
     * 
     * // Get first 10 Wishlists
     * const wishlists = await prisma.wishlist.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wishlistWithIdOnly = await prisma.wishlist.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WishlistFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WishlistFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<WishlistPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Wishlist.
     * @param {WishlistCreateArgs} args - Arguments to create a Wishlist.
     * @example
     * // Create one Wishlist
     * const Wishlist = await prisma.wishlist.create({
     *   data: {
     *     // ... data to create a Wishlist
     *   }
     * })
     * 
    **/
    create<T extends WishlistCreateArgs<ExtArgs>>(
      args: SelectSubset<T, WishlistCreateArgs<ExtArgs>>
    ): Prisma__WishlistClient<$Types.GetResult<WishlistPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Wishlists.
     *     @param {WishlistCreateManyArgs} args - Arguments to create many Wishlists.
     *     @example
     *     // Create many Wishlists
     *     const wishlist = await prisma.wishlist.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WishlistCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WishlistCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Wishlist.
     * @param {WishlistDeleteArgs} args - Arguments to delete one Wishlist.
     * @example
     * // Delete one Wishlist
     * const Wishlist = await prisma.wishlist.delete({
     *   where: {
     *     // ... filter to delete one Wishlist
     *   }
     * })
     * 
    **/
    delete<T extends WishlistDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, WishlistDeleteArgs<ExtArgs>>
    ): Prisma__WishlistClient<$Types.GetResult<WishlistPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Wishlist.
     * @param {WishlistUpdateArgs} args - Arguments to update one Wishlist.
     * @example
     * // Update one Wishlist
     * const wishlist = await prisma.wishlist.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WishlistUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, WishlistUpdateArgs<ExtArgs>>
    ): Prisma__WishlistClient<$Types.GetResult<WishlistPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Wishlists.
     * @param {WishlistDeleteManyArgs} args - Arguments to filter Wishlists to delete.
     * @example
     * // Delete a few Wishlists
     * const { count } = await prisma.wishlist.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WishlistDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WishlistDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wishlists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Wishlists
     * const wishlist = await prisma.wishlist.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WishlistUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, WishlistUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Wishlist.
     * @param {WishlistUpsertArgs} args - Arguments to update or create a Wishlist.
     * @example
     * // Update or create a Wishlist
     * const wishlist = await prisma.wishlist.upsert({
     *   create: {
     *     // ... data to create a Wishlist
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Wishlist we want to update
     *   }
     * })
    **/
    upsert<T extends WishlistUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, WishlistUpsertArgs<ExtArgs>>
    ): Prisma__WishlistClient<$Types.GetResult<WishlistPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Wishlists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistCountArgs} args - Arguments to filter Wishlists to count.
     * @example
     * // Count the number of Wishlists
     * const count = await prisma.wishlist.count({
     *   where: {
     *     // ... the filter for the Wishlists we want to count
     *   }
     * })
    **/
    count<T extends WishlistCountArgs>(
      args?: Subset<T, WishlistCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WishlistCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Wishlist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WishlistAggregateArgs>(args: Subset<T, WishlistAggregateArgs>): Prisma.PrismaPromise<GetWishlistAggregateType<T>>

    /**
     * Group by Wishlist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WishlistGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WishlistGroupByArgs['orderBy'] }
        : { orderBy?: WishlistGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WishlistGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWishlistGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Wishlist.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__WishlistClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    items<T extends Wishlist$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Wishlist$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<WishlistItemPayload<ExtArgs>, T, 'findMany', never>| Null>;

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Wishlist base type for findUnique actions
   */
  export type WishlistFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WishlistInclude<ExtArgs> | null
    /**
     * Filter, which Wishlist to fetch.
     */
    where: WishlistWhereUniqueInput
  }

  /**
   * Wishlist findUnique
   */
  export interface WishlistFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends WishlistFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Wishlist findUniqueOrThrow
   */
  export type WishlistFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WishlistInclude<ExtArgs> | null
    /**
     * Filter, which Wishlist to fetch.
     */
    where: WishlistWhereUniqueInput
  }


  /**
   * Wishlist base type for findFirst actions
   */
  export type WishlistFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WishlistInclude<ExtArgs> | null
    /**
     * Filter, which Wishlist to fetch.
     */
    where?: WishlistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wishlists to fetch.
     */
    orderBy?: Enumerable<WishlistOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wishlists.
     */
    cursor?: WishlistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wishlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wishlists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wishlists.
     */
    distinct?: Enumerable<WishlistScalarFieldEnum>
  }

  /**
   * Wishlist findFirst
   */
  export interface WishlistFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends WishlistFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Wishlist findFirstOrThrow
   */
  export type WishlistFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WishlistInclude<ExtArgs> | null
    /**
     * Filter, which Wishlist to fetch.
     */
    where?: WishlistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wishlists to fetch.
     */
    orderBy?: Enumerable<WishlistOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wishlists.
     */
    cursor?: WishlistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wishlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wishlists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wishlists.
     */
    distinct?: Enumerable<WishlistScalarFieldEnum>
  }


  /**
   * Wishlist findMany
   */
  export type WishlistFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WishlistInclude<ExtArgs> | null
    /**
     * Filter, which Wishlists to fetch.
     */
    where?: WishlistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wishlists to fetch.
     */
    orderBy?: Enumerable<WishlistOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Wishlists.
     */
    cursor?: WishlistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wishlists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wishlists.
     */
    skip?: number
    distinct?: Enumerable<WishlistScalarFieldEnum>
  }


  /**
   * Wishlist create
   */
  export type WishlistCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WishlistInclude<ExtArgs> | null
    /**
     * The data needed to create a Wishlist.
     */
    data: XOR<WishlistCreateInput, WishlistUncheckedCreateInput>
  }


  /**
   * Wishlist createMany
   */
  export type WishlistCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Wishlists.
     */
    data: Enumerable<WishlistCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Wishlist update
   */
  export type WishlistUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WishlistInclude<ExtArgs> | null
    /**
     * The data needed to update a Wishlist.
     */
    data: XOR<WishlistUpdateInput, WishlistUncheckedUpdateInput>
    /**
     * Choose, which Wishlist to update.
     */
    where: WishlistWhereUniqueInput
  }


  /**
   * Wishlist updateMany
   */
  export type WishlistUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Wishlists.
     */
    data: XOR<WishlistUpdateManyMutationInput, WishlistUncheckedUpdateManyInput>
    /**
     * Filter which Wishlists to update
     */
    where?: WishlistWhereInput
  }


  /**
   * Wishlist upsert
   */
  export type WishlistUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WishlistInclude<ExtArgs> | null
    /**
     * The filter to search for the Wishlist to update in case it exists.
     */
    where: WishlistWhereUniqueInput
    /**
     * In case the Wishlist found by the `where` argument doesn't exist, create a new Wishlist with this data.
     */
    create: XOR<WishlistCreateInput, WishlistUncheckedCreateInput>
    /**
     * In case the Wishlist was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WishlistUpdateInput, WishlistUncheckedUpdateInput>
  }


  /**
   * Wishlist delete
   */
  export type WishlistDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WishlistInclude<ExtArgs> | null
    /**
     * Filter which Wishlist to delete.
     */
    where: WishlistWhereUniqueInput
  }


  /**
   * Wishlist deleteMany
   */
  export type WishlistDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Wishlists to delete
     */
    where?: WishlistWhereInput
  }


  /**
   * Wishlist.items
   */
  export type Wishlist$itemsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WishlistItemInclude<ExtArgs> | null
    where?: WishlistItemWhereInput
    orderBy?: Enumerable<WishlistItemOrderByWithRelationInput>
    cursor?: WishlistItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<WishlistItemScalarFieldEnum>
  }


  /**
   * Wishlist without action
   */
  export type WishlistArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wishlist
     */
    select?: WishlistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WishlistInclude<ExtArgs> | null
  }



  /**
   * Model WishlistItem
   */


  export type AggregateWishlistItem = {
    _count: WishlistItemCountAggregateOutputType | null
    _avg: WishlistItemAvgAggregateOutputType | null
    _sum: WishlistItemSumAggregateOutputType | null
    _min: WishlistItemMinAggregateOutputType | null
    _max: WishlistItemMaxAggregateOutputType | null
  }

  export type WishlistItemAvgAggregateOutputType = {
    id: number | null
    wishlistId: number | null
    productId: number | null
  }

  export type WishlistItemSumAggregateOutputType = {
    id: number | null
    wishlistId: number | null
    productId: number | null
  }

  export type WishlistItemMinAggregateOutputType = {
    id: number | null
    wishlistId: number | null
    productId: number | null
  }

  export type WishlistItemMaxAggregateOutputType = {
    id: number | null
    wishlistId: number | null
    productId: number | null
  }

  export type WishlistItemCountAggregateOutputType = {
    id: number
    wishlistId: number
    productId: number
    _all: number
  }


  export type WishlistItemAvgAggregateInputType = {
    id?: true
    wishlistId?: true
    productId?: true
  }

  export type WishlistItemSumAggregateInputType = {
    id?: true
    wishlistId?: true
    productId?: true
  }

  export type WishlistItemMinAggregateInputType = {
    id?: true
    wishlistId?: true
    productId?: true
  }

  export type WishlistItemMaxAggregateInputType = {
    id?: true
    wishlistId?: true
    productId?: true
  }

  export type WishlistItemCountAggregateInputType = {
    id?: true
    wishlistId?: true
    productId?: true
    _all?: true
  }

  export type WishlistItemAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which WishlistItem to aggregate.
     */
    where?: WishlistItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WishlistItems to fetch.
     */
    orderBy?: Enumerable<WishlistItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WishlistItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WishlistItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WishlistItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WishlistItems
    **/
    _count?: true | WishlistItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WishlistItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WishlistItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WishlistItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WishlistItemMaxAggregateInputType
  }

  export type GetWishlistItemAggregateType<T extends WishlistItemAggregateArgs> = {
        [P in keyof T & keyof AggregateWishlistItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWishlistItem[P]>
      : GetScalarType<T[P], AggregateWishlistItem[P]>
  }




  export type WishlistItemGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: WishlistItemWhereInput
    orderBy?: Enumerable<WishlistItemOrderByWithAggregationInput>
    by: WishlistItemScalarFieldEnum[]
    having?: WishlistItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WishlistItemCountAggregateInputType | true
    _avg?: WishlistItemAvgAggregateInputType
    _sum?: WishlistItemSumAggregateInputType
    _min?: WishlistItemMinAggregateInputType
    _max?: WishlistItemMaxAggregateInputType
  }


  export type WishlistItemGroupByOutputType = {
    id: number
    wishlistId: number
    productId: number
    _count: WishlistItemCountAggregateOutputType | null
    _avg: WishlistItemAvgAggregateOutputType | null
    _sum: WishlistItemSumAggregateOutputType | null
    _min: WishlistItemMinAggregateOutputType | null
    _max: WishlistItemMaxAggregateOutputType | null
  }

  type GetWishlistItemGroupByPayload<T extends WishlistItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<WishlistItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WishlistItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WishlistItemGroupByOutputType[P]>
            : GetScalarType<T[P], WishlistItemGroupByOutputType[P]>
        }
      >
    >


  export type WishlistItemSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    wishlistId?: boolean
    productId?: boolean
    wishlist?: boolean | WishlistArgs<ExtArgs>
    product?: boolean | ProductArgs<ExtArgs>
  }, ExtArgs["result"]["wishlistItem"]>

  export type WishlistItemSelectScalar = {
    id?: boolean
    wishlistId?: boolean
    productId?: boolean
  }

  export type WishlistItemInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    wishlist?: boolean | WishlistArgs<ExtArgs>
    product?: boolean | ProductArgs<ExtArgs>
  }


  type WishlistItemGetPayload<S extends boolean | null | undefined | WishlistItemArgs> = $Types.GetResult<WishlistItemPayload, S>

  type WishlistItemCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<WishlistItemFindManyArgs, 'select' | 'include'> & {
      select?: WishlistItemCountAggregateInputType | true
    }

  export interface WishlistItemDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WishlistItem'], meta: { name: 'WishlistItem' } }
    /**
     * Find zero or one WishlistItem that matches the filter.
     * @param {WishlistItemFindUniqueArgs} args - Arguments to find a WishlistItem
     * @example
     * // Get one WishlistItem
     * const wishlistItem = await prisma.wishlistItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WishlistItemFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, WishlistItemFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'WishlistItem'> extends True ? Prisma__WishlistItemClient<$Types.GetResult<WishlistItemPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__WishlistItemClient<$Types.GetResult<WishlistItemPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one WishlistItem that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {WishlistItemFindUniqueOrThrowArgs} args - Arguments to find a WishlistItem
     * @example
     * // Get one WishlistItem
     * const wishlistItem = await prisma.wishlistItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends WishlistItemFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WishlistItemFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__WishlistItemClient<$Types.GetResult<WishlistItemPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first WishlistItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistItemFindFirstArgs} args - Arguments to find a WishlistItem
     * @example
     * // Get one WishlistItem
     * const wishlistItem = await prisma.wishlistItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WishlistItemFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, WishlistItemFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'WishlistItem'> extends True ? Prisma__WishlistItemClient<$Types.GetResult<WishlistItemPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__WishlistItemClient<$Types.GetResult<WishlistItemPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first WishlistItem that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistItemFindFirstOrThrowArgs} args - Arguments to find a WishlistItem
     * @example
     * // Get one WishlistItem
     * const wishlistItem = await prisma.wishlistItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends WishlistItemFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WishlistItemFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__WishlistItemClient<$Types.GetResult<WishlistItemPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more WishlistItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistItemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WishlistItems
     * const wishlistItems = await prisma.wishlistItem.findMany()
     * 
     * // Get first 10 WishlistItems
     * const wishlistItems = await prisma.wishlistItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wishlistItemWithIdOnly = await prisma.wishlistItem.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WishlistItemFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WishlistItemFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<WishlistItemPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a WishlistItem.
     * @param {WishlistItemCreateArgs} args - Arguments to create a WishlistItem.
     * @example
     * // Create one WishlistItem
     * const WishlistItem = await prisma.wishlistItem.create({
     *   data: {
     *     // ... data to create a WishlistItem
     *   }
     * })
     * 
    **/
    create<T extends WishlistItemCreateArgs<ExtArgs>>(
      args: SelectSubset<T, WishlistItemCreateArgs<ExtArgs>>
    ): Prisma__WishlistItemClient<$Types.GetResult<WishlistItemPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many WishlistItems.
     *     @param {WishlistItemCreateManyArgs} args - Arguments to create many WishlistItems.
     *     @example
     *     // Create many WishlistItems
     *     const wishlistItem = await prisma.wishlistItem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WishlistItemCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WishlistItemCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WishlistItem.
     * @param {WishlistItemDeleteArgs} args - Arguments to delete one WishlistItem.
     * @example
     * // Delete one WishlistItem
     * const WishlistItem = await prisma.wishlistItem.delete({
     *   where: {
     *     // ... filter to delete one WishlistItem
     *   }
     * })
     * 
    **/
    delete<T extends WishlistItemDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, WishlistItemDeleteArgs<ExtArgs>>
    ): Prisma__WishlistItemClient<$Types.GetResult<WishlistItemPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one WishlistItem.
     * @param {WishlistItemUpdateArgs} args - Arguments to update one WishlistItem.
     * @example
     * // Update one WishlistItem
     * const wishlistItem = await prisma.wishlistItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WishlistItemUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, WishlistItemUpdateArgs<ExtArgs>>
    ): Prisma__WishlistItemClient<$Types.GetResult<WishlistItemPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more WishlistItems.
     * @param {WishlistItemDeleteManyArgs} args - Arguments to filter WishlistItems to delete.
     * @example
     * // Delete a few WishlistItems
     * const { count } = await prisma.wishlistItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WishlistItemDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WishlistItemDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WishlistItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WishlistItems
     * const wishlistItem = await prisma.wishlistItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WishlistItemUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, WishlistItemUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WishlistItem.
     * @param {WishlistItemUpsertArgs} args - Arguments to update or create a WishlistItem.
     * @example
     * // Update or create a WishlistItem
     * const wishlistItem = await prisma.wishlistItem.upsert({
     *   create: {
     *     // ... data to create a WishlistItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WishlistItem we want to update
     *   }
     * })
    **/
    upsert<T extends WishlistItemUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, WishlistItemUpsertArgs<ExtArgs>>
    ): Prisma__WishlistItemClient<$Types.GetResult<WishlistItemPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of WishlistItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistItemCountArgs} args - Arguments to filter WishlistItems to count.
     * @example
     * // Count the number of WishlistItems
     * const count = await prisma.wishlistItem.count({
     *   where: {
     *     // ... the filter for the WishlistItems we want to count
     *   }
     * })
    **/
    count<T extends WishlistItemCountArgs>(
      args?: Subset<T, WishlistItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WishlistItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WishlistItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WishlistItemAggregateArgs>(args: Subset<T, WishlistItemAggregateArgs>): Prisma.PrismaPromise<GetWishlistItemAggregateType<T>>

    /**
     * Group by WishlistItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WishlistItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WishlistItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WishlistItemGroupByArgs['orderBy'] }
        : { orderBy?: WishlistItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WishlistItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWishlistItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for WishlistItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__WishlistItemClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    wishlist<T extends WishlistArgs<ExtArgs> = {}>(args?: Subset<T, WishlistArgs<ExtArgs>>): Prisma__WishlistClient<$Types.GetResult<WishlistPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    product<T extends ProductArgs<ExtArgs> = {}>(args?: Subset<T, ProductArgs<ExtArgs>>): Prisma__ProductClient<$Types.GetResult<ProductPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * WishlistItem base type for findUnique actions
   */
  export type WishlistItemFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WishlistItemInclude<ExtArgs> | null
    /**
     * Filter, which WishlistItem to fetch.
     */
    where: WishlistItemWhereUniqueInput
  }

  /**
   * WishlistItem findUnique
   */
  export interface WishlistItemFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends WishlistItemFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * WishlistItem findUniqueOrThrow
   */
  export type WishlistItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WishlistItemInclude<ExtArgs> | null
    /**
     * Filter, which WishlistItem to fetch.
     */
    where: WishlistItemWhereUniqueInput
  }


  /**
   * WishlistItem base type for findFirst actions
   */
  export type WishlistItemFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WishlistItemInclude<ExtArgs> | null
    /**
     * Filter, which WishlistItem to fetch.
     */
    where?: WishlistItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WishlistItems to fetch.
     */
    orderBy?: Enumerable<WishlistItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WishlistItems.
     */
    cursor?: WishlistItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WishlistItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WishlistItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WishlistItems.
     */
    distinct?: Enumerable<WishlistItemScalarFieldEnum>
  }

  /**
   * WishlistItem findFirst
   */
  export interface WishlistItemFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends WishlistItemFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * WishlistItem findFirstOrThrow
   */
  export type WishlistItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WishlistItemInclude<ExtArgs> | null
    /**
     * Filter, which WishlistItem to fetch.
     */
    where?: WishlistItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WishlistItems to fetch.
     */
    orderBy?: Enumerable<WishlistItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WishlistItems.
     */
    cursor?: WishlistItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WishlistItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WishlistItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WishlistItems.
     */
    distinct?: Enumerable<WishlistItemScalarFieldEnum>
  }


  /**
   * WishlistItem findMany
   */
  export type WishlistItemFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WishlistItemInclude<ExtArgs> | null
    /**
     * Filter, which WishlistItems to fetch.
     */
    where?: WishlistItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WishlistItems to fetch.
     */
    orderBy?: Enumerable<WishlistItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WishlistItems.
     */
    cursor?: WishlistItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WishlistItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WishlistItems.
     */
    skip?: number
    distinct?: Enumerable<WishlistItemScalarFieldEnum>
  }


  /**
   * WishlistItem create
   */
  export type WishlistItemCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WishlistItemInclude<ExtArgs> | null
    /**
     * The data needed to create a WishlistItem.
     */
    data: XOR<WishlistItemCreateInput, WishlistItemUncheckedCreateInput>
  }


  /**
   * WishlistItem createMany
   */
  export type WishlistItemCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WishlistItems.
     */
    data: Enumerable<WishlistItemCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * WishlistItem update
   */
  export type WishlistItemUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WishlistItemInclude<ExtArgs> | null
    /**
     * The data needed to update a WishlistItem.
     */
    data: XOR<WishlistItemUpdateInput, WishlistItemUncheckedUpdateInput>
    /**
     * Choose, which WishlistItem to update.
     */
    where: WishlistItemWhereUniqueInput
  }


  /**
   * WishlistItem updateMany
   */
  export type WishlistItemUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WishlistItems.
     */
    data: XOR<WishlistItemUpdateManyMutationInput, WishlistItemUncheckedUpdateManyInput>
    /**
     * Filter which WishlistItems to update
     */
    where?: WishlistItemWhereInput
  }


  /**
   * WishlistItem upsert
   */
  export type WishlistItemUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WishlistItemInclude<ExtArgs> | null
    /**
     * The filter to search for the WishlistItem to update in case it exists.
     */
    where: WishlistItemWhereUniqueInput
    /**
     * In case the WishlistItem found by the `where` argument doesn't exist, create a new WishlistItem with this data.
     */
    create: XOR<WishlistItemCreateInput, WishlistItemUncheckedCreateInput>
    /**
     * In case the WishlistItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WishlistItemUpdateInput, WishlistItemUncheckedUpdateInput>
  }


  /**
   * WishlistItem delete
   */
  export type WishlistItemDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WishlistItemInclude<ExtArgs> | null
    /**
     * Filter which WishlistItem to delete.
     */
    where: WishlistItemWhereUniqueInput
  }


  /**
   * WishlistItem deleteMany
   */
  export type WishlistItemDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which WishlistItems to delete
     */
    where?: WishlistItemWhereInput
  }


  /**
   * WishlistItem without action
   */
  export type WishlistItemArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WishlistItem
     */
    select?: WishlistItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WishlistItemInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const RolesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type RolesScalarFieldEnum = (typeof RolesScalarFieldEnum)[keyof typeof RolesScalarFieldEnum]


  export const SyncDataLastIdScalarFieldEnum: {
    id: 'id',
    lastId: 'lastId',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type SyncDataLastIdScalarFieldEnum = (typeof SyncDataLastIdScalarFieldEnum)[keyof typeof SyncDataLastIdScalarFieldEnum]


  export const ProductCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    genderId: 'genderId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type ProductCategoryScalarFieldEnum = (typeof ProductCategoryScalarFieldEnum)[keyof typeof ProductCategoryScalarFieldEnum]


  export const ProductTypeScalarFieldEnum: {
    id: 'id',
    itemsName: 'itemsName',
    productCategoryId: 'productCategoryId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type ProductTypeScalarFieldEnum = (typeof ProductTypeScalarFieldEnum)[keyof typeof ProductTypeScalarFieldEnum]


  export const ProductTypeSizeScalarFieldEnum: {
    id: 'id',
    size: 'size',
    ietmsId: 'ietmsId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type ProductTypeSizeScalarFieldEnum = (typeof ProductTypeSizeScalarFieldEnum)[keyof typeof ProductTypeSizeScalarFieldEnum]


  export const GenderScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type GenderScalarFieldEnum = (typeof GenderScalarFieldEnum)[keyof typeof GenderScalarFieldEnum]


  export const CountryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    timezoneOffset: 'timezoneOffset',
    dialCode: 'dialCode',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type CountryScalarFieldEnum = (typeof CountryScalarFieldEnum)[keyof typeof CountryScalarFieldEnum]


  export const StateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    countryId: 'countryId',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type StateScalarFieldEnum = (typeof StateScalarFieldEnum)[keyof typeof StateScalarFieldEnum]


  export const AddressScalarFieldEnum: {
    id: 'id',
    doorNumber: 'doorNumber',
    streetName: 'streetName',
    pinCode: 'pinCode',
    stateId: 'stateId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type AddressScalarFieldEnum = (typeof AddressScalarFieldEnum)[keyof typeof AddressScalarFieldEnum]


  export const UserAddressScalarFieldEnum: {
    id: 'id',
    addressId: 'addressId',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type UserAddressScalarFieldEnum = (typeof UserAddressScalarFieldEnum)[keyof typeof UserAddressScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    email: 'email',
    mobile: 'mobile',
    token: 'token',
    roleId: 'roleId',
    genderId: 'genderId',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ProductOwnerScalarFieldEnum: {
    id: 'id',
    syncUserId: 'syncUserId',
    ownerName: 'ownerName',
    ownerEmail: 'ownerEmail',
    ownerMobile: 'ownerMobile',
    storeName: 'storeName',
    storeAddress: 'storeAddress',
    storeCity: 'storeCity',
    storePincode: 'storePincode',
    storeState: 'storeState',
    customerCareEmail: 'customerCareEmail',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type ProductOwnerScalarFieldEnum = (typeof ProductOwnerScalarFieldEnum)[keyof typeof ProductOwnerScalarFieldEnum]


  export const UserPasswordScalarFieldEnum: {
    id: 'id',
    password: 'password',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type UserPasswordScalarFieldEnum = (typeof UserPasswordScalarFieldEnum)[keyof typeof UserPasswordScalarFieldEnum]


  export const SearchItemsScalarFieldEnum: {
    id: 'id',
    searchName: 'searchName',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type SearchItemsScalarFieldEnum = (typeof SearchItemsScalarFieldEnum)[keyof typeof SearchItemsScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    productId: 'productId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const UserLoginRequestScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    email: 'email',
    mobile: 'mobile',
    otp: 'otp',
    isUsed: 'isUsed',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type UserLoginRequestScalarFieldEnum = (typeof UserLoginRequestScalarFieldEnum)[keyof typeof UserLoginRequestScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    syncId: 'syncId',
    title: 'title',
    price: 'price',
    productTypeId: 'productTypeId',
    productOwnerId: 'productOwnerId',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt',
    isActive: 'isActive'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const ProductReviewScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    userId: 'userId',
    review: 'review',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type ProductReviewScalarFieldEnum = (typeof ProductReviewScalarFieldEnum)[keyof typeof ProductReviewScalarFieldEnum]


  export const ReturnedProductScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    returns: 'returns',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type ReturnedProductScalarFieldEnum = (typeof ReturnedProductScalarFieldEnum)[keyof typeof ReturnedProductScalarFieldEnum]


  export const DeleveryPeriodScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    deliveryForMetroCitys: 'deliveryForMetroCitys',
    deliveryForOtherCitys: 'deliveryForOtherCitys',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type DeleveryPeriodScalarFieldEnum = (typeof DeleveryPeriodScalarFieldEnum)[keyof typeof DeleveryPeriodScalarFieldEnum]


  export const ProductColorScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    colors: 'colors',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type ProductColorScalarFieldEnum = (typeof ProductColorScalarFieldEnum)[keyof typeof ProductColorScalarFieldEnum]


  export const PriceHistoryScalarFieldEnum: {
    id: 'id',
    price: 'price',
    productId: 'productId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type PriceHistoryScalarFieldEnum = (typeof PriceHistoryScalarFieldEnum)[keyof typeof PriceHistoryScalarFieldEnum]


  export const ProductAviableSizesScalarFieldEnum: {
    id: 'id',
    quantity: 'quantity',
    productColorId: 'productColorId',
    productTypeSizeId: 'productTypeSizeId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type ProductAviableSizesScalarFieldEnum = (typeof ProductAviableSizesScalarFieldEnum)[keyof typeof ProductAviableSizesScalarFieldEnum]


  export const SeasonalDressesScalarFieldEnum: {
    id: 'id',
    seasonal: 'seasonal',
    productId: 'productId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type SeasonalDressesScalarFieldEnum = (typeof SeasonalDressesScalarFieldEnum)[keyof typeof SeasonalDressesScalarFieldEnum]


  export const ProductImagesScalarFieldEnum: {
    id: 'id',
    imageUrl: 'imageUrl',
    productColorId: 'productColorId',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type ProductImagesScalarFieldEnum = (typeof ProductImagesScalarFieldEnum)[keyof typeof ProductImagesScalarFieldEnum]


  export const CommonDescriptionScalarFieldEnum: {
    id: 'id',
    fit: 'fit',
    materail: 'materail',
    care: 'care',
    brandName: 'brandName',
    origin: 'origin',
    productId: 'productId',
    occasion: 'occasion',
    specialFeature: 'specialFeature',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type CommonDescriptionScalarFieldEnum = (typeof CommonDescriptionScalarFieldEnum)[keyof typeof CommonDescriptionScalarFieldEnum]


  export const TopDescriptionScalarFieldEnum: {
    id: 'id',
    productDescription: 'productDescription',
    sleeveTypeId: 'sleeveTypeId',
    weight: 'weight',
    chest: 'chest',
    shoulder: 'shoulder',
    neckTypeId: 'neckTypeId',
    type: 'type',
    colorFamily: 'colorFamily',
    printAndPattern: 'printAndPattern',
    length: 'length',
    pocket: 'pocket',
    commonDescriptionId: 'commonDescriptionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type TopDescriptionScalarFieldEnum = (typeof TopDescriptionScalarFieldEnum)[keyof typeof TopDescriptionScalarFieldEnum]


  export const BottomDescriptionScalarFieldEnum: {
    id: 'id',
    productDescription: 'productDescription',
    weight: 'weight',
    printAndPattern: 'printAndPattern',
    length: 'length',
    waist: 'waist',
    hip: 'hip',
    commonDescriptionId: 'commonDescriptionId',
    type: 'type',
    colorFamily: 'colorFamily',
    pocket: 'pocket',
    kurtasDescriptionId: 'kurtasDescriptionId',
    topDescriptionId: 'topDescriptionId',
    beltLoop: 'beltLoop',
    typeOfPantId: 'typeOfPantId',
    typesOfPleatsId: 'typesOfPleatsId',
    typesOfLengthId: 'typesOfLengthId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type BottomDescriptionScalarFieldEnum = (typeof BottomDescriptionScalarFieldEnum)[keyof typeof BottomDescriptionScalarFieldEnum]


  export const KurtasDescriptionScalarFieldEnum: {
    id: 'id',
    work: 'work',
    productDescription: 'productDescription',
    chest: 'chest',
    shoulder: 'shoulder',
    transparencyOfTheFabric: 'transparencyOfTheFabric',
    kurtasLengthTypeId: 'kurtasLengthTypeId',
    weight: 'weight',
    colorFamily: 'colorFamily',
    pocket: 'pocket',
    type: 'type',
    printAndpattern: 'printAndpattern',
    kurtasNeckTypeId: 'kurtasNeckTypeId',
    kurtasSleeveTypeId: 'kurtasSleeveTypeId',
    commonDescriptionId: 'commonDescriptionId',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type KurtasDescriptionScalarFieldEnum = (typeof KurtasDescriptionScalarFieldEnum)[keyof typeof KurtasDescriptionScalarFieldEnum]


  export const ShoesDescriptionScalarFieldEnum: {
    id: 'id',
    pattern: 'pattern',
    footLength: 'footLength',
    type: 'type',
    soleMaterial: 'soleMaterial',
    printAndPattern: 'printAndPattern',
    upperMaterial: 'upperMaterial',
    closure: 'closure',
    toeType: 'toeType',
    weight: 'weight',
    colorFamily: 'colorFamily',
    productDescription: 'productDescription',
    packageContains: 'packageContains',
    commonDescriptionId: 'commonDescriptionId',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type ShoesDescriptionScalarFieldEnum = (typeof ShoesDescriptionScalarFieldEnum)[keyof typeof ShoesDescriptionScalarFieldEnum]


  export const WatchesDescriptionScalarFieldEnum: {
    id: 'id',
    type: 'type',
    weight: 'weight',
    model: 'model',
    dialShape: 'dialShape',
    printAndPattern: 'printAndPattern',
    dialDiameter: 'dialDiameter',
    dialColor: 'dialColor',
    strapColor: 'strapColor',
    colorFamily: 'colorFamily',
    productDescription: 'productDescription',
    commonDescriptionId: 'commonDescriptionId',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type WatchesDescriptionScalarFieldEnum = (typeof WatchesDescriptionScalarFieldEnum)[keyof typeof WatchesDescriptionScalarFieldEnum]


  export const PerfumesDescriptionScalarFieldEnum: {
    id: 'id',
    productDescription: 'productDescription',
    type: 'type',
    materialDescription: 'materialDescription',
    weight: 'weight',
    commonDescriptionId: 'commonDescriptionId',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type PerfumesDescriptionScalarFieldEnum = (typeof PerfumesDescriptionScalarFieldEnum)[keyof typeof PerfumesDescriptionScalarFieldEnum]


  export const InnersDescriptionScalarFieldEnum: {
    id: 'id',
    type: 'type',
    productDescription: 'productDescription',
    weight: 'weight',
    length: 'length',
    waistRise: 'waistRise',
    printAndPattern: 'printAndPattern',
    packageContains: 'packageContains',
    lookAndFeel: 'lookAndFeel',
    colorFamily: 'colorFamily',
    vestsSleeveTypeId: 'vestsSleeveTypeId',
    vestsNeckTypeId: 'vestsNeckTypeId',
    commonDescriptionId: 'commonDescriptionId',
    multiColors: 'multiColors'
  };

  export type InnersDescriptionScalarFieldEnum = (typeof InnersDescriptionScalarFieldEnum)[keyof typeof InnersDescriptionScalarFieldEnum]


  export const WarrantyScalarFieldEnum: {
    id: 'id',
    shoesDescriptionId: 'shoesDescriptionId',
    watchsId: 'watchsId',
    warrantyPeriod: 'warrantyPeriod',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type WarrantyScalarFieldEnum = (typeof WarrantyScalarFieldEnum)[keyof typeof WarrantyScalarFieldEnum]


  export const SleeveTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type SleeveTypeScalarFieldEnum = (typeof SleeveTypeScalarFieldEnum)[keyof typeof SleeveTypeScalarFieldEnum]


  export const NeckTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type NeckTypeScalarFieldEnum = (typeof NeckTypeScalarFieldEnum)[keyof typeof NeckTypeScalarFieldEnum]


  export const KurtasLengthTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type KurtasLengthTypeScalarFieldEnum = (typeof KurtasLengthTypeScalarFieldEnum)[keyof typeof KurtasLengthTypeScalarFieldEnum]


  export const TypesOfBottomScalarFieldEnum: {
    id: 'id',
    name: 'name',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type TypesOfBottomScalarFieldEnum = (typeof TypesOfBottomScalarFieldEnum)[keyof typeof TypesOfBottomScalarFieldEnum]


  export const TypesOfPleatsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type TypesOfPleatsScalarFieldEnum = (typeof TypesOfPleatsScalarFieldEnum)[keyof typeof TypesOfPleatsScalarFieldEnum]


  export const TypesOfLengthBottomScalarFieldEnum: {
    id: 'id',
    name: 'name',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type TypesOfLengthBottomScalarFieldEnum = (typeof TypesOfLengthBottomScalarFieldEnum)[keyof typeof TypesOfLengthBottomScalarFieldEnum]


  export const QuantityHistoryScalarFieldEnum: {
    id: 'id',
    quantity: 'quantity',
    productAviableSizesId: 'productAviableSizesId',
    timestamp: 'timestamp',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type QuantityHistoryScalarFieldEnum = (typeof QuantityHistoryScalarFieldEnum)[keyof typeof QuantityHistoryScalarFieldEnum]


  export const OfferScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    offerPercntage: 'offerPercntage',
    offerPrice: 'offerPrice',
    currentPrice: 'currentPrice',
    offerQuantity: 'offerQuantity',
    currentQuantity: 'currentQuantity',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type OfferScalarFieldEnum = (typeof OfferScalarFieldEnum)[keyof typeof OfferScalarFieldEnum]


  export const OfferValidityScalarFieldEnum: {
    id: 'id',
    fromDate: 'fromDate',
    toDate: 'toDate',
    fromTime: 'fromTime',
    toTime: 'toTime',
    monday: 'monday',
    tuesday: 'tuesday',
    wednesday: 'wednesday',
    thursday: 'thursday',
    friday: 'friday',
    saturday: 'saturday',
    sunday: 'sunday',
    offerId: 'offerId',
    offerPromotionPeriodId: 'offerPromotionPeriodId',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type OfferValidityScalarFieldEnum = (typeof OfferValidityScalarFieldEnum)[keyof typeof OfferValidityScalarFieldEnum]


  export const OfferPromotionPeriodsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type OfferPromotionPeriodsScalarFieldEnum = (typeof OfferPromotionPeriodsScalarFieldEnum)[keyof typeof OfferPromotionPeriodsScalarFieldEnum]


  export const CartScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    productId: 'productId',
    isCheckedOut: 'isCheckedOut',
    isRemoved: 'isRemoved',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type CartScalarFieldEnum = (typeof CartScalarFieldEnum)[keyof typeof CartScalarFieldEnum]


  export const WishlistScalarFieldEnum: {
    id: 'id',
    userId: 'userId'
  };

  export type WishlistScalarFieldEnum = (typeof WishlistScalarFieldEnum)[keyof typeof WishlistScalarFieldEnum]


  export const WishlistItemScalarFieldEnum: {
    id: 'id',
    wishlistId: 'wishlistId',
    productId: 'productId'
  };

  export type WishlistItemScalarFieldEnum = (typeof WishlistItemScalarFieldEnum)[keyof typeof WishlistItemScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Deep Input Types
   */


  export type RolesWhereInput = {
    AND?: Enumerable<RolesWhereInput>
    OR?: Enumerable<RolesWhereInput>
    NOT?: Enumerable<RolesWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    isActive?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    user?: UserListRelationFilter
  }

  export type RolesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    user?: UserOrderByRelationAggregateInput
  }

  export type RolesWhereUniqueInput = {
    id?: number
  }

  export type RolesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: RolesCountOrderByAggregateInput
    _avg?: RolesAvgOrderByAggregateInput
    _max?: RolesMaxOrderByAggregateInput
    _min?: RolesMinOrderByAggregateInput
    _sum?: RolesSumOrderByAggregateInput
  }

  export type RolesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RolesScalarWhereWithAggregatesInput>
    OR?: Enumerable<RolesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RolesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    isActive?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type SyncDataLastIdWhereInput = {
    AND?: Enumerable<SyncDataLastIdWhereInput>
    OR?: Enumerable<SyncDataLastIdWhereInput>
    NOT?: Enumerable<SyncDataLastIdWhereInput>
    id?: IntFilter | number
    lastId?: IntFilter | number
    isActive?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type SyncDataLastIdOrderByWithRelationInput = {
    id?: SortOrder
    lastId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
  }

  export type SyncDataLastIdWhereUniqueInput = {
    id?: number
  }

  export type SyncDataLastIdOrderByWithAggregationInput = {
    id?: SortOrder
    lastId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: SyncDataLastIdCountOrderByAggregateInput
    _avg?: SyncDataLastIdAvgOrderByAggregateInput
    _max?: SyncDataLastIdMaxOrderByAggregateInput
    _min?: SyncDataLastIdMinOrderByAggregateInput
    _sum?: SyncDataLastIdSumOrderByAggregateInput
  }

  export type SyncDataLastIdScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SyncDataLastIdScalarWhereWithAggregatesInput>
    OR?: Enumerable<SyncDataLastIdScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SyncDataLastIdScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    lastId?: IntWithAggregatesFilter | number
    isActive?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type ProductCategoryWhereInput = {
    AND?: Enumerable<ProductCategoryWhereInput>
    OR?: Enumerable<ProductCategoryWhereInput>
    NOT?: Enumerable<ProductCategoryWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    genderId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    gender?: XOR<GenderRelationFilter, GenderWhereInput>
    productType?: ProductTypeListRelationFilter
  }

  export type ProductCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    genderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    gender?: GenderOrderByWithRelationInput
    productType?: ProductTypeOrderByRelationAggregateInput
  }

  export type ProductCategoryWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type ProductCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    genderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ProductCategoryCountOrderByAggregateInput
    _avg?: ProductCategoryAvgOrderByAggregateInput
    _max?: ProductCategoryMaxOrderByAggregateInput
    _min?: ProductCategoryMinOrderByAggregateInput
    _sum?: ProductCategorySumOrderByAggregateInput
  }

  export type ProductCategoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductCategoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductCategoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductCategoryScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    genderId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type ProductTypeWhereInput = {
    AND?: Enumerable<ProductTypeWhereInput>
    OR?: Enumerable<ProductTypeWhereInput>
    NOT?: Enumerable<ProductTypeWhereInput>
    id?: IntFilter | number
    itemsName?: StringFilter | string
    productCategoryId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    ProductCategory?: XOR<ProductCategoryRelationFilter, ProductCategoryWhereInput>
    sizes?: ProductTypeSizeListRelationFilter
    product?: ProductListRelationFilter
  }

  export type ProductTypeOrderByWithRelationInput = {
    id?: SortOrder
    itemsName?: SortOrder
    productCategoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    ProductCategory?: ProductCategoryOrderByWithRelationInput
    sizes?: ProductTypeSizeOrderByRelationAggregateInput
    product?: ProductOrderByRelationAggregateInput
  }

  export type ProductTypeWhereUniqueInput = {
    id?: number
  }

  export type ProductTypeOrderByWithAggregationInput = {
    id?: SortOrder
    itemsName?: SortOrder
    productCategoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ProductTypeCountOrderByAggregateInput
    _avg?: ProductTypeAvgOrderByAggregateInput
    _max?: ProductTypeMaxOrderByAggregateInput
    _min?: ProductTypeMinOrderByAggregateInput
    _sum?: ProductTypeSumOrderByAggregateInput
  }

  export type ProductTypeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductTypeScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductTypeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductTypeScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    itemsName?: StringWithAggregatesFilter | string
    productCategoryId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type ProductTypeSizeWhereInput = {
    AND?: Enumerable<ProductTypeSizeWhereInput>
    OR?: Enumerable<ProductTypeSizeWhereInput>
    NOT?: Enumerable<ProductTypeSizeWhereInput>
    id?: IntFilter | number
    size?: StringFilter | string
    ietmsId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    aviableSizes?: ProductAviableSizesListRelationFilter
    productType?: XOR<ProductTypeRelationFilter, ProductTypeWhereInput>
  }

  export type ProductTypeSizeOrderByWithRelationInput = {
    id?: SortOrder
    size?: SortOrder
    ietmsId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    aviableSizes?: ProductAviableSizesOrderByRelationAggregateInput
    productType?: ProductTypeOrderByWithRelationInput
  }

  export type ProductTypeSizeWhereUniqueInput = {
    id?: number
  }

  export type ProductTypeSizeOrderByWithAggregationInput = {
    id?: SortOrder
    size?: SortOrder
    ietmsId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ProductTypeSizeCountOrderByAggregateInput
    _avg?: ProductTypeSizeAvgOrderByAggregateInput
    _max?: ProductTypeSizeMaxOrderByAggregateInput
    _min?: ProductTypeSizeMinOrderByAggregateInput
    _sum?: ProductTypeSizeSumOrderByAggregateInput
  }

  export type ProductTypeSizeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductTypeSizeScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductTypeSizeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductTypeSizeScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    size?: StringWithAggregatesFilter | string
    ietmsId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type GenderWhereInput = {
    AND?: Enumerable<GenderWhereInput>
    OR?: Enumerable<GenderWhereInput>
    NOT?: Enumerable<GenderWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    productCategory?: ProductCategoryListRelationFilter
    user?: UserListRelationFilter
  }

  export type GenderOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    productCategory?: ProductCategoryOrderByRelationAggregateInput
    user?: UserOrderByRelationAggregateInput
  }

  export type GenderWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type GenderOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: GenderCountOrderByAggregateInput
    _avg?: GenderAvgOrderByAggregateInput
    _max?: GenderMaxOrderByAggregateInput
    _min?: GenderMinOrderByAggregateInput
    _sum?: GenderSumOrderByAggregateInput
  }

  export type GenderScalarWhereWithAggregatesInput = {
    AND?: Enumerable<GenderScalarWhereWithAggregatesInput>
    OR?: Enumerable<GenderScalarWhereWithAggregatesInput>
    NOT?: Enumerable<GenderScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type CountryWhereInput = {
    AND?: Enumerable<CountryWhereInput>
    OR?: Enumerable<CountryWhereInput>
    NOT?: Enumerable<CountryWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    timezoneOffset?: IntFilter | number
    dialCode?: StringFilter | string
    isActive?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    state?: StateListRelationFilter
  }

  export type CountryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    timezoneOffset?: SortOrder
    dialCode?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    state?: StateOrderByRelationAggregateInput
  }

  export type CountryWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type CountryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    timezoneOffset?: SortOrder
    dialCode?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: CountryCountOrderByAggregateInput
    _avg?: CountryAvgOrderByAggregateInput
    _max?: CountryMaxOrderByAggregateInput
    _min?: CountryMinOrderByAggregateInput
    _sum?: CountrySumOrderByAggregateInput
  }

  export type CountryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CountryScalarWhereWithAggregatesInput>
    OR?: Enumerable<CountryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CountryScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    timezoneOffset?: IntWithAggregatesFilter | number
    dialCode?: StringWithAggregatesFilter | string
    isActive?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type StateWhereInput = {
    AND?: Enumerable<StateWhereInput>
    OR?: Enumerable<StateWhereInput>
    NOT?: Enumerable<StateWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    countryId?: IntFilter | number
    isActive?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    country?: XOR<CountryRelationFilter, CountryWhereInput>
    district?: AddressListRelationFilter
  }

  export type StateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    countryId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    country?: CountryOrderByWithRelationInput
    district?: AddressOrderByRelationAggregateInput
  }

  export type StateWhereUniqueInput = {
    id?: number
  }

  export type StateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    countryId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: StateCountOrderByAggregateInput
    _avg?: StateAvgOrderByAggregateInput
    _max?: StateMaxOrderByAggregateInput
    _min?: StateMinOrderByAggregateInput
    _sum?: StateSumOrderByAggregateInput
  }

  export type StateScalarWhereWithAggregatesInput = {
    AND?: Enumerable<StateScalarWhereWithAggregatesInput>
    OR?: Enumerable<StateScalarWhereWithAggregatesInput>
    NOT?: Enumerable<StateScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    countryId?: IntWithAggregatesFilter | number
    isActive?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type AddressWhereInput = {
    AND?: Enumerable<AddressWhereInput>
    OR?: Enumerable<AddressWhereInput>
    NOT?: Enumerable<AddressWhereInput>
    id?: IntFilter | number
    doorNumber?: StringFilter | string
    streetName?: StringFilter | string
    pinCode?: StringFilter | string
    stateId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    state?: XOR<StateRelationFilter, StateWhereInput>
    userAddress?: UserAddressListRelationFilter
  }

  export type AddressOrderByWithRelationInput = {
    id?: SortOrder
    doorNumber?: SortOrder
    streetName?: SortOrder
    pinCode?: SortOrder
    stateId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    state?: StateOrderByWithRelationInput
    userAddress?: UserAddressOrderByRelationAggregateInput
  }

  export type AddressWhereUniqueInput = {
    id?: number
  }

  export type AddressOrderByWithAggregationInput = {
    id?: SortOrder
    doorNumber?: SortOrder
    streetName?: SortOrder
    pinCode?: SortOrder
    stateId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: AddressCountOrderByAggregateInput
    _avg?: AddressAvgOrderByAggregateInput
    _max?: AddressMaxOrderByAggregateInput
    _min?: AddressMinOrderByAggregateInput
    _sum?: AddressSumOrderByAggregateInput
  }

  export type AddressScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AddressScalarWhereWithAggregatesInput>
    OR?: Enumerable<AddressScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AddressScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    doorNumber?: StringWithAggregatesFilter | string
    streetName?: StringWithAggregatesFilter | string
    pinCode?: StringWithAggregatesFilter | string
    stateId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type UserAddressWhereInput = {
    AND?: Enumerable<UserAddressWhereInput>
    OR?: Enumerable<UserAddressWhereInput>
    NOT?: Enumerable<UserAddressWhereInput>
    id?: IntFilter | number
    addressId?: IntFilter | number
    userId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    address?: XOR<AddressRelationFilter, AddressWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserAddressOrderByWithRelationInput = {
    id?: SortOrder
    addressId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    address?: AddressOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type UserAddressWhereUniqueInput = {
    id?: number
  }

  export type UserAddressOrderByWithAggregationInput = {
    id?: SortOrder
    addressId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: UserAddressCountOrderByAggregateInput
    _avg?: UserAddressAvgOrderByAggregateInput
    _max?: UserAddressMaxOrderByAggregateInput
    _min?: UserAddressMinOrderByAggregateInput
    _sum?: UserAddressSumOrderByAggregateInput
  }

  export type UserAddressScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserAddressScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserAddressScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserAddressScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    addressId?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: IntFilter | number
    username?: StringFilter | string
    email?: StringFilter | string
    mobile?: StringFilter | string
    token?: StringNullableFilter | string | null
    roleId?: IntFilter | number
    genderId?: IntFilter | number
    isActive?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    userProduct?: ProductListRelationFilter
    userAddress?: UserAddressListRelationFilter
    addCart?: CartListRelationFilter
    wishlist?: WishlistListRelationFilter
    loginRequests?: UserLoginRequestListRelationFilter
    ProductReview?: ProductReviewListRelationFilter
    order?: OrderListRelationFilter
    userSearchItems?: SearchItemsListRelationFilter
    password?: UserPasswordListRelationFilter
    roles?: XOR<RolesRelationFilter, RolesWhereInput>
    gender?: XOR<GenderRelationFilter, GenderWhereInput>
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    token?: SortOrderInput | SortOrder
    roleId?: SortOrder
    genderId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    userProduct?: ProductOrderByRelationAggregateInput
    userAddress?: UserAddressOrderByRelationAggregateInput
    addCart?: CartOrderByRelationAggregateInput
    wishlist?: WishlistOrderByRelationAggregateInput
    loginRequests?: UserLoginRequestOrderByRelationAggregateInput
    ProductReview?: ProductReviewOrderByRelationAggregateInput
    order?: OrderOrderByRelationAggregateInput
    userSearchItems?: SearchItemsOrderByRelationAggregateInput
    password?: UserPasswordOrderByRelationAggregateInput
    roles?: RolesOrderByWithRelationInput
    gender?: GenderOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = {
    id?: number
    email?: string
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    token?: SortOrderInput | SortOrder
    roleId?: SortOrder
    genderId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    username?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    mobile?: StringWithAggregatesFilter | string
    token?: StringNullableWithAggregatesFilter | string | null
    roleId?: IntWithAggregatesFilter | number
    genderId?: IntWithAggregatesFilter | number
    isActive?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type ProductOwnerWhereInput = {
    AND?: Enumerable<ProductOwnerWhereInput>
    OR?: Enumerable<ProductOwnerWhereInput>
    NOT?: Enumerable<ProductOwnerWhereInput>
    id?: IntFilter | number
    syncUserId?: IntFilter | number
    ownerName?: StringFilter | string
    ownerEmail?: StringFilter | string
    ownerMobile?: StringFilter | string
    storeName?: StringFilter | string
    storeAddress?: StringFilter | string
    storeCity?: StringFilter | string
    storePincode?: StringFilter | string
    storeState?: StringFilter | string
    customerCareEmail?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    product?: ProductListRelationFilter
  }

  export type ProductOwnerOrderByWithRelationInput = {
    id?: SortOrder
    syncUserId?: SortOrder
    ownerName?: SortOrder
    ownerEmail?: SortOrder
    ownerMobile?: SortOrder
    storeName?: SortOrder
    storeAddress?: SortOrder
    storeCity?: SortOrder
    storePincode?: SortOrder
    storeState?: SortOrder
    customerCareEmail?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    product?: ProductOrderByRelationAggregateInput
  }

  export type ProductOwnerWhereUniqueInput = {
    id?: number
  }

  export type ProductOwnerOrderByWithAggregationInput = {
    id?: SortOrder
    syncUserId?: SortOrder
    ownerName?: SortOrder
    ownerEmail?: SortOrder
    ownerMobile?: SortOrder
    storeName?: SortOrder
    storeAddress?: SortOrder
    storeCity?: SortOrder
    storePincode?: SortOrder
    storeState?: SortOrder
    customerCareEmail?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ProductOwnerCountOrderByAggregateInput
    _avg?: ProductOwnerAvgOrderByAggregateInput
    _max?: ProductOwnerMaxOrderByAggregateInput
    _min?: ProductOwnerMinOrderByAggregateInput
    _sum?: ProductOwnerSumOrderByAggregateInput
  }

  export type ProductOwnerScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductOwnerScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductOwnerScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductOwnerScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    syncUserId?: IntWithAggregatesFilter | number
    ownerName?: StringWithAggregatesFilter | string
    ownerEmail?: StringWithAggregatesFilter | string
    ownerMobile?: StringWithAggregatesFilter | string
    storeName?: StringWithAggregatesFilter | string
    storeAddress?: StringWithAggregatesFilter | string
    storeCity?: StringWithAggregatesFilter | string
    storePincode?: StringWithAggregatesFilter | string
    storeState?: StringWithAggregatesFilter | string
    customerCareEmail?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type UserPasswordWhereInput = {
    AND?: Enumerable<UserPasswordWhereInput>
    OR?: Enumerable<UserPasswordWhereInput>
    NOT?: Enumerable<UserPasswordWhereInput>
    id?: IntFilter | number
    password?: StringFilter | string
    userId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserPasswordOrderByWithRelationInput = {
    id?: SortOrder
    password?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserPasswordWhereUniqueInput = {
    id?: number
  }

  export type UserPasswordOrderByWithAggregationInput = {
    id?: SortOrder
    password?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: UserPasswordCountOrderByAggregateInput
    _avg?: UserPasswordAvgOrderByAggregateInput
    _max?: UserPasswordMaxOrderByAggregateInput
    _min?: UserPasswordMinOrderByAggregateInput
    _sum?: UserPasswordSumOrderByAggregateInput
  }

  export type UserPasswordScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserPasswordScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserPasswordScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserPasswordScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    password?: StringWithAggregatesFilter | string
    userId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type SearchItemsWhereInput = {
    AND?: Enumerable<SearchItemsWhereInput>
    OR?: Enumerable<SearchItemsWhereInput>
    NOT?: Enumerable<SearchItemsWhereInput>
    id?: IntFilter | number
    searchName?: StringFilter | string
    userId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    User?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SearchItemsOrderByWithRelationInput = {
    id?: SortOrder
    searchName?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    User?: UserOrderByWithRelationInput
  }

  export type SearchItemsWhereUniqueInput = {
    id?: number
  }

  export type SearchItemsOrderByWithAggregationInput = {
    id?: SortOrder
    searchName?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: SearchItemsCountOrderByAggregateInput
    _avg?: SearchItemsAvgOrderByAggregateInput
    _max?: SearchItemsMaxOrderByAggregateInput
    _min?: SearchItemsMinOrderByAggregateInput
    _sum?: SearchItemsSumOrderByAggregateInput
  }

  export type SearchItemsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SearchItemsScalarWhereWithAggregatesInput>
    OR?: Enumerable<SearchItemsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SearchItemsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    searchName?: StringWithAggregatesFilter | string
    userId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type OrderWhereInput = {
    AND?: Enumerable<OrderWhereInput>
    OR?: Enumerable<OrderWhereInput>
    NOT?: Enumerable<OrderWhereInput>
    id?: IntFilter | number
    userId?: IntFilter | number
    productId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type OrderWhereUniqueInput = {
    id?: number
  }

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OrderScalarWhereWithAggregatesInput>
    OR?: Enumerable<OrderScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OrderScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
    productId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type UserLoginRequestWhereInput = {
    AND?: Enumerable<UserLoginRequestWhereInput>
    OR?: Enumerable<UserLoginRequestWhereInput>
    NOT?: Enumerable<UserLoginRequestWhereInput>
    id?: IntFilter | number
    userId?: IntFilter | number
    email?: StringFilter | string
    mobile?: StringNullableFilter | string | null
    otp?: StringFilter | string
    isUsed?: BoolFilter | boolean
    isActive?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserLoginRequestOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    mobile?: SortOrderInput | SortOrder
    otp?: SortOrder
    isUsed?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserLoginRequestWhereUniqueInput = {
    id?: number
  }

  export type UserLoginRequestOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    mobile?: SortOrderInput | SortOrder
    otp?: SortOrder
    isUsed?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: UserLoginRequestCountOrderByAggregateInput
    _avg?: UserLoginRequestAvgOrderByAggregateInput
    _max?: UserLoginRequestMaxOrderByAggregateInput
    _min?: UserLoginRequestMinOrderByAggregateInput
    _sum?: UserLoginRequestSumOrderByAggregateInput
  }

  export type UserLoginRequestScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserLoginRequestScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserLoginRequestScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserLoginRequestScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
    email?: StringWithAggregatesFilter | string
    mobile?: StringNullableWithAggregatesFilter | string | null
    otp?: StringWithAggregatesFilter | string
    isUsed?: BoolWithAggregatesFilter | boolean
    isActive?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type ProductWhereInput = {
    AND?: Enumerable<ProductWhereInput>
    OR?: Enumerable<ProductWhereInput>
    NOT?: Enumerable<ProductWhereInput>
    id?: IntFilter | number
    syncId?: IntFilter | number
    title?: StringFilter | string
    price?: FloatFilter | number
    productTypeId?: IntFilter | number
    productOwnerId?: IntNullableFilter | number | null
    userId?: IntNullableFilter | number | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    isActive?: BoolFilter | boolean
    color?: ProductColorListRelationFilter
    offer?: OfferListRelationFilter
    seasonalDresses?: SeasonalDressesListRelationFilter
    productType?: XOR<ProductTypeRelationFilter, ProductTypeWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput> | null
    priceHistory?: PriceHistoryListRelationFilter
    commonDescription?: CommonDescriptionListRelationFilter
    delivery?: DeleveryPeriodListRelationFilter
    returns?: ReturnedProductListRelationFilter
    cart?: CartListRelationFilter
    wishlistItem?: WishlistItemListRelationFilter
    productReviews?: ProductReviewListRelationFilter
    order?: OrderListRelationFilter
    productOwner?: XOR<ProductOwnerRelationFilter, ProductOwnerWhereInput> | null
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    syncId?: SortOrder
    title?: SortOrder
    price?: SortOrder
    productTypeId?: SortOrder
    productOwnerId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    color?: ProductColorOrderByRelationAggregateInput
    offer?: OfferOrderByRelationAggregateInput
    seasonalDresses?: SeasonalDressesOrderByRelationAggregateInput
    productType?: ProductTypeOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    priceHistory?: PriceHistoryOrderByRelationAggregateInput
    commonDescription?: CommonDescriptionOrderByRelationAggregateInput
    delivery?: DeleveryPeriodOrderByRelationAggregateInput
    returns?: ReturnedProductOrderByRelationAggregateInput
    cart?: CartOrderByRelationAggregateInput
    wishlistItem?: WishlistItemOrderByRelationAggregateInput
    productReviews?: ProductReviewOrderByRelationAggregateInput
    order?: OrderOrderByRelationAggregateInput
    productOwner?: ProductOwnerOrderByWithRelationInput
  }

  export type ProductWhereUniqueInput = {
    id?: number
  }

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    syncId?: SortOrder
    title?: SortOrder
    price?: SortOrder
    productTypeId?: SortOrder
    productOwnerId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    syncId?: IntWithAggregatesFilter | number
    title?: StringWithAggregatesFilter | string
    price?: FloatWithAggregatesFilter | number
    productTypeId?: IntWithAggregatesFilter | number
    productOwnerId?: IntNullableWithAggregatesFilter | number | null
    userId?: IntNullableWithAggregatesFilter | number | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    isActive?: BoolWithAggregatesFilter | boolean
  }

  export type ProductReviewWhereInput = {
    AND?: Enumerable<ProductReviewWhereInput>
    OR?: Enumerable<ProductReviewWhereInput>
    NOT?: Enumerable<ProductReviewWhereInput>
    id?: IntFilter | number
    productId?: IntFilter | number
    userId?: IntFilter | number
    review?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ProductReviewOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    userId?: SortOrder
    review?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    product?: ProductOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ProductReviewWhereUniqueInput = {
    id?: number
  }

  export type ProductReviewOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    userId?: SortOrder
    review?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ProductReviewCountOrderByAggregateInput
    _avg?: ProductReviewAvgOrderByAggregateInput
    _max?: ProductReviewMaxOrderByAggregateInput
    _min?: ProductReviewMinOrderByAggregateInput
    _sum?: ProductReviewSumOrderByAggregateInput
  }

  export type ProductReviewScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductReviewScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductReviewScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductReviewScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    productId?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
    review?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type ReturnedProductWhereInput = {
    AND?: Enumerable<ReturnedProductWhereInput>
    OR?: Enumerable<ReturnedProductWhereInput>
    NOT?: Enumerable<ReturnedProductWhereInput>
    id?: IntFilter | number
    productId?: IntFilter | number
    returns?: IntFilter | number
    isActive?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }

  export type ReturnedProductOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    returns?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    product?: ProductOrderByWithRelationInput
  }

  export type ReturnedProductWhereUniqueInput = {
    id?: number
  }

  export type ReturnedProductOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    returns?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ReturnedProductCountOrderByAggregateInput
    _avg?: ReturnedProductAvgOrderByAggregateInput
    _max?: ReturnedProductMaxOrderByAggregateInput
    _min?: ReturnedProductMinOrderByAggregateInput
    _sum?: ReturnedProductSumOrderByAggregateInput
  }

  export type ReturnedProductScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ReturnedProductScalarWhereWithAggregatesInput>
    OR?: Enumerable<ReturnedProductScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ReturnedProductScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    productId?: IntWithAggregatesFilter | number
    returns?: IntWithAggregatesFilter | number
    isActive?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type DeleveryPeriodWhereInput = {
    AND?: Enumerable<DeleveryPeriodWhereInput>
    OR?: Enumerable<DeleveryPeriodWhereInput>
    NOT?: Enumerable<DeleveryPeriodWhereInput>
    id?: IntFilter | number
    productId?: IntFilter | number
    deliveryForMetroCitys?: IntFilter | number
    deliveryForOtherCitys?: IntFilter | number
    isActive?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }

  export type DeleveryPeriodOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    deliveryForMetroCitys?: SortOrder
    deliveryForOtherCitys?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    product?: ProductOrderByWithRelationInput
  }

  export type DeleveryPeriodWhereUniqueInput = {
    id?: number
  }

  export type DeleveryPeriodOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    deliveryForMetroCitys?: SortOrder
    deliveryForOtherCitys?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: DeleveryPeriodCountOrderByAggregateInput
    _avg?: DeleveryPeriodAvgOrderByAggregateInput
    _max?: DeleveryPeriodMaxOrderByAggregateInput
    _min?: DeleveryPeriodMinOrderByAggregateInput
    _sum?: DeleveryPeriodSumOrderByAggregateInput
  }

  export type DeleveryPeriodScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DeleveryPeriodScalarWhereWithAggregatesInput>
    OR?: Enumerable<DeleveryPeriodScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DeleveryPeriodScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    productId?: IntWithAggregatesFilter | number
    deliveryForMetroCitys?: IntWithAggregatesFilter | number
    deliveryForOtherCitys?: IntWithAggregatesFilter | number
    isActive?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type ProductColorWhereInput = {
    AND?: Enumerable<ProductColorWhereInput>
    OR?: Enumerable<ProductColorWhereInput>
    NOT?: Enumerable<ProductColorWhereInput>
    id?: IntFilter | number
    productId?: IntFilter | number
    colors?: StringFilter | string
    isActive?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    colorSize?: ProductAviableSizesListRelationFilter
    productImages?: ProductImagesListRelationFilter
  }

  export type ProductColorOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    colors?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    product?: ProductOrderByWithRelationInput
    colorSize?: ProductAviableSizesOrderByRelationAggregateInput
    productImages?: ProductImagesOrderByRelationAggregateInput
  }

  export type ProductColorWhereUniqueInput = {
    id?: number
  }

  export type ProductColorOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    colors?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ProductColorCountOrderByAggregateInput
    _avg?: ProductColorAvgOrderByAggregateInput
    _max?: ProductColorMaxOrderByAggregateInput
    _min?: ProductColorMinOrderByAggregateInput
    _sum?: ProductColorSumOrderByAggregateInput
  }

  export type ProductColorScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductColorScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductColorScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductColorScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    productId?: IntWithAggregatesFilter | number
    colors?: StringWithAggregatesFilter | string
    isActive?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type PriceHistoryWhereInput = {
    AND?: Enumerable<PriceHistoryWhereInput>
    OR?: Enumerable<PriceHistoryWhereInput>
    NOT?: Enumerable<PriceHistoryWhereInput>
    id?: IntFilter | number
    price?: IntFilter | number
    productId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    Product?: XOR<ProductRelationFilter, ProductWhereInput>
  }

  export type PriceHistoryOrderByWithRelationInput = {
    id?: SortOrder
    price?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    Product?: ProductOrderByWithRelationInput
  }

  export type PriceHistoryWhereUniqueInput = {
    id?: number
  }

  export type PriceHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    price?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: PriceHistoryCountOrderByAggregateInput
    _avg?: PriceHistoryAvgOrderByAggregateInput
    _max?: PriceHistoryMaxOrderByAggregateInput
    _min?: PriceHistoryMinOrderByAggregateInput
    _sum?: PriceHistorySumOrderByAggregateInput
  }

  export type PriceHistoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PriceHistoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<PriceHistoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PriceHistoryScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    price?: IntWithAggregatesFilter | number
    productId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type ProductAviableSizesWhereInput = {
    AND?: Enumerable<ProductAviableSizesWhereInput>
    OR?: Enumerable<ProductAviableSizesWhereInput>
    NOT?: Enumerable<ProductAviableSizesWhereInput>
    id?: IntFilter | number
    quantity?: IntFilter | number
    productColorId?: IntFilter | number
    productTypeSizeId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    history?: QuantityHistoryListRelationFilter
    productColor?: XOR<ProductColorRelationFilter, ProductColorWhereInput>
    productTypeSize?: XOR<ProductTypeSizeRelationFilter, ProductTypeSizeWhereInput>
  }

  export type ProductAviableSizesOrderByWithRelationInput = {
    id?: SortOrder
    quantity?: SortOrder
    productColorId?: SortOrder
    productTypeSizeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    history?: QuantityHistoryOrderByRelationAggregateInput
    productColor?: ProductColorOrderByWithRelationInput
    productTypeSize?: ProductTypeSizeOrderByWithRelationInput
  }

  export type ProductAviableSizesWhereUniqueInput = {
    id?: number
  }

  export type ProductAviableSizesOrderByWithAggregationInput = {
    id?: SortOrder
    quantity?: SortOrder
    productColorId?: SortOrder
    productTypeSizeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ProductAviableSizesCountOrderByAggregateInput
    _avg?: ProductAviableSizesAvgOrderByAggregateInput
    _max?: ProductAviableSizesMaxOrderByAggregateInput
    _min?: ProductAviableSizesMinOrderByAggregateInput
    _sum?: ProductAviableSizesSumOrderByAggregateInput
  }

  export type ProductAviableSizesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductAviableSizesScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductAviableSizesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductAviableSizesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    quantity?: IntWithAggregatesFilter | number
    productColorId?: IntWithAggregatesFilter | number
    productTypeSizeId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type SeasonalDressesWhereInput = {
    AND?: Enumerable<SeasonalDressesWhereInput>
    OR?: Enumerable<SeasonalDressesWhereInput>
    NOT?: Enumerable<SeasonalDressesWhereInput>
    id?: IntFilter | number
    seasonal?: StringFilter | string
    productId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }

  export type SeasonalDressesOrderByWithRelationInput = {
    id?: SortOrder
    seasonal?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    product?: ProductOrderByWithRelationInput
  }

  export type SeasonalDressesWhereUniqueInput = {
    id?: number
  }

  export type SeasonalDressesOrderByWithAggregationInput = {
    id?: SortOrder
    seasonal?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: SeasonalDressesCountOrderByAggregateInput
    _avg?: SeasonalDressesAvgOrderByAggregateInput
    _max?: SeasonalDressesMaxOrderByAggregateInput
    _min?: SeasonalDressesMinOrderByAggregateInput
    _sum?: SeasonalDressesSumOrderByAggregateInput
  }

  export type SeasonalDressesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SeasonalDressesScalarWhereWithAggregatesInput>
    OR?: Enumerable<SeasonalDressesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SeasonalDressesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    seasonal?: StringWithAggregatesFilter | string
    productId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type ProductImagesWhereInput = {
    AND?: Enumerable<ProductImagesWhereInput>
    OR?: Enumerable<ProductImagesWhereInput>
    NOT?: Enumerable<ProductImagesWhereInput>
    id?: IntFilter | number
    imageUrl?: StringFilter | string
    productColorId?: IntFilter | number
    isActive?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    productColor?: XOR<ProductColorRelationFilter, ProductColorWhereInput> | null
  }

  export type ProductImagesOrderByWithRelationInput = {
    id?: SortOrder
    imageUrl?: SortOrder
    productColorId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    productColor?: ProductColorOrderByWithRelationInput
  }

  export type ProductImagesWhereUniqueInput = {
    id?: number
  }

  export type ProductImagesOrderByWithAggregationInput = {
    id?: SortOrder
    imageUrl?: SortOrder
    productColorId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ProductImagesCountOrderByAggregateInput
    _avg?: ProductImagesAvgOrderByAggregateInput
    _max?: ProductImagesMaxOrderByAggregateInput
    _min?: ProductImagesMinOrderByAggregateInput
    _sum?: ProductImagesSumOrderByAggregateInput
  }

  export type ProductImagesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductImagesScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductImagesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductImagesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    imageUrl?: StringWithAggregatesFilter | string
    productColorId?: IntWithAggregatesFilter | number
    isActive?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type CommonDescriptionWhereInput = {
    AND?: Enumerable<CommonDescriptionWhereInput>
    OR?: Enumerable<CommonDescriptionWhereInput>
    NOT?: Enumerable<CommonDescriptionWhereInput>
    id?: IntFilter | number
    fit?: StringNullableFilter | string | null
    materail?: StringFilter | string
    care?: StringFilter | string
    brandName?: StringFilter | string
    origin?: StringFilter | string
    productId?: IntFilter | number
    occasion?: StringFilter | string
    specialFeature?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    topDescription?: TopDescriptionListRelationFilter
    pantDescription?: BottomDescriptionListRelationFilter
    kurtasDescription?: KurtasDescriptionListRelationFilter
    shoesDescription?: ShoesDescriptionListRelationFilter
    innerDescription?: InnersDescriptionListRelationFilter
    watchesDescription?: WatchesDescriptionListRelationFilter
    perfumesDescription?: PerfumesDescriptionListRelationFilter
  }

  export type CommonDescriptionOrderByWithRelationInput = {
    id?: SortOrder
    fit?: SortOrderInput | SortOrder
    materail?: SortOrder
    care?: SortOrder
    brandName?: SortOrder
    origin?: SortOrder
    productId?: SortOrder
    occasion?: SortOrder
    specialFeature?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    product?: ProductOrderByWithRelationInput
    topDescription?: TopDescriptionOrderByRelationAggregateInput
    pantDescription?: BottomDescriptionOrderByRelationAggregateInput
    kurtasDescription?: KurtasDescriptionOrderByRelationAggregateInput
    shoesDescription?: ShoesDescriptionOrderByRelationAggregateInput
    innerDescription?: InnersDescriptionOrderByRelationAggregateInput
    watchesDescription?: WatchesDescriptionOrderByRelationAggregateInput
    perfumesDescription?: PerfumesDescriptionOrderByRelationAggregateInput
  }

  export type CommonDescriptionWhereUniqueInput = {
    id?: number
  }

  export type CommonDescriptionOrderByWithAggregationInput = {
    id?: SortOrder
    fit?: SortOrderInput | SortOrder
    materail?: SortOrder
    care?: SortOrder
    brandName?: SortOrder
    origin?: SortOrder
    productId?: SortOrder
    occasion?: SortOrder
    specialFeature?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: CommonDescriptionCountOrderByAggregateInput
    _avg?: CommonDescriptionAvgOrderByAggregateInput
    _max?: CommonDescriptionMaxOrderByAggregateInput
    _min?: CommonDescriptionMinOrderByAggregateInput
    _sum?: CommonDescriptionSumOrderByAggregateInput
  }

  export type CommonDescriptionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CommonDescriptionScalarWhereWithAggregatesInput>
    OR?: Enumerable<CommonDescriptionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CommonDescriptionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    fit?: StringNullableWithAggregatesFilter | string | null
    materail?: StringWithAggregatesFilter | string
    care?: StringWithAggregatesFilter | string
    brandName?: StringWithAggregatesFilter | string
    origin?: StringWithAggregatesFilter | string
    productId?: IntWithAggregatesFilter | number
    occasion?: StringWithAggregatesFilter | string
    specialFeature?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type TopDescriptionWhereInput = {
    AND?: Enumerable<TopDescriptionWhereInput>
    OR?: Enumerable<TopDescriptionWhereInput>
    NOT?: Enumerable<TopDescriptionWhereInput>
    id?: IntFilter | number
    productDescription?: StringNullableFilter | string | null
    sleeveTypeId?: IntFilter | number
    weight?: IntNullableFilter | number | null
    chest?: IntFilter | number
    shoulder?: IntFilter | number
    neckTypeId?: IntFilter | number
    type?: StringNullableFilter | string | null
    colorFamily?: StringNullableFilter | string | null
    printAndPattern?: StringNullableFilter | string | null
    length?: IntFilter | number
    pocket?: StringFilter | string
    commonDescriptionId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    commonDescription?: XOR<CommonDescriptionRelationFilter, CommonDescriptionWhereInput> | null
    sleeveType?: XOR<SleeveTypeRelationFilter, SleeveTypeWhereInput>
    neckType?: XOR<NeckTypeRelationFilter, NeckTypeWhereInput>
    bottomDescription?: BottomDescriptionListRelationFilter
  }

  export type TopDescriptionOrderByWithRelationInput = {
    id?: SortOrder
    productDescription?: SortOrderInput | SortOrder
    sleeveTypeId?: SortOrder
    weight?: SortOrderInput | SortOrder
    chest?: SortOrder
    shoulder?: SortOrder
    neckTypeId?: SortOrder
    type?: SortOrderInput | SortOrder
    colorFamily?: SortOrderInput | SortOrder
    printAndPattern?: SortOrderInput | SortOrder
    length?: SortOrder
    pocket?: SortOrder
    commonDescriptionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    commonDescription?: CommonDescriptionOrderByWithRelationInput
    sleeveType?: SleeveTypeOrderByWithRelationInput
    neckType?: NeckTypeOrderByWithRelationInput
    bottomDescription?: BottomDescriptionOrderByRelationAggregateInput
  }

  export type TopDescriptionWhereUniqueInput = {
    id?: number
  }

  export type TopDescriptionOrderByWithAggregationInput = {
    id?: SortOrder
    productDescription?: SortOrderInput | SortOrder
    sleeveTypeId?: SortOrder
    weight?: SortOrderInput | SortOrder
    chest?: SortOrder
    shoulder?: SortOrder
    neckTypeId?: SortOrder
    type?: SortOrderInput | SortOrder
    colorFamily?: SortOrderInput | SortOrder
    printAndPattern?: SortOrderInput | SortOrder
    length?: SortOrder
    pocket?: SortOrder
    commonDescriptionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: TopDescriptionCountOrderByAggregateInput
    _avg?: TopDescriptionAvgOrderByAggregateInput
    _max?: TopDescriptionMaxOrderByAggregateInput
    _min?: TopDescriptionMinOrderByAggregateInput
    _sum?: TopDescriptionSumOrderByAggregateInput
  }

  export type TopDescriptionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TopDescriptionScalarWhereWithAggregatesInput>
    OR?: Enumerable<TopDescriptionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TopDescriptionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    productDescription?: StringNullableWithAggregatesFilter | string | null
    sleeveTypeId?: IntWithAggregatesFilter | number
    weight?: IntNullableWithAggregatesFilter | number | null
    chest?: IntWithAggregatesFilter | number
    shoulder?: IntWithAggregatesFilter | number
    neckTypeId?: IntWithAggregatesFilter | number
    type?: StringNullableWithAggregatesFilter | string | null
    colorFamily?: StringNullableWithAggregatesFilter | string | null
    printAndPattern?: StringNullableWithAggregatesFilter | string | null
    length?: IntWithAggregatesFilter | number
    pocket?: StringWithAggregatesFilter | string
    commonDescriptionId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type BottomDescriptionWhereInput = {
    AND?: Enumerable<BottomDescriptionWhereInput>
    OR?: Enumerable<BottomDescriptionWhereInput>
    NOT?: Enumerable<BottomDescriptionWhereInput>
    id?: IntFilter | number
    productDescription?: StringNullableFilter | string | null
    weight?: IntNullableFilter | number | null
    printAndPattern?: StringFilter | string
    length?: IntFilter | number
    waist?: IntFilter | number
    hip?: IntFilter | number
    commonDescriptionId?: IntFilter | number
    type?: StringNullableFilter | string | null
    colorFamily?: StringNullableFilter | string | null
    pocket?: StringNullableFilter | string | null
    kurtasDescriptionId?: IntNullableFilter | number | null
    topDescriptionId?: IntNullableFilter | number | null
    beltLoop?: BoolFilter | boolean
    typeOfPantId?: IntFilter | number
    typesOfPleatsId?: IntFilter | number
    typesOfLengthId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    typesOfPants?: XOR<TypesOfBottomRelationFilter, TypesOfBottomWhereInput>
    typesOfPleats?: XOR<TypesOfPleatsRelationFilter, TypesOfPleatsWhereInput>
    typesOfLength?: XOR<TypesOfLengthBottomRelationFilter, TypesOfLengthBottomWhereInput>
    commonDescription?: XOR<CommonDescriptionRelationFilter, CommonDescriptionWhereInput>
    kurtasDescription?: XOR<KurtasDescriptionRelationFilter, KurtasDescriptionWhereInput> | null
    topDescription?: XOR<TopDescriptionRelationFilter, TopDescriptionWhereInput> | null
  }

  export type BottomDescriptionOrderByWithRelationInput = {
    id?: SortOrder
    productDescription?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    printAndPattern?: SortOrder
    length?: SortOrder
    waist?: SortOrder
    hip?: SortOrder
    commonDescriptionId?: SortOrder
    type?: SortOrderInput | SortOrder
    colorFamily?: SortOrderInput | SortOrder
    pocket?: SortOrderInput | SortOrder
    kurtasDescriptionId?: SortOrderInput | SortOrder
    topDescriptionId?: SortOrderInput | SortOrder
    beltLoop?: SortOrder
    typeOfPantId?: SortOrder
    typesOfPleatsId?: SortOrder
    typesOfLengthId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    typesOfPants?: TypesOfBottomOrderByWithRelationInput
    typesOfPleats?: TypesOfPleatsOrderByWithRelationInput
    typesOfLength?: TypesOfLengthBottomOrderByWithRelationInput
    commonDescription?: CommonDescriptionOrderByWithRelationInput
    kurtasDescription?: KurtasDescriptionOrderByWithRelationInput
    topDescription?: TopDescriptionOrderByWithRelationInput
  }

  export type BottomDescriptionWhereUniqueInput = {
    id?: number
  }

  export type BottomDescriptionOrderByWithAggregationInput = {
    id?: SortOrder
    productDescription?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    printAndPattern?: SortOrder
    length?: SortOrder
    waist?: SortOrder
    hip?: SortOrder
    commonDescriptionId?: SortOrder
    type?: SortOrderInput | SortOrder
    colorFamily?: SortOrderInput | SortOrder
    pocket?: SortOrderInput | SortOrder
    kurtasDescriptionId?: SortOrderInput | SortOrder
    topDescriptionId?: SortOrderInput | SortOrder
    beltLoop?: SortOrder
    typeOfPantId?: SortOrder
    typesOfPleatsId?: SortOrder
    typesOfLengthId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: BottomDescriptionCountOrderByAggregateInput
    _avg?: BottomDescriptionAvgOrderByAggregateInput
    _max?: BottomDescriptionMaxOrderByAggregateInput
    _min?: BottomDescriptionMinOrderByAggregateInput
    _sum?: BottomDescriptionSumOrderByAggregateInput
  }

  export type BottomDescriptionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BottomDescriptionScalarWhereWithAggregatesInput>
    OR?: Enumerable<BottomDescriptionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BottomDescriptionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    productDescription?: StringNullableWithAggregatesFilter | string | null
    weight?: IntNullableWithAggregatesFilter | number | null
    printAndPattern?: StringWithAggregatesFilter | string
    length?: IntWithAggregatesFilter | number
    waist?: IntWithAggregatesFilter | number
    hip?: IntWithAggregatesFilter | number
    commonDescriptionId?: IntWithAggregatesFilter | number
    type?: StringNullableWithAggregatesFilter | string | null
    colorFamily?: StringNullableWithAggregatesFilter | string | null
    pocket?: StringNullableWithAggregatesFilter | string | null
    kurtasDescriptionId?: IntNullableWithAggregatesFilter | number | null
    topDescriptionId?: IntNullableWithAggregatesFilter | number | null
    beltLoop?: BoolWithAggregatesFilter | boolean
    typeOfPantId?: IntWithAggregatesFilter | number
    typesOfPleatsId?: IntWithAggregatesFilter | number
    typesOfLengthId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type KurtasDescriptionWhereInput = {
    AND?: Enumerable<KurtasDescriptionWhereInput>
    OR?: Enumerable<KurtasDescriptionWhereInput>
    NOT?: Enumerable<KurtasDescriptionWhereInput>
    id?: IntFilter | number
    work?: StringNullableFilter | string | null
    productDescription?: StringFilter | string
    chest?: IntFilter | number
    shoulder?: IntFilter | number
    transparencyOfTheFabric?: BoolFilter | boolean
    kurtasLengthTypeId?: IntFilter | number
    weight?: IntNullableFilter | number | null
    colorFamily?: StringNullableFilter | string | null
    pocket?: StringFilter | string
    type?: StringFilter | string
    printAndpattern?: StringNullableFilter | string | null
    kurtasNeckTypeId?: IntFilter | number
    kurtasSleeveTypeId?: IntFilter | number
    commonDescriptionId?: IntFilter | number
    isActive?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    kurtasLengthType?: XOR<KurtasLengthTypeRelationFilter, KurtasLengthTypeWhereInput>
    neckType?: XOR<NeckTypeRelationFilter, NeckTypeWhereInput>
    sleeveType?: XOR<SleeveTypeRelationFilter, SleeveTypeWhereInput>
    commonDescription?: XOR<CommonDescriptionRelationFilter, CommonDescriptionWhereInput>
    bottomDescription?: BottomDescriptionListRelationFilter
  }

  export type KurtasDescriptionOrderByWithRelationInput = {
    id?: SortOrder
    work?: SortOrderInput | SortOrder
    productDescription?: SortOrder
    chest?: SortOrder
    shoulder?: SortOrder
    transparencyOfTheFabric?: SortOrder
    kurtasLengthTypeId?: SortOrder
    weight?: SortOrderInput | SortOrder
    colorFamily?: SortOrderInput | SortOrder
    pocket?: SortOrder
    type?: SortOrder
    printAndpattern?: SortOrderInput | SortOrder
    kurtasNeckTypeId?: SortOrder
    kurtasSleeveTypeId?: SortOrder
    commonDescriptionId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    kurtasLengthType?: KurtasLengthTypeOrderByWithRelationInput
    neckType?: NeckTypeOrderByWithRelationInput
    sleeveType?: SleeveTypeOrderByWithRelationInput
    commonDescription?: CommonDescriptionOrderByWithRelationInput
    bottomDescription?: BottomDescriptionOrderByRelationAggregateInput
  }

  export type KurtasDescriptionWhereUniqueInput = {
    id?: number
  }

  export type KurtasDescriptionOrderByWithAggregationInput = {
    id?: SortOrder
    work?: SortOrderInput | SortOrder
    productDescription?: SortOrder
    chest?: SortOrder
    shoulder?: SortOrder
    transparencyOfTheFabric?: SortOrder
    kurtasLengthTypeId?: SortOrder
    weight?: SortOrderInput | SortOrder
    colorFamily?: SortOrderInput | SortOrder
    pocket?: SortOrder
    type?: SortOrder
    printAndpattern?: SortOrderInput | SortOrder
    kurtasNeckTypeId?: SortOrder
    kurtasSleeveTypeId?: SortOrder
    commonDescriptionId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: KurtasDescriptionCountOrderByAggregateInput
    _avg?: KurtasDescriptionAvgOrderByAggregateInput
    _max?: KurtasDescriptionMaxOrderByAggregateInput
    _min?: KurtasDescriptionMinOrderByAggregateInput
    _sum?: KurtasDescriptionSumOrderByAggregateInput
  }

  export type KurtasDescriptionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<KurtasDescriptionScalarWhereWithAggregatesInput>
    OR?: Enumerable<KurtasDescriptionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<KurtasDescriptionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    work?: StringNullableWithAggregatesFilter | string | null
    productDescription?: StringWithAggregatesFilter | string
    chest?: IntWithAggregatesFilter | number
    shoulder?: IntWithAggregatesFilter | number
    transparencyOfTheFabric?: BoolWithAggregatesFilter | boolean
    kurtasLengthTypeId?: IntWithAggregatesFilter | number
    weight?: IntNullableWithAggregatesFilter | number | null
    colorFamily?: StringNullableWithAggregatesFilter | string | null
    pocket?: StringWithAggregatesFilter | string
    type?: StringWithAggregatesFilter | string
    printAndpattern?: StringNullableWithAggregatesFilter | string | null
    kurtasNeckTypeId?: IntWithAggregatesFilter | number
    kurtasSleeveTypeId?: IntWithAggregatesFilter | number
    commonDescriptionId?: IntWithAggregatesFilter | number
    isActive?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type ShoesDescriptionWhereInput = {
    AND?: Enumerable<ShoesDescriptionWhereInput>
    OR?: Enumerable<ShoesDescriptionWhereInput>
    NOT?: Enumerable<ShoesDescriptionWhereInput>
    id?: IntFilter | number
    pattern?: StringNullableFilter | string | null
    footLength?: StringFilter | string
    type?: StringFilter | string
    soleMaterial?: StringNullableFilter | string | null
    printAndPattern?: StringNullableFilter | string | null
    upperMaterial?: StringNullableFilter | string | null
    closure?: StringNullableFilter | string | null
    toeType?: StringFilter | string
    weight?: IntNullableFilter | number | null
    colorFamily?: StringNullableFilter | string | null
    productDescription?: StringNullableFilter | string | null
    packageContains?: IntNullableFilter | number | null
    commonDescriptionId?: IntFilter | number
    isActive?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    warranty?: WarrantyListRelationFilter
    commonDescription?: XOR<CommonDescriptionRelationFilter, CommonDescriptionWhereInput>
  }

  export type ShoesDescriptionOrderByWithRelationInput = {
    id?: SortOrder
    pattern?: SortOrderInput | SortOrder
    footLength?: SortOrder
    type?: SortOrder
    soleMaterial?: SortOrderInput | SortOrder
    printAndPattern?: SortOrderInput | SortOrder
    upperMaterial?: SortOrderInput | SortOrder
    closure?: SortOrderInput | SortOrder
    toeType?: SortOrder
    weight?: SortOrderInput | SortOrder
    colorFamily?: SortOrderInput | SortOrder
    productDescription?: SortOrderInput | SortOrder
    packageContains?: SortOrderInput | SortOrder
    commonDescriptionId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    warranty?: WarrantyOrderByRelationAggregateInput
    commonDescription?: CommonDescriptionOrderByWithRelationInput
  }

  export type ShoesDescriptionWhereUniqueInput = {
    id?: number
  }

  export type ShoesDescriptionOrderByWithAggregationInput = {
    id?: SortOrder
    pattern?: SortOrderInput | SortOrder
    footLength?: SortOrder
    type?: SortOrder
    soleMaterial?: SortOrderInput | SortOrder
    printAndPattern?: SortOrderInput | SortOrder
    upperMaterial?: SortOrderInput | SortOrder
    closure?: SortOrderInput | SortOrder
    toeType?: SortOrder
    weight?: SortOrderInput | SortOrder
    colorFamily?: SortOrderInput | SortOrder
    productDescription?: SortOrderInput | SortOrder
    packageContains?: SortOrderInput | SortOrder
    commonDescriptionId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ShoesDescriptionCountOrderByAggregateInput
    _avg?: ShoesDescriptionAvgOrderByAggregateInput
    _max?: ShoesDescriptionMaxOrderByAggregateInput
    _min?: ShoesDescriptionMinOrderByAggregateInput
    _sum?: ShoesDescriptionSumOrderByAggregateInput
  }

  export type ShoesDescriptionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ShoesDescriptionScalarWhereWithAggregatesInput>
    OR?: Enumerable<ShoesDescriptionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ShoesDescriptionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    pattern?: StringNullableWithAggregatesFilter | string | null
    footLength?: StringWithAggregatesFilter | string
    type?: StringWithAggregatesFilter | string
    soleMaterial?: StringNullableWithAggregatesFilter | string | null
    printAndPattern?: StringNullableWithAggregatesFilter | string | null
    upperMaterial?: StringNullableWithAggregatesFilter | string | null
    closure?: StringNullableWithAggregatesFilter | string | null
    toeType?: StringWithAggregatesFilter | string
    weight?: IntNullableWithAggregatesFilter | number | null
    colorFamily?: StringNullableWithAggregatesFilter | string | null
    productDescription?: StringNullableWithAggregatesFilter | string | null
    packageContains?: IntNullableWithAggregatesFilter | number | null
    commonDescriptionId?: IntWithAggregatesFilter | number
    isActive?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type WatchesDescriptionWhereInput = {
    AND?: Enumerable<WatchesDescriptionWhereInput>
    OR?: Enumerable<WatchesDescriptionWhereInput>
    NOT?: Enumerable<WatchesDescriptionWhereInput>
    id?: IntFilter | number
    type?: StringNullableFilter | string | null
    weight?: IntFilter | number
    model?: StringFilter | string
    dialShape?: StringFilter | string
    printAndPattern?: StringNullableFilter | string | null
    dialDiameter?: StringFilter | string
    dialColor?: StringFilter | string
    strapColor?: StringFilter | string
    colorFamily?: StringNullableFilter | string | null
    productDescription?: StringNullableFilter | string | null
    commonDescriptionId?: IntFilter | number
    isActive?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    warranty?: WarrantyListRelationFilter
    commonDescription?: XOR<CommonDescriptionRelationFilter, CommonDescriptionWhereInput>
  }

  export type WatchesDescriptionOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrderInput | SortOrder
    weight?: SortOrder
    model?: SortOrder
    dialShape?: SortOrder
    printAndPattern?: SortOrderInput | SortOrder
    dialDiameter?: SortOrder
    dialColor?: SortOrder
    strapColor?: SortOrder
    colorFamily?: SortOrderInput | SortOrder
    productDescription?: SortOrderInput | SortOrder
    commonDescriptionId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    warranty?: WarrantyOrderByRelationAggregateInput
    commonDescription?: CommonDescriptionOrderByWithRelationInput
  }

  export type WatchesDescriptionWhereUniqueInput = {
    id?: number
  }

  export type WatchesDescriptionOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrderInput | SortOrder
    weight?: SortOrder
    model?: SortOrder
    dialShape?: SortOrder
    printAndPattern?: SortOrderInput | SortOrder
    dialDiameter?: SortOrder
    dialColor?: SortOrder
    strapColor?: SortOrder
    colorFamily?: SortOrderInput | SortOrder
    productDescription?: SortOrderInput | SortOrder
    commonDescriptionId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: WatchesDescriptionCountOrderByAggregateInput
    _avg?: WatchesDescriptionAvgOrderByAggregateInput
    _max?: WatchesDescriptionMaxOrderByAggregateInput
    _min?: WatchesDescriptionMinOrderByAggregateInput
    _sum?: WatchesDescriptionSumOrderByAggregateInput
  }

  export type WatchesDescriptionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<WatchesDescriptionScalarWhereWithAggregatesInput>
    OR?: Enumerable<WatchesDescriptionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<WatchesDescriptionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    type?: StringNullableWithAggregatesFilter | string | null
    weight?: IntWithAggregatesFilter | number
    model?: StringWithAggregatesFilter | string
    dialShape?: StringWithAggregatesFilter | string
    printAndPattern?: StringNullableWithAggregatesFilter | string | null
    dialDiameter?: StringWithAggregatesFilter | string
    dialColor?: StringWithAggregatesFilter | string
    strapColor?: StringWithAggregatesFilter | string
    colorFamily?: StringNullableWithAggregatesFilter | string | null
    productDescription?: StringNullableWithAggregatesFilter | string | null
    commonDescriptionId?: IntWithAggregatesFilter | number
    isActive?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type PerfumesDescriptionWhereInput = {
    AND?: Enumerable<PerfumesDescriptionWhereInput>
    OR?: Enumerable<PerfumesDescriptionWhereInput>
    NOT?: Enumerable<PerfumesDescriptionWhereInput>
    id?: IntFilter | number
    productDescription?: StringFilter | string
    type?: StringNullableFilter | string | null
    materialDescription?: StringFilter | string
    weight?: IntFilter | number
    commonDescriptionId?: IntFilter | number
    isActive?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    commonDescription?: XOR<CommonDescriptionRelationFilter, CommonDescriptionWhereInput>
  }

  export type PerfumesDescriptionOrderByWithRelationInput = {
    id?: SortOrder
    productDescription?: SortOrder
    type?: SortOrderInput | SortOrder
    materialDescription?: SortOrder
    weight?: SortOrder
    commonDescriptionId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    commonDescription?: CommonDescriptionOrderByWithRelationInput
  }

  export type PerfumesDescriptionWhereUniqueInput = {
    id?: number
  }

  export type PerfumesDescriptionOrderByWithAggregationInput = {
    id?: SortOrder
    productDescription?: SortOrder
    type?: SortOrderInput | SortOrder
    materialDescription?: SortOrder
    weight?: SortOrder
    commonDescriptionId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: PerfumesDescriptionCountOrderByAggregateInput
    _avg?: PerfumesDescriptionAvgOrderByAggregateInput
    _max?: PerfumesDescriptionMaxOrderByAggregateInput
    _min?: PerfumesDescriptionMinOrderByAggregateInput
    _sum?: PerfumesDescriptionSumOrderByAggregateInput
  }

  export type PerfumesDescriptionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PerfumesDescriptionScalarWhereWithAggregatesInput>
    OR?: Enumerable<PerfumesDescriptionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PerfumesDescriptionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    productDescription?: StringWithAggregatesFilter | string
    type?: StringNullableWithAggregatesFilter | string | null
    materialDescription?: StringWithAggregatesFilter | string
    weight?: IntWithAggregatesFilter | number
    commonDescriptionId?: IntWithAggregatesFilter | number
    isActive?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type InnersDescriptionWhereInput = {
    AND?: Enumerable<InnersDescriptionWhereInput>
    OR?: Enumerable<InnersDescriptionWhereInput>
    NOT?: Enumerable<InnersDescriptionWhereInput>
    id?: IntFilter | number
    type?: StringFilter | string
    productDescription?: StringFilter | string
    weight?: IntNullableFilter | number | null
    length?: IntFilter | number
    waistRise?: IntFilter | number
    printAndPattern?: StringNullableFilter | string | null
    packageContains?: IntFilter | number
    lookAndFeel?: StringFilter | string
    colorFamily?: StringNullableFilter | string | null
    vestsSleeveTypeId?: IntNullableFilter | number | null
    vestsNeckTypeId?: IntNullableFilter | number | null
    commonDescriptionId?: IntFilter | number
    multiColors?: BoolFilter | boolean
    sleeveType?: XOR<SleeveTypeRelationFilter, SleeveTypeWhereInput> | null
    neckType?: XOR<NeckTypeRelationFilter, NeckTypeWhereInput> | null
    commonDescription?: XOR<CommonDescriptionRelationFilter, CommonDescriptionWhereInput>
  }

  export type InnersDescriptionOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    productDescription?: SortOrder
    weight?: SortOrderInput | SortOrder
    length?: SortOrder
    waistRise?: SortOrder
    printAndPattern?: SortOrderInput | SortOrder
    packageContains?: SortOrder
    lookAndFeel?: SortOrder
    colorFamily?: SortOrderInput | SortOrder
    vestsSleeveTypeId?: SortOrderInput | SortOrder
    vestsNeckTypeId?: SortOrderInput | SortOrder
    commonDescriptionId?: SortOrder
    multiColors?: SortOrder
    sleeveType?: SleeveTypeOrderByWithRelationInput
    neckType?: NeckTypeOrderByWithRelationInput
    commonDescription?: CommonDescriptionOrderByWithRelationInput
  }

  export type InnersDescriptionWhereUniqueInput = {
    id?: number
  }

  export type InnersDescriptionOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    productDescription?: SortOrder
    weight?: SortOrderInput | SortOrder
    length?: SortOrder
    waistRise?: SortOrder
    printAndPattern?: SortOrderInput | SortOrder
    packageContains?: SortOrder
    lookAndFeel?: SortOrder
    colorFamily?: SortOrderInput | SortOrder
    vestsSleeveTypeId?: SortOrderInput | SortOrder
    vestsNeckTypeId?: SortOrderInput | SortOrder
    commonDescriptionId?: SortOrder
    multiColors?: SortOrder
    _count?: InnersDescriptionCountOrderByAggregateInput
    _avg?: InnersDescriptionAvgOrderByAggregateInput
    _max?: InnersDescriptionMaxOrderByAggregateInput
    _min?: InnersDescriptionMinOrderByAggregateInput
    _sum?: InnersDescriptionSumOrderByAggregateInput
  }

  export type InnersDescriptionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<InnersDescriptionScalarWhereWithAggregatesInput>
    OR?: Enumerable<InnersDescriptionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<InnersDescriptionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    type?: StringWithAggregatesFilter | string
    productDescription?: StringWithAggregatesFilter | string
    weight?: IntNullableWithAggregatesFilter | number | null
    length?: IntWithAggregatesFilter | number
    waistRise?: IntWithAggregatesFilter | number
    printAndPattern?: StringNullableWithAggregatesFilter | string | null
    packageContains?: IntWithAggregatesFilter | number
    lookAndFeel?: StringWithAggregatesFilter | string
    colorFamily?: StringNullableWithAggregatesFilter | string | null
    vestsSleeveTypeId?: IntNullableWithAggregatesFilter | number | null
    vestsNeckTypeId?: IntNullableWithAggregatesFilter | number | null
    commonDescriptionId?: IntWithAggregatesFilter | number
    multiColors?: BoolWithAggregatesFilter | boolean
  }

  export type WarrantyWhereInput = {
    AND?: Enumerable<WarrantyWhereInput>
    OR?: Enumerable<WarrantyWhereInput>
    NOT?: Enumerable<WarrantyWhereInput>
    id?: IntFilter | number
    shoesDescriptionId?: IntNullableFilter | number | null
    watchsId?: IntNullableFilter | number | null
    warrantyPeriod?: IntFilter | number
    isActive?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    shoesDescription?: XOR<ShoesDescriptionRelationFilter, ShoesDescriptionWhereInput> | null
    watches?: XOR<WatchesDescriptionRelationFilter, WatchesDescriptionWhereInput> | null
  }

  export type WarrantyOrderByWithRelationInput = {
    id?: SortOrder
    shoesDescriptionId?: SortOrderInput | SortOrder
    watchsId?: SortOrderInput | SortOrder
    warrantyPeriod?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    shoesDescription?: ShoesDescriptionOrderByWithRelationInput
    watches?: WatchesDescriptionOrderByWithRelationInput
  }

  export type WarrantyWhereUniqueInput = {
    id?: number
  }

  export type WarrantyOrderByWithAggregationInput = {
    id?: SortOrder
    shoesDescriptionId?: SortOrderInput | SortOrder
    watchsId?: SortOrderInput | SortOrder
    warrantyPeriod?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: WarrantyCountOrderByAggregateInput
    _avg?: WarrantyAvgOrderByAggregateInput
    _max?: WarrantyMaxOrderByAggregateInput
    _min?: WarrantyMinOrderByAggregateInput
    _sum?: WarrantySumOrderByAggregateInput
  }

  export type WarrantyScalarWhereWithAggregatesInput = {
    AND?: Enumerable<WarrantyScalarWhereWithAggregatesInput>
    OR?: Enumerable<WarrantyScalarWhereWithAggregatesInput>
    NOT?: Enumerable<WarrantyScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    shoesDescriptionId?: IntNullableWithAggregatesFilter | number | null
    watchsId?: IntNullableWithAggregatesFilter | number | null
    warrantyPeriod?: IntWithAggregatesFilter | number
    isActive?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type SleeveTypeWhereInput = {
    AND?: Enumerable<SleeveTypeWhereInput>
    OR?: Enumerable<SleeveTypeWhereInput>
    NOT?: Enumerable<SleeveTypeWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    isActive?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    kurtasDescription?: KurtasDescriptionListRelationFilter
    innersDescription?: InnersDescriptionListRelationFilter
    topDescription?: TopDescriptionListRelationFilter
  }

  export type SleeveTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    kurtasDescription?: KurtasDescriptionOrderByRelationAggregateInput
    innersDescription?: InnersDescriptionOrderByRelationAggregateInput
    topDescription?: TopDescriptionOrderByRelationAggregateInput
  }

  export type SleeveTypeWhereUniqueInput = {
    id?: number
  }

  export type SleeveTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: SleeveTypeCountOrderByAggregateInput
    _avg?: SleeveTypeAvgOrderByAggregateInput
    _max?: SleeveTypeMaxOrderByAggregateInput
    _min?: SleeveTypeMinOrderByAggregateInput
    _sum?: SleeveTypeSumOrderByAggregateInput
  }

  export type SleeveTypeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SleeveTypeScalarWhereWithAggregatesInput>
    OR?: Enumerable<SleeveTypeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SleeveTypeScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    isActive?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type NeckTypeWhereInput = {
    AND?: Enumerable<NeckTypeWhereInput>
    OR?: Enumerable<NeckTypeWhereInput>
    NOT?: Enumerable<NeckTypeWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    isActive?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    kurtasDescription?: KurtasDescriptionListRelationFilter
    innersDescription?: InnersDescriptionListRelationFilter
    topDescription?: TopDescriptionListRelationFilter
  }

  export type NeckTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    kurtasDescription?: KurtasDescriptionOrderByRelationAggregateInput
    innersDescription?: InnersDescriptionOrderByRelationAggregateInput
    topDescription?: TopDescriptionOrderByRelationAggregateInput
  }

  export type NeckTypeWhereUniqueInput = {
    id?: number
  }

  export type NeckTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: NeckTypeCountOrderByAggregateInput
    _avg?: NeckTypeAvgOrderByAggregateInput
    _max?: NeckTypeMaxOrderByAggregateInput
    _min?: NeckTypeMinOrderByAggregateInput
    _sum?: NeckTypeSumOrderByAggregateInput
  }

  export type NeckTypeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<NeckTypeScalarWhereWithAggregatesInput>
    OR?: Enumerable<NeckTypeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<NeckTypeScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    isActive?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type KurtasLengthTypeWhereInput = {
    AND?: Enumerable<KurtasLengthTypeWhereInput>
    OR?: Enumerable<KurtasLengthTypeWhereInput>
    NOT?: Enumerable<KurtasLengthTypeWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    isActive?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    kurtasDescription?: KurtasDescriptionListRelationFilter
  }

  export type KurtasLengthTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    kurtasDescription?: KurtasDescriptionOrderByRelationAggregateInput
  }

  export type KurtasLengthTypeWhereUniqueInput = {
    id?: number
  }

  export type KurtasLengthTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: KurtasLengthTypeCountOrderByAggregateInput
    _avg?: KurtasLengthTypeAvgOrderByAggregateInput
    _max?: KurtasLengthTypeMaxOrderByAggregateInput
    _min?: KurtasLengthTypeMinOrderByAggregateInput
    _sum?: KurtasLengthTypeSumOrderByAggregateInput
  }

  export type KurtasLengthTypeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<KurtasLengthTypeScalarWhereWithAggregatesInput>
    OR?: Enumerable<KurtasLengthTypeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<KurtasLengthTypeScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    isActive?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type TypesOfBottomWhereInput = {
    AND?: Enumerable<TypesOfBottomWhereInput>
    OR?: Enumerable<TypesOfBottomWhereInput>
    NOT?: Enumerable<TypesOfBottomWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    isActive?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    description?: BottomDescriptionListRelationFilter
  }

  export type TypesOfBottomOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    description?: BottomDescriptionOrderByRelationAggregateInput
  }

  export type TypesOfBottomWhereUniqueInput = {
    id?: number
  }

  export type TypesOfBottomOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: TypesOfBottomCountOrderByAggregateInput
    _avg?: TypesOfBottomAvgOrderByAggregateInput
    _max?: TypesOfBottomMaxOrderByAggregateInput
    _min?: TypesOfBottomMinOrderByAggregateInput
    _sum?: TypesOfBottomSumOrderByAggregateInput
  }

  export type TypesOfBottomScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TypesOfBottomScalarWhereWithAggregatesInput>
    OR?: Enumerable<TypesOfBottomScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TypesOfBottomScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    isActive?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type TypesOfPleatsWhereInput = {
    AND?: Enumerable<TypesOfPleatsWhereInput>
    OR?: Enumerable<TypesOfPleatsWhereInput>
    NOT?: Enumerable<TypesOfPleatsWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    isActive?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    description?: BottomDescriptionListRelationFilter
  }

  export type TypesOfPleatsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    description?: BottomDescriptionOrderByRelationAggregateInput
  }

  export type TypesOfPleatsWhereUniqueInput = {
    id?: number
  }

  export type TypesOfPleatsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: TypesOfPleatsCountOrderByAggregateInput
    _avg?: TypesOfPleatsAvgOrderByAggregateInput
    _max?: TypesOfPleatsMaxOrderByAggregateInput
    _min?: TypesOfPleatsMinOrderByAggregateInput
    _sum?: TypesOfPleatsSumOrderByAggregateInput
  }

  export type TypesOfPleatsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TypesOfPleatsScalarWhereWithAggregatesInput>
    OR?: Enumerable<TypesOfPleatsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TypesOfPleatsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    isActive?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type TypesOfLengthBottomWhereInput = {
    AND?: Enumerable<TypesOfLengthBottomWhereInput>
    OR?: Enumerable<TypesOfLengthBottomWhereInput>
    NOT?: Enumerable<TypesOfLengthBottomWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    isActive?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    description?: BottomDescriptionListRelationFilter
  }

  export type TypesOfLengthBottomOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    description?: BottomDescriptionOrderByRelationAggregateInput
  }

  export type TypesOfLengthBottomWhereUniqueInput = {
    id?: number
  }

  export type TypesOfLengthBottomOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: TypesOfLengthBottomCountOrderByAggregateInput
    _avg?: TypesOfLengthBottomAvgOrderByAggregateInput
    _max?: TypesOfLengthBottomMaxOrderByAggregateInput
    _min?: TypesOfLengthBottomMinOrderByAggregateInput
    _sum?: TypesOfLengthBottomSumOrderByAggregateInput
  }

  export type TypesOfLengthBottomScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TypesOfLengthBottomScalarWhereWithAggregatesInput>
    OR?: Enumerable<TypesOfLengthBottomScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TypesOfLengthBottomScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    isActive?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type QuantityHistoryWhereInput = {
    AND?: Enumerable<QuantityHistoryWhereInput>
    OR?: Enumerable<QuantityHistoryWhereInput>
    NOT?: Enumerable<QuantityHistoryWhereInput>
    id?: IntFilter | number
    quantity?: IntFilter | number
    productAviableSizesId?: IntFilter | number
    timestamp?: DateTimeFilter | Date | string
    isActive?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    productAviableSizes?: XOR<ProductAviableSizesRelationFilter, ProductAviableSizesWhereInput>
  }

  export type QuantityHistoryOrderByWithRelationInput = {
    id?: SortOrder
    quantity?: SortOrder
    productAviableSizesId?: SortOrder
    timestamp?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    productAviableSizes?: ProductAviableSizesOrderByWithRelationInput
  }

  export type QuantityHistoryWhereUniqueInput = {
    id?: number
  }

  export type QuantityHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    quantity?: SortOrder
    productAviableSizesId?: SortOrder
    timestamp?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: QuantityHistoryCountOrderByAggregateInput
    _avg?: QuantityHistoryAvgOrderByAggregateInput
    _max?: QuantityHistoryMaxOrderByAggregateInput
    _min?: QuantityHistoryMinOrderByAggregateInput
    _sum?: QuantityHistorySumOrderByAggregateInput
  }

  export type QuantityHistoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<QuantityHistoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<QuantityHistoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<QuantityHistoryScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    quantity?: IntWithAggregatesFilter | number
    productAviableSizesId?: IntWithAggregatesFilter | number
    timestamp?: DateTimeWithAggregatesFilter | Date | string
    isActive?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type OfferWhereInput = {
    AND?: Enumerable<OfferWhereInput>
    OR?: Enumerable<OfferWhereInput>
    NOT?: Enumerable<OfferWhereInput>
    id?: IntFilter | number
    productId?: IntFilter | number
    offerPercntage?: FloatFilter | number
    offerPrice?: FloatFilter | number
    currentPrice?: FloatFilter | number
    offerQuantity?: IntFilter | number
    currentQuantity?: IntFilter | number
    isActive?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    offerValidity?: OfferValidityListRelationFilter
  }

  export type OfferOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    offerPercntage?: SortOrder
    offerPrice?: SortOrder
    currentPrice?: SortOrder
    offerQuantity?: SortOrder
    currentQuantity?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    product?: ProductOrderByWithRelationInput
    offerValidity?: OfferValidityOrderByRelationAggregateInput
  }

  export type OfferWhereUniqueInput = {
    id?: number
  }

  export type OfferOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    offerPercntage?: SortOrder
    offerPrice?: SortOrder
    currentPrice?: SortOrder
    offerQuantity?: SortOrder
    currentQuantity?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: OfferCountOrderByAggregateInput
    _avg?: OfferAvgOrderByAggregateInput
    _max?: OfferMaxOrderByAggregateInput
    _min?: OfferMinOrderByAggregateInput
    _sum?: OfferSumOrderByAggregateInput
  }

  export type OfferScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OfferScalarWhereWithAggregatesInput>
    OR?: Enumerable<OfferScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OfferScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    productId?: IntWithAggregatesFilter | number
    offerPercntage?: FloatWithAggregatesFilter | number
    offerPrice?: FloatWithAggregatesFilter | number
    currentPrice?: FloatWithAggregatesFilter | number
    offerQuantity?: IntWithAggregatesFilter | number
    currentQuantity?: IntWithAggregatesFilter | number
    isActive?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type OfferValidityWhereInput = {
    AND?: Enumerable<OfferValidityWhereInput>
    OR?: Enumerable<OfferValidityWhereInput>
    NOT?: Enumerable<OfferValidityWhereInput>
    id?: IntFilter | number
    fromDate?: DateTimeFilter | Date | string
    toDate?: DateTimeFilter | Date | string
    fromTime?: DateTimeFilter | Date | string
    toTime?: DateTimeFilter | Date | string
    monday?: BoolFilter | boolean
    tuesday?: BoolFilter | boolean
    wednesday?: BoolFilter | boolean
    thursday?: BoolFilter | boolean
    friday?: BoolFilter | boolean
    saturday?: BoolFilter | boolean
    sunday?: BoolFilter | boolean
    offerId?: IntFilter | number
    offerPromotionPeriodId?: IntNullableFilter | number | null
    isActive?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    offer?: XOR<OfferRelationFilter, OfferWhereInput> | null
    offerPromotionPeriod?: XOR<OfferPromotionPeriodsRelationFilter, OfferPromotionPeriodsWhereInput> | null
  }

  export type OfferValidityOrderByWithRelationInput = {
    id?: SortOrder
    fromDate?: SortOrder
    toDate?: SortOrder
    fromTime?: SortOrder
    toTime?: SortOrder
    monday?: SortOrder
    tuesday?: SortOrder
    wednesday?: SortOrder
    thursday?: SortOrder
    friday?: SortOrder
    saturday?: SortOrder
    sunday?: SortOrder
    offerId?: SortOrder
    offerPromotionPeriodId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    offer?: OfferOrderByWithRelationInput
    offerPromotionPeriod?: OfferPromotionPeriodsOrderByWithRelationInput
  }

  export type OfferValidityWhereUniqueInput = {
    id?: number
    offerPromotionPeriodId?: number
  }

  export type OfferValidityOrderByWithAggregationInput = {
    id?: SortOrder
    fromDate?: SortOrder
    toDate?: SortOrder
    fromTime?: SortOrder
    toTime?: SortOrder
    monday?: SortOrder
    tuesday?: SortOrder
    wednesday?: SortOrder
    thursday?: SortOrder
    friday?: SortOrder
    saturday?: SortOrder
    sunday?: SortOrder
    offerId?: SortOrder
    offerPromotionPeriodId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: OfferValidityCountOrderByAggregateInput
    _avg?: OfferValidityAvgOrderByAggregateInput
    _max?: OfferValidityMaxOrderByAggregateInput
    _min?: OfferValidityMinOrderByAggregateInput
    _sum?: OfferValiditySumOrderByAggregateInput
  }

  export type OfferValidityScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OfferValidityScalarWhereWithAggregatesInput>
    OR?: Enumerable<OfferValidityScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OfferValidityScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    fromDate?: DateTimeWithAggregatesFilter | Date | string
    toDate?: DateTimeWithAggregatesFilter | Date | string
    fromTime?: DateTimeWithAggregatesFilter | Date | string
    toTime?: DateTimeWithAggregatesFilter | Date | string
    monday?: BoolWithAggregatesFilter | boolean
    tuesday?: BoolWithAggregatesFilter | boolean
    wednesday?: BoolWithAggregatesFilter | boolean
    thursday?: BoolWithAggregatesFilter | boolean
    friday?: BoolWithAggregatesFilter | boolean
    saturday?: BoolWithAggregatesFilter | boolean
    sunday?: BoolWithAggregatesFilter | boolean
    offerId?: IntWithAggregatesFilter | number
    offerPromotionPeriodId?: IntNullableWithAggregatesFilter | number | null
    isActive?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type OfferPromotionPeriodsWhereInput = {
    AND?: Enumerable<OfferPromotionPeriodsWhereInput>
    OR?: Enumerable<OfferPromotionPeriodsWhereInput>
    NOT?: Enumerable<OfferPromotionPeriodsWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    offerValidity?: XOR<OfferValidityRelationFilter, OfferValidityWhereInput> | null
  }

  export type OfferPromotionPeriodsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    offerValidity?: OfferValidityOrderByWithRelationInput
  }

  export type OfferPromotionPeriodsWhereUniqueInput = {
    id?: number
  }

  export type OfferPromotionPeriodsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: OfferPromotionPeriodsCountOrderByAggregateInput
    _avg?: OfferPromotionPeriodsAvgOrderByAggregateInput
    _max?: OfferPromotionPeriodsMaxOrderByAggregateInput
    _min?: OfferPromotionPeriodsMinOrderByAggregateInput
    _sum?: OfferPromotionPeriodsSumOrderByAggregateInput
  }

  export type OfferPromotionPeriodsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OfferPromotionPeriodsScalarWhereWithAggregatesInput>
    OR?: Enumerable<OfferPromotionPeriodsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OfferPromotionPeriodsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type CartWhereInput = {
    AND?: Enumerable<CartWhereInput>
    OR?: Enumerable<CartWhereInput>
    NOT?: Enumerable<CartWhereInput>
    id?: IntFilter | number
    userId?: IntFilter | number
    productId?: IntFilter | number
    isCheckedOut?: BoolFilter | boolean
    isRemoved?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }

  export type CartOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    isCheckedOut?: SortOrder
    isRemoved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type CartWhereUniqueInput = {
    id?: number
  }

  export type CartOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    isCheckedOut?: SortOrder
    isRemoved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: CartCountOrderByAggregateInput
    _avg?: CartAvgOrderByAggregateInput
    _max?: CartMaxOrderByAggregateInput
    _min?: CartMinOrderByAggregateInput
    _sum?: CartSumOrderByAggregateInput
  }

  export type CartScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CartScalarWhereWithAggregatesInput>
    OR?: Enumerable<CartScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CartScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
    productId?: IntWithAggregatesFilter | number
    isCheckedOut?: BoolWithAggregatesFilter | boolean
    isRemoved?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type WishlistWhereInput = {
    AND?: Enumerable<WishlistWhereInput>
    OR?: Enumerable<WishlistWhereInput>
    NOT?: Enumerable<WishlistWhereInput>
    id?: IntFilter | number
    userId?: IntFilter | number
    items?: WishlistItemListRelationFilter
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type WishlistOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    items?: WishlistItemOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
  }

  export type WishlistWhereUniqueInput = {
    id?: number
    userId?: number
  }

  export type WishlistOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    _count?: WishlistCountOrderByAggregateInput
    _avg?: WishlistAvgOrderByAggregateInput
    _max?: WishlistMaxOrderByAggregateInput
    _min?: WishlistMinOrderByAggregateInput
    _sum?: WishlistSumOrderByAggregateInput
  }

  export type WishlistScalarWhereWithAggregatesInput = {
    AND?: Enumerable<WishlistScalarWhereWithAggregatesInput>
    OR?: Enumerable<WishlistScalarWhereWithAggregatesInput>
    NOT?: Enumerable<WishlistScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
  }

  export type WishlistItemWhereInput = {
    AND?: Enumerable<WishlistItemWhereInput>
    OR?: Enumerable<WishlistItemWhereInput>
    NOT?: Enumerable<WishlistItemWhereInput>
    id?: IntFilter | number
    wishlistId?: IntFilter | number
    productId?: IntFilter | number
    wishlist?: XOR<WishlistRelationFilter, WishlistWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }

  export type WishlistItemOrderByWithRelationInput = {
    id?: SortOrder
    wishlistId?: SortOrder
    productId?: SortOrder
    wishlist?: WishlistOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type WishlistItemWhereUniqueInput = {
    id?: number
  }

  export type WishlistItemOrderByWithAggregationInput = {
    id?: SortOrder
    wishlistId?: SortOrder
    productId?: SortOrder
    _count?: WishlistItemCountOrderByAggregateInput
    _avg?: WishlistItemAvgOrderByAggregateInput
    _max?: WishlistItemMaxOrderByAggregateInput
    _min?: WishlistItemMinOrderByAggregateInput
    _sum?: WishlistItemSumOrderByAggregateInput
  }

  export type WishlistItemScalarWhereWithAggregatesInput = {
    AND?: Enumerable<WishlistItemScalarWhereWithAggregatesInput>
    OR?: Enumerable<WishlistItemScalarWhereWithAggregatesInput>
    NOT?: Enumerable<WishlistItemScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    wishlistId?: IntWithAggregatesFilter | number
    productId?: IntWithAggregatesFilter | number
  }

  export type RolesCreateInput = {
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user?: UserCreateNestedManyWithoutRolesInput
  }

  export type RolesUncheckedCreateInput = {
    id?: number
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user?: UserUncheckedCreateNestedManyWithoutRolesInput
  }

  export type RolesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateManyWithoutRolesNestedInput
  }

  export type RolesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUncheckedUpdateManyWithoutRolesNestedInput
  }

  export type RolesCreateManyInput = {
    id?: number
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type RolesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RolesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SyncDataLastIdCreateInput = {
    lastId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type SyncDataLastIdUncheckedCreateInput = {
    id?: number
    lastId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type SyncDataLastIdUpdateInput = {
    lastId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SyncDataLastIdUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    lastId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SyncDataLastIdCreateManyInput = {
    id?: number
    lastId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type SyncDataLastIdUpdateManyMutationInput = {
    lastId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SyncDataLastIdUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    lastId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductCategoryCreateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    gender: GenderCreateNestedOneWithoutProductCategoryInput
    productType?: ProductTypeCreateNestedManyWithoutProductCategoryInput
  }

  export type ProductCategoryUncheckedCreateInput = {
    id?: number
    name: string
    genderId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    productType?: ProductTypeUncheckedCreateNestedManyWithoutProductCategoryInput
  }

  export type ProductCategoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: GenderUpdateOneRequiredWithoutProductCategoryNestedInput
    productType?: ProductTypeUpdateManyWithoutProductCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    genderId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productType?: ProductTypeUncheckedUpdateManyWithoutProductCategoryNestedInput
  }

  export type ProductCategoryCreateManyInput = {
    id?: number
    name: string
    genderId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ProductCategoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductCategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    genderId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductTypeCreateInput = {
    itemsName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    ProductCategory: ProductCategoryCreateNestedOneWithoutProductTypeInput
    sizes?: ProductTypeSizeCreateNestedManyWithoutProductTypeInput
    product?: ProductCreateNestedManyWithoutProductTypeInput
  }

  export type ProductTypeUncheckedCreateInput = {
    id?: number
    itemsName: string
    productCategoryId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sizes?: ProductTypeSizeUncheckedCreateNestedManyWithoutProductTypeInput
    product?: ProductUncheckedCreateNestedManyWithoutProductTypeInput
  }

  export type ProductTypeUpdateInput = {
    itemsName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ProductCategory?: ProductCategoryUpdateOneRequiredWithoutProductTypeNestedInput
    sizes?: ProductTypeSizeUpdateManyWithoutProductTypeNestedInput
    product?: ProductUpdateManyWithoutProductTypeNestedInput
  }

  export type ProductTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemsName?: StringFieldUpdateOperationsInput | string
    productCategoryId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sizes?: ProductTypeSizeUncheckedUpdateManyWithoutProductTypeNestedInput
    product?: ProductUncheckedUpdateManyWithoutProductTypeNestedInput
  }

  export type ProductTypeCreateManyInput = {
    id?: number
    itemsName: string
    productCategoryId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ProductTypeUpdateManyMutationInput = {
    itemsName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemsName?: StringFieldUpdateOperationsInput | string
    productCategoryId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductTypeSizeCreateInput = {
    size: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    aviableSizes?: ProductAviableSizesCreateNestedManyWithoutProductTypeSizeInput
    productType: ProductTypeCreateNestedOneWithoutSizesInput
  }

  export type ProductTypeSizeUncheckedCreateInput = {
    id?: number
    size: string
    ietmsId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    aviableSizes?: ProductAviableSizesUncheckedCreateNestedManyWithoutProductTypeSizeInput
  }

  export type ProductTypeSizeUpdateInput = {
    size?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aviableSizes?: ProductAviableSizesUpdateManyWithoutProductTypeSizeNestedInput
    productType?: ProductTypeUpdateOneRequiredWithoutSizesNestedInput
  }

  export type ProductTypeSizeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    size?: StringFieldUpdateOperationsInput | string
    ietmsId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aviableSizes?: ProductAviableSizesUncheckedUpdateManyWithoutProductTypeSizeNestedInput
  }

  export type ProductTypeSizeCreateManyInput = {
    id?: number
    size: string
    ietmsId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ProductTypeSizeUpdateManyMutationInput = {
    size?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductTypeSizeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    size?: StringFieldUpdateOperationsInput | string
    ietmsId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GenderCreateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    productCategory?: ProductCategoryCreateNestedManyWithoutGenderInput
    user?: UserCreateNestedManyWithoutGenderInput
  }

  export type GenderUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    productCategory?: ProductCategoryUncheckedCreateNestedManyWithoutGenderInput
    user?: UserUncheckedCreateNestedManyWithoutGenderInput
  }

  export type GenderUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productCategory?: ProductCategoryUpdateManyWithoutGenderNestedInput
    user?: UserUpdateManyWithoutGenderNestedInput
  }

  export type GenderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productCategory?: ProductCategoryUncheckedUpdateManyWithoutGenderNestedInput
    user?: UserUncheckedUpdateManyWithoutGenderNestedInput
  }

  export type GenderCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type GenderUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GenderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CountryCreateInput = {
    name: string
    timezoneOffset: number
    dialCode: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    state?: StateCreateNestedManyWithoutCountryInput
  }

  export type CountryUncheckedCreateInput = {
    id?: number
    name: string
    timezoneOffset: number
    dialCode: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    state?: StateUncheckedCreateNestedManyWithoutCountryInput
  }

  export type CountryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    timezoneOffset?: IntFieldUpdateOperationsInput | number
    dialCode?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    state?: StateUpdateManyWithoutCountryNestedInput
  }

  export type CountryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    timezoneOffset?: IntFieldUpdateOperationsInput | number
    dialCode?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    state?: StateUncheckedUpdateManyWithoutCountryNestedInput
  }

  export type CountryCreateManyInput = {
    id?: number
    name: string
    timezoneOffset: number
    dialCode: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type CountryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    timezoneOffset?: IntFieldUpdateOperationsInput | number
    dialCode?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CountryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    timezoneOffset?: IntFieldUpdateOperationsInput | number
    dialCode?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StateCreateInput = {
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    country: CountryCreateNestedOneWithoutStateInput
    district?: AddressCreateNestedManyWithoutStateInput
  }

  export type StateUncheckedCreateInput = {
    id?: number
    name: string
    countryId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    district?: AddressUncheckedCreateNestedManyWithoutStateInput
  }

  export type StateUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: CountryUpdateOneRequiredWithoutStateNestedInput
    district?: AddressUpdateManyWithoutStateNestedInput
  }

  export type StateUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    countryId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    district?: AddressUncheckedUpdateManyWithoutStateNestedInput
  }

  export type StateCreateManyInput = {
    id?: number
    name: string
    countryId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type StateUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StateUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    countryId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AddressCreateInput = {
    doorNumber: string
    streetName: string
    pinCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    state: StateCreateNestedOneWithoutDistrictInput
    userAddress?: UserAddressCreateNestedManyWithoutAddressInput
  }

  export type AddressUncheckedCreateInput = {
    id?: number
    doorNumber: string
    streetName: string
    pinCode: string
    stateId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userAddress?: UserAddressUncheckedCreateNestedManyWithoutAddressInput
  }

  export type AddressUpdateInput = {
    doorNumber?: StringFieldUpdateOperationsInput | string
    streetName?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    state?: StateUpdateOneRequiredWithoutDistrictNestedInput
    userAddress?: UserAddressUpdateManyWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    doorNumber?: StringFieldUpdateOperationsInput | string
    streetName?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    stateId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userAddress?: UserAddressUncheckedUpdateManyWithoutAddressNestedInput
  }

  export type AddressCreateManyInput = {
    id?: number
    doorNumber: string
    streetName: string
    pinCode: string
    stateId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AddressUpdateManyMutationInput = {
    doorNumber?: StringFieldUpdateOperationsInput | string
    streetName?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AddressUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    doorNumber?: StringFieldUpdateOperationsInput | string
    streetName?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    stateId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserAddressCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    address: AddressCreateNestedOneWithoutUserAddressInput
    user: UserCreateNestedOneWithoutUserAddressInput
  }

  export type UserAddressUncheckedCreateInput = {
    id?: number
    addressId: number
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UserAddressUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: AddressUpdateOneRequiredWithoutUserAddressNestedInput
    user?: UserUpdateOneRequiredWithoutUserAddressNestedInput
  }

  export type UserAddressUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    addressId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserAddressCreateManyInput = {
    id?: number
    addressId: number
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UserAddressUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserAddressUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    addressId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCreateInput = {
    username: string
    email: string
    mobile: string
    token?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userProduct?: ProductCreateNestedManyWithoutUserInput
    userAddress?: UserAddressCreateNestedManyWithoutUserInput
    addCart?: CartCreateNestedManyWithoutUserInput
    wishlist?: WishlistCreateNestedManyWithoutUserInput
    loginRequests?: UserLoginRequestCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewCreateNestedManyWithoutUserInput
    order?: OrderCreateNestedManyWithoutUserInput
    userSearchItems?: SearchItemsCreateNestedManyWithoutUserInput
    password?: UserPasswordCreateNestedManyWithoutUserInput
    roles?: RolesCreateNestedOneWithoutUserInput
    gender: GenderCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    username: string
    email: string
    mobile: string
    token?: string | null
    roleId?: number
    genderId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userProduct?: ProductUncheckedCreateNestedManyWithoutUserInput
    userAddress?: UserAddressUncheckedCreateNestedManyWithoutUserInput
    addCart?: CartUncheckedCreateNestedManyWithoutUserInput
    wishlist?: WishlistUncheckedCreateNestedManyWithoutUserInput
    loginRequests?: UserLoginRequestUncheckedCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewUncheckedCreateNestedManyWithoutUserInput
    order?: OrderUncheckedCreateNestedManyWithoutUserInput
    userSearchItems?: SearchItemsUncheckedCreateNestedManyWithoutUserInput
    password?: UserPasswordUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userProduct?: ProductUpdateManyWithoutUserNestedInput
    userAddress?: UserAddressUpdateManyWithoutUserNestedInput
    addCart?: CartUpdateManyWithoutUserNestedInput
    wishlist?: WishlistUpdateManyWithoutUserNestedInput
    loginRequests?: UserLoginRequestUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUpdateManyWithoutUserNestedInput
    order?: OrderUpdateManyWithoutUserNestedInput
    userSearchItems?: SearchItemsUpdateManyWithoutUserNestedInput
    password?: UserPasswordUpdateManyWithoutUserNestedInput
    roles?: RolesUpdateOneRequiredWithoutUserNestedInput
    gender?: GenderUpdateOneRequiredWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: IntFieldUpdateOperationsInput | number
    genderId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userProduct?: ProductUncheckedUpdateManyWithoutUserNestedInput
    userAddress?: UserAddressUncheckedUpdateManyWithoutUserNestedInput
    addCart?: CartUncheckedUpdateManyWithoutUserNestedInput
    wishlist?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    loginRequests?: UserLoginRequestUncheckedUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUncheckedUpdateManyWithoutUserNestedInput
    order?: OrderUncheckedUpdateManyWithoutUserNestedInput
    userSearchItems?: SearchItemsUncheckedUpdateManyWithoutUserNestedInput
    password?: UserPasswordUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    username: string
    email: string
    mobile: string
    token?: string | null
    roleId?: number
    genderId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: IntFieldUpdateOperationsInput | number
    genderId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductOwnerCreateInput = {
    syncUserId: number
    ownerName: string
    ownerEmail: string
    ownerMobile: string
    storeName: string
    storeAddress: string
    storeCity: string
    storePincode: string
    storeState: string
    customerCareEmail: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    product?: ProductCreateNestedManyWithoutProductOwnerInput
  }

  export type ProductOwnerUncheckedCreateInput = {
    id?: number
    syncUserId: number
    ownerName: string
    ownerEmail: string
    ownerMobile: string
    storeName: string
    storeAddress: string
    storeCity: string
    storePincode: string
    storeState: string
    customerCareEmail: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    product?: ProductUncheckedCreateNestedManyWithoutProductOwnerInput
  }

  export type ProductOwnerUpdateInput = {
    syncUserId?: IntFieldUpdateOperationsInput | number
    ownerName?: StringFieldUpdateOperationsInput | string
    ownerEmail?: StringFieldUpdateOperationsInput | string
    ownerMobile?: StringFieldUpdateOperationsInput | string
    storeName?: StringFieldUpdateOperationsInput | string
    storeAddress?: StringFieldUpdateOperationsInput | string
    storeCity?: StringFieldUpdateOperationsInput | string
    storePincode?: StringFieldUpdateOperationsInput | string
    storeState?: StringFieldUpdateOperationsInput | string
    customerCareEmail?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    product?: ProductUpdateManyWithoutProductOwnerNestedInput
  }

  export type ProductOwnerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    syncUserId?: IntFieldUpdateOperationsInput | number
    ownerName?: StringFieldUpdateOperationsInput | string
    ownerEmail?: StringFieldUpdateOperationsInput | string
    ownerMobile?: StringFieldUpdateOperationsInput | string
    storeName?: StringFieldUpdateOperationsInput | string
    storeAddress?: StringFieldUpdateOperationsInput | string
    storeCity?: StringFieldUpdateOperationsInput | string
    storePincode?: StringFieldUpdateOperationsInput | string
    storeState?: StringFieldUpdateOperationsInput | string
    customerCareEmail?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    product?: ProductUncheckedUpdateManyWithoutProductOwnerNestedInput
  }

  export type ProductOwnerCreateManyInput = {
    id?: number
    syncUserId: number
    ownerName: string
    ownerEmail: string
    ownerMobile: string
    storeName: string
    storeAddress: string
    storeCity: string
    storePincode: string
    storeState: string
    customerCareEmail: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ProductOwnerUpdateManyMutationInput = {
    syncUserId?: IntFieldUpdateOperationsInput | number
    ownerName?: StringFieldUpdateOperationsInput | string
    ownerEmail?: StringFieldUpdateOperationsInput | string
    ownerMobile?: StringFieldUpdateOperationsInput | string
    storeName?: StringFieldUpdateOperationsInput | string
    storeAddress?: StringFieldUpdateOperationsInput | string
    storeCity?: StringFieldUpdateOperationsInput | string
    storePincode?: StringFieldUpdateOperationsInput | string
    storeState?: StringFieldUpdateOperationsInput | string
    customerCareEmail?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductOwnerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    syncUserId?: IntFieldUpdateOperationsInput | number
    ownerName?: StringFieldUpdateOperationsInput | string
    ownerEmail?: StringFieldUpdateOperationsInput | string
    ownerMobile?: StringFieldUpdateOperationsInput | string
    storeName?: StringFieldUpdateOperationsInput | string
    storeAddress?: StringFieldUpdateOperationsInput | string
    storeCity?: StringFieldUpdateOperationsInput | string
    storePincode?: StringFieldUpdateOperationsInput | string
    storeState?: StringFieldUpdateOperationsInput | string
    customerCareEmail?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserPasswordCreateInput = {
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutPasswordInput
  }

  export type UserPasswordUncheckedCreateInput = {
    id?: number
    password: string
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UserPasswordUpdateInput = {
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutPasswordNestedInput
  }

  export type UserPasswordUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserPasswordCreateManyInput = {
    id?: number
    password: string
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UserPasswordUpdateManyMutationInput = {
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserPasswordUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SearchItemsCreateInput = {
    searchName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    User: UserCreateNestedOneWithoutUserSearchItemsInput
  }

  export type SearchItemsUncheckedCreateInput = {
    id?: number
    searchName: string
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type SearchItemsUpdateInput = {
    searchName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    User?: UserUpdateOneRequiredWithoutUserSearchItemsNestedInput
  }

  export type SearchItemsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    searchName?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SearchItemsCreateManyInput = {
    id?: number
    searchName: string
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type SearchItemsUpdateManyMutationInput = {
    searchName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SearchItemsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    searchName?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutOrderInput
    product: ProductCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateInput = {
    id?: number
    userId: number
    productId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type OrderUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutOrderNestedInput
    product?: ProductUpdateOneRequiredWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderCreateManyInput = {
    id?: number
    userId: number
    productId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type OrderUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserLoginRequestCreateInput = {
    email: string
    mobile?: string | null
    otp: string
    isUsed?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutLoginRequestsInput
  }

  export type UserLoginRequestUncheckedCreateInput = {
    id?: number
    userId: number
    email: string
    mobile?: string | null
    otp: string
    isUsed?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UserLoginRequestUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutLoginRequestsNestedInput
  }

  export type UserLoginRequestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserLoginRequestCreateManyInput = {
    id?: number
    userId: number
    email: string
    mobile?: string | null
    otp: string
    isUsed?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UserLoginRequestUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserLoginRequestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductCreateInput = {
    syncId: number
    title: string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    isActive?: boolean
    color?: ProductColorCreateNestedManyWithoutProductInput
    offer?: OfferCreateNestedManyWithoutProductInput
    seasonalDresses?: SeasonalDressesCreateNestedManyWithoutProductInput
    productType: ProductTypeCreateNestedOneWithoutProductInput
    user?: UserCreateNestedOneWithoutUserProductInput
    priceHistory?: PriceHistoryCreateNestedManyWithoutProductInput
    commonDescription?: CommonDescriptionCreateNestedManyWithoutProductInput
    delivery?: DeleveryPeriodCreateNestedManyWithoutProductInput
    returns?: ReturnedProductCreateNestedManyWithoutProductInput
    cart?: CartCreateNestedManyWithoutProductInput
    wishlistItem?: WishlistItemCreateNestedManyWithoutProductInput
    productReviews?: ProductReviewCreateNestedManyWithoutProductInput
    order?: OrderCreateNestedManyWithoutProductInput
    productOwner?: ProductOwnerCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: number
    syncId: number
    title: string
    price: number
    productTypeId: number
    productOwnerId?: number | null
    userId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    isActive?: boolean
    color?: ProductColorUncheckedCreateNestedManyWithoutProductInput
    offer?: OfferUncheckedCreateNestedManyWithoutProductInput
    seasonalDresses?: SeasonalDressesUncheckedCreateNestedManyWithoutProductInput
    priceHistory?: PriceHistoryUncheckedCreateNestedManyWithoutProductInput
    commonDescription?: CommonDescriptionUncheckedCreateNestedManyWithoutProductInput
    delivery?: DeleveryPeriodUncheckedCreateNestedManyWithoutProductInput
    returns?: ReturnedProductUncheckedCreateNestedManyWithoutProductInput
    cart?: CartUncheckedCreateNestedManyWithoutProductInput
    wishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutProductInput
    productReviews?: ProductReviewUncheckedCreateNestedManyWithoutProductInput
    order?: OrderUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    syncId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    color?: ProductColorUpdateManyWithoutProductNestedInput
    offer?: OfferUpdateManyWithoutProductNestedInput
    seasonalDresses?: SeasonalDressesUpdateManyWithoutProductNestedInput
    productType?: ProductTypeUpdateOneRequiredWithoutProductNestedInput
    user?: UserUpdateOneWithoutUserProductNestedInput
    priceHistory?: PriceHistoryUpdateManyWithoutProductNestedInput
    commonDescription?: CommonDescriptionUpdateManyWithoutProductNestedInput
    delivery?: DeleveryPeriodUpdateManyWithoutProductNestedInput
    returns?: ReturnedProductUpdateManyWithoutProductNestedInput
    cart?: CartUpdateManyWithoutProductNestedInput
    wishlistItem?: WishlistItemUpdateManyWithoutProductNestedInput
    productReviews?: ProductReviewUpdateManyWithoutProductNestedInput
    order?: OrderUpdateManyWithoutProductNestedInput
    productOwner?: ProductOwnerUpdateOneWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    syncId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    productTypeId?: IntFieldUpdateOperationsInput | number
    productOwnerId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    color?: ProductColorUncheckedUpdateManyWithoutProductNestedInput
    offer?: OfferUncheckedUpdateManyWithoutProductNestedInput
    seasonalDresses?: SeasonalDressesUncheckedUpdateManyWithoutProductNestedInput
    priceHistory?: PriceHistoryUncheckedUpdateManyWithoutProductNestedInput
    commonDescription?: CommonDescriptionUncheckedUpdateManyWithoutProductNestedInput
    delivery?: DeleveryPeriodUncheckedUpdateManyWithoutProductNestedInput
    returns?: ReturnedProductUncheckedUpdateManyWithoutProductNestedInput
    cart?: CartUncheckedUpdateManyWithoutProductNestedInput
    wishlistItem?: WishlistItemUncheckedUpdateManyWithoutProductNestedInput
    productReviews?: ProductReviewUncheckedUpdateManyWithoutProductNestedInput
    order?: OrderUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: number
    syncId: number
    title: string
    price: number
    productTypeId: number
    productOwnerId?: number | null
    userId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    isActive?: boolean
  }

  export type ProductUpdateManyMutationInput = {
    syncId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    syncId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    productTypeId?: IntFieldUpdateOperationsInput | number
    productOwnerId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductReviewCreateInput = {
    review: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    product: ProductCreateNestedOneWithoutProductReviewsInput
    user: UserCreateNestedOneWithoutProductReviewInput
  }

  export type ProductReviewUncheckedCreateInput = {
    id?: number
    productId: number
    userId: number
    review: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ProductReviewUpdateInput = {
    review?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    product?: ProductUpdateOneRequiredWithoutProductReviewsNestedInput
    user?: UserUpdateOneRequiredWithoutProductReviewNestedInput
  }

  export type ProductReviewUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    review?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductReviewCreateManyInput = {
    id?: number
    productId: number
    userId: number
    review: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ProductReviewUpdateManyMutationInput = {
    review?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductReviewUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    review?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReturnedProductCreateInput = {
    returns: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    product: ProductCreateNestedOneWithoutReturnsInput
  }

  export type ReturnedProductUncheckedCreateInput = {
    id?: number
    productId: number
    returns: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ReturnedProductUpdateInput = {
    returns?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    product?: ProductUpdateOneRequiredWithoutReturnsNestedInput
  }

  export type ReturnedProductUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    returns?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReturnedProductCreateManyInput = {
    id?: number
    productId: number
    returns: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ReturnedProductUpdateManyMutationInput = {
    returns?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReturnedProductUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    returns?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DeleveryPeriodCreateInput = {
    deliveryForMetroCitys: number
    deliveryForOtherCitys: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    product: ProductCreateNestedOneWithoutDeliveryInput
  }

  export type DeleveryPeriodUncheckedCreateInput = {
    id?: number
    productId: number
    deliveryForMetroCitys: number
    deliveryForOtherCitys: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type DeleveryPeriodUpdateInput = {
    deliveryForMetroCitys?: IntFieldUpdateOperationsInput | number
    deliveryForOtherCitys?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    product?: ProductUpdateOneRequiredWithoutDeliveryNestedInput
  }

  export type DeleveryPeriodUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    deliveryForMetroCitys?: IntFieldUpdateOperationsInput | number
    deliveryForOtherCitys?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DeleveryPeriodCreateManyInput = {
    id?: number
    productId: number
    deliveryForMetroCitys: number
    deliveryForOtherCitys: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type DeleveryPeriodUpdateManyMutationInput = {
    deliveryForMetroCitys?: IntFieldUpdateOperationsInput | number
    deliveryForOtherCitys?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DeleveryPeriodUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    deliveryForMetroCitys?: IntFieldUpdateOperationsInput | number
    deliveryForOtherCitys?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductColorCreateInput = {
    colors: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    product: ProductCreateNestedOneWithoutColorInput
    colorSize?: ProductAviableSizesCreateNestedManyWithoutProductColorInput
    productImages?: ProductImagesCreateNestedManyWithoutProductColorInput
  }

  export type ProductColorUncheckedCreateInput = {
    id?: number
    productId: number
    colors: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    colorSize?: ProductAviableSizesUncheckedCreateNestedManyWithoutProductColorInput
    productImages?: ProductImagesUncheckedCreateNestedManyWithoutProductColorInput
  }

  export type ProductColorUpdateInput = {
    colors?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    product?: ProductUpdateOneRequiredWithoutColorNestedInput
    colorSize?: ProductAviableSizesUpdateManyWithoutProductColorNestedInput
    productImages?: ProductImagesUpdateManyWithoutProductColorNestedInput
  }

  export type ProductColorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    colors?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    colorSize?: ProductAviableSizesUncheckedUpdateManyWithoutProductColorNestedInput
    productImages?: ProductImagesUncheckedUpdateManyWithoutProductColorNestedInput
  }

  export type ProductColorCreateManyInput = {
    id?: number
    productId: number
    colors: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ProductColorUpdateManyMutationInput = {
    colors?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductColorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    colors?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PriceHistoryCreateInput = {
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    Product: ProductCreateNestedOneWithoutPriceHistoryInput
  }

  export type PriceHistoryUncheckedCreateInput = {
    id?: number
    price: number
    productId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PriceHistoryUpdateInput = {
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Product?: ProductUpdateOneRequiredWithoutPriceHistoryNestedInput
  }

  export type PriceHistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PriceHistoryCreateManyInput = {
    id?: number
    price: number
    productId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PriceHistoryUpdateManyMutationInput = {
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PriceHistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductAviableSizesCreateInput = {
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    history?: QuantityHistoryCreateNestedManyWithoutProductAviableSizesInput
    productColor: ProductColorCreateNestedOneWithoutColorSizeInput
    productTypeSize: ProductTypeSizeCreateNestedOneWithoutAviableSizesInput
  }

  export type ProductAviableSizesUncheckedCreateInput = {
    id?: number
    quantity: number
    productColorId: number
    productTypeSizeId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    history?: QuantityHistoryUncheckedCreateNestedManyWithoutProductAviableSizesInput
  }

  export type ProductAviableSizesUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    history?: QuantityHistoryUpdateManyWithoutProductAviableSizesNestedInput
    productColor?: ProductColorUpdateOneRequiredWithoutColorSizeNestedInput
    productTypeSize?: ProductTypeSizeUpdateOneRequiredWithoutAviableSizesNestedInput
  }

  export type ProductAviableSizesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    productColorId?: IntFieldUpdateOperationsInput | number
    productTypeSizeId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    history?: QuantityHistoryUncheckedUpdateManyWithoutProductAviableSizesNestedInput
  }

  export type ProductAviableSizesCreateManyInput = {
    id?: number
    quantity: number
    productColorId: number
    productTypeSizeId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ProductAviableSizesUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductAviableSizesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    productColorId?: IntFieldUpdateOperationsInput | number
    productTypeSizeId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SeasonalDressesCreateInput = {
    seasonal: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    product: ProductCreateNestedOneWithoutSeasonalDressesInput
  }

  export type SeasonalDressesUncheckedCreateInput = {
    id?: number
    seasonal: string
    productId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type SeasonalDressesUpdateInput = {
    seasonal?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    product?: ProductUpdateOneRequiredWithoutSeasonalDressesNestedInput
  }

  export type SeasonalDressesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    seasonal?: StringFieldUpdateOperationsInput | string
    productId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SeasonalDressesCreateManyInput = {
    id?: number
    seasonal: string
    productId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type SeasonalDressesUpdateManyMutationInput = {
    seasonal?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SeasonalDressesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    seasonal?: StringFieldUpdateOperationsInput | string
    productId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductImagesCreateInput = {
    imageUrl: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    productColor?: ProductColorCreateNestedOneWithoutProductImagesInput
  }

  export type ProductImagesUncheckedCreateInput = {
    id?: number
    imageUrl: string
    productColorId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ProductImagesUpdateInput = {
    imageUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productColor?: ProductColorUpdateOneWithoutProductImagesNestedInput
  }

  export type ProductImagesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    imageUrl?: StringFieldUpdateOperationsInput | string
    productColorId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductImagesCreateManyInput = {
    id?: number
    imageUrl: string
    productColorId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ProductImagesUpdateManyMutationInput = {
    imageUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductImagesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    imageUrl?: StringFieldUpdateOperationsInput | string
    productColorId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CommonDescriptionCreateInput = {
    fit?: string | null
    materail: string
    care: string
    brandName: string
    origin: string
    occasion: string
    specialFeature?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    product: ProductCreateNestedOneWithoutCommonDescriptionInput
    topDescription?: TopDescriptionCreateNestedManyWithoutCommonDescriptionInput
    pantDescription?: BottomDescriptionCreateNestedManyWithoutCommonDescriptionInput
    kurtasDescription?: KurtasDescriptionCreateNestedManyWithoutCommonDescriptionInput
    shoesDescription?: ShoesDescriptionCreateNestedManyWithoutCommonDescriptionInput
    innerDescription?: InnersDescriptionCreateNestedManyWithoutCommonDescriptionInput
    watchesDescription?: WatchesDescriptionCreateNestedManyWithoutCommonDescriptionInput
    perfumesDescription?: PerfumesDescriptionCreateNestedManyWithoutCommonDescriptionInput
  }

  export type CommonDescriptionUncheckedCreateInput = {
    id?: number
    fit?: string | null
    materail: string
    care: string
    brandName: string
    origin: string
    productId: number
    occasion: string
    specialFeature?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    topDescription?: TopDescriptionUncheckedCreateNestedManyWithoutCommonDescriptionInput
    pantDescription?: BottomDescriptionUncheckedCreateNestedManyWithoutCommonDescriptionInput
    kurtasDescription?: KurtasDescriptionUncheckedCreateNestedManyWithoutCommonDescriptionInput
    shoesDescription?: ShoesDescriptionUncheckedCreateNestedManyWithoutCommonDescriptionInput
    innerDescription?: InnersDescriptionUncheckedCreateNestedManyWithoutCommonDescriptionInput
    watchesDescription?: WatchesDescriptionUncheckedCreateNestedManyWithoutCommonDescriptionInput
    perfumesDescription?: PerfumesDescriptionUncheckedCreateNestedManyWithoutCommonDescriptionInput
  }

  export type CommonDescriptionUpdateInput = {
    fit?: NullableStringFieldUpdateOperationsInput | string | null
    materail?: StringFieldUpdateOperationsInput | string
    care?: StringFieldUpdateOperationsInput | string
    brandName?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    occasion?: StringFieldUpdateOperationsInput | string
    specialFeature?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    product?: ProductUpdateOneRequiredWithoutCommonDescriptionNestedInput
    topDescription?: TopDescriptionUpdateManyWithoutCommonDescriptionNestedInput
    pantDescription?: BottomDescriptionUpdateManyWithoutCommonDescriptionNestedInput
    kurtasDescription?: KurtasDescriptionUpdateManyWithoutCommonDescriptionNestedInput
    shoesDescription?: ShoesDescriptionUpdateManyWithoutCommonDescriptionNestedInput
    innerDescription?: InnersDescriptionUpdateManyWithoutCommonDescriptionNestedInput
    watchesDescription?: WatchesDescriptionUpdateManyWithoutCommonDescriptionNestedInput
    perfumesDescription?: PerfumesDescriptionUpdateManyWithoutCommonDescriptionNestedInput
  }

  export type CommonDescriptionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fit?: NullableStringFieldUpdateOperationsInput | string | null
    materail?: StringFieldUpdateOperationsInput | string
    care?: StringFieldUpdateOperationsInput | string
    brandName?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    productId?: IntFieldUpdateOperationsInput | number
    occasion?: StringFieldUpdateOperationsInput | string
    specialFeature?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    topDescription?: TopDescriptionUncheckedUpdateManyWithoutCommonDescriptionNestedInput
    pantDescription?: BottomDescriptionUncheckedUpdateManyWithoutCommonDescriptionNestedInput
    kurtasDescription?: KurtasDescriptionUncheckedUpdateManyWithoutCommonDescriptionNestedInput
    shoesDescription?: ShoesDescriptionUncheckedUpdateManyWithoutCommonDescriptionNestedInput
    innerDescription?: InnersDescriptionUncheckedUpdateManyWithoutCommonDescriptionNestedInput
    watchesDescription?: WatchesDescriptionUncheckedUpdateManyWithoutCommonDescriptionNestedInput
    perfumesDescription?: PerfumesDescriptionUncheckedUpdateManyWithoutCommonDescriptionNestedInput
  }

  export type CommonDescriptionCreateManyInput = {
    id?: number
    fit?: string | null
    materail: string
    care: string
    brandName: string
    origin: string
    productId: number
    occasion: string
    specialFeature?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type CommonDescriptionUpdateManyMutationInput = {
    fit?: NullableStringFieldUpdateOperationsInput | string | null
    materail?: StringFieldUpdateOperationsInput | string
    care?: StringFieldUpdateOperationsInput | string
    brandName?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    occasion?: StringFieldUpdateOperationsInput | string
    specialFeature?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CommonDescriptionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fit?: NullableStringFieldUpdateOperationsInput | string | null
    materail?: StringFieldUpdateOperationsInput | string
    care?: StringFieldUpdateOperationsInput | string
    brandName?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    productId?: IntFieldUpdateOperationsInput | number
    occasion?: StringFieldUpdateOperationsInput | string
    specialFeature?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TopDescriptionCreateInput = {
    productDescription?: string | null
    weight?: number | null
    chest: number
    shoulder: number
    type?: string | null
    colorFamily?: string | null
    printAndPattern?: string | null
    length: number
    pocket: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    commonDescription?: CommonDescriptionCreateNestedOneWithoutTopDescriptionInput
    sleeveType: SleeveTypeCreateNestedOneWithoutTopDescriptionInput
    neckType: NeckTypeCreateNestedOneWithoutTopDescriptionInput
    bottomDescription?: BottomDescriptionCreateNestedManyWithoutTopDescriptionInput
  }

  export type TopDescriptionUncheckedCreateInput = {
    id?: number
    productDescription?: string | null
    sleeveTypeId: number
    weight?: number | null
    chest: number
    shoulder: number
    neckTypeId: number
    type?: string | null
    colorFamily?: string | null
    printAndPattern?: string | null
    length: number
    pocket: string
    commonDescriptionId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    bottomDescription?: BottomDescriptionUncheckedCreateNestedManyWithoutTopDescriptionInput
  }

  export type TopDescriptionUpdateInput = {
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    chest?: IntFieldUpdateOperationsInput | number
    shoulder?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    printAndPattern?: NullableStringFieldUpdateOperationsInput | string | null
    length?: IntFieldUpdateOperationsInput | number
    pocket?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commonDescription?: CommonDescriptionUpdateOneWithoutTopDescriptionNestedInput
    sleeveType?: SleeveTypeUpdateOneRequiredWithoutTopDescriptionNestedInput
    neckType?: NeckTypeUpdateOneRequiredWithoutTopDescriptionNestedInput
    bottomDescription?: BottomDescriptionUpdateManyWithoutTopDescriptionNestedInput
  }

  export type TopDescriptionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    sleeveTypeId?: IntFieldUpdateOperationsInput | number
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    chest?: IntFieldUpdateOperationsInput | number
    shoulder?: IntFieldUpdateOperationsInput | number
    neckTypeId?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    printAndPattern?: NullableStringFieldUpdateOperationsInput | string | null
    length?: IntFieldUpdateOperationsInput | number
    pocket?: StringFieldUpdateOperationsInput | string
    commonDescriptionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bottomDescription?: BottomDescriptionUncheckedUpdateManyWithoutTopDescriptionNestedInput
  }

  export type TopDescriptionCreateManyInput = {
    id?: number
    productDescription?: string | null
    sleeveTypeId: number
    weight?: number | null
    chest: number
    shoulder: number
    neckTypeId: number
    type?: string | null
    colorFamily?: string | null
    printAndPattern?: string | null
    length: number
    pocket: string
    commonDescriptionId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type TopDescriptionUpdateManyMutationInput = {
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    chest?: IntFieldUpdateOperationsInput | number
    shoulder?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    printAndPattern?: NullableStringFieldUpdateOperationsInput | string | null
    length?: IntFieldUpdateOperationsInput | number
    pocket?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TopDescriptionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    sleeveTypeId?: IntFieldUpdateOperationsInput | number
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    chest?: IntFieldUpdateOperationsInput | number
    shoulder?: IntFieldUpdateOperationsInput | number
    neckTypeId?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    printAndPattern?: NullableStringFieldUpdateOperationsInput | string | null
    length?: IntFieldUpdateOperationsInput | number
    pocket?: StringFieldUpdateOperationsInput | string
    commonDescriptionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BottomDescriptionCreateInput = {
    productDescription?: string | null
    weight?: number | null
    printAndPattern: string
    length: number
    waist: number
    hip: number
    type?: string | null
    colorFamily?: string | null
    pocket?: string | null
    beltLoop?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    typesOfPants: TypesOfBottomCreateNestedOneWithoutDescriptionInput
    typesOfPleats: TypesOfPleatsCreateNestedOneWithoutDescriptionInput
    typesOfLength: TypesOfLengthBottomCreateNestedOneWithoutDescriptionInput
    commonDescription: CommonDescriptionCreateNestedOneWithoutPantDescriptionInput
    kurtasDescription?: KurtasDescriptionCreateNestedOneWithoutBottomDescriptionInput
    topDescription?: TopDescriptionCreateNestedOneWithoutBottomDescriptionInput
  }

  export type BottomDescriptionUncheckedCreateInput = {
    id?: number
    productDescription?: string | null
    weight?: number | null
    printAndPattern: string
    length: number
    waist: number
    hip: number
    commonDescriptionId: number
    type?: string | null
    colorFamily?: string | null
    pocket?: string | null
    kurtasDescriptionId?: number | null
    topDescriptionId?: number | null
    beltLoop?: boolean
    typeOfPantId: number
    typesOfPleatsId: number
    typesOfLengthId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type BottomDescriptionUpdateInput = {
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    printAndPattern?: StringFieldUpdateOperationsInput | string
    length?: IntFieldUpdateOperationsInput | number
    waist?: IntFieldUpdateOperationsInput | number
    hip?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    pocket?: NullableStringFieldUpdateOperationsInput | string | null
    beltLoop?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    typesOfPants?: TypesOfBottomUpdateOneRequiredWithoutDescriptionNestedInput
    typesOfPleats?: TypesOfPleatsUpdateOneRequiredWithoutDescriptionNestedInput
    typesOfLength?: TypesOfLengthBottomUpdateOneRequiredWithoutDescriptionNestedInput
    commonDescription?: CommonDescriptionUpdateOneRequiredWithoutPantDescriptionNestedInput
    kurtasDescription?: KurtasDescriptionUpdateOneWithoutBottomDescriptionNestedInput
    topDescription?: TopDescriptionUpdateOneWithoutBottomDescriptionNestedInput
  }

  export type BottomDescriptionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    printAndPattern?: StringFieldUpdateOperationsInput | string
    length?: IntFieldUpdateOperationsInput | number
    waist?: IntFieldUpdateOperationsInput | number
    hip?: IntFieldUpdateOperationsInput | number
    commonDescriptionId?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    pocket?: NullableStringFieldUpdateOperationsInput | string | null
    kurtasDescriptionId?: NullableIntFieldUpdateOperationsInput | number | null
    topDescriptionId?: NullableIntFieldUpdateOperationsInput | number | null
    beltLoop?: BoolFieldUpdateOperationsInput | boolean
    typeOfPantId?: IntFieldUpdateOperationsInput | number
    typesOfPleatsId?: IntFieldUpdateOperationsInput | number
    typesOfLengthId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BottomDescriptionCreateManyInput = {
    id?: number
    productDescription?: string | null
    weight?: number | null
    printAndPattern: string
    length: number
    waist: number
    hip: number
    commonDescriptionId: number
    type?: string | null
    colorFamily?: string | null
    pocket?: string | null
    kurtasDescriptionId?: number | null
    topDescriptionId?: number | null
    beltLoop?: boolean
    typeOfPantId: number
    typesOfPleatsId: number
    typesOfLengthId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type BottomDescriptionUpdateManyMutationInput = {
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    printAndPattern?: StringFieldUpdateOperationsInput | string
    length?: IntFieldUpdateOperationsInput | number
    waist?: IntFieldUpdateOperationsInput | number
    hip?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    pocket?: NullableStringFieldUpdateOperationsInput | string | null
    beltLoop?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BottomDescriptionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    printAndPattern?: StringFieldUpdateOperationsInput | string
    length?: IntFieldUpdateOperationsInput | number
    waist?: IntFieldUpdateOperationsInput | number
    hip?: IntFieldUpdateOperationsInput | number
    commonDescriptionId?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    pocket?: NullableStringFieldUpdateOperationsInput | string | null
    kurtasDescriptionId?: NullableIntFieldUpdateOperationsInput | number | null
    topDescriptionId?: NullableIntFieldUpdateOperationsInput | number | null
    beltLoop?: BoolFieldUpdateOperationsInput | boolean
    typeOfPantId?: IntFieldUpdateOperationsInput | number
    typesOfPleatsId?: IntFieldUpdateOperationsInput | number
    typesOfLengthId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type KurtasDescriptionCreateInput = {
    work?: string | null
    productDescription: string
    chest: number
    shoulder: number
    transparencyOfTheFabric?: boolean
    weight?: number | null
    colorFamily?: string | null
    pocket: string
    type: string
    printAndpattern?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    kurtasLengthType: KurtasLengthTypeCreateNestedOneWithoutKurtasDescriptionInput
    neckType: NeckTypeCreateNestedOneWithoutKurtasDescriptionInput
    sleeveType: SleeveTypeCreateNestedOneWithoutKurtasDescriptionInput
    commonDescription: CommonDescriptionCreateNestedOneWithoutKurtasDescriptionInput
    bottomDescription?: BottomDescriptionCreateNestedManyWithoutKurtasDescriptionInput
  }

  export type KurtasDescriptionUncheckedCreateInput = {
    id?: number
    work?: string | null
    productDescription: string
    chest: number
    shoulder: number
    transparencyOfTheFabric?: boolean
    kurtasLengthTypeId: number
    weight?: number | null
    colorFamily?: string | null
    pocket: string
    type: string
    printAndpattern?: string | null
    kurtasNeckTypeId: number
    kurtasSleeveTypeId: number
    commonDescriptionId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    bottomDescription?: BottomDescriptionUncheckedCreateNestedManyWithoutKurtasDescriptionInput
  }

  export type KurtasDescriptionUpdateInput = {
    work?: NullableStringFieldUpdateOperationsInput | string | null
    productDescription?: StringFieldUpdateOperationsInput | string
    chest?: IntFieldUpdateOperationsInput | number
    shoulder?: IntFieldUpdateOperationsInput | number
    transparencyOfTheFabric?: BoolFieldUpdateOperationsInput | boolean
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    pocket?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    printAndpattern?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kurtasLengthType?: KurtasLengthTypeUpdateOneRequiredWithoutKurtasDescriptionNestedInput
    neckType?: NeckTypeUpdateOneRequiredWithoutKurtasDescriptionNestedInput
    sleeveType?: SleeveTypeUpdateOneRequiredWithoutKurtasDescriptionNestedInput
    commonDescription?: CommonDescriptionUpdateOneRequiredWithoutKurtasDescriptionNestedInput
    bottomDescription?: BottomDescriptionUpdateManyWithoutKurtasDescriptionNestedInput
  }

  export type KurtasDescriptionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    work?: NullableStringFieldUpdateOperationsInput | string | null
    productDescription?: StringFieldUpdateOperationsInput | string
    chest?: IntFieldUpdateOperationsInput | number
    shoulder?: IntFieldUpdateOperationsInput | number
    transparencyOfTheFabric?: BoolFieldUpdateOperationsInput | boolean
    kurtasLengthTypeId?: IntFieldUpdateOperationsInput | number
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    pocket?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    printAndpattern?: NullableStringFieldUpdateOperationsInput | string | null
    kurtasNeckTypeId?: IntFieldUpdateOperationsInput | number
    kurtasSleeveTypeId?: IntFieldUpdateOperationsInput | number
    commonDescriptionId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bottomDescription?: BottomDescriptionUncheckedUpdateManyWithoutKurtasDescriptionNestedInput
  }

  export type KurtasDescriptionCreateManyInput = {
    id?: number
    work?: string | null
    productDescription: string
    chest: number
    shoulder: number
    transparencyOfTheFabric?: boolean
    kurtasLengthTypeId: number
    weight?: number | null
    colorFamily?: string | null
    pocket: string
    type: string
    printAndpattern?: string | null
    kurtasNeckTypeId: number
    kurtasSleeveTypeId: number
    commonDescriptionId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type KurtasDescriptionUpdateManyMutationInput = {
    work?: NullableStringFieldUpdateOperationsInput | string | null
    productDescription?: StringFieldUpdateOperationsInput | string
    chest?: IntFieldUpdateOperationsInput | number
    shoulder?: IntFieldUpdateOperationsInput | number
    transparencyOfTheFabric?: BoolFieldUpdateOperationsInput | boolean
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    pocket?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    printAndpattern?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type KurtasDescriptionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    work?: NullableStringFieldUpdateOperationsInput | string | null
    productDescription?: StringFieldUpdateOperationsInput | string
    chest?: IntFieldUpdateOperationsInput | number
    shoulder?: IntFieldUpdateOperationsInput | number
    transparencyOfTheFabric?: BoolFieldUpdateOperationsInput | boolean
    kurtasLengthTypeId?: IntFieldUpdateOperationsInput | number
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    pocket?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    printAndpattern?: NullableStringFieldUpdateOperationsInput | string | null
    kurtasNeckTypeId?: IntFieldUpdateOperationsInput | number
    kurtasSleeveTypeId?: IntFieldUpdateOperationsInput | number
    commonDescriptionId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ShoesDescriptionCreateInput = {
    pattern?: string | null
    footLength: string
    type: string
    soleMaterial?: string | null
    printAndPattern?: string | null
    upperMaterial?: string | null
    closure?: string | null
    toeType: string
    weight?: number | null
    colorFamily?: string | null
    productDescription?: string | null
    packageContains?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    warranty?: WarrantyCreateNestedManyWithoutShoesDescriptionInput
    commonDescription: CommonDescriptionCreateNestedOneWithoutShoesDescriptionInput
  }

  export type ShoesDescriptionUncheckedCreateInput = {
    id?: number
    pattern?: string | null
    footLength: string
    type: string
    soleMaterial?: string | null
    printAndPattern?: string | null
    upperMaterial?: string | null
    closure?: string | null
    toeType: string
    weight?: number | null
    colorFamily?: string | null
    productDescription?: string | null
    packageContains?: number | null
    commonDescriptionId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    warranty?: WarrantyUncheckedCreateNestedManyWithoutShoesDescriptionInput
  }

  export type ShoesDescriptionUpdateInput = {
    pattern?: NullableStringFieldUpdateOperationsInput | string | null
    footLength?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    soleMaterial?: NullableStringFieldUpdateOperationsInput | string | null
    printAndPattern?: NullableStringFieldUpdateOperationsInput | string | null
    upperMaterial?: NullableStringFieldUpdateOperationsInput | string | null
    closure?: NullableStringFieldUpdateOperationsInput | string | null
    toeType?: StringFieldUpdateOperationsInput | string
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    packageContains?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warranty?: WarrantyUpdateManyWithoutShoesDescriptionNestedInput
    commonDescription?: CommonDescriptionUpdateOneRequiredWithoutShoesDescriptionNestedInput
  }

  export type ShoesDescriptionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pattern?: NullableStringFieldUpdateOperationsInput | string | null
    footLength?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    soleMaterial?: NullableStringFieldUpdateOperationsInput | string | null
    printAndPattern?: NullableStringFieldUpdateOperationsInput | string | null
    upperMaterial?: NullableStringFieldUpdateOperationsInput | string | null
    closure?: NullableStringFieldUpdateOperationsInput | string | null
    toeType?: StringFieldUpdateOperationsInput | string
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    packageContains?: NullableIntFieldUpdateOperationsInput | number | null
    commonDescriptionId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warranty?: WarrantyUncheckedUpdateManyWithoutShoesDescriptionNestedInput
  }

  export type ShoesDescriptionCreateManyInput = {
    id?: number
    pattern?: string | null
    footLength: string
    type: string
    soleMaterial?: string | null
    printAndPattern?: string | null
    upperMaterial?: string | null
    closure?: string | null
    toeType: string
    weight?: number | null
    colorFamily?: string | null
    productDescription?: string | null
    packageContains?: number | null
    commonDescriptionId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ShoesDescriptionUpdateManyMutationInput = {
    pattern?: NullableStringFieldUpdateOperationsInput | string | null
    footLength?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    soleMaterial?: NullableStringFieldUpdateOperationsInput | string | null
    printAndPattern?: NullableStringFieldUpdateOperationsInput | string | null
    upperMaterial?: NullableStringFieldUpdateOperationsInput | string | null
    closure?: NullableStringFieldUpdateOperationsInput | string | null
    toeType?: StringFieldUpdateOperationsInput | string
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    packageContains?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ShoesDescriptionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pattern?: NullableStringFieldUpdateOperationsInput | string | null
    footLength?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    soleMaterial?: NullableStringFieldUpdateOperationsInput | string | null
    printAndPattern?: NullableStringFieldUpdateOperationsInput | string | null
    upperMaterial?: NullableStringFieldUpdateOperationsInput | string | null
    closure?: NullableStringFieldUpdateOperationsInput | string | null
    toeType?: StringFieldUpdateOperationsInput | string
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    packageContains?: NullableIntFieldUpdateOperationsInput | number | null
    commonDescriptionId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WatchesDescriptionCreateInput = {
    type?: string | null
    weight: number
    model: string
    dialShape: string
    printAndPattern?: string | null
    dialDiameter: string
    dialColor: string
    strapColor: string
    colorFamily?: string | null
    productDescription?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    warranty?: WarrantyCreateNestedManyWithoutWatchesInput
    commonDescription: CommonDescriptionCreateNestedOneWithoutWatchesDescriptionInput
  }

  export type WatchesDescriptionUncheckedCreateInput = {
    id?: number
    type?: string | null
    weight: number
    model: string
    dialShape: string
    printAndPattern?: string | null
    dialDiameter: string
    dialColor: string
    strapColor: string
    colorFamily?: string | null
    productDescription?: string | null
    commonDescriptionId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    warranty?: WarrantyUncheckedCreateNestedManyWithoutWatchesInput
  }

  export type WatchesDescriptionUpdateInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: IntFieldUpdateOperationsInput | number
    model?: StringFieldUpdateOperationsInput | string
    dialShape?: StringFieldUpdateOperationsInput | string
    printAndPattern?: NullableStringFieldUpdateOperationsInput | string | null
    dialDiameter?: StringFieldUpdateOperationsInput | string
    dialColor?: StringFieldUpdateOperationsInput | string
    strapColor?: StringFieldUpdateOperationsInput | string
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warranty?: WarrantyUpdateManyWithoutWatchesNestedInput
    commonDescription?: CommonDescriptionUpdateOneRequiredWithoutWatchesDescriptionNestedInput
  }

  export type WatchesDescriptionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: IntFieldUpdateOperationsInput | number
    model?: StringFieldUpdateOperationsInput | string
    dialShape?: StringFieldUpdateOperationsInput | string
    printAndPattern?: NullableStringFieldUpdateOperationsInput | string | null
    dialDiameter?: StringFieldUpdateOperationsInput | string
    dialColor?: StringFieldUpdateOperationsInput | string
    strapColor?: StringFieldUpdateOperationsInput | string
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    commonDescriptionId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warranty?: WarrantyUncheckedUpdateManyWithoutWatchesNestedInput
  }

  export type WatchesDescriptionCreateManyInput = {
    id?: number
    type?: string | null
    weight: number
    model: string
    dialShape: string
    printAndPattern?: string | null
    dialDiameter: string
    dialColor: string
    strapColor: string
    colorFamily?: string | null
    productDescription?: string | null
    commonDescriptionId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type WatchesDescriptionUpdateManyMutationInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: IntFieldUpdateOperationsInput | number
    model?: StringFieldUpdateOperationsInput | string
    dialShape?: StringFieldUpdateOperationsInput | string
    printAndPattern?: NullableStringFieldUpdateOperationsInput | string | null
    dialDiameter?: StringFieldUpdateOperationsInput | string
    dialColor?: StringFieldUpdateOperationsInput | string
    strapColor?: StringFieldUpdateOperationsInput | string
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WatchesDescriptionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: IntFieldUpdateOperationsInput | number
    model?: StringFieldUpdateOperationsInput | string
    dialShape?: StringFieldUpdateOperationsInput | string
    printAndPattern?: NullableStringFieldUpdateOperationsInput | string | null
    dialDiameter?: StringFieldUpdateOperationsInput | string
    dialColor?: StringFieldUpdateOperationsInput | string
    strapColor?: StringFieldUpdateOperationsInput | string
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    commonDescriptionId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PerfumesDescriptionCreateInput = {
    productDescription: string
    type?: string | null
    materialDescription: string
    weight: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    commonDescription: CommonDescriptionCreateNestedOneWithoutPerfumesDescriptionInput
  }

  export type PerfumesDescriptionUncheckedCreateInput = {
    id?: number
    productDescription: string
    type?: string | null
    materialDescription: string
    weight: number
    commonDescriptionId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PerfumesDescriptionUpdateInput = {
    productDescription?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    materialDescription?: StringFieldUpdateOperationsInput | string
    weight?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commonDescription?: CommonDescriptionUpdateOneRequiredWithoutPerfumesDescriptionNestedInput
  }

  export type PerfumesDescriptionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productDescription?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    materialDescription?: StringFieldUpdateOperationsInput | string
    weight?: IntFieldUpdateOperationsInput | number
    commonDescriptionId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PerfumesDescriptionCreateManyInput = {
    id?: number
    productDescription: string
    type?: string | null
    materialDescription: string
    weight: number
    commonDescriptionId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PerfumesDescriptionUpdateManyMutationInput = {
    productDescription?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    materialDescription?: StringFieldUpdateOperationsInput | string
    weight?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PerfumesDescriptionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productDescription?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    materialDescription?: StringFieldUpdateOperationsInput | string
    weight?: IntFieldUpdateOperationsInput | number
    commonDescriptionId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InnersDescriptionCreateInput = {
    type: string
    productDescription: string
    weight?: number | null
    length: number
    waistRise: number
    printAndPattern?: string | null
    packageContains: number
    lookAndFeel: string
    colorFamily?: string | null
    multiColors?: boolean
    sleeveType?: SleeveTypeCreateNestedOneWithoutInnersDescriptionInput
    neckType?: NeckTypeCreateNestedOneWithoutInnersDescriptionInput
    commonDescription: CommonDescriptionCreateNestedOneWithoutInnerDescriptionInput
  }

  export type InnersDescriptionUncheckedCreateInput = {
    id?: number
    type: string
    productDescription: string
    weight?: number | null
    length: number
    waistRise: number
    printAndPattern?: string | null
    packageContains: number
    lookAndFeel: string
    colorFamily?: string | null
    vestsSleeveTypeId?: number | null
    vestsNeckTypeId?: number | null
    commonDescriptionId: number
    multiColors?: boolean
  }

  export type InnersDescriptionUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    productDescription?: StringFieldUpdateOperationsInput | string
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    length?: IntFieldUpdateOperationsInput | number
    waistRise?: IntFieldUpdateOperationsInput | number
    printAndPattern?: NullableStringFieldUpdateOperationsInput | string | null
    packageContains?: IntFieldUpdateOperationsInput | number
    lookAndFeel?: StringFieldUpdateOperationsInput | string
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    multiColors?: BoolFieldUpdateOperationsInput | boolean
    sleeveType?: SleeveTypeUpdateOneWithoutInnersDescriptionNestedInput
    neckType?: NeckTypeUpdateOneWithoutInnersDescriptionNestedInput
    commonDescription?: CommonDescriptionUpdateOneRequiredWithoutInnerDescriptionNestedInput
  }

  export type InnersDescriptionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    productDescription?: StringFieldUpdateOperationsInput | string
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    length?: IntFieldUpdateOperationsInput | number
    waistRise?: IntFieldUpdateOperationsInput | number
    printAndPattern?: NullableStringFieldUpdateOperationsInput | string | null
    packageContains?: IntFieldUpdateOperationsInput | number
    lookAndFeel?: StringFieldUpdateOperationsInput | string
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    vestsSleeveTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    vestsNeckTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    commonDescriptionId?: IntFieldUpdateOperationsInput | number
    multiColors?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InnersDescriptionCreateManyInput = {
    id?: number
    type: string
    productDescription: string
    weight?: number | null
    length: number
    waistRise: number
    printAndPattern?: string | null
    packageContains: number
    lookAndFeel: string
    colorFamily?: string | null
    vestsSleeveTypeId?: number | null
    vestsNeckTypeId?: number | null
    commonDescriptionId: number
    multiColors?: boolean
  }

  export type InnersDescriptionUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    productDescription?: StringFieldUpdateOperationsInput | string
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    length?: IntFieldUpdateOperationsInput | number
    waistRise?: IntFieldUpdateOperationsInput | number
    printAndPattern?: NullableStringFieldUpdateOperationsInput | string | null
    packageContains?: IntFieldUpdateOperationsInput | number
    lookAndFeel?: StringFieldUpdateOperationsInput | string
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    multiColors?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InnersDescriptionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    productDescription?: StringFieldUpdateOperationsInput | string
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    length?: IntFieldUpdateOperationsInput | number
    waistRise?: IntFieldUpdateOperationsInput | number
    printAndPattern?: NullableStringFieldUpdateOperationsInput | string | null
    packageContains?: IntFieldUpdateOperationsInput | number
    lookAndFeel?: StringFieldUpdateOperationsInput | string
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    vestsSleeveTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    vestsNeckTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    commonDescriptionId?: IntFieldUpdateOperationsInput | number
    multiColors?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WarrantyCreateInput = {
    warrantyPeriod: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    shoesDescription?: ShoesDescriptionCreateNestedOneWithoutWarrantyInput
    watches?: WatchesDescriptionCreateNestedOneWithoutWarrantyInput
  }

  export type WarrantyUncheckedCreateInput = {
    id?: number
    shoesDescriptionId?: number | null
    watchsId?: number | null
    warrantyPeriod: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type WarrantyUpdateInput = {
    warrantyPeriod?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shoesDescription?: ShoesDescriptionUpdateOneWithoutWarrantyNestedInput
    watches?: WatchesDescriptionUpdateOneWithoutWarrantyNestedInput
  }

  export type WarrantyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    shoesDescriptionId?: NullableIntFieldUpdateOperationsInput | number | null
    watchsId?: NullableIntFieldUpdateOperationsInput | number | null
    warrantyPeriod?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WarrantyCreateManyInput = {
    id?: number
    shoesDescriptionId?: number | null
    watchsId?: number | null
    warrantyPeriod: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type WarrantyUpdateManyMutationInput = {
    warrantyPeriod?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WarrantyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    shoesDescriptionId?: NullableIntFieldUpdateOperationsInput | number | null
    watchsId?: NullableIntFieldUpdateOperationsInput | number | null
    warrantyPeriod?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SleeveTypeCreateInput = {
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    kurtasDescription?: KurtasDescriptionCreateNestedManyWithoutSleeveTypeInput
    innersDescription?: InnersDescriptionCreateNestedManyWithoutSleeveTypeInput
    topDescription?: TopDescriptionCreateNestedManyWithoutSleeveTypeInput
  }

  export type SleeveTypeUncheckedCreateInput = {
    id?: number
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    kurtasDescription?: KurtasDescriptionUncheckedCreateNestedManyWithoutSleeveTypeInput
    innersDescription?: InnersDescriptionUncheckedCreateNestedManyWithoutSleeveTypeInput
    topDescription?: TopDescriptionUncheckedCreateNestedManyWithoutSleeveTypeInput
  }

  export type SleeveTypeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kurtasDescription?: KurtasDescriptionUpdateManyWithoutSleeveTypeNestedInput
    innersDescription?: InnersDescriptionUpdateManyWithoutSleeveTypeNestedInput
    topDescription?: TopDescriptionUpdateManyWithoutSleeveTypeNestedInput
  }

  export type SleeveTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kurtasDescription?: KurtasDescriptionUncheckedUpdateManyWithoutSleeveTypeNestedInput
    innersDescription?: InnersDescriptionUncheckedUpdateManyWithoutSleeveTypeNestedInput
    topDescription?: TopDescriptionUncheckedUpdateManyWithoutSleeveTypeNestedInput
  }

  export type SleeveTypeCreateManyInput = {
    id?: number
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type SleeveTypeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SleeveTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NeckTypeCreateInput = {
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    kurtasDescription?: KurtasDescriptionCreateNestedManyWithoutNeckTypeInput
    innersDescription?: InnersDescriptionCreateNestedManyWithoutNeckTypeInput
    topDescription?: TopDescriptionCreateNestedManyWithoutNeckTypeInput
  }

  export type NeckTypeUncheckedCreateInput = {
    id?: number
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    kurtasDescription?: KurtasDescriptionUncheckedCreateNestedManyWithoutNeckTypeInput
    innersDescription?: InnersDescriptionUncheckedCreateNestedManyWithoutNeckTypeInput
    topDescription?: TopDescriptionUncheckedCreateNestedManyWithoutNeckTypeInput
  }

  export type NeckTypeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kurtasDescription?: KurtasDescriptionUpdateManyWithoutNeckTypeNestedInput
    innersDescription?: InnersDescriptionUpdateManyWithoutNeckTypeNestedInput
    topDescription?: TopDescriptionUpdateManyWithoutNeckTypeNestedInput
  }

  export type NeckTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kurtasDescription?: KurtasDescriptionUncheckedUpdateManyWithoutNeckTypeNestedInput
    innersDescription?: InnersDescriptionUncheckedUpdateManyWithoutNeckTypeNestedInput
    topDescription?: TopDescriptionUncheckedUpdateManyWithoutNeckTypeNestedInput
  }

  export type NeckTypeCreateManyInput = {
    id?: number
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type NeckTypeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NeckTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type KurtasLengthTypeCreateInput = {
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    kurtasDescription?: KurtasDescriptionCreateNestedManyWithoutKurtasLengthTypeInput
  }

  export type KurtasLengthTypeUncheckedCreateInput = {
    id?: number
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    kurtasDescription?: KurtasDescriptionUncheckedCreateNestedManyWithoutKurtasLengthTypeInput
  }

  export type KurtasLengthTypeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kurtasDescription?: KurtasDescriptionUpdateManyWithoutKurtasLengthTypeNestedInput
  }

  export type KurtasLengthTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kurtasDescription?: KurtasDescriptionUncheckedUpdateManyWithoutKurtasLengthTypeNestedInput
  }

  export type KurtasLengthTypeCreateManyInput = {
    id?: number
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type KurtasLengthTypeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type KurtasLengthTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TypesOfBottomCreateInput = {
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    description?: BottomDescriptionCreateNestedManyWithoutTypesOfPantsInput
  }

  export type TypesOfBottomUncheckedCreateInput = {
    id?: number
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    description?: BottomDescriptionUncheckedCreateNestedManyWithoutTypesOfPantsInput
  }

  export type TypesOfBottomUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: BottomDescriptionUpdateManyWithoutTypesOfPantsNestedInput
  }

  export type TypesOfBottomUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: BottomDescriptionUncheckedUpdateManyWithoutTypesOfPantsNestedInput
  }

  export type TypesOfBottomCreateManyInput = {
    id?: number
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type TypesOfBottomUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TypesOfBottomUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TypesOfPleatsCreateInput = {
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    description?: BottomDescriptionCreateNestedManyWithoutTypesOfPleatsInput
  }

  export type TypesOfPleatsUncheckedCreateInput = {
    id?: number
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    description?: BottomDescriptionUncheckedCreateNestedManyWithoutTypesOfPleatsInput
  }

  export type TypesOfPleatsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: BottomDescriptionUpdateManyWithoutTypesOfPleatsNestedInput
  }

  export type TypesOfPleatsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: BottomDescriptionUncheckedUpdateManyWithoutTypesOfPleatsNestedInput
  }

  export type TypesOfPleatsCreateManyInput = {
    id?: number
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type TypesOfPleatsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TypesOfPleatsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TypesOfLengthBottomCreateInput = {
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    description?: BottomDescriptionCreateNestedManyWithoutTypesOfLengthInput
  }

  export type TypesOfLengthBottomUncheckedCreateInput = {
    id?: number
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    description?: BottomDescriptionUncheckedCreateNestedManyWithoutTypesOfLengthInput
  }

  export type TypesOfLengthBottomUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: BottomDescriptionUpdateManyWithoutTypesOfLengthNestedInput
  }

  export type TypesOfLengthBottomUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: BottomDescriptionUncheckedUpdateManyWithoutTypesOfLengthNestedInput
  }

  export type TypesOfLengthBottomCreateManyInput = {
    id?: number
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type TypesOfLengthBottomUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TypesOfLengthBottomUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuantityHistoryCreateInput = {
    quantity: number
    timestamp?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    productAviableSizes: ProductAviableSizesCreateNestedOneWithoutHistoryInput
  }

  export type QuantityHistoryUncheckedCreateInput = {
    id?: number
    quantity: number
    productAviableSizesId: number
    timestamp?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type QuantityHistoryUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productAviableSizes?: ProductAviableSizesUpdateOneRequiredWithoutHistoryNestedInput
  }

  export type QuantityHistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    productAviableSizesId?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuantityHistoryCreateManyInput = {
    id?: number
    quantity: number
    productAviableSizesId: number
    timestamp?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type QuantityHistoryUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuantityHistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    productAviableSizesId?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OfferCreateInput = {
    offerPercntage: number
    offerPrice: number
    currentPrice: number
    offerQuantity: number
    currentQuantity: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    product: ProductCreateNestedOneWithoutOfferInput
    offerValidity?: OfferValidityCreateNestedManyWithoutOfferInput
  }

  export type OfferUncheckedCreateInput = {
    id?: number
    productId: number
    offerPercntage: number
    offerPrice: number
    currentPrice: number
    offerQuantity: number
    currentQuantity: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    offerValidity?: OfferValidityUncheckedCreateNestedManyWithoutOfferInput
  }

  export type OfferUpdateInput = {
    offerPercntage?: FloatFieldUpdateOperationsInput | number
    offerPrice?: FloatFieldUpdateOperationsInput | number
    currentPrice?: FloatFieldUpdateOperationsInput | number
    offerQuantity?: IntFieldUpdateOperationsInput | number
    currentQuantity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    product?: ProductUpdateOneRequiredWithoutOfferNestedInput
    offerValidity?: OfferValidityUpdateManyWithoutOfferNestedInput
  }

  export type OfferUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    offerPercntage?: FloatFieldUpdateOperationsInput | number
    offerPrice?: FloatFieldUpdateOperationsInput | number
    currentPrice?: FloatFieldUpdateOperationsInput | number
    offerQuantity?: IntFieldUpdateOperationsInput | number
    currentQuantity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    offerValidity?: OfferValidityUncheckedUpdateManyWithoutOfferNestedInput
  }

  export type OfferCreateManyInput = {
    id?: number
    productId: number
    offerPercntage: number
    offerPrice: number
    currentPrice: number
    offerQuantity: number
    currentQuantity: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type OfferUpdateManyMutationInput = {
    offerPercntage?: FloatFieldUpdateOperationsInput | number
    offerPrice?: FloatFieldUpdateOperationsInput | number
    currentPrice?: FloatFieldUpdateOperationsInput | number
    offerQuantity?: IntFieldUpdateOperationsInput | number
    currentQuantity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OfferUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    offerPercntage?: FloatFieldUpdateOperationsInput | number
    offerPrice?: FloatFieldUpdateOperationsInput | number
    currentPrice?: FloatFieldUpdateOperationsInput | number
    offerQuantity?: IntFieldUpdateOperationsInput | number
    currentQuantity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OfferValidityCreateInput = {
    fromDate: Date | string
    toDate: Date | string
    fromTime: Date | string
    toTime: Date | string
    monday: boolean
    tuesday: boolean
    wednesday: boolean
    thursday: boolean
    friday: boolean
    saturday: boolean
    sunday: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    offer?: OfferCreateNestedOneWithoutOfferValidityInput
    offerPromotionPeriod?: OfferPromotionPeriodsCreateNestedOneWithoutOfferValidityInput
  }

  export type OfferValidityUncheckedCreateInput = {
    id?: number
    fromDate: Date | string
    toDate: Date | string
    fromTime: Date | string
    toTime: Date | string
    monday: boolean
    tuesday: boolean
    wednesday: boolean
    thursday: boolean
    friday: boolean
    saturday: boolean
    sunday: boolean
    offerId: number
    offerPromotionPeriodId?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type OfferValidityUpdateInput = {
    fromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    toDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fromTime?: DateTimeFieldUpdateOperationsInput | Date | string
    toTime?: DateTimeFieldUpdateOperationsInput | Date | string
    monday?: BoolFieldUpdateOperationsInput | boolean
    tuesday?: BoolFieldUpdateOperationsInput | boolean
    wednesday?: BoolFieldUpdateOperationsInput | boolean
    thursday?: BoolFieldUpdateOperationsInput | boolean
    friday?: BoolFieldUpdateOperationsInput | boolean
    saturday?: BoolFieldUpdateOperationsInput | boolean
    sunday?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    offer?: OfferUpdateOneWithoutOfferValidityNestedInput
    offerPromotionPeriod?: OfferPromotionPeriodsUpdateOneWithoutOfferValidityNestedInput
  }

  export type OfferValidityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    toDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fromTime?: DateTimeFieldUpdateOperationsInput | Date | string
    toTime?: DateTimeFieldUpdateOperationsInput | Date | string
    monday?: BoolFieldUpdateOperationsInput | boolean
    tuesday?: BoolFieldUpdateOperationsInput | boolean
    wednesday?: BoolFieldUpdateOperationsInput | boolean
    thursday?: BoolFieldUpdateOperationsInput | boolean
    friday?: BoolFieldUpdateOperationsInput | boolean
    saturday?: BoolFieldUpdateOperationsInput | boolean
    sunday?: BoolFieldUpdateOperationsInput | boolean
    offerId?: IntFieldUpdateOperationsInput | number
    offerPromotionPeriodId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OfferValidityCreateManyInput = {
    id?: number
    fromDate: Date | string
    toDate: Date | string
    fromTime: Date | string
    toTime: Date | string
    monday: boolean
    tuesday: boolean
    wednesday: boolean
    thursday: boolean
    friday: boolean
    saturday: boolean
    sunday: boolean
    offerId: number
    offerPromotionPeriodId?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type OfferValidityUpdateManyMutationInput = {
    fromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    toDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fromTime?: DateTimeFieldUpdateOperationsInput | Date | string
    toTime?: DateTimeFieldUpdateOperationsInput | Date | string
    monday?: BoolFieldUpdateOperationsInput | boolean
    tuesday?: BoolFieldUpdateOperationsInput | boolean
    wednesday?: BoolFieldUpdateOperationsInput | boolean
    thursday?: BoolFieldUpdateOperationsInput | boolean
    friday?: BoolFieldUpdateOperationsInput | boolean
    saturday?: BoolFieldUpdateOperationsInput | boolean
    sunday?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OfferValidityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    toDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fromTime?: DateTimeFieldUpdateOperationsInput | Date | string
    toTime?: DateTimeFieldUpdateOperationsInput | Date | string
    monday?: BoolFieldUpdateOperationsInput | boolean
    tuesday?: BoolFieldUpdateOperationsInput | boolean
    wednesday?: BoolFieldUpdateOperationsInput | boolean
    thursday?: BoolFieldUpdateOperationsInput | boolean
    friday?: BoolFieldUpdateOperationsInput | boolean
    saturday?: BoolFieldUpdateOperationsInput | boolean
    sunday?: BoolFieldUpdateOperationsInput | boolean
    offerId?: IntFieldUpdateOperationsInput | number
    offerPromotionPeriodId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OfferPromotionPeriodsCreateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    offerValidity?: OfferValidityCreateNestedOneWithoutOfferPromotionPeriodInput
  }

  export type OfferPromotionPeriodsUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    offerValidity?: OfferValidityUncheckedCreateNestedOneWithoutOfferPromotionPeriodInput
  }

  export type OfferPromotionPeriodsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    offerValidity?: OfferValidityUpdateOneWithoutOfferPromotionPeriodNestedInput
  }

  export type OfferPromotionPeriodsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    offerValidity?: OfferValidityUncheckedUpdateOneWithoutOfferPromotionPeriodNestedInput
  }

  export type OfferPromotionPeriodsCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type OfferPromotionPeriodsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OfferPromotionPeriodsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CartCreateInput = {
    isCheckedOut: boolean
    isRemoved: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutAddCartInput
    product: ProductCreateNestedOneWithoutCartInput
  }

  export type CartUncheckedCreateInput = {
    id?: number
    userId: number
    productId: number
    isCheckedOut: boolean
    isRemoved: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type CartUpdateInput = {
    isCheckedOut?: BoolFieldUpdateOperationsInput | boolean
    isRemoved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutAddCartNestedInput
    product?: ProductUpdateOneRequiredWithoutCartNestedInput
  }

  export type CartUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    isCheckedOut?: BoolFieldUpdateOperationsInput | boolean
    isRemoved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CartCreateManyInput = {
    id?: number
    userId: number
    productId: number
    isCheckedOut: boolean
    isRemoved: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type CartUpdateManyMutationInput = {
    isCheckedOut?: BoolFieldUpdateOperationsInput | boolean
    isRemoved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CartUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    isCheckedOut?: BoolFieldUpdateOperationsInput | boolean
    isRemoved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WishlistCreateInput = {
    items?: WishlistItemCreateNestedManyWithoutWishlistInput
    user: UserCreateNestedOneWithoutWishlistInput
  }

  export type WishlistUncheckedCreateInput = {
    id?: number
    userId: number
    items?: WishlistItemUncheckedCreateNestedManyWithoutWishlistInput
  }

  export type WishlistUpdateInput = {
    items?: WishlistItemUpdateManyWithoutWishlistNestedInput
    user?: UserUpdateOneRequiredWithoutWishlistNestedInput
  }

  export type WishlistUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    items?: WishlistItemUncheckedUpdateManyWithoutWishlistNestedInput
  }

  export type WishlistCreateManyInput = {
    id?: number
    userId: number
  }

  export type WishlistUpdateManyMutationInput = {

  }

  export type WishlistUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type WishlistItemCreateInput = {
    wishlist: WishlistCreateNestedOneWithoutItemsInput
    product: ProductCreateNestedOneWithoutWishlistItemInput
  }

  export type WishlistItemUncheckedCreateInput = {
    id?: number
    wishlistId: number
    productId: number
  }

  export type WishlistItemUpdateInput = {
    wishlist?: WishlistUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutWishlistItemNestedInput
  }

  export type WishlistItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    wishlistId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
  }

  export type WishlistItemCreateManyInput = {
    id?: number
    wishlistId: number
    productId: number
  }

  export type WishlistItemUpdateManyMutationInput = {

  }

  export type WishlistItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    wishlistId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RolesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type RolesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RolesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type RolesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type RolesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type SyncDataLastIdCountOrderByAggregateInput = {
    id?: SortOrder
    lastId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type SyncDataLastIdAvgOrderByAggregateInput = {
    id?: SortOrder
    lastId?: SortOrder
  }

  export type SyncDataLastIdMaxOrderByAggregateInput = {
    id?: SortOrder
    lastId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type SyncDataLastIdMinOrderByAggregateInput = {
    id?: SortOrder
    lastId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type SyncDataLastIdSumOrderByAggregateInput = {
    id?: SortOrder
    lastId?: SortOrder
  }

  export type GenderRelationFilter = {
    is?: GenderWhereInput | null
    isNot?: GenderWhereInput | null
  }

  export type ProductTypeListRelationFilter = {
    every?: ProductTypeWhereInput
    some?: ProductTypeWhereInput
    none?: ProductTypeWhereInput
  }

  export type ProductTypeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    genderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ProductCategoryAvgOrderByAggregateInput = {
    id?: SortOrder
    genderId?: SortOrder
  }

  export type ProductCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    genderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ProductCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    genderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ProductCategorySumOrderByAggregateInput = {
    id?: SortOrder
    genderId?: SortOrder
  }

  export type ProductCategoryRelationFilter = {
    is?: ProductCategoryWhereInput | null
    isNot?: ProductCategoryWhereInput | null
  }

  export type ProductTypeSizeListRelationFilter = {
    every?: ProductTypeSizeWhereInput
    some?: ProductTypeSizeWhereInput
    none?: ProductTypeSizeWhereInput
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type ProductTypeSizeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductTypeCountOrderByAggregateInput = {
    id?: SortOrder
    itemsName?: SortOrder
    productCategoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ProductTypeAvgOrderByAggregateInput = {
    id?: SortOrder
    productCategoryId?: SortOrder
  }

  export type ProductTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    itemsName?: SortOrder
    productCategoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ProductTypeMinOrderByAggregateInput = {
    id?: SortOrder
    itemsName?: SortOrder
    productCategoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ProductTypeSumOrderByAggregateInput = {
    id?: SortOrder
    productCategoryId?: SortOrder
  }

  export type ProductAviableSizesListRelationFilter = {
    every?: ProductAviableSizesWhereInput
    some?: ProductAviableSizesWhereInput
    none?: ProductAviableSizesWhereInput
  }

  export type ProductTypeRelationFilter = {
    is?: ProductTypeWhereInput | null
    isNot?: ProductTypeWhereInput | null
  }

  export type ProductAviableSizesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductTypeSizeCountOrderByAggregateInput = {
    id?: SortOrder
    size?: SortOrder
    ietmsId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ProductTypeSizeAvgOrderByAggregateInput = {
    id?: SortOrder
    ietmsId?: SortOrder
  }

  export type ProductTypeSizeMaxOrderByAggregateInput = {
    id?: SortOrder
    size?: SortOrder
    ietmsId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ProductTypeSizeMinOrderByAggregateInput = {
    id?: SortOrder
    size?: SortOrder
    ietmsId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ProductTypeSizeSumOrderByAggregateInput = {
    id?: SortOrder
    ietmsId?: SortOrder
  }

  export type ProductCategoryListRelationFilter = {
    every?: ProductCategoryWhereInput
    some?: ProductCategoryWhereInput
    none?: ProductCategoryWhereInput
  }

  export type ProductCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GenderCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type GenderAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type GenderMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type GenderMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type GenderSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StateListRelationFilter = {
    every?: StateWhereInput
    some?: StateWhereInput
    none?: StateWhereInput
  }

  export type StateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CountryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    timezoneOffset?: SortOrder
    dialCode?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type CountryAvgOrderByAggregateInput = {
    id?: SortOrder
    timezoneOffset?: SortOrder
  }

  export type CountryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    timezoneOffset?: SortOrder
    dialCode?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type CountryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    timezoneOffset?: SortOrder
    dialCode?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type CountrySumOrderByAggregateInput = {
    id?: SortOrder
    timezoneOffset?: SortOrder
  }

  export type CountryRelationFilter = {
    is?: CountryWhereInput | null
    isNot?: CountryWhereInput | null
  }

  export type AddressListRelationFilter = {
    every?: AddressWhereInput
    some?: AddressWhereInput
    none?: AddressWhereInput
  }

  export type AddressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    countryId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type StateAvgOrderByAggregateInput = {
    id?: SortOrder
    countryId?: SortOrder
  }

  export type StateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    countryId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type StateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    countryId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type StateSumOrderByAggregateInput = {
    id?: SortOrder
    countryId?: SortOrder
  }

  export type StateRelationFilter = {
    is?: StateWhereInput | null
    isNot?: StateWhereInput | null
  }

  export type UserAddressListRelationFilter = {
    every?: UserAddressWhereInput
    some?: UserAddressWhereInput
    none?: UserAddressWhereInput
  }

  export type UserAddressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AddressCountOrderByAggregateInput = {
    id?: SortOrder
    doorNumber?: SortOrder
    streetName?: SortOrder
    pinCode?: SortOrder
    stateId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type AddressAvgOrderByAggregateInput = {
    id?: SortOrder
    stateId?: SortOrder
  }

  export type AddressMaxOrderByAggregateInput = {
    id?: SortOrder
    doorNumber?: SortOrder
    streetName?: SortOrder
    pinCode?: SortOrder
    stateId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type AddressMinOrderByAggregateInput = {
    id?: SortOrder
    doorNumber?: SortOrder
    streetName?: SortOrder
    pinCode?: SortOrder
    stateId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type AddressSumOrderByAggregateInput = {
    id?: SortOrder
    stateId?: SortOrder
  }

  export type AddressRelationFilter = {
    is?: AddressWhereInput | null
    isNot?: AddressWhereInput | null
  }

  export type UserRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type UserAddressCountOrderByAggregateInput = {
    id?: SortOrder
    addressId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserAddressAvgOrderByAggregateInput = {
    id?: SortOrder
    addressId?: SortOrder
    userId?: SortOrder
  }

  export type UserAddressMaxOrderByAggregateInput = {
    id?: SortOrder
    addressId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserAddressMinOrderByAggregateInput = {
    id?: SortOrder
    addressId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserAddressSumOrderByAggregateInput = {
    id?: SortOrder
    addressId?: SortOrder
    userId?: SortOrder
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type CartListRelationFilter = {
    every?: CartWhereInput
    some?: CartWhereInput
    none?: CartWhereInput
  }

  export type WishlistListRelationFilter = {
    every?: WishlistWhereInput
    some?: WishlistWhereInput
    none?: WishlistWhereInput
  }

  export type UserLoginRequestListRelationFilter = {
    every?: UserLoginRequestWhereInput
    some?: UserLoginRequestWhereInput
    none?: UserLoginRequestWhereInput
  }

  export type ProductReviewListRelationFilter = {
    every?: ProductReviewWhereInput
    some?: ProductReviewWhereInput
    none?: ProductReviewWhereInput
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type SearchItemsListRelationFilter = {
    every?: SearchItemsWhereInput
    some?: SearchItemsWhereInput
    none?: SearchItemsWhereInput
  }

  export type UserPasswordListRelationFilter = {
    every?: UserPasswordWhereInput
    some?: UserPasswordWhereInput
    none?: UserPasswordWhereInput
  }

  export type RolesRelationFilter = {
    is?: RolesWhereInput | null
    isNot?: RolesWhereInput | null
  }

  export type CartOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WishlistOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserLoginRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SearchItemsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserPasswordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    token?: SortOrder
    roleId?: SortOrder
    genderId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    genderId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    token?: SortOrder
    roleId?: SortOrder
    genderId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    token?: SortOrder
    roleId?: SortOrder
    genderId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    genderId?: SortOrder
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type ProductOwnerCountOrderByAggregateInput = {
    id?: SortOrder
    syncUserId?: SortOrder
    ownerName?: SortOrder
    ownerEmail?: SortOrder
    ownerMobile?: SortOrder
    storeName?: SortOrder
    storeAddress?: SortOrder
    storeCity?: SortOrder
    storePincode?: SortOrder
    storeState?: SortOrder
    customerCareEmail?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ProductOwnerAvgOrderByAggregateInput = {
    id?: SortOrder
    syncUserId?: SortOrder
  }

  export type ProductOwnerMaxOrderByAggregateInput = {
    id?: SortOrder
    syncUserId?: SortOrder
    ownerName?: SortOrder
    ownerEmail?: SortOrder
    ownerMobile?: SortOrder
    storeName?: SortOrder
    storeAddress?: SortOrder
    storeCity?: SortOrder
    storePincode?: SortOrder
    storeState?: SortOrder
    customerCareEmail?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ProductOwnerMinOrderByAggregateInput = {
    id?: SortOrder
    syncUserId?: SortOrder
    ownerName?: SortOrder
    ownerEmail?: SortOrder
    ownerMobile?: SortOrder
    storeName?: SortOrder
    storeAddress?: SortOrder
    storeCity?: SortOrder
    storePincode?: SortOrder
    storeState?: SortOrder
    customerCareEmail?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ProductOwnerSumOrderByAggregateInput = {
    id?: SortOrder
    syncUserId?: SortOrder
  }

  export type UserPasswordCountOrderByAggregateInput = {
    id?: SortOrder
    password?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserPasswordAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type UserPasswordMaxOrderByAggregateInput = {
    id?: SortOrder
    password?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserPasswordMinOrderByAggregateInput = {
    id?: SortOrder
    password?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserPasswordSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type SearchItemsCountOrderByAggregateInput = {
    id?: SortOrder
    searchName?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type SearchItemsAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type SearchItemsMaxOrderByAggregateInput = {
    id?: SortOrder
    searchName?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type SearchItemsMinOrderByAggregateInput = {
    id?: SortOrder
    searchName?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type SearchItemsSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type ProductRelationFilter = {
    is?: ProductWhereInput | null
    isNot?: ProductWhereInput | null
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
  }

  export type UserLoginRequestCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    otp?: SortOrder
    isUsed?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserLoginRequestAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type UserLoginRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    otp?: SortOrder
    isUsed?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserLoginRequestMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    mobile?: SortOrder
    otp?: SortOrder
    isUsed?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserLoginRequestSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type ProductColorListRelationFilter = {
    every?: ProductColorWhereInput
    some?: ProductColorWhereInput
    none?: ProductColorWhereInput
  }

  export type OfferListRelationFilter = {
    every?: OfferWhereInput
    some?: OfferWhereInput
    none?: OfferWhereInput
  }

  export type SeasonalDressesListRelationFilter = {
    every?: SeasonalDressesWhereInput
    some?: SeasonalDressesWhereInput
    none?: SeasonalDressesWhereInput
  }

  export type PriceHistoryListRelationFilter = {
    every?: PriceHistoryWhereInput
    some?: PriceHistoryWhereInput
    none?: PriceHistoryWhereInput
  }

  export type CommonDescriptionListRelationFilter = {
    every?: CommonDescriptionWhereInput
    some?: CommonDescriptionWhereInput
    none?: CommonDescriptionWhereInput
  }

  export type DeleveryPeriodListRelationFilter = {
    every?: DeleveryPeriodWhereInput
    some?: DeleveryPeriodWhereInput
    none?: DeleveryPeriodWhereInput
  }

  export type ReturnedProductListRelationFilter = {
    every?: ReturnedProductWhereInput
    some?: ReturnedProductWhereInput
    none?: ReturnedProductWhereInput
  }

  export type WishlistItemListRelationFilter = {
    every?: WishlistItemWhereInput
    some?: WishlistItemWhereInput
    none?: WishlistItemWhereInput
  }

  export type ProductOwnerRelationFilter = {
    is?: ProductOwnerWhereInput | null
    isNot?: ProductOwnerWhereInput | null
  }

  export type ProductColorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OfferOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SeasonalDressesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PriceHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommonDescriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeleveryPeriodOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReturnedProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WishlistItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    syncId?: SortOrder
    title?: SortOrder
    price?: SortOrder
    productTypeId?: SortOrder
    productOwnerId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    isActive?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    id?: SortOrder
    syncId?: SortOrder
    price?: SortOrder
    productTypeId?: SortOrder
    productOwnerId?: SortOrder
    userId?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    syncId?: SortOrder
    title?: SortOrder
    price?: SortOrder
    productTypeId?: SortOrder
    productOwnerId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    isActive?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    syncId?: SortOrder
    title?: SortOrder
    price?: SortOrder
    productTypeId?: SortOrder
    productOwnerId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    isActive?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    id?: SortOrder
    syncId?: SortOrder
    price?: SortOrder
    productTypeId?: SortOrder
    productOwnerId?: SortOrder
    userId?: SortOrder
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type ProductReviewCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    userId?: SortOrder
    review?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ProductReviewAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    userId?: SortOrder
  }

  export type ProductReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    userId?: SortOrder
    review?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ProductReviewMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    userId?: SortOrder
    review?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ProductReviewSumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    userId?: SortOrder
  }

  export type ReturnedProductCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    returns?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ReturnedProductAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    returns?: SortOrder
  }

  export type ReturnedProductMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    returns?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ReturnedProductMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    returns?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ReturnedProductSumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    returns?: SortOrder
  }

  export type DeleveryPeriodCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    deliveryForMetroCitys?: SortOrder
    deliveryForOtherCitys?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type DeleveryPeriodAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    deliveryForMetroCitys?: SortOrder
    deliveryForOtherCitys?: SortOrder
  }

  export type DeleveryPeriodMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    deliveryForMetroCitys?: SortOrder
    deliveryForOtherCitys?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type DeleveryPeriodMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    deliveryForMetroCitys?: SortOrder
    deliveryForOtherCitys?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type DeleveryPeriodSumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    deliveryForMetroCitys?: SortOrder
    deliveryForOtherCitys?: SortOrder
  }

  export type ProductImagesListRelationFilter = {
    every?: ProductImagesWhereInput
    some?: ProductImagesWhereInput
    none?: ProductImagesWhereInput
  }

  export type ProductImagesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductColorCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    colors?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ProductColorAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
  }

  export type ProductColorMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    colors?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ProductColorMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    colors?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ProductColorSumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
  }

  export type PriceHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type PriceHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    productId?: SortOrder
  }

  export type PriceHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type PriceHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type PriceHistorySumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    productId?: SortOrder
  }

  export type QuantityHistoryListRelationFilter = {
    every?: QuantityHistoryWhereInput
    some?: QuantityHistoryWhereInput
    none?: QuantityHistoryWhereInput
  }

  export type ProductColorRelationFilter = {
    is?: ProductColorWhereInput | null
    isNot?: ProductColorWhereInput | null
  }

  export type ProductTypeSizeRelationFilter = {
    is?: ProductTypeSizeWhereInput | null
    isNot?: ProductTypeSizeWhereInput | null
  }

  export type QuantityHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductAviableSizesCountOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    productColorId?: SortOrder
    productTypeSizeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ProductAviableSizesAvgOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    productColorId?: SortOrder
    productTypeSizeId?: SortOrder
  }

  export type ProductAviableSizesMaxOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    productColorId?: SortOrder
    productTypeSizeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ProductAviableSizesMinOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    productColorId?: SortOrder
    productTypeSizeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ProductAviableSizesSumOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    productColorId?: SortOrder
    productTypeSizeId?: SortOrder
  }

  export type SeasonalDressesCountOrderByAggregateInput = {
    id?: SortOrder
    seasonal?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type SeasonalDressesAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
  }

  export type SeasonalDressesMaxOrderByAggregateInput = {
    id?: SortOrder
    seasonal?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type SeasonalDressesMinOrderByAggregateInput = {
    id?: SortOrder
    seasonal?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type SeasonalDressesSumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
  }

  export type ProductImagesCountOrderByAggregateInput = {
    id?: SortOrder
    imageUrl?: SortOrder
    productColorId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ProductImagesAvgOrderByAggregateInput = {
    id?: SortOrder
    productColorId?: SortOrder
  }

  export type ProductImagesMaxOrderByAggregateInput = {
    id?: SortOrder
    imageUrl?: SortOrder
    productColorId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ProductImagesMinOrderByAggregateInput = {
    id?: SortOrder
    imageUrl?: SortOrder
    productColorId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ProductImagesSumOrderByAggregateInput = {
    id?: SortOrder
    productColorId?: SortOrder
  }

  export type TopDescriptionListRelationFilter = {
    every?: TopDescriptionWhereInput
    some?: TopDescriptionWhereInput
    none?: TopDescriptionWhereInput
  }

  export type BottomDescriptionListRelationFilter = {
    every?: BottomDescriptionWhereInput
    some?: BottomDescriptionWhereInput
    none?: BottomDescriptionWhereInput
  }

  export type KurtasDescriptionListRelationFilter = {
    every?: KurtasDescriptionWhereInput
    some?: KurtasDescriptionWhereInput
    none?: KurtasDescriptionWhereInput
  }

  export type ShoesDescriptionListRelationFilter = {
    every?: ShoesDescriptionWhereInput
    some?: ShoesDescriptionWhereInput
    none?: ShoesDescriptionWhereInput
  }

  export type InnersDescriptionListRelationFilter = {
    every?: InnersDescriptionWhereInput
    some?: InnersDescriptionWhereInput
    none?: InnersDescriptionWhereInput
  }

  export type WatchesDescriptionListRelationFilter = {
    every?: WatchesDescriptionWhereInput
    some?: WatchesDescriptionWhereInput
    none?: WatchesDescriptionWhereInput
  }

  export type PerfumesDescriptionListRelationFilter = {
    every?: PerfumesDescriptionWhereInput
    some?: PerfumesDescriptionWhereInput
    none?: PerfumesDescriptionWhereInput
  }

  export type TopDescriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BottomDescriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KurtasDescriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShoesDescriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InnersDescriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WatchesDescriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PerfumesDescriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommonDescriptionCountOrderByAggregateInput = {
    id?: SortOrder
    fit?: SortOrder
    materail?: SortOrder
    care?: SortOrder
    brandName?: SortOrder
    origin?: SortOrder
    productId?: SortOrder
    occasion?: SortOrder
    specialFeature?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type CommonDescriptionAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
  }

  export type CommonDescriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    fit?: SortOrder
    materail?: SortOrder
    care?: SortOrder
    brandName?: SortOrder
    origin?: SortOrder
    productId?: SortOrder
    occasion?: SortOrder
    specialFeature?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type CommonDescriptionMinOrderByAggregateInput = {
    id?: SortOrder
    fit?: SortOrder
    materail?: SortOrder
    care?: SortOrder
    brandName?: SortOrder
    origin?: SortOrder
    productId?: SortOrder
    occasion?: SortOrder
    specialFeature?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type CommonDescriptionSumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
  }

  export type CommonDescriptionRelationFilter = {
    is?: CommonDescriptionWhereInput | null
    isNot?: CommonDescriptionWhereInput | null
  }

  export type SleeveTypeRelationFilter = {
    is?: SleeveTypeWhereInput | null
    isNot?: SleeveTypeWhereInput | null
  }

  export type NeckTypeRelationFilter = {
    is?: NeckTypeWhereInput | null
    isNot?: NeckTypeWhereInput | null
  }

  export type TopDescriptionCountOrderByAggregateInput = {
    id?: SortOrder
    productDescription?: SortOrder
    sleeveTypeId?: SortOrder
    weight?: SortOrder
    chest?: SortOrder
    shoulder?: SortOrder
    neckTypeId?: SortOrder
    type?: SortOrder
    colorFamily?: SortOrder
    printAndPattern?: SortOrder
    length?: SortOrder
    pocket?: SortOrder
    commonDescriptionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type TopDescriptionAvgOrderByAggregateInput = {
    id?: SortOrder
    sleeveTypeId?: SortOrder
    weight?: SortOrder
    chest?: SortOrder
    shoulder?: SortOrder
    neckTypeId?: SortOrder
    length?: SortOrder
    commonDescriptionId?: SortOrder
  }

  export type TopDescriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    productDescription?: SortOrder
    sleeveTypeId?: SortOrder
    weight?: SortOrder
    chest?: SortOrder
    shoulder?: SortOrder
    neckTypeId?: SortOrder
    type?: SortOrder
    colorFamily?: SortOrder
    printAndPattern?: SortOrder
    length?: SortOrder
    pocket?: SortOrder
    commonDescriptionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type TopDescriptionMinOrderByAggregateInput = {
    id?: SortOrder
    productDescription?: SortOrder
    sleeveTypeId?: SortOrder
    weight?: SortOrder
    chest?: SortOrder
    shoulder?: SortOrder
    neckTypeId?: SortOrder
    type?: SortOrder
    colorFamily?: SortOrder
    printAndPattern?: SortOrder
    length?: SortOrder
    pocket?: SortOrder
    commonDescriptionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type TopDescriptionSumOrderByAggregateInput = {
    id?: SortOrder
    sleeveTypeId?: SortOrder
    weight?: SortOrder
    chest?: SortOrder
    shoulder?: SortOrder
    neckTypeId?: SortOrder
    length?: SortOrder
    commonDescriptionId?: SortOrder
  }

  export type TypesOfBottomRelationFilter = {
    is?: TypesOfBottomWhereInput | null
    isNot?: TypesOfBottomWhereInput | null
  }

  export type TypesOfPleatsRelationFilter = {
    is?: TypesOfPleatsWhereInput | null
    isNot?: TypesOfPleatsWhereInput | null
  }

  export type TypesOfLengthBottomRelationFilter = {
    is?: TypesOfLengthBottomWhereInput | null
    isNot?: TypesOfLengthBottomWhereInput | null
  }

  export type KurtasDescriptionRelationFilter = {
    is?: KurtasDescriptionWhereInput | null
    isNot?: KurtasDescriptionWhereInput | null
  }

  export type TopDescriptionRelationFilter = {
    is?: TopDescriptionWhereInput | null
    isNot?: TopDescriptionWhereInput | null
  }

  export type BottomDescriptionCountOrderByAggregateInput = {
    id?: SortOrder
    productDescription?: SortOrder
    weight?: SortOrder
    printAndPattern?: SortOrder
    length?: SortOrder
    waist?: SortOrder
    hip?: SortOrder
    commonDescriptionId?: SortOrder
    type?: SortOrder
    colorFamily?: SortOrder
    pocket?: SortOrder
    kurtasDescriptionId?: SortOrder
    topDescriptionId?: SortOrder
    beltLoop?: SortOrder
    typeOfPantId?: SortOrder
    typesOfPleatsId?: SortOrder
    typesOfLengthId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type BottomDescriptionAvgOrderByAggregateInput = {
    id?: SortOrder
    weight?: SortOrder
    length?: SortOrder
    waist?: SortOrder
    hip?: SortOrder
    commonDescriptionId?: SortOrder
    kurtasDescriptionId?: SortOrder
    topDescriptionId?: SortOrder
    typeOfPantId?: SortOrder
    typesOfPleatsId?: SortOrder
    typesOfLengthId?: SortOrder
  }

  export type BottomDescriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    productDescription?: SortOrder
    weight?: SortOrder
    printAndPattern?: SortOrder
    length?: SortOrder
    waist?: SortOrder
    hip?: SortOrder
    commonDescriptionId?: SortOrder
    type?: SortOrder
    colorFamily?: SortOrder
    pocket?: SortOrder
    kurtasDescriptionId?: SortOrder
    topDescriptionId?: SortOrder
    beltLoop?: SortOrder
    typeOfPantId?: SortOrder
    typesOfPleatsId?: SortOrder
    typesOfLengthId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type BottomDescriptionMinOrderByAggregateInput = {
    id?: SortOrder
    productDescription?: SortOrder
    weight?: SortOrder
    printAndPattern?: SortOrder
    length?: SortOrder
    waist?: SortOrder
    hip?: SortOrder
    commonDescriptionId?: SortOrder
    type?: SortOrder
    colorFamily?: SortOrder
    pocket?: SortOrder
    kurtasDescriptionId?: SortOrder
    topDescriptionId?: SortOrder
    beltLoop?: SortOrder
    typeOfPantId?: SortOrder
    typesOfPleatsId?: SortOrder
    typesOfLengthId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type BottomDescriptionSumOrderByAggregateInput = {
    id?: SortOrder
    weight?: SortOrder
    length?: SortOrder
    waist?: SortOrder
    hip?: SortOrder
    commonDescriptionId?: SortOrder
    kurtasDescriptionId?: SortOrder
    topDescriptionId?: SortOrder
    typeOfPantId?: SortOrder
    typesOfPleatsId?: SortOrder
    typesOfLengthId?: SortOrder
  }

  export type KurtasLengthTypeRelationFilter = {
    is?: KurtasLengthTypeWhereInput | null
    isNot?: KurtasLengthTypeWhereInput | null
  }

  export type KurtasDescriptionCountOrderByAggregateInput = {
    id?: SortOrder
    work?: SortOrder
    productDescription?: SortOrder
    chest?: SortOrder
    shoulder?: SortOrder
    transparencyOfTheFabric?: SortOrder
    kurtasLengthTypeId?: SortOrder
    weight?: SortOrder
    colorFamily?: SortOrder
    pocket?: SortOrder
    type?: SortOrder
    printAndpattern?: SortOrder
    kurtasNeckTypeId?: SortOrder
    kurtasSleeveTypeId?: SortOrder
    commonDescriptionId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type KurtasDescriptionAvgOrderByAggregateInput = {
    id?: SortOrder
    chest?: SortOrder
    shoulder?: SortOrder
    kurtasLengthTypeId?: SortOrder
    weight?: SortOrder
    kurtasNeckTypeId?: SortOrder
    kurtasSleeveTypeId?: SortOrder
    commonDescriptionId?: SortOrder
  }

  export type KurtasDescriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    work?: SortOrder
    productDescription?: SortOrder
    chest?: SortOrder
    shoulder?: SortOrder
    transparencyOfTheFabric?: SortOrder
    kurtasLengthTypeId?: SortOrder
    weight?: SortOrder
    colorFamily?: SortOrder
    pocket?: SortOrder
    type?: SortOrder
    printAndpattern?: SortOrder
    kurtasNeckTypeId?: SortOrder
    kurtasSleeveTypeId?: SortOrder
    commonDescriptionId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type KurtasDescriptionMinOrderByAggregateInput = {
    id?: SortOrder
    work?: SortOrder
    productDescription?: SortOrder
    chest?: SortOrder
    shoulder?: SortOrder
    transparencyOfTheFabric?: SortOrder
    kurtasLengthTypeId?: SortOrder
    weight?: SortOrder
    colorFamily?: SortOrder
    pocket?: SortOrder
    type?: SortOrder
    printAndpattern?: SortOrder
    kurtasNeckTypeId?: SortOrder
    kurtasSleeveTypeId?: SortOrder
    commonDescriptionId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type KurtasDescriptionSumOrderByAggregateInput = {
    id?: SortOrder
    chest?: SortOrder
    shoulder?: SortOrder
    kurtasLengthTypeId?: SortOrder
    weight?: SortOrder
    kurtasNeckTypeId?: SortOrder
    kurtasSleeveTypeId?: SortOrder
    commonDescriptionId?: SortOrder
  }

  export type WarrantyListRelationFilter = {
    every?: WarrantyWhereInput
    some?: WarrantyWhereInput
    none?: WarrantyWhereInput
  }

  export type WarrantyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShoesDescriptionCountOrderByAggregateInput = {
    id?: SortOrder
    pattern?: SortOrder
    footLength?: SortOrder
    type?: SortOrder
    soleMaterial?: SortOrder
    printAndPattern?: SortOrder
    upperMaterial?: SortOrder
    closure?: SortOrder
    toeType?: SortOrder
    weight?: SortOrder
    colorFamily?: SortOrder
    productDescription?: SortOrder
    packageContains?: SortOrder
    commonDescriptionId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ShoesDescriptionAvgOrderByAggregateInput = {
    id?: SortOrder
    weight?: SortOrder
    packageContains?: SortOrder
    commonDescriptionId?: SortOrder
  }

  export type ShoesDescriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    pattern?: SortOrder
    footLength?: SortOrder
    type?: SortOrder
    soleMaterial?: SortOrder
    printAndPattern?: SortOrder
    upperMaterial?: SortOrder
    closure?: SortOrder
    toeType?: SortOrder
    weight?: SortOrder
    colorFamily?: SortOrder
    productDescription?: SortOrder
    packageContains?: SortOrder
    commonDescriptionId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ShoesDescriptionMinOrderByAggregateInput = {
    id?: SortOrder
    pattern?: SortOrder
    footLength?: SortOrder
    type?: SortOrder
    soleMaterial?: SortOrder
    printAndPattern?: SortOrder
    upperMaterial?: SortOrder
    closure?: SortOrder
    toeType?: SortOrder
    weight?: SortOrder
    colorFamily?: SortOrder
    productDescription?: SortOrder
    packageContains?: SortOrder
    commonDescriptionId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ShoesDescriptionSumOrderByAggregateInput = {
    id?: SortOrder
    weight?: SortOrder
    packageContains?: SortOrder
    commonDescriptionId?: SortOrder
  }

  export type WatchesDescriptionCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    weight?: SortOrder
    model?: SortOrder
    dialShape?: SortOrder
    printAndPattern?: SortOrder
    dialDiameter?: SortOrder
    dialColor?: SortOrder
    strapColor?: SortOrder
    colorFamily?: SortOrder
    productDescription?: SortOrder
    commonDescriptionId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type WatchesDescriptionAvgOrderByAggregateInput = {
    id?: SortOrder
    weight?: SortOrder
    commonDescriptionId?: SortOrder
  }

  export type WatchesDescriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    weight?: SortOrder
    model?: SortOrder
    dialShape?: SortOrder
    printAndPattern?: SortOrder
    dialDiameter?: SortOrder
    dialColor?: SortOrder
    strapColor?: SortOrder
    colorFamily?: SortOrder
    productDescription?: SortOrder
    commonDescriptionId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type WatchesDescriptionMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    weight?: SortOrder
    model?: SortOrder
    dialShape?: SortOrder
    printAndPattern?: SortOrder
    dialDiameter?: SortOrder
    dialColor?: SortOrder
    strapColor?: SortOrder
    colorFamily?: SortOrder
    productDescription?: SortOrder
    commonDescriptionId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type WatchesDescriptionSumOrderByAggregateInput = {
    id?: SortOrder
    weight?: SortOrder
    commonDescriptionId?: SortOrder
  }

  export type PerfumesDescriptionCountOrderByAggregateInput = {
    id?: SortOrder
    productDescription?: SortOrder
    type?: SortOrder
    materialDescription?: SortOrder
    weight?: SortOrder
    commonDescriptionId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type PerfumesDescriptionAvgOrderByAggregateInput = {
    id?: SortOrder
    weight?: SortOrder
    commonDescriptionId?: SortOrder
  }

  export type PerfumesDescriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    productDescription?: SortOrder
    type?: SortOrder
    materialDescription?: SortOrder
    weight?: SortOrder
    commonDescriptionId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type PerfumesDescriptionMinOrderByAggregateInput = {
    id?: SortOrder
    productDescription?: SortOrder
    type?: SortOrder
    materialDescription?: SortOrder
    weight?: SortOrder
    commonDescriptionId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type PerfumesDescriptionSumOrderByAggregateInput = {
    id?: SortOrder
    weight?: SortOrder
    commonDescriptionId?: SortOrder
  }

  export type InnersDescriptionCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    productDescription?: SortOrder
    weight?: SortOrder
    length?: SortOrder
    waistRise?: SortOrder
    printAndPattern?: SortOrder
    packageContains?: SortOrder
    lookAndFeel?: SortOrder
    colorFamily?: SortOrder
    vestsSleeveTypeId?: SortOrder
    vestsNeckTypeId?: SortOrder
    commonDescriptionId?: SortOrder
    multiColors?: SortOrder
  }

  export type InnersDescriptionAvgOrderByAggregateInput = {
    id?: SortOrder
    weight?: SortOrder
    length?: SortOrder
    waistRise?: SortOrder
    packageContains?: SortOrder
    vestsSleeveTypeId?: SortOrder
    vestsNeckTypeId?: SortOrder
    commonDescriptionId?: SortOrder
  }

  export type InnersDescriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    productDescription?: SortOrder
    weight?: SortOrder
    length?: SortOrder
    waistRise?: SortOrder
    printAndPattern?: SortOrder
    packageContains?: SortOrder
    lookAndFeel?: SortOrder
    colorFamily?: SortOrder
    vestsSleeveTypeId?: SortOrder
    vestsNeckTypeId?: SortOrder
    commonDescriptionId?: SortOrder
    multiColors?: SortOrder
  }

  export type InnersDescriptionMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    productDescription?: SortOrder
    weight?: SortOrder
    length?: SortOrder
    waistRise?: SortOrder
    printAndPattern?: SortOrder
    packageContains?: SortOrder
    lookAndFeel?: SortOrder
    colorFamily?: SortOrder
    vestsSleeveTypeId?: SortOrder
    vestsNeckTypeId?: SortOrder
    commonDescriptionId?: SortOrder
    multiColors?: SortOrder
  }

  export type InnersDescriptionSumOrderByAggregateInput = {
    id?: SortOrder
    weight?: SortOrder
    length?: SortOrder
    waistRise?: SortOrder
    packageContains?: SortOrder
    vestsSleeveTypeId?: SortOrder
    vestsNeckTypeId?: SortOrder
    commonDescriptionId?: SortOrder
  }

  export type ShoesDescriptionRelationFilter = {
    is?: ShoesDescriptionWhereInput | null
    isNot?: ShoesDescriptionWhereInput | null
  }

  export type WatchesDescriptionRelationFilter = {
    is?: WatchesDescriptionWhereInput | null
    isNot?: WatchesDescriptionWhereInput | null
  }

  export type WarrantyCountOrderByAggregateInput = {
    id?: SortOrder
    shoesDescriptionId?: SortOrder
    watchsId?: SortOrder
    warrantyPeriod?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type WarrantyAvgOrderByAggregateInput = {
    id?: SortOrder
    shoesDescriptionId?: SortOrder
    watchsId?: SortOrder
    warrantyPeriod?: SortOrder
  }

  export type WarrantyMaxOrderByAggregateInput = {
    id?: SortOrder
    shoesDescriptionId?: SortOrder
    watchsId?: SortOrder
    warrantyPeriod?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type WarrantyMinOrderByAggregateInput = {
    id?: SortOrder
    shoesDescriptionId?: SortOrder
    watchsId?: SortOrder
    warrantyPeriod?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type WarrantySumOrderByAggregateInput = {
    id?: SortOrder
    shoesDescriptionId?: SortOrder
    watchsId?: SortOrder
    warrantyPeriod?: SortOrder
  }

  export type SleeveTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type SleeveTypeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SleeveTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type SleeveTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type SleeveTypeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type NeckTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type NeckTypeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type NeckTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type NeckTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type NeckTypeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type KurtasLengthTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type KurtasLengthTypeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type KurtasLengthTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type KurtasLengthTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type KurtasLengthTypeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TypesOfBottomCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type TypesOfBottomAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TypesOfBottomMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type TypesOfBottomMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type TypesOfBottomSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TypesOfPleatsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type TypesOfPleatsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TypesOfPleatsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type TypesOfPleatsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type TypesOfPleatsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TypesOfLengthBottomCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type TypesOfLengthBottomAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TypesOfLengthBottomMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type TypesOfLengthBottomMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type TypesOfLengthBottomSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProductAviableSizesRelationFilter = {
    is?: ProductAviableSizesWhereInput | null
    isNot?: ProductAviableSizesWhereInput | null
  }

  export type QuantityHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    productAviableSizesId?: SortOrder
    timestamp?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type QuantityHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    productAviableSizesId?: SortOrder
  }

  export type QuantityHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    productAviableSizesId?: SortOrder
    timestamp?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type QuantityHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    productAviableSizesId?: SortOrder
    timestamp?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type QuantityHistorySumOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    productAviableSizesId?: SortOrder
  }

  export type OfferValidityListRelationFilter = {
    every?: OfferValidityWhereInput
    some?: OfferValidityWhereInput
    none?: OfferValidityWhereInput
  }

  export type OfferValidityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OfferCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    offerPercntage?: SortOrder
    offerPrice?: SortOrder
    currentPrice?: SortOrder
    offerQuantity?: SortOrder
    currentQuantity?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type OfferAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    offerPercntage?: SortOrder
    offerPrice?: SortOrder
    currentPrice?: SortOrder
    offerQuantity?: SortOrder
    currentQuantity?: SortOrder
  }

  export type OfferMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    offerPercntage?: SortOrder
    offerPrice?: SortOrder
    currentPrice?: SortOrder
    offerQuantity?: SortOrder
    currentQuantity?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type OfferMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    offerPercntage?: SortOrder
    offerPrice?: SortOrder
    currentPrice?: SortOrder
    offerQuantity?: SortOrder
    currentQuantity?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type OfferSumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    offerPercntage?: SortOrder
    offerPrice?: SortOrder
    currentPrice?: SortOrder
    offerQuantity?: SortOrder
    currentQuantity?: SortOrder
  }

  export type OfferRelationFilter = {
    is?: OfferWhereInput | null
    isNot?: OfferWhereInput | null
  }

  export type OfferPromotionPeriodsRelationFilter = {
    is?: OfferPromotionPeriodsWhereInput | null
    isNot?: OfferPromotionPeriodsWhereInput | null
  }

  export type OfferValidityCountOrderByAggregateInput = {
    id?: SortOrder
    fromDate?: SortOrder
    toDate?: SortOrder
    fromTime?: SortOrder
    toTime?: SortOrder
    monday?: SortOrder
    tuesday?: SortOrder
    wednesday?: SortOrder
    thursday?: SortOrder
    friday?: SortOrder
    saturday?: SortOrder
    sunday?: SortOrder
    offerId?: SortOrder
    offerPromotionPeriodId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type OfferValidityAvgOrderByAggregateInput = {
    id?: SortOrder
    offerId?: SortOrder
    offerPromotionPeriodId?: SortOrder
  }

  export type OfferValidityMaxOrderByAggregateInput = {
    id?: SortOrder
    fromDate?: SortOrder
    toDate?: SortOrder
    fromTime?: SortOrder
    toTime?: SortOrder
    monday?: SortOrder
    tuesday?: SortOrder
    wednesday?: SortOrder
    thursday?: SortOrder
    friday?: SortOrder
    saturday?: SortOrder
    sunday?: SortOrder
    offerId?: SortOrder
    offerPromotionPeriodId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type OfferValidityMinOrderByAggregateInput = {
    id?: SortOrder
    fromDate?: SortOrder
    toDate?: SortOrder
    fromTime?: SortOrder
    toTime?: SortOrder
    monday?: SortOrder
    tuesday?: SortOrder
    wednesday?: SortOrder
    thursday?: SortOrder
    friday?: SortOrder
    saturday?: SortOrder
    sunday?: SortOrder
    offerId?: SortOrder
    offerPromotionPeriodId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type OfferValiditySumOrderByAggregateInput = {
    id?: SortOrder
    offerId?: SortOrder
    offerPromotionPeriodId?: SortOrder
  }

  export type OfferValidityRelationFilter = {
    is?: OfferValidityWhereInput | null
    isNot?: OfferValidityWhereInput | null
  }

  export type OfferPromotionPeriodsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type OfferPromotionPeriodsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type OfferPromotionPeriodsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type OfferPromotionPeriodsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type OfferPromotionPeriodsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CartCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    isCheckedOut?: SortOrder
    isRemoved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type CartAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
  }

  export type CartMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    isCheckedOut?: SortOrder
    isRemoved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type CartMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    isCheckedOut?: SortOrder
    isRemoved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type CartSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
  }

  export type WishlistCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type WishlistAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type WishlistMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type WishlistMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type WishlistSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type WishlistRelationFilter = {
    is?: WishlistWhereInput | null
    isNot?: WishlistWhereInput | null
  }

  export type WishlistItemCountOrderByAggregateInput = {
    id?: SortOrder
    wishlistId?: SortOrder
    productId?: SortOrder
  }

  export type WishlistItemAvgOrderByAggregateInput = {
    id?: SortOrder
    wishlistId?: SortOrder
    productId?: SortOrder
  }

  export type WishlistItemMaxOrderByAggregateInput = {
    id?: SortOrder
    wishlistId?: SortOrder
    productId?: SortOrder
  }

  export type WishlistItemMinOrderByAggregateInput = {
    id?: SortOrder
    wishlistId?: SortOrder
    productId?: SortOrder
  }

  export type WishlistItemSumOrderByAggregateInput = {
    id?: SortOrder
    wishlistId?: SortOrder
    productId?: SortOrder
  }

  export type UserCreateNestedManyWithoutRolesInput = {
    create?: XOR<Enumerable<UserCreateWithoutRolesInput>, Enumerable<UserUncheckedCreateWithoutRolesInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutRolesInput>
    createMany?: UserCreateManyRolesInputEnvelope
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type UserUncheckedCreateNestedManyWithoutRolesInput = {
    create?: XOR<Enumerable<UserCreateWithoutRolesInput>, Enumerable<UserUncheckedCreateWithoutRolesInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutRolesInput>
    createMany?: UserCreateManyRolesInputEnvelope
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateManyWithoutRolesNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutRolesInput>, Enumerable<UserUncheckedCreateWithoutRolesInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutRolesInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutRolesInput>
    createMany?: UserCreateManyRolesInputEnvelope
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutRolesInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutRolesInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUncheckedUpdateManyWithoutRolesNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutRolesInput>, Enumerable<UserUncheckedCreateWithoutRolesInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutRolesInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutRolesInput>
    createMany?: UserCreateManyRolesInputEnvelope
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutRolesInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutRolesInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type GenderCreateNestedOneWithoutProductCategoryInput = {
    create?: XOR<GenderCreateWithoutProductCategoryInput, GenderUncheckedCreateWithoutProductCategoryInput>
    connectOrCreate?: GenderCreateOrConnectWithoutProductCategoryInput
    connect?: GenderWhereUniqueInput
  }

  export type ProductTypeCreateNestedManyWithoutProductCategoryInput = {
    create?: XOR<Enumerable<ProductTypeCreateWithoutProductCategoryInput>, Enumerable<ProductTypeUncheckedCreateWithoutProductCategoryInput>>
    connectOrCreate?: Enumerable<ProductTypeCreateOrConnectWithoutProductCategoryInput>
    createMany?: ProductTypeCreateManyProductCategoryInputEnvelope
    connect?: Enumerable<ProductTypeWhereUniqueInput>
  }

  export type ProductTypeUncheckedCreateNestedManyWithoutProductCategoryInput = {
    create?: XOR<Enumerable<ProductTypeCreateWithoutProductCategoryInput>, Enumerable<ProductTypeUncheckedCreateWithoutProductCategoryInput>>
    connectOrCreate?: Enumerable<ProductTypeCreateOrConnectWithoutProductCategoryInput>
    createMany?: ProductTypeCreateManyProductCategoryInputEnvelope
    connect?: Enumerable<ProductTypeWhereUniqueInput>
  }

  export type GenderUpdateOneRequiredWithoutProductCategoryNestedInput = {
    create?: XOR<GenderCreateWithoutProductCategoryInput, GenderUncheckedCreateWithoutProductCategoryInput>
    connectOrCreate?: GenderCreateOrConnectWithoutProductCategoryInput
    upsert?: GenderUpsertWithoutProductCategoryInput
    connect?: GenderWhereUniqueInput
    update?: XOR<GenderUpdateWithoutProductCategoryInput, GenderUncheckedUpdateWithoutProductCategoryInput>
  }

  export type ProductTypeUpdateManyWithoutProductCategoryNestedInput = {
    create?: XOR<Enumerable<ProductTypeCreateWithoutProductCategoryInput>, Enumerable<ProductTypeUncheckedCreateWithoutProductCategoryInput>>
    connectOrCreate?: Enumerable<ProductTypeCreateOrConnectWithoutProductCategoryInput>
    upsert?: Enumerable<ProductTypeUpsertWithWhereUniqueWithoutProductCategoryInput>
    createMany?: ProductTypeCreateManyProductCategoryInputEnvelope
    set?: Enumerable<ProductTypeWhereUniqueInput>
    disconnect?: Enumerable<ProductTypeWhereUniqueInput>
    delete?: Enumerable<ProductTypeWhereUniqueInput>
    connect?: Enumerable<ProductTypeWhereUniqueInput>
    update?: Enumerable<ProductTypeUpdateWithWhereUniqueWithoutProductCategoryInput>
    updateMany?: Enumerable<ProductTypeUpdateManyWithWhereWithoutProductCategoryInput>
    deleteMany?: Enumerable<ProductTypeScalarWhereInput>
  }

  export type ProductTypeUncheckedUpdateManyWithoutProductCategoryNestedInput = {
    create?: XOR<Enumerable<ProductTypeCreateWithoutProductCategoryInput>, Enumerable<ProductTypeUncheckedCreateWithoutProductCategoryInput>>
    connectOrCreate?: Enumerable<ProductTypeCreateOrConnectWithoutProductCategoryInput>
    upsert?: Enumerable<ProductTypeUpsertWithWhereUniqueWithoutProductCategoryInput>
    createMany?: ProductTypeCreateManyProductCategoryInputEnvelope
    set?: Enumerable<ProductTypeWhereUniqueInput>
    disconnect?: Enumerable<ProductTypeWhereUniqueInput>
    delete?: Enumerable<ProductTypeWhereUniqueInput>
    connect?: Enumerable<ProductTypeWhereUniqueInput>
    update?: Enumerable<ProductTypeUpdateWithWhereUniqueWithoutProductCategoryInput>
    updateMany?: Enumerable<ProductTypeUpdateManyWithWhereWithoutProductCategoryInput>
    deleteMany?: Enumerable<ProductTypeScalarWhereInput>
  }

  export type ProductCategoryCreateNestedOneWithoutProductTypeInput = {
    create?: XOR<ProductCategoryCreateWithoutProductTypeInput, ProductCategoryUncheckedCreateWithoutProductTypeInput>
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutProductTypeInput
    connect?: ProductCategoryWhereUniqueInput
  }

  export type ProductTypeSizeCreateNestedManyWithoutProductTypeInput = {
    create?: XOR<Enumerable<ProductTypeSizeCreateWithoutProductTypeInput>, Enumerable<ProductTypeSizeUncheckedCreateWithoutProductTypeInput>>
    connectOrCreate?: Enumerable<ProductTypeSizeCreateOrConnectWithoutProductTypeInput>
    createMany?: ProductTypeSizeCreateManyProductTypeInputEnvelope
    connect?: Enumerable<ProductTypeSizeWhereUniqueInput>
  }

  export type ProductCreateNestedManyWithoutProductTypeInput = {
    create?: XOR<Enumerable<ProductCreateWithoutProductTypeInput>, Enumerable<ProductUncheckedCreateWithoutProductTypeInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutProductTypeInput>
    createMany?: ProductCreateManyProductTypeInputEnvelope
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type ProductTypeSizeUncheckedCreateNestedManyWithoutProductTypeInput = {
    create?: XOR<Enumerable<ProductTypeSizeCreateWithoutProductTypeInput>, Enumerable<ProductTypeSizeUncheckedCreateWithoutProductTypeInput>>
    connectOrCreate?: Enumerable<ProductTypeSizeCreateOrConnectWithoutProductTypeInput>
    createMany?: ProductTypeSizeCreateManyProductTypeInputEnvelope
    connect?: Enumerable<ProductTypeSizeWhereUniqueInput>
  }

  export type ProductUncheckedCreateNestedManyWithoutProductTypeInput = {
    create?: XOR<Enumerable<ProductCreateWithoutProductTypeInput>, Enumerable<ProductUncheckedCreateWithoutProductTypeInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutProductTypeInput>
    createMany?: ProductCreateManyProductTypeInputEnvelope
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type ProductCategoryUpdateOneRequiredWithoutProductTypeNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutProductTypeInput, ProductCategoryUncheckedCreateWithoutProductTypeInput>
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutProductTypeInput
    upsert?: ProductCategoryUpsertWithoutProductTypeInput
    connect?: ProductCategoryWhereUniqueInput
    update?: XOR<ProductCategoryUpdateWithoutProductTypeInput, ProductCategoryUncheckedUpdateWithoutProductTypeInput>
  }

  export type ProductTypeSizeUpdateManyWithoutProductTypeNestedInput = {
    create?: XOR<Enumerable<ProductTypeSizeCreateWithoutProductTypeInput>, Enumerable<ProductTypeSizeUncheckedCreateWithoutProductTypeInput>>
    connectOrCreate?: Enumerable<ProductTypeSizeCreateOrConnectWithoutProductTypeInput>
    upsert?: Enumerable<ProductTypeSizeUpsertWithWhereUniqueWithoutProductTypeInput>
    createMany?: ProductTypeSizeCreateManyProductTypeInputEnvelope
    set?: Enumerable<ProductTypeSizeWhereUniqueInput>
    disconnect?: Enumerable<ProductTypeSizeWhereUniqueInput>
    delete?: Enumerable<ProductTypeSizeWhereUniqueInput>
    connect?: Enumerable<ProductTypeSizeWhereUniqueInput>
    update?: Enumerable<ProductTypeSizeUpdateWithWhereUniqueWithoutProductTypeInput>
    updateMany?: Enumerable<ProductTypeSizeUpdateManyWithWhereWithoutProductTypeInput>
    deleteMany?: Enumerable<ProductTypeSizeScalarWhereInput>
  }

  export type ProductUpdateManyWithoutProductTypeNestedInput = {
    create?: XOR<Enumerable<ProductCreateWithoutProductTypeInput>, Enumerable<ProductUncheckedCreateWithoutProductTypeInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutProductTypeInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutProductTypeInput>
    createMany?: ProductCreateManyProductTypeInputEnvelope
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutProductTypeInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutProductTypeInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type ProductTypeSizeUncheckedUpdateManyWithoutProductTypeNestedInput = {
    create?: XOR<Enumerable<ProductTypeSizeCreateWithoutProductTypeInput>, Enumerable<ProductTypeSizeUncheckedCreateWithoutProductTypeInput>>
    connectOrCreate?: Enumerable<ProductTypeSizeCreateOrConnectWithoutProductTypeInput>
    upsert?: Enumerable<ProductTypeSizeUpsertWithWhereUniqueWithoutProductTypeInput>
    createMany?: ProductTypeSizeCreateManyProductTypeInputEnvelope
    set?: Enumerable<ProductTypeSizeWhereUniqueInput>
    disconnect?: Enumerable<ProductTypeSizeWhereUniqueInput>
    delete?: Enumerable<ProductTypeSizeWhereUniqueInput>
    connect?: Enumerable<ProductTypeSizeWhereUniqueInput>
    update?: Enumerable<ProductTypeSizeUpdateWithWhereUniqueWithoutProductTypeInput>
    updateMany?: Enumerable<ProductTypeSizeUpdateManyWithWhereWithoutProductTypeInput>
    deleteMany?: Enumerable<ProductTypeSizeScalarWhereInput>
  }

  export type ProductUncheckedUpdateManyWithoutProductTypeNestedInput = {
    create?: XOR<Enumerable<ProductCreateWithoutProductTypeInput>, Enumerable<ProductUncheckedCreateWithoutProductTypeInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutProductTypeInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutProductTypeInput>
    createMany?: ProductCreateManyProductTypeInputEnvelope
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutProductTypeInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutProductTypeInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type ProductAviableSizesCreateNestedManyWithoutProductTypeSizeInput = {
    create?: XOR<Enumerable<ProductAviableSizesCreateWithoutProductTypeSizeInput>, Enumerable<ProductAviableSizesUncheckedCreateWithoutProductTypeSizeInput>>
    connectOrCreate?: Enumerable<ProductAviableSizesCreateOrConnectWithoutProductTypeSizeInput>
    createMany?: ProductAviableSizesCreateManyProductTypeSizeInputEnvelope
    connect?: Enumerable<ProductAviableSizesWhereUniqueInput>
  }

  export type ProductTypeCreateNestedOneWithoutSizesInput = {
    create?: XOR<ProductTypeCreateWithoutSizesInput, ProductTypeUncheckedCreateWithoutSizesInput>
    connectOrCreate?: ProductTypeCreateOrConnectWithoutSizesInput
    connect?: ProductTypeWhereUniqueInput
  }

  export type ProductAviableSizesUncheckedCreateNestedManyWithoutProductTypeSizeInput = {
    create?: XOR<Enumerable<ProductAviableSizesCreateWithoutProductTypeSizeInput>, Enumerable<ProductAviableSizesUncheckedCreateWithoutProductTypeSizeInput>>
    connectOrCreate?: Enumerable<ProductAviableSizesCreateOrConnectWithoutProductTypeSizeInput>
    createMany?: ProductAviableSizesCreateManyProductTypeSizeInputEnvelope
    connect?: Enumerable<ProductAviableSizesWhereUniqueInput>
  }

  export type ProductAviableSizesUpdateManyWithoutProductTypeSizeNestedInput = {
    create?: XOR<Enumerable<ProductAviableSizesCreateWithoutProductTypeSizeInput>, Enumerable<ProductAviableSizesUncheckedCreateWithoutProductTypeSizeInput>>
    connectOrCreate?: Enumerable<ProductAviableSizesCreateOrConnectWithoutProductTypeSizeInput>
    upsert?: Enumerable<ProductAviableSizesUpsertWithWhereUniqueWithoutProductTypeSizeInput>
    createMany?: ProductAviableSizesCreateManyProductTypeSizeInputEnvelope
    set?: Enumerable<ProductAviableSizesWhereUniqueInput>
    disconnect?: Enumerable<ProductAviableSizesWhereUniqueInput>
    delete?: Enumerable<ProductAviableSizesWhereUniqueInput>
    connect?: Enumerable<ProductAviableSizesWhereUniqueInput>
    update?: Enumerable<ProductAviableSizesUpdateWithWhereUniqueWithoutProductTypeSizeInput>
    updateMany?: Enumerable<ProductAviableSizesUpdateManyWithWhereWithoutProductTypeSizeInput>
    deleteMany?: Enumerable<ProductAviableSizesScalarWhereInput>
  }

  export type ProductTypeUpdateOneRequiredWithoutSizesNestedInput = {
    create?: XOR<ProductTypeCreateWithoutSizesInput, ProductTypeUncheckedCreateWithoutSizesInput>
    connectOrCreate?: ProductTypeCreateOrConnectWithoutSizesInput
    upsert?: ProductTypeUpsertWithoutSizesInput
    connect?: ProductTypeWhereUniqueInput
    update?: XOR<ProductTypeUpdateWithoutSizesInput, ProductTypeUncheckedUpdateWithoutSizesInput>
  }

  export type ProductAviableSizesUncheckedUpdateManyWithoutProductTypeSizeNestedInput = {
    create?: XOR<Enumerable<ProductAviableSizesCreateWithoutProductTypeSizeInput>, Enumerable<ProductAviableSizesUncheckedCreateWithoutProductTypeSizeInput>>
    connectOrCreate?: Enumerable<ProductAviableSizesCreateOrConnectWithoutProductTypeSizeInput>
    upsert?: Enumerable<ProductAviableSizesUpsertWithWhereUniqueWithoutProductTypeSizeInput>
    createMany?: ProductAviableSizesCreateManyProductTypeSizeInputEnvelope
    set?: Enumerable<ProductAviableSizesWhereUniqueInput>
    disconnect?: Enumerable<ProductAviableSizesWhereUniqueInput>
    delete?: Enumerable<ProductAviableSizesWhereUniqueInput>
    connect?: Enumerable<ProductAviableSizesWhereUniqueInput>
    update?: Enumerable<ProductAviableSizesUpdateWithWhereUniqueWithoutProductTypeSizeInput>
    updateMany?: Enumerable<ProductAviableSizesUpdateManyWithWhereWithoutProductTypeSizeInput>
    deleteMany?: Enumerable<ProductAviableSizesScalarWhereInput>
  }

  export type ProductCategoryCreateNestedManyWithoutGenderInput = {
    create?: XOR<Enumerable<ProductCategoryCreateWithoutGenderInput>, Enumerable<ProductCategoryUncheckedCreateWithoutGenderInput>>
    connectOrCreate?: Enumerable<ProductCategoryCreateOrConnectWithoutGenderInput>
    createMany?: ProductCategoryCreateManyGenderInputEnvelope
    connect?: Enumerable<ProductCategoryWhereUniqueInput>
  }

  export type UserCreateNestedManyWithoutGenderInput = {
    create?: XOR<Enumerable<UserCreateWithoutGenderInput>, Enumerable<UserUncheckedCreateWithoutGenderInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutGenderInput>
    createMany?: UserCreateManyGenderInputEnvelope
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type ProductCategoryUncheckedCreateNestedManyWithoutGenderInput = {
    create?: XOR<Enumerable<ProductCategoryCreateWithoutGenderInput>, Enumerable<ProductCategoryUncheckedCreateWithoutGenderInput>>
    connectOrCreate?: Enumerable<ProductCategoryCreateOrConnectWithoutGenderInput>
    createMany?: ProductCategoryCreateManyGenderInputEnvelope
    connect?: Enumerable<ProductCategoryWhereUniqueInput>
  }

  export type UserUncheckedCreateNestedManyWithoutGenderInput = {
    create?: XOR<Enumerable<UserCreateWithoutGenderInput>, Enumerable<UserUncheckedCreateWithoutGenderInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutGenderInput>
    createMany?: UserCreateManyGenderInputEnvelope
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type ProductCategoryUpdateManyWithoutGenderNestedInput = {
    create?: XOR<Enumerable<ProductCategoryCreateWithoutGenderInput>, Enumerable<ProductCategoryUncheckedCreateWithoutGenderInput>>
    connectOrCreate?: Enumerable<ProductCategoryCreateOrConnectWithoutGenderInput>
    upsert?: Enumerable<ProductCategoryUpsertWithWhereUniqueWithoutGenderInput>
    createMany?: ProductCategoryCreateManyGenderInputEnvelope
    set?: Enumerable<ProductCategoryWhereUniqueInput>
    disconnect?: Enumerable<ProductCategoryWhereUniqueInput>
    delete?: Enumerable<ProductCategoryWhereUniqueInput>
    connect?: Enumerable<ProductCategoryWhereUniqueInput>
    update?: Enumerable<ProductCategoryUpdateWithWhereUniqueWithoutGenderInput>
    updateMany?: Enumerable<ProductCategoryUpdateManyWithWhereWithoutGenderInput>
    deleteMany?: Enumerable<ProductCategoryScalarWhereInput>
  }

  export type UserUpdateManyWithoutGenderNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutGenderInput>, Enumerable<UserUncheckedCreateWithoutGenderInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutGenderInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutGenderInput>
    createMany?: UserCreateManyGenderInputEnvelope
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutGenderInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutGenderInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type ProductCategoryUncheckedUpdateManyWithoutGenderNestedInput = {
    create?: XOR<Enumerable<ProductCategoryCreateWithoutGenderInput>, Enumerable<ProductCategoryUncheckedCreateWithoutGenderInput>>
    connectOrCreate?: Enumerable<ProductCategoryCreateOrConnectWithoutGenderInput>
    upsert?: Enumerable<ProductCategoryUpsertWithWhereUniqueWithoutGenderInput>
    createMany?: ProductCategoryCreateManyGenderInputEnvelope
    set?: Enumerable<ProductCategoryWhereUniqueInput>
    disconnect?: Enumerable<ProductCategoryWhereUniqueInput>
    delete?: Enumerable<ProductCategoryWhereUniqueInput>
    connect?: Enumerable<ProductCategoryWhereUniqueInput>
    update?: Enumerable<ProductCategoryUpdateWithWhereUniqueWithoutGenderInput>
    updateMany?: Enumerable<ProductCategoryUpdateManyWithWhereWithoutGenderInput>
    deleteMany?: Enumerable<ProductCategoryScalarWhereInput>
  }

  export type UserUncheckedUpdateManyWithoutGenderNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutGenderInput>, Enumerable<UserUncheckedCreateWithoutGenderInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutGenderInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutGenderInput>
    createMany?: UserCreateManyGenderInputEnvelope
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutGenderInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutGenderInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type StateCreateNestedManyWithoutCountryInput = {
    create?: XOR<Enumerable<StateCreateWithoutCountryInput>, Enumerable<StateUncheckedCreateWithoutCountryInput>>
    connectOrCreate?: Enumerable<StateCreateOrConnectWithoutCountryInput>
    createMany?: StateCreateManyCountryInputEnvelope
    connect?: Enumerable<StateWhereUniqueInput>
  }

  export type StateUncheckedCreateNestedManyWithoutCountryInput = {
    create?: XOR<Enumerable<StateCreateWithoutCountryInput>, Enumerable<StateUncheckedCreateWithoutCountryInput>>
    connectOrCreate?: Enumerable<StateCreateOrConnectWithoutCountryInput>
    createMany?: StateCreateManyCountryInputEnvelope
    connect?: Enumerable<StateWhereUniqueInput>
  }

  export type StateUpdateManyWithoutCountryNestedInput = {
    create?: XOR<Enumerable<StateCreateWithoutCountryInput>, Enumerable<StateUncheckedCreateWithoutCountryInput>>
    connectOrCreate?: Enumerable<StateCreateOrConnectWithoutCountryInput>
    upsert?: Enumerable<StateUpsertWithWhereUniqueWithoutCountryInput>
    createMany?: StateCreateManyCountryInputEnvelope
    set?: Enumerable<StateWhereUniqueInput>
    disconnect?: Enumerable<StateWhereUniqueInput>
    delete?: Enumerable<StateWhereUniqueInput>
    connect?: Enumerable<StateWhereUniqueInput>
    update?: Enumerable<StateUpdateWithWhereUniqueWithoutCountryInput>
    updateMany?: Enumerable<StateUpdateManyWithWhereWithoutCountryInput>
    deleteMany?: Enumerable<StateScalarWhereInput>
  }

  export type StateUncheckedUpdateManyWithoutCountryNestedInput = {
    create?: XOR<Enumerable<StateCreateWithoutCountryInput>, Enumerable<StateUncheckedCreateWithoutCountryInput>>
    connectOrCreate?: Enumerable<StateCreateOrConnectWithoutCountryInput>
    upsert?: Enumerable<StateUpsertWithWhereUniqueWithoutCountryInput>
    createMany?: StateCreateManyCountryInputEnvelope
    set?: Enumerable<StateWhereUniqueInput>
    disconnect?: Enumerable<StateWhereUniqueInput>
    delete?: Enumerable<StateWhereUniqueInput>
    connect?: Enumerable<StateWhereUniqueInput>
    update?: Enumerable<StateUpdateWithWhereUniqueWithoutCountryInput>
    updateMany?: Enumerable<StateUpdateManyWithWhereWithoutCountryInput>
    deleteMany?: Enumerable<StateScalarWhereInput>
  }

  export type CountryCreateNestedOneWithoutStateInput = {
    create?: XOR<CountryCreateWithoutStateInput, CountryUncheckedCreateWithoutStateInput>
    connectOrCreate?: CountryCreateOrConnectWithoutStateInput
    connect?: CountryWhereUniqueInput
  }

  export type AddressCreateNestedManyWithoutStateInput = {
    create?: XOR<Enumerable<AddressCreateWithoutStateInput>, Enumerable<AddressUncheckedCreateWithoutStateInput>>
    connectOrCreate?: Enumerable<AddressCreateOrConnectWithoutStateInput>
    createMany?: AddressCreateManyStateInputEnvelope
    connect?: Enumerable<AddressWhereUniqueInput>
  }

  export type AddressUncheckedCreateNestedManyWithoutStateInput = {
    create?: XOR<Enumerable<AddressCreateWithoutStateInput>, Enumerable<AddressUncheckedCreateWithoutStateInput>>
    connectOrCreate?: Enumerable<AddressCreateOrConnectWithoutStateInput>
    createMany?: AddressCreateManyStateInputEnvelope
    connect?: Enumerable<AddressWhereUniqueInput>
  }

  export type CountryUpdateOneRequiredWithoutStateNestedInput = {
    create?: XOR<CountryCreateWithoutStateInput, CountryUncheckedCreateWithoutStateInput>
    connectOrCreate?: CountryCreateOrConnectWithoutStateInput
    upsert?: CountryUpsertWithoutStateInput
    connect?: CountryWhereUniqueInput
    update?: XOR<CountryUpdateWithoutStateInput, CountryUncheckedUpdateWithoutStateInput>
  }

  export type AddressUpdateManyWithoutStateNestedInput = {
    create?: XOR<Enumerable<AddressCreateWithoutStateInput>, Enumerable<AddressUncheckedCreateWithoutStateInput>>
    connectOrCreate?: Enumerable<AddressCreateOrConnectWithoutStateInput>
    upsert?: Enumerable<AddressUpsertWithWhereUniqueWithoutStateInput>
    createMany?: AddressCreateManyStateInputEnvelope
    set?: Enumerable<AddressWhereUniqueInput>
    disconnect?: Enumerable<AddressWhereUniqueInput>
    delete?: Enumerable<AddressWhereUniqueInput>
    connect?: Enumerable<AddressWhereUniqueInput>
    update?: Enumerable<AddressUpdateWithWhereUniqueWithoutStateInput>
    updateMany?: Enumerable<AddressUpdateManyWithWhereWithoutStateInput>
    deleteMany?: Enumerable<AddressScalarWhereInput>
  }

  export type AddressUncheckedUpdateManyWithoutStateNestedInput = {
    create?: XOR<Enumerable<AddressCreateWithoutStateInput>, Enumerable<AddressUncheckedCreateWithoutStateInput>>
    connectOrCreate?: Enumerable<AddressCreateOrConnectWithoutStateInput>
    upsert?: Enumerable<AddressUpsertWithWhereUniqueWithoutStateInput>
    createMany?: AddressCreateManyStateInputEnvelope
    set?: Enumerable<AddressWhereUniqueInput>
    disconnect?: Enumerable<AddressWhereUniqueInput>
    delete?: Enumerable<AddressWhereUniqueInput>
    connect?: Enumerable<AddressWhereUniqueInput>
    update?: Enumerable<AddressUpdateWithWhereUniqueWithoutStateInput>
    updateMany?: Enumerable<AddressUpdateManyWithWhereWithoutStateInput>
    deleteMany?: Enumerable<AddressScalarWhereInput>
  }

  export type StateCreateNestedOneWithoutDistrictInput = {
    create?: XOR<StateCreateWithoutDistrictInput, StateUncheckedCreateWithoutDistrictInput>
    connectOrCreate?: StateCreateOrConnectWithoutDistrictInput
    connect?: StateWhereUniqueInput
  }

  export type UserAddressCreateNestedManyWithoutAddressInput = {
    create?: XOR<Enumerable<UserAddressCreateWithoutAddressInput>, Enumerable<UserAddressUncheckedCreateWithoutAddressInput>>
    connectOrCreate?: Enumerable<UserAddressCreateOrConnectWithoutAddressInput>
    createMany?: UserAddressCreateManyAddressInputEnvelope
    connect?: Enumerable<UserAddressWhereUniqueInput>
  }

  export type UserAddressUncheckedCreateNestedManyWithoutAddressInput = {
    create?: XOR<Enumerable<UserAddressCreateWithoutAddressInput>, Enumerable<UserAddressUncheckedCreateWithoutAddressInput>>
    connectOrCreate?: Enumerable<UserAddressCreateOrConnectWithoutAddressInput>
    createMany?: UserAddressCreateManyAddressInputEnvelope
    connect?: Enumerable<UserAddressWhereUniqueInput>
  }

  export type StateUpdateOneRequiredWithoutDistrictNestedInput = {
    create?: XOR<StateCreateWithoutDistrictInput, StateUncheckedCreateWithoutDistrictInput>
    connectOrCreate?: StateCreateOrConnectWithoutDistrictInput
    upsert?: StateUpsertWithoutDistrictInput
    connect?: StateWhereUniqueInput
    update?: XOR<StateUpdateWithoutDistrictInput, StateUncheckedUpdateWithoutDistrictInput>
  }

  export type UserAddressUpdateManyWithoutAddressNestedInput = {
    create?: XOR<Enumerable<UserAddressCreateWithoutAddressInput>, Enumerable<UserAddressUncheckedCreateWithoutAddressInput>>
    connectOrCreate?: Enumerable<UserAddressCreateOrConnectWithoutAddressInput>
    upsert?: Enumerable<UserAddressUpsertWithWhereUniqueWithoutAddressInput>
    createMany?: UserAddressCreateManyAddressInputEnvelope
    set?: Enumerable<UserAddressWhereUniqueInput>
    disconnect?: Enumerable<UserAddressWhereUniqueInput>
    delete?: Enumerable<UserAddressWhereUniqueInput>
    connect?: Enumerable<UserAddressWhereUniqueInput>
    update?: Enumerable<UserAddressUpdateWithWhereUniqueWithoutAddressInput>
    updateMany?: Enumerable<UserAddressUpdateManyWithWhereWithoutAddressInput>
    deleteMany?: Enumerable<UserAddressScalarWhereInput>
  }

  export type UserAddressUncheckedUpdateManyWithoutAddressNestedInput = {
    create?: XOR<Enumerable<UserAddressCreateWithoutAddressInput>, Enumerable<UserAddressUncheckedCreateWithoutAddressInput>>
    connectOrCreate?: Enumerable<UserAddressCreateOrConnectWithoutAddressInput>
    upsert?: Enumerable<UserAddressUpsertWithWhereUniqueWithoutAddressInput>
    createMany?: UserAddressCreateManyAddressInputEnvelope
    set?: Enumerable<UserAddressWhereUniqueInput>
    disconnect?: Enumerable<UserAddressWhereUniqueInput>
    delete?: Enumerable<UserAddressWhereUniqueInput>
    connect?: Enumerable<UserAddressWhereUniqueInput>
    update?: Enumerable<UserAddressUpdateWithWhereUniqueWithoutAddressInput>
    updateMany?: Enumerable<UserAddressUpdateManyWithWhereWithoutAddressInput>
    deleteMany?: Enumerable<UserAddressScalarWhereInput>
  }

  export type AddressCreateNestedOneWithoutUserAddressInput = {
    create?: XOR<AddressCreateWithoutUserAddressInput, AddressUncheckedCreateWithoutUserAddressInput>
    connectOrCreate?: AddressCreateOrConnectWithoutUserAddressInput
    connect?: AddressWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUserAddressInput = {
    create?: XOR<UserCreateWithoutUserAddressInput, UserUncheckedCreateWithoutUserAddressInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserAddressInput
    connect?: UserWhereUniqueInput
  }

  export type AddressUpdateOneRequiredWithoutUserAddressNestedInput = {
    create?: XOR<AddressCreateWithoutUserAddressInput, AddressUncheckedCreateWithoutUserAddressInput>
    connectOrCreate?: AddressCreateOrConnectWithoutUserAddressInput
    upsert?: AddressUpsertWithoutUserAddressInput
    connect?: AddressWhereUniqueInput
    update?: XOR<AddressUpdateWithoutUserAddressInput, AddressUncheckedUpdateWithoutUserAddressInput>
  }

  export type UserUpdateOneRequiredWithoutUserAddressNestedInput = {
    create?: XOR<UserCreateWithoutUserAddressInput, UserUncheckedCreateWithoutUserAddressInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserAddressInput
    upsert?: UserUpsertWithoutUserAddressInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutUserAddressInput, UserUncheckedUpdateWithoutUserAddressInput>
  }

  export type ProductCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ProductCreateWithoutUserInput>, Enumerable<ProductUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutUserInput>
    createMany?: ProductCreateManyUserInputEnvelope
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type UserAddressCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserAddressCreateWithoutUserInput>, Enumerable<UserAddressUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserAddressCreateOrConnectWithoutUserInput>
    createMany?: UserAddressCreateManyUserInputEnvelope
    connect?: Enumerable<UserAddressWhereUniqueInput>
  }

  export type CartCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CartCreateWithoutUserInput>, Enumerable<CartUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CartCreateOrConnectWithoutUserInput>
    createMany?: CartCreateManyUserInputEnvelope
    connect?: Enumerable<CartWhereUniqueInput>
  }

  export type WishlistCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<WishlistCreateWithoutUserInput>, Enumerable<WishlistUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<WishlistCreateOrConnectWithoutUserInput>
    createMany?: WishlistCreateManyUserInputEnvelope
    connect?: Enumerable<WishlistWhereUniqueInput>
  }

  export type UserLoginRequestCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserLoginRequestCreateWithoutUserInput>, Enumerable<UserLoginRequestUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserLoginRequestCreateOrConnectWithoutUserInput>
    createMany?: UserLoginRequestCreateManyUserInputEnvelope
    connect?: Enumerable<UserLoginRequestWhereUniqueInput>
  }

  export type ProductReviewCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ProductReviewCreateWithoutUserInput>, Enumerable<ProductReviewUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ProductReviewCreateOrConnectWithoutUserInput>
    createMany?: ProductReviewCreateManyUserInputEnvelope
    connect?: Enumerable<ProductReviewWhereUniqueInput>
  }

  export type OrderCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<OrderCreateWithoutUserInput>, Enumerable<OrderUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutUserInput>
    createMany?: OrderCreateManyUserInputEnvelope
    connect?: Enumerable<OrderWhereUniqueInput>
  }

  export type SearchItemsCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<SearchItemsCreateWithoutUserInput>, Enumerable<SearchItemsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<SearchItemsCreateOrConnectWithoutUserInput>
    createMany?: SearchItemsCreateManyUserInputEnvelope
    connect?: Enumerable<SearchItemsWhereUniqueInput>
  }

  export type UserPasswordCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserPasswordCreateWithoutUserInput>, Enumerable<UserPasswordUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserPasswordCreateOrConnectWithoutUserInput>
    createMany?: UserPasswordCreateManyUserInputEnvelope
    connect?: Enumerable<UserPasswordWhereUniqueInput>
  }

  export type RolesCreateNestedOneWithoutUserInput = {
    create?: XOR<RolesCreateWithoutUserInput, RolesUncheckedCreateWithoutUserInput>
    connectOrCreate?: RolesCreateOrConnectWithoutUserInput
    connect?: RolesWhereUniqueInput
  }

  export type GenderCreateNestedOneWithoutUserInput = {
    create?: XOR<GenderCreateWithoutUserInput, GenderUncheckedCreateWithoutUserInput>
    connectOrCreate?: GenderCreateOrConnectWithoutUserInput
    connect?: GenderWhereUniqueInput
  }

  export type ProductUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ProductCreateWithoutUserInput>, Enumerable<ProductUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutUserInput>
    createMany?: ProductCreateManyUserInputEnvelope
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type UserAddressUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserAddressCreateWithoutUserInput>, Enumerable<UserAddressUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserAddressCreateOrConnectWithoutUserInput>
    createMany?: UserAddressCreateManyUserInputEnvelope
    connect?: Enumerable<UserAddressWhereUniqueInput>
  }

  export type CartUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CartCreateWithoutUserInput>, Enumerable<CartUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CartCreateOrConnectWithoutUserInput>
    createMany?: CartCreateManyUserInputEnvelope
    connect?: Enumerable<CartWhereUniqueInput>
  }

  export type WishlistUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<WishlistCreateWithoutUserInput>, Enumerable<WishlistUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<WishlistCreateOrConnectWithoutUserInput>
    createMany?: WishlistCreateManyUserInputEnvelope
    connect?: Enumerable<WishlistWhereUniqueInput>
  }

  export type UserLoginRequestUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserLoginRequestCreateWithoutUserInput>, Enumerable<UserLoginRequestUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserLoginRequestCreateOrConnectWithoutUserInput>
    createMany?: UserLoginRequestCreateManyUserInputEnvelope
    connect?: Enumerable<UserLoginRequestWhereUniqueInput>
  }

  export type ProductReviewUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ProductReviewCreateWithoutUserInput>, Enumerable<ProductReviewUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ProductReviewCreateOrConnectWithoutUserInput>
    createMany?: ProductReviewCreateManyUserInputEnvelope
    connect?: Enumerable<ProductReviewWhereUniqueInput>
  }

  export type OrderUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<OrderCreateWithoutUserInput>, Enumerable<OrderUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutUserInput>
    createMany?: OrderCreateManyUserInputEnvelope
    connect?: Enumerable<OrderWhereUniqueInput>
  }

  export type SearchItemsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<SearchItemsCreateWithoutUserInput>, Enumerable<SearchItemsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<SearchItemsCreateOrConnectWithoutUserInput>
    createMany?: SearchItemsCreateManyUserInputEnvelope
    connect?: Enumerable<SearchItemsWhereUniqueInput>
  }

  export type UserPasswordUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserPasswordCreateWithoutUserInput>, Enumerable<UserPasswordUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserPasswordCreateOrConnectWithoutUserInput>
    createMany?: UserPasswordCreateManyUserInputEnvelope
    connect?: Enumerable<UserPasswordWhereUniqueInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type ProductUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ProductCreateWithoutUserInput>, Enumerable<ProductUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ProductCreateManyUserInputEnvelope
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type UserAddressUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UserAddressCreateWithoutUserInput>, Enumerable<UserAddressUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserAddressCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserAddressUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserAddressCreateManyUserInputEnvelope
    set?: Enumerable<UserAddressWhereUniqueInput>
    disconnect?: Enumerable<UserAddressWhereUniqueInput>
    delete?: Enumerable<UserAddressWhereUniqueInput>
    connect?: Enumerable<UserAddressWhereUniqueInput>
    update?: Enumerable<UserAddressUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserAddressUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserAddressScalarWhereInput>
  }

  export type CartUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<CartCreateWithoutUserInput>, Enumerable<CartUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CartCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<CartUpsertWithWhereUniqueWithoutUserInput>
    createMany?: CartCreateManyUserInputEnvelope
    set?: Enumerable<CartWhereUniqueInput>
    disconnect?: Enumerable<CartWhereUniqueInput>
    delete?: Enumerable<CartWhereUniqueInput>
    connect?: Enumerable<CartWhereUniqueInput>
    update?: Enumerable<CartUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CartUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CartScalarWhereInput>
  }

  export type WishlistUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<WishlistCreateWithoutUserInput>, Enumerable<WishlistUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<WishlistCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<WishlistUpsertWithWhereUniqueWithoutUserInput>
    createMany?: WishlistCreateManyUserInputEnvelope
    set?: Enumerable<WishlistWhereUniqueInput>
    disconnect?: Enumerable<WishlistWhereUniqueInput>
    delete?: Enumerable<WishlistWhereUniqueInput>
    connect?: Enumerable<WishlistWhereUniqueInput>
    update?: Enumerable<WishlistUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<WishlistUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<WishlistScalarWhereInput>
  }

  export type UserLoginRequestUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UserLoginRequestCreateWithoutUserInput>, Enumerable<UserLoginRequestUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserLoginRequestCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserLoginRequestUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserLoginRequestCreateManyUserInputEnvelope
    set?: Enumerable<UserLoginRequestWhereUniqueInput>
    disconnect?: Enumerable<UserLoginRequestWhereUniqueInput>
    delete?: Enumerable<UserLoginRequestWhereUniqueInput>
    connect?: Enumerable<UserLoginRequestWhereUniqueInput>
    update?: Enumerable<UserLoginRequestUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserLoginRequestUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserLoginRequestScalarWhereInput>
  }

  export type ProductReviewUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ProductReviewCreateWithoutUserInput>, Enumerable<ProductReviewUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ProductReviewCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ProductReviewUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ProductReviewCreateManyUserInputEnvelope
    set?: Enumerable<ProductReviewWhereUniqueInput>
    disconnect?: Enumerable<ProductReviewWhereUniqueInput>
    delete?: Enumerable<ProductReviewWhereUniqueInput>
    connect?: Enumerable<ProductReviewWhereUniqueInput>
    update?: Enumerable<ProductReviewUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ProductReviewUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ProductReviewScalarWhereInput>
  }

  export type OrderUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<OrderCreateWithoutUserInput>, Enumerable<OrderUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<OrderUpsertWithWhereUniqueWithoutUserInput>
    createMany?: OrderCreateManyUserInputEnvelope
    set?: Enumerable<OrderWhereUniqueInput>
    disconnect?: Enumerable<OrderWhereUniqueInput>
    delete?: Enumerable<OrderWhereUniqueInput>
    connect?: Enumerable<OrderWhereUniqueInput>
    update?: Enumerable<OrderUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<OrderUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<OrderScalarWhereInput>
  }

  export type SearchItemsUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<SearchItemsCreateWithoutUserInput>, Enumerable<SearchItemsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<SearchItemsCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<SearchItemsUpsertWithWhereUniqueWithoutUserInput>
    createMany?: SearchItemsCreateManyUserInputEnvelope
    set?: Enumerable<SearchItemsWhereUniqueInput>
    disconnect?: Enumerable<SearchItemsWhereUniqueInput>
    delete?: Enumerable<SearchItemsWhereUniqueInput>
    connect?: Enumerable<SearchItemsWhereUniqueInput>
    update?: Enumerable<SearchItemsUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<SearchItemsUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<SearchItemsScalarWhereInput>
  }

  export type UserPasswordUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UserPasswordCreateWithoutUserInput>, Enumerable<UserPasswordUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserPasswordCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserPasswordUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserPasswordCreateManyUserInputEnvelope
    set?: Enumerable<UserPasswordWhereUniqueInput>
    disconnect?: Enumerable<UserPasswordWhereUniqueInput>
    delete?: Enumerable<UserPasswordWhereUniqueInput>
    connect?: Enumerable<UserPasswordWhereUniqueInput>
    update?: Enumerable<UserPasswordUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserPasswordUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserPasswordScalarWhereInput>
  }

  export type RolesUpdateOneRequiredWithoutUserNestedInput = {
    create?: XOR<RolesCreateWithoutUserInput, RolesUncheckedCreateWithoutUserInput>
    connectOrCreate?: RolesCreateOrConnectWithoutUserInput
    upsert?: RolesUpsertWithoutUserInput
    connect?: RolesWhereUniqueInput
    update?: XOR<RolesUpdateWithoutUserInput, RolesUncheckedUpdateWithoutUserInput>
  }

  export type GenderUpdateOneRequiredWithoutUserNestedInput = {
    create?: XOR<GenderCreateWithoutUserInput, GenderUncheckedCreateWithoutUserInput>
    connectOrCreate?: GenderCreateOrConnectWithoutUserInput
    upsert?: GenderUpsertWithoutUserInput
    connect?: GenderWhereUniqueInput
    update?: XOR<GenderUpdateWithoutUserInput, GenderUncheckedUpdateWithoutUserInput>
  }

  export type ProductUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ProductCreateWithoutUserInput>, Enumerable<ProductUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ProductCreateManyUserInputEnvelope
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type UserAddressUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UserAddressCreateWithoutUserInput>, Enumerable<UserAddressUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserAddressCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserAddressUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserAddressCreateManyUserInputEnvelope
    set?: Enumerable<UserAddressWhereUniqueInput>
    disconnect?: Enumerable<UserAddressWhereUniqueInput>
    delete?: Enumerable<UserAddressWhereUniqueInput>
    connect?: Enumerable<UserAddressWhereUniqueInput>
    update?: Enumerable<UserAddressUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserAddressUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserAddressScalarWhereInput>
  }

  export type CartUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<CartCreateWithoutUserInput>, Enumerable<CartUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CartCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<CartUpsertWithWhereUniqueWithoutUserInput>
    createMany?: CartCreateManyUserInputEnvelope
    set?: Enumerable<CartWhereUniqueInput>
    disconnect?: Enumerable<CartWhereUniqueInput>
    delete?: Enumerable<CartWhereUniqueInput>
    connect?: Enumerable<CartWhereUniqueInput>
    update?: Enumerable<CartUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CartUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CartScalarWhereInput>
  }

  export type WishlistUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<WishlistCreateWithoutUserInput>, Enumerable<WishlistUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<WishlistCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<WishlistUpsertWithWhereUniqueWithoutUserInput>
    createMany?: WishlistCreateManyUserInputEnvelope
    set?: Enumerable<WishlistWhereUniqueInput>
    disconnect?: Enumerable<WishlistWhereUniqueInput>
    delete?: Enumerable<WishlistWhereUniqueInput>
    connect?: Enumerable<WishlistWhereUniqueInput>
    update?: Enumerable<WishlistUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<WishlistUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<WishlistScalarWhereInput>
  }

  export type UserLoginRequestUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UserLoginRequestCreateWithoutUserInput>, Enumerable<UserLoginRequestUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserLoginRequestCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserLoginRequestUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserLoginRequestCreateManyUserInputEnvelope
    set?: Enumerable<UserLoginRequestWhereUniqueInput>
    disconnect?: Enumerable<UserLoginRequestWhereUniqueInput>
    delete?: Enumerable<UserLoginRequestWhereUniqueInput>
    connect?: Enumerable<UserLoginRequestWhereUniqueInput>
    update?: Enumerable<UserLoginRequestUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserLoginRequestUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserLoginRequestScalarWhereInput>
  }

  export type ProductReviewUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ProductReviewCreateWithoutUserInput>, Enumerable<ProductReviewUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ProductReviewCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ProductReviewUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ProductReviewCreateManyUserInputEnvelope
    set?: Enumerable<ProductReviewWhereUniqueInput>
    disconnect?: Enumerable<ProductReviewWhereUniqueInput>
    delete?: Enumerable<ProductReviewWhereUniqueInput>
    connect?: Enumerable<ProductReviewWhereUniqueInput>
    update?: Enumerable<ProductReviewUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ProductReviewUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ProductReviewScalarWhereInput>
  }

  export type OrderUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<OrderCreateWithoutUserInput>, Enumerable<OrderUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<OrderUpsertWithWhereUniqueWithoutUserInput>
    createMany?: OrderCreateManyUserInputEnvelope
    set?: Enumerable<OrderWhereUniqueInput>
    disconnect?: Enumerable<OrderWhereUniqueInput>
    delete?: Enumerable<OrderWhereUniqueInput>
    connect?: Enumerable<OrderWhereUniqueInput>
    update?: Enumerable<OrderUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<OrderUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<OrderScalarWhereInput>
  }

  export type SearchItemsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<SearchItemsCreateWithoutUserInput>, Enumerable<SearchItemsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<SearchItemsCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<SearchItemsUpsertWithWhereUniqueWithoutUserInput>
    createMany?: SearchItemsCreateManyUserInputEnvelope
    set?: Enumerable<SearchItemsWhereUniqueInput>
    disconnect?: Enumerable<SearchItemsWhereUniqueInput>
    delete?: Enumerable<SearchItemsWhereUniqueInput>
    connect?: Enumerable<SearchItemsWhereUniqueInput>
    update?: Enumerable<SearchItemsUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<SearchItemsUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<SearchItemsScalarWhereInput>
  }

  export type UserPasswordUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UserPasswordCreateWithoutUserInput>, Enumerable<UserPasswordUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserPasswordCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserPasswordUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserPasswordCreateManyUserInputEnvelope
    set?: Enumerable<UserPasswordWhereUniqueInput>
    disconnect?: Enumerable<UserPasswordWhereUniqueInput>
    delete?: Enumerable<UserPasswordWhereUniqueInput>
    connect?: Enumerable<UserPasswordWhereUniqueInput>
    update?: Enumerable<UserPasswordUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserPasswordUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserPasswordScalarWhereInput>
  }

  export type ProductCreateNestedManyWithoutProductOwnerInput = {
    create?: XOR<Enumerable<ProductCreateWithoutProductOwnerInput>, Enumerable<ProductUncheckedCreateWithoutProductOwnerInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutProductOwnerInput>
    createMany?: ProductCreateManyProductOwnerInputEnvelope
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type ProductUncheckedCreateNestedManyWithoutProductOwnerInput = {
    create?: XOR<Enumerable<ProductCreateWithoutProductOwnerInput>, Enumerable<ProductUncheckedCreateWithoutProductOwnerInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutProductOwnerInput>
    createMany?: ProductCreateManyProductOwnerInputEnvelope
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type ProductUpdateManyWithoutProductOwnerNestedInput = {
    create?: XOR<Enumerable<ProductCreateWithoutProductOwnerInput>, Enumerable<ProductUncheckedCreateWithoutProductOwnerInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutProductOwnerInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutProductOwnerInput>
    createMany?: ProductCreateManyProductOwnerInputEnvelope
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutProductOwnerInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutProductOwnerInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type ProductUncheckedUpdateManyWithoutProductOwnerNestedInput = {
    create?: XOR<Enumerable<ProductCreateWithoutProductOwnerInput>, Enumerable<ProductUncheckedCreateWithoutProductOwnerInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutProductOwnerInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutProductOwnerInput>
    createMany?: ProductCreateManyProductOwnerInputEnvelope
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutProductOwnerInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutProductOwnerInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutPasswordInput = {
    create?: XOR<UserCreateWithoutPasswordInput, UserUncheckedCreateWithoutPasswordInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPasswordNestedInput = {
    create?: XOR<UserCreateWithoutPasswordInput, UserUncheckedCreateWithoutPasswordInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordInput
    upsert?: UserUpsertWithoutPasswordInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutPasswordInput, UserUncheckedUpdateWithoutPasswordInput>
  }

  export type UserCreateNestedOneWithoutUserSearchItemsInput = {
    create?: XOR<UserCreateWithoutUserSearchItemsInput, UserUncheckedCreateWithoutUserSearchItemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserSearchItemsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserSearchItemsNestedInput = {
    create?: XOR<UserCreateWithoutUserSearchItemsInput, UserUncheckedCreateWithoutUserSearchItemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserSearchItemsInput
    upsert?: UserUpsertWithoutUserSearchItemsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutUserSearchItemsInput, UserUncheckedUpdateWithoutUserSearchItemsInput>
  }

  export type UserCreateNestedOneWithoutOrderInput = {
    create?: XOR<UserCreateWithoutOrderInput, UserUncheckedCreateWithoutOrderInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrderInput
    connect?: UserWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutOrderInput = {
    create?: XOR<ProductCreateWithoutOrderInput, ProductUncheckedCreateWithoutOrderInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOrderInput
    connect?: ProductWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutOrderNestedInput = {
    create?: XOR<UserCreateWithoutOrderInput, UserUncheckedCreateWithoutOrderInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrderInput
    upsert?: UserUpsertWithoutOrderInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutOrderInput, UserUncheckedUpdateWithoutOrderInput>
  }

  export type ProductUpdateOneRequiredWithoutOrderNestedInput = {
    create?: XOR<ProductCreateWithoutOrderInput, ProductUncheckedCreateWithoutOrderInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOrderInput
    upsert?: ProductUpsertWithoutOrderInput
    connect?: ProductWhereUniqueInput
    update?: XOR<ProductUpdateWithoutOrderInput, ProductUncheckedUpdateWithoutOrderInput>
  }

  export type UserCreateNestedOneWithoutLoginRequestsInput = {
    create?: XOR<UserCreateWithoutLoginRequestsInput, UserUncheckedCreateWithoutLoginRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLoginRequestsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutLoginRequestsNestedInput = {
    create?: XOR<UserCreateWithoutLoginRequestsInput, UserUncheckedCreateWithoutLoginRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLoginRequestsInput
    upsert?: UserUpsertWithoutLoginRequestsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutLoginRequestsInput, UserUncheckedUpdateWithoutLoginRequestsInput>
  }

  export type ProductColorCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<ProductColorCreateWithoutProductInput>, Enumerable<ProductColorUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ProductColorCreateOrConnectWithoutProductInput>
    createMany?: ProductColorCreateManyProductInputEnvelope
    connect?: Enumerable<ProductColorWhereUniqueInput>
  }

  export type OfferCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<OfferCreateWithoutProductInput>, Enumerable<OfferUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<OfferCreateOrConnectWithoutProductInput>
    createMany?: OfferCreateManyProductInputEnvelope
    connect?: Enumerable<OfferWhereUniqueInput>
  }

  export type SeasonalDressesCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<SeasonalDressesCreateWithoutProductInput>, Enumerable<SeasonalDressesUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<SeasonalDressesCreateOrConnectWithoutProductInput>
    createMany?: SeasonalDressesCreateManyProductInputEnvelope
    connect?: Enumerable<SeasonalDressesWhereUniqueInput>
  }

  export type ProductTypeCreateNestedOneWithoutProductInput = {
    create?: XOR<ProductTypeCreateWithoutProductInput, ProductTypeUncheckedCreateWithoutProductInput>
    connectOrCreate?: ProductTypeCreateOrConnectWithoutProductInput
    connect?: ProductTypeWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUserProductInput = {
    create?: XOR<UserCreateWithoutUserProductInput, UserUncheckedCreateWithoutUserProductInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserProductInput
    connect?: UserWhereUniqueInput
  }

  export type PriceHistoryCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<PriceHistoryCreateWithoutProductInput>, Enumerable<PriceHistoryUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<PriceHistoryCreateOrConnectWithoutProductInput>
    createMany?: PriceHistoryCreateManyProductInputEnvelope
    connect?: Enumerable<PriceHistoryWhereUniqueInput>
  }

  export type CommonDescriptionCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<CommonDescriptionCreateWithoutProductInput>, Enumerable<CommonDescriptionUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<CommonDescriptionCreateOrConnectWithoutProductInput>
    createMany?: CommonDescriptionCreateManyProductInputEnvelope
    connect?: Enumerable<CommonDescriptionWhereUniqueInput>
  }

  export type DeleveryPeriodCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<DeleveryPeriodCreateWithoutProductInput>, Enumerable<DeleveryPeriodUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<DeleveryPeriodCreateOrConnectWithoutProductInput>
    createMany?: DeleveryPeriodCreateManyProductInputEnvelope
    connect?: Enumerable<DeleveryPeriodWhereUniqueInput>
  }

  export type ReturnedProductCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<ReturnedProductCreateWithoutProductInput>, Enumerable<ReturnedProductUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ReturnedProductCreateOrConnectWithoutProductInput>
    createMany?: ReturnedProductCreateManyProductInputEnvelope
    connect?: Enumerable<ReturnedProductWhereUniqueInput>
  }

  export type CartCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<CartCreateWithoutProductInput>, Enumerable<CartUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<CartCreateOrConnectWithoutProductInput>
    createMany?: CartCreateManyProductInputEnvelope
    connect?: Enumerable<CartWhereUniqueInput>
  }

  export type WishlistItemCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<WishlistItemCreateWithoutProductInput>, Enumerable<WishlistItemUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<WishlistItemCreateOrConnectWithoutProductInput>
    createMany?: WishlistItemCreateManyProductInputEnvelope
    connect?: Enumerable<WishlistItemWhereUniqueInput>
  }

  export type ProductReviewCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<ProductReviewCreateWithoutProductInput>, Enumerable<ProductReviewUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ProductReviewCreateOrConnectWithoutProductInput>
    createMany?: ProductReviewCreateManyProductInputEnvelope
    connect?: Enumerable<ProductReviewWhereUniqueInput>
  }

  export type OrderCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<OrderCreateWithoutProductInput>, Enumerable<OrderUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutProductInput>
    createMany?: OrderCreateManyProductInputEnvelope
    connect?: Enumerable<OrderWhereUniqueInput>
  }

  export type ProductOwnerCreateNestedOneWithoutProductInput = {
    create?: XOR<ProductOwnerCreateWithoutProductInput, ProductOwnerUncheckedCreateWithoutProductInput>
    connectOrCreate?: ProductOwnerCreateOrConnectWithoutProductInput
    connect?: ProductOwnerWhereUniqueInput
  }

  export type ProductColorUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<ProductColorCreateWithoutProductInput>, Enumerable<ProductColorUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ProductColorCreateOrConnectWithoutProductInput>
    createMany?: ProductColorCreateManyProductInputEnvelope
    connect?: Enumerable<ProductColorWhereUniqueInput>
  }

  export type OfferUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<OfferCreateWithoutProductInput>, Enumerable<OfferUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<OfferCreateOrConnectWithoutProductInput>
    createMany?: OfferCreateManyProductInputEnvelope
    connect?: Enumerable<OfferWhereUniqueInput>
  }

  export type SeasonalDressesUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<SeasonalDressesCreateWithoutProductInput>, Enumerable<SeasonalDressesUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<SeasonalDressesCreateOrConnectWithoutProductInput>
    createMany?: SeasonalDressesCreateManyProductInputEnvelope
    connect?: Enumerable<SeasonalDressesWhereUniqueInput>
  }

  export type PriceHistoryUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<PriceHistoryCreateWithoutProductInput>, Enumerable<PriceHistoryUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<PriceHistoryCreateOrConnectWithoutProductInput>
    createMany?: PriceHistoryCreateManyProductInputEnvelope
    connect?: Enumerable<PriceHistoryWhereUniqueInput>
  }

  export type CommonDescriptionUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<CommonDescriptionCreateWithoutProductInput>, Enumerable<CommonDescriptionUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<CommonDescriptionCreateOrConnectWithoutProductInput>
    createMany?: CommonDescriptionCreateManyProductInputEnvelope
    connect?: Enumerable<CommonDescriptionWhereUniqueInput>
  }

  export type DeleveryPeriodUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<DeleveryPeriodCreateWithoutProductInput>, Enumerable<DeleveryPeriodUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<DeleveryPeriodCreateOrConnectWithoutProductInput>
    createMany?: DeleveryPeriodCreateManyProductInputEnvelope
    connect?: Enumerable<DeleveryPeriodWhereUniqueInput>
  }

  export type ReturnedProductUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<ReturnedProductCreateWithoutProductInput>, Enumerable<ReturnedProductUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ReturnedProductCreateOrConnectWithoutProductInput>
    createMany?: ReturnedProductCreateManyProductInputEnvelope
    connect?: Enumerable<ReturnedProductWhereUniqueInput>
  }

  export type CartUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<CartCreateWithoutProductInput>, Enumerable<CartUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<CartCreateOrConnectWithoutProductInput>
    createMany?: CartCreateManyProductInputEnvelope
    connect?: Enumerable<CartWhereUniqueInput>
  }

  export type WishlistItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<WishlistItemCreateWithoutProductInput>, Enumerable<WishlistItemUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<WishlistItemCreateOrConnectWithoutProductInput>
    createMany?: WishlistItemCreateManyProductInputEnvelope
    connect?: Enumerable<WishlistItemWhereUniqueInput>
  }

  export type ProductReviewUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<ProductReviewCreateWithoutProductInput>, Enumerable<ProductReviewUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ProductReviewCreateOrConnectWithoutProductInput>
    createMany?: ProductReviewCreateManyProductInputEnvelope
    connect?: Enumerable<ProductReviewWhereUniqueInput>
  }

  export type OrderUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<OrderCreateWithoutProductInput>, Enumerable<OrderUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutProductInput>
    createMany?: OrderCreateManyProductInputEnvelope
    connect?: Enumerable<OrderWhereUniqueInput>
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProductColorUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<ProductColorCreateWithoutProductInput>, Enumerable<ProductColorUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ProductColorCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<ProductColorUpsertWithWhereUniqueWithoutProductInput>
    createMany?: ProductColorCreateManyProductInputEnvelope
    set?: Enumerable<ProductColorWhereUniqueInput>
    disconnect?: Enumerable<ProductColorWhereUniqueInput>
    delete?: Enumerable<ProductColorWhereUniqueInput>
    connect?: Enumerable<ProductColorWhereUniqueInput>
    update?: Enumerable<ProductColorUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<ProductColorUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<ProductColorScalarWhereInput>
  }

  export type OfferUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<OfferCreateWithoutProductInput>, Enumerable<OfferUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<OfferCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<OfferUpsertWithWhereUniqueWithoutProductInput>
    createMany?: OfferCreateManyProductInputEnvelope
    set?: Enumerable<OfferWhereUniqueInput>
    disconnect?: Enumerable<OfferWhereUniqueInput>
    delete?: Enumerable<OfferWhereUniqueInput>
    connect?: Enumerable<OfferWhereUniqueInput>
    update?: Enumerable<OfferUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<OfferUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<OfferScalarWhereInput>
  }

  export type SeasonalDressesUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<SeasonalDressesCreateWithoutProductInput>, Enumerable<SeasonalDressesUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<SeasonalDressesCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<SeasonalDressesUpsertWithWhereUniqueWithoutProductInput>
    createMany?: SeasonalDressesCreateManyProductInputEnvelope
    set?: Enumerable<SeasonalDressesWhereUniqueInput>
    disconnect?: Enumerable<SeasonalDressesWhereUniqueInput>
    delete?: Enumerable<SeasonalDressesWhereUniqueInput>
    connect?: Enumerable<SeasonalDressesWhereUniqueInput>
    update?: Enumerable<SeasonalDressesUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<SeasonalDressesUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<SeasonalDressesScalarWhereInput>
  }

  export type ProductTypeUpdateOneRequiredWithoutProductNestedInput = {
    create?: XOR<ProductTypeCreateWithoutProductInput, ProductTypeUncheckedCreateWithoutProductInput>
    connectOrCreate?: ProductTypeCreateOrConnectWithoutProductInput
    upsert?: ProductTypeUpsertWithoutProductInput
    connect?: ProductTypeWhereUniqueInput
    update?: XOR<ProductTypeUpdateWithoutProductInput, ProductTypeUncheckedUpdateWithoutProductInput>
  }

  export type UserUpdateOneWithoutUserProductNestedInput = {
    create?: XOR<UserCreateWithoutUserProductInput, UserUncheckedCreateWithoutUserProductInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserProductInput
    upsert?: UserUpsertWithoutUserProductInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutUserProductInput, UserUncheckedUpdateWithoutUserProductInput>
  }

  export type PriceHistoryUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<PriceHistoryCreateWithoutProductInput>, Enumerable<PriceHistoryUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<PriceHistoryCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<PriceHistoryUpsertWithWhereUniqueWithoutProductInput>
    createMany?: PriceHistoryCreateManyProductInputEnvelope
    set?: Enumerable<PriceHistoryWhereUniqueInput>
    disconnect?: Enumerable<PriceHistoryWhereUniqueInput>
    delete?: Enumerable<PriceHistoryWhereUniqueInput>
    connect?: Enumerable<PriceHistoryWhereUniqueInput>
    update?: Enumerable<PriceHistoryUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<PriceHistoryUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<PriceHistoryScalarWhereInput>
  }

  export type CommonDescriptionUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<CommonDescriptionCreateWithoutProductInput>, Enumerable<CommonDescriptionUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<CommonDescriptionCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<CommonDescriptionUpsertWithWhereUniqueWithoutProductInput>
    createMany?: CommonDescriptionCreateManyProductInputEnvelope
    set?: Enumerable<CommonDescriptionWhereUniqueInput>
    disconnect?: Enumerable<CommonDescriptionWhereUniqueInput>
    delete?: Enumerable<CommonDescriptionWhereUniqueInput>
    connect?: Enumerable<CommonDescriptionWhereUniqueInput>
    update?: Enumerable<CommonDescriptionUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<CommonDescriptionUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<CommonDescriptionScalarWhereInput>
  }

  export type DeleveryPeriodUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<DeleveryPeriodCreateWithoutProductInput>, Enumerable<DeleveryPeriodUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<DeleveryPeriodCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<DeleveryPeriodUpsertWithWhereUniqueWithoutProductInput>
    createMany?: DeleveryPeriodCreateManyProductInputEnvelope
    set?: Enumerable<DeleveryPeriodWhereUniqueInput>
    disconnect?: Enumerable<DeleveryPeriodWhereUniqueInput>
    delete?: Enumerable<DeleveryPeriodWhereUniqueInput>
    connect?: Enumerable<DeleveryPeriodWhereUniqueInput>
    update?: Enumerable<DeleveryPeriodUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<DeleveryPeriodUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<DeleveryPeriodScalarWhereInput>
  }

  export type ReturnedProductUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<ReturnedProductCreateWithoutProductInput>, Enumerable<ReturnedProductUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ReturnedProductCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<ReturnedProductUpsertWithWhereUniqueWithoutProductInput>
    createMany?: ReturnedProductCreateManyProductInputEnvelope
    set?: Enumerable<ReturnedProductWhereUniqueInput>
    disconnect?: Enumerable<ReturnedProductWhereUniqueInput>
    delete?: Enumerable<ReturnedProductWhereUniqueInput>
    connect?: Enumerable<ReturnedProductWhereUniqueInput>
    update?: Enumerable<ReturnedProductUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<ReturnedProductUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<ReturnedProductScalarWhereInput>
  }

  export type CartUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<CartCreateWithoutProductInput>, Enumerable<CartUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<CartCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<CartUpsertWithWhereUniqueWithoutProductInput>
    createMany?: CartCreateManyProductInputEnvelope
    set?: Enumerable<CartWhereUniqueInput>
    disconnect?: Enumerable<CartWhereUniqueInput>
    delete?: Enumerable<CartWhereUniqueInput>
    connect?: Enumerable<CartWhereUniqueInput>
    update?: Enumerable<CartUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<CartUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<CartScalarWhereInput>
  }

  export type WishlistItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<WishlistItemCreateWithoutProductInput>, Enumerable<WishlistItemUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<WishlistItemCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<WishlistItemUpsertWithWhereUniqueWithoutProductInput>
    createMany?: WishlistItemCreateManyProductInputEnvelope
    set?: Enumerable<WishlistItemWhereUniqueInput>
    disconnect?: Enumerable<WishlistItemWhereUniqueInput>
    delete?: Enumerable<WishlistItemWhereUniqueInput>
    connect?: Enumerable<WishlistItemWhereUniqueInput>
    update?: Enumerable<WishlistItemUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<WishlistItemUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<WishlistItemScalarWhereInput>
  }

  export type ProductReviewUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<ProductReviewCreateWithoutProductInput>, Enumerable<ProductReviewUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ProductReviewCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<ProductReviewUpsertWithWhereUniqueWithoutProductInput>
    createMany?: ProductReviewCreateManyProductInputEnvelope
    set?: Enumerable<ProductReviewWhereUniqueInput>
    disconnect?: Enumerable<ProductReviewWhereUniqueInput>
    delete?: Enumerable<ProductReviewWhereUniqueInput>
    connect?: Enumerable<ProductReviewWhereUniqueInput>
    update?: Enumerable<ProductReviewUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<ProductReviewUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<ProductReviewScalarWhereInput>
  }

  export type OrderUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<OrderCreateWithoutProductInput>, Enumerable<OrderUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<OrderUpsertWithWhereUniqueWithoutProductInput>
    createMany?: OrderCreateManyProductInputEnvelope
    set?: Enumerable<OrderWhereUniqueInput>
    disconnect?: Enumerable<OrderWhereUniqueInput>
    delete?: Enumerable<OrderWhereUniqueInput>
    connect?: Enumerable<OrderWhereUniqueInput>
    update?: Enumerable<OrderUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<OrderUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<OrderScalarWhereInput>
  }

  export type ProductOwnerUpdateOneWithoutProductNestedInput = {
    create?: XOR<ProductOwnerCreateWithoutProductInput, ProductOwnerUncheckedCreateWithoutProductInput>
    connectOrCreate?: ProductOwnerCreateOrConnectWithoutProductInput
    upsert?: ProductOwnerUpsertWithoutProductInput
    disconnect?: boolean
    delete?: boolean
    connect?: ProductOwnerWhereUniqueInput
    update?: XOR<ProductOwnerUpdateWithoutProductInput, ProductOwnerUncheckedUpdateWithoutProductInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProductColorUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<ProductColorCreateWithoutProductInput>, Enumerable<ProductColorUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ProductColorCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<ProductColorUpsertWithWhereUniqueWithoutProductInput>
    createMany?: ProductColorCreateManyProductInputEnvelope
    set?: Enumerable<ProductColorWhereUniqueInput>
    disconnect?: Enumerable<ProductColorWhereUniqueInput>
    delete?: Enumerable<ProductColorWhereUniqueInput>
    connect?: Enumerable<ProductColorWhereUniqueInput>
    update?: Enumerable<ProductColorUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<ProductColorUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<ProductColorScalarWhereInput>
  }

  export type OfferUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<OfferCreateWithoutProductInput>, Enumerable<OfferUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<OfferCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<OfferUpsertWithWhereUniqueWithoutProductInput>
    createMany?: OfferCreateManyProductInputEnvelope
    set?: Enumerable<OfferWhereUniqueInput>
    disconnect?: Enumerable<OfferWhereUniqueInput>
    delete?: Enumerable<OfferWhereUniqueInput>
    connect?: Enumerable<OfferWhereUniqueInput>
    update?: Enumerable<OfferUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<OfferUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<OfferScalarWhereInput>
  }

  export type SeasonalDressesUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<SeasonalDressesCreateWithoutProductInput>, Enumerable<SeasonalDressesUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<SeasonalDressesCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<SeasonalDressesUpsertWithWhereUniqueWithoutProductInput>
    createMany?: SeasonalDressesCreateManyProductInputEnvelope
    set?: Enumerable<SeasonalDressesWhereUniqueInput>
    disconnect?: Enumerable<SeasonalDressesWhereUniqueInput>
    delete?: Enumerable<SeasonalDressesWhereUniqueInput>
    connect?: Enumerable<SeasonalDressesWhereUniqueInput>
    update?: Enumerable<SeasonalDressesUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<SeasonalDressesUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<SeasonalDressesScalarWhereInput>
  }

  export type PriceHistoryUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<PriceHistoryCreateWithoutProductInput>, Enumerable<PriceHistoryUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<PriceHistoryCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<PriceHistoryUpsertWithWhereUniqueWithoutProductInput>
    createMany?: PriceHistoryCreateManyProductInputEnvelope
    set?: Enumerable<PriceHistoryWhereUniqueInput>
    disconnect?: Enumerable<PriceHistoryWhereUniqueInput>
    delete?: Enumerable<PriceHistoryWhereUniqueInput>
    connect?: Enumerable<PriceHistoryWhereUniqueInput>
    update?: Enumerable<PriceHistoryUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<PriceHistoryUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<PriceHistoryScalarWhereInput>
  }

  export type CommonDescriptionUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<CommonDescriptionCreateWithoutProductInput>, Enumerable<CommonDescriptionUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<CommonDescriptionCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<CommonDescriptionUpsertWithWhereUniqueWithoutProductInput>
    createMany?: CommonDescriptionCreateManyProductInputEnvelope
    set?: Enumerable<CommonDescriptionWhereUniqueInput>
    disconnect?: Enumerable<CommonDescriptionWhereUniqueInput>
    delete?: Enumerable<CommonDescriptionWhereUniqueInput>
    connect?: Enumerable<CommonDescriptionWhereUniqueInput>
    update?: Enumerable<CommonDescriptionUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<CommonDescriptionUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<CommonDescriptionScalarWhereInput>
  }

  export type DeleveryPeriodUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<DeleveryPeriodCreateWithoutProductInput>, Enumerable<DeleveryPeriodUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<DeleveryPeriodCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<DeleveryPeriodUpsertWithWhereUniqueWithoutProductInput>
    createMany?: DeleveryPeriodCreateManyProductInputEnvelope
    set?: Enumerable<DeleveryPeriodWhereUniqueInput>
    disconnect?: Enumerable<DeleveryPeriodWhereUniqueInput>
    delete?: Enumerable<DeleveryPeriodWhereUniqueInput>
    connect?: Enumerable<DeleveryPeriodWhereUniqueInput>
    update?: Enumerable<DeleveryPeriodUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<DeleveryPeriodUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<DeleveryPeriodScalarWhereInput>
  }

  export type ReturnedProductUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<ReturnedProductCreateWithoutProductInput>, Enumerable<ReturnedProductUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ReturnedProductCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<ReturnedProductUpsertWithWhereUniqueWithoutProductInput>
    createMany?: ReturnedProductCreateManyProductInputEnvelope
    set?: Enumerable<ReturnedProductWhereUniqueInput>
    disconnect?: Enumerable<ReturnedProductWhereUniqueInput>
    delete?: Enumerable<ReturnedProductWhereUniqueInput>
    connect?: Enumerable<ReturnedProductWhereUniqueInput>
    update?: Enumerable<ReturnedProductUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<ReturnedProductUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<ReturnedProductScalarWhereInput>
  }

  export type CartUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<CartCreateWithoutProductInput>, Enumerable<CartUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<CartCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<CartUpsertWithWhereUniqueWithoutProductInput>
    createMany?: CartCreateManyProductInputEnvelope
    set?: Enumerable<CartWhereUniqueInput>
    disconnect?: Enumerable<CartWhereUniqueInput>
    delete?: Enumerable<CartWhereUniqueInput>
    connect?: Enumerable<CartWhereUniqueInput>
    update?: Enumerable<CartUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<CartUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<CartScalarWhereInput>
  }

  export type WishlistItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<WishlistItemCreateWithoutProductInput>, Enumerable<WishlistItemUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<WishlistItemCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<WishlistItemUpsertWithWhereUniqueWithoutProductInput>
    createMany?: WishlistItemCreateManyProductInputEnvelope
    set?: Enumerable<WishlistItemWhereUniqueInput>
    disconnect?: Enumerable<WishlistItemWhereUniqueInput>
    delete?: Enumerable<WishlistItemWhereUniqueInput>
    connect?: Enumerable<WishlistItemWhereUniqueInput>
    update?: Enumerable<WishlistItemUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<WishlistItemUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<WishlistItemScalarWhereInput>
  }

  export type ProductReviewUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<ProductReviewCreateWithoutProductInput>, Enumerable<ProductReviewUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ProductReviewCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<ProductReviewUpsertWithWhereUniqueWithoutProductInput>
    createMany?: ProductReviewCreateManyProductInputEnvelope
    set?: Enumerable<ProductReviewWhereUniqueInput>
    disconnect?: Enumerable<ProductReviewWhereUniqueInput>
    delete?: Enumerable<ProductReviewWhereUniqueInput>
    connect?: Enumerable<ProductReviewWhereUniqueInput>
    update?: Enumerable<ProductReviewUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<ProductReviewUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<ProductReviewScalarWhereInput>
  }

  export type OrderUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<OrderCreateWithoutProductInput>, Enumerable<OrderUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<OrderUpsertWithWhereUniqueWithoutProductInput>
    createMany?: OrderCreateManyProductInputEnvelope
    set?: Enumerable<OrderWhereUniqueInput>
    disconnect?: Enumerable<OrderWhereUniqueInput>
    delete?: Enumerable<OrderWhereUniqueInput>
    connect?: Enumerable<OrderWhereUniqueInput>
    update?: Enumerable<OrderUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<OrderUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<OrderScalarWhereInput>
  }

  export type ProductCreateNestedOneWithoutProductReviewsInput = {
    create?: XOR<ProductCreateWithoutProductReviewsInput, ProductUncheckedCreateWithoutProductReviewsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductReviewsInput
    connect?: ProductWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProductReviewInput = {
    create?: XOR<UserCreateWithoutProductReviewInput, UserUncheckedCreateWithoutProductReviewInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductReviewInput
    connect?: UserWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutProductReviewsNestedInput = {
    create?: XOR<ProductCreateWithoutProductReviewsInput, ProductUncheckedCreateWithoutProductReviewsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductReviewsInput
    upsert?: ProductUpsertWithoutProductReviewsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<ProductUpdateWithoutProductReviewsInput, ProductUncheckedUpdateWithoutProductReviewsInput>
  }

  export type UserUpdateOneRequiredWithoutProductReviewNestedInput = {
    create?: XOR<UserCreateWithoutProductReviewInput, UserUncheckedCreateWithoutProductReviewInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductReviewInput
    upsert?: UserUpsertWithoutProductReviewInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutProductReviewInput, UserUncheckedUpdateWithoutProductReviewInput>
  }

  export type ProductCreateNestedOneWithoutReturnsInput = {
    create?: XOR<ProductCreateWithoutReturnsInput, ProductUncheckedCreateWithoutReturnsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutReturnsInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutReturnsNestedInput = {
    create?: XOR<ProductCreateWithoutReturnsInput, ProductUncheckedCreateWithoutReturnsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutReturnsInput
    upsert?: ProductUpsertWithoutReturnsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<ProductUpdateWithoutReturnsInput, ProductUncheckedUpdateWithoutReturnsInput>
  }

  export type ProductCreateNestedOneWithoutDeliveryInput = {
    create?: XOR<ProductCreateWithoutDeliveryInput, ProductUncheckedCreateWithoutDeliveryInput>
    connectOrCreate?: ProductCreateOrConnectWithoutDeliveryInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutDeliveryNestedInput = {
    create?: XOR<ProductCreateWithoutDeliveryInput, ProductUncheckedCreateWithoutDeliveryInput>
    connectOrCreate?: ProductCreateOrConnectWithoutDeliveryInput
    upsert?: ProductUpsertWithoutDeliveryInput
    connect?: ProductWhereUniqueInput
    update?: XOR<ProductUpdateWithoutDeliveryInput, ProductUncheckedUpdateWithoutDeliveryInput>
  }

  export type ProductCreateNestedOneWithoutColorInput = {
    create?: XOR<ProductCreateWithoutColorInput, ProductUncheckedCreateWithoutColorInput>
    connectOrCreate?: ProductCreateOrConnectWithoutColorInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductAviableSizesCreateNestedManyWithoutProductColorInput = {
    create?: XOR<Enumerable<ProductAviableSizesCreateWithoutProductColorInput>, Enumerable<ProductAviableSizesUncheckedCreateWithoutProductColorInput>>
    connectOrCreate?: Enumerable<ProductAviableSizesCreateOrConnectWithoutProductColorInput>
    createMany?: ProductAviableSizesCreateManyProductColorInputEnvelope
    connect?: Enumerable<ProductAviableSizesWhereUniqueInput>
  }

  export type ProductImagesCreateNestedManyWithoutProductColorInput = {
    create?: XOR<Enumerable<ProductImagesCreateWithoutProductColorInput>, Enumerable<ProductImagesUncheckedCreateWithoutProductColorInput>>
    connectOrCreate?: Enumerable<ProductImagesCreateOrConnectWithoutProductColorInput>
    createMany?: ProductImagesCreateManyProductColorInputEnvelope
    connect?: Enumerable<ProductImagesWhereUniqueInput>
  }

  export type ProductAviableSizesUncheckedCreateNestedManyWithoutProductColorInput = {
    create?: XOR<Enumerable<ProductAviableSizesCreateWithoutProductColorInput>, Enumerable<ProductAviableSizesUncheckedCreateWithoutProductColorInput>>
    connectOrCreate?: Enumerable<ProductAviableSizesCreateOrConnectWithoutProductColorInput>
    createMany?: ProductAviableSizesCreateManyProductColorInputEnvelope
    connect?: Enumerable<ProductAviableSizesWhereUniqueInput>
  }

  export type ProductImagesUncheckedCreateNestedManyWithoutProductColorInput = {
    create?: XOR<Enumerable<ProductImagesCreateWithoutProductColorInput>, Enumerable<ProductImagesUncheckedCreateWithoutProductColorInput>>
    connectOrCreate?: Enumerable<ProductImagesCreateOrConnectWithoutProductColorInput>
    createMany?: ProductImagesCreateManyProductColorInputEnvelope
    connect?: Enumerable<ProductImagesWhereUniqueInput>
  }

  export type ProductUpdateOneRequiredWithoutColorNestedInput = {
    create?: XOR<ProductCreateWithoutColorInput, ProductUncheckedCreateWithoutColorInput>
    connectOrCreate?: ProductCreateOrConnectWithoutColorInput
    upsert?: ProductUpsertWithoutColorInput
    connect?: ProductWhereUniqueInput
    update?: XOR<ProductUpdateWithoutColorInput, ProductUncheckedUpdateWithoutColorInput>
  }

  export type ProductAviableSizesUpdateManyWithoutProductColorNestedInput = {
    create?: XOR<Enumerable<ProductAviableSizesCreateWithoutProductColorInput>, Enumerable<ProductAviableSizesUncheckedCreateWithoutProductColorInput>>
    connectOrCreate?: Enumerable<ProductAviableSizesCreateOrConnectWithoutProductColorInput>
    upsert?: Enumerable<ProductAviableSizesUpsertWithWhereUniqueWithoutProductColorInput>
    createMany?: ProductAviableSizesCreateManyProductColorInputEnvelope
    set?: Enumerable<ProductAviableSizesWhereUniqueInput>
    disconnect?: Enumerable<ProductAviableSizesWhereUniqueInput>
    delete?: Enumerable<ProductAviableSizesWhereUniqueInput>
    connect?: Enumerable<ProductAviableSizesWhereUniqueInput>
    update?: Enumerable<ProductAviableSizesUpdateWithWhereUniqueWithoutProductColorInput>
    updateMany?: Enumerable<ProductAviableSizesUpdateManyWithWhereWithoutProductColorInput>
    deleteMany?: Enumerable<ProductAviableSizesScalarWhereInput>
  }

  export type ProductImagesUpdateManyWithoutProductColorNestedInput = {
    create?: XOR<Enumerable<ProductImagesCreateWithoutProductColorInput>, Enumerable<ProductImagesUncheckedCreateWithoutProductColorInput>>
    connectOrCreate?: Enumerable<ProductImagesCreateOrConnectWithoutProductColorInput>
    upsert?: Enumerable<ProductImagesUpsertWithWhereUniqueWithoutProductColorInput>
    createMany?: ProductImagesCreateManyProductColorInputEnvelope
    set?: Enumerable<ProductImagesWhereUniqueInput>
    disconnect?: Enumerable<ProductImagesWhereUniqueInput>
    delete?: Enumerable<ProductImagesWhereUniqueInput>
    connect?: Enumerable<ProductImagesWhereUniqueInput>
    update?: Enumerable<ProductImagesUpdateWithWhereUniqueWithoutProductColorInput>
    updateMany?: Enumerable<ProductImagesUpdateManyWithWhereWithoutProductColorInput>
    deleteMany?: Enumerable<ProductImagesScalarWhereInput>
  }

  export type ProductAviableSizesUncheckedUpdateManyWithoutProductColorNestedInput = {
    create?: XOR<Enumerable<ProductAviableSizesCreateWithoutProductColorInput>, Enumerable<ProductAviableSizesUncheckedCreateWithoutProductColorInput>>
    connectOrCreate?: Enumerable<ProductAviableSizesCreateOrConnectWithoutProductColorInput>
    upsert?: Enumerable<ProductAviableSizesUpsertWithWhereUniqueWithoutProductColorInput>
    createMany?: ProductAviableSizesCreateManyProductColorInputEnvelope
    set?: Enumerable<ProductAviableSizesWhereUniqueInput>
    disconnect?: Enumerable<ProductAviableSizesWhereUniqueInput>
    delete?: Enumerable<ProductAviableSizesWhereUniqueInput>
    connect?: Enumerable<ProductAviableSizesWhereUniqueInput>
    update?: Enumerable<ProductAviableSizesUpdateWithWhereUniqueWithoutProductColorInput>
    updateMany?: Enumerable<ProductAviableSizesUpdateManyWithWhereWithoutProductColorInput>
    deleteMany?: Enumerable<ProductAviableSizesScalarWhereInput>
  }

  export type ProductImagesUncheckedUpdateManyWithoutProductColorNestedInput = {
    create?: XOR<Enumerable<ProductImagesCreateWithoutProductColorInput>, Enumerable<ProductImagesUncheckedCreateWithoutProductColorInput>>
    connectOrCreate?: Enumerable<ProductImagesCreateOrConnectWithoutProductColorInput>
    upsert?: Enumerable<ProductImagesUpsertWithWhereUniqueWithoutProductColorInput>
    createMany?: ProductImagesCreateManyProductColorInputEnvelope
    set?: Enumerable<ProductImagesWhereUniqueInput>
    disconnect?: Enumerable<ProductImagesWhereUniqueInput>
    delete?: Enumerable<ProductImagesWhereUniqueInput>
    connect?: Enumerable<ProductImagesWhereUniqueInput>
    update?: Enumerable<ProductImagesUpdateWithWhereUniqueWithoutProductColorInput>
    updateMany?: Enumerable<ProductImagesUpdateManyWithWhereWithoutProductColorInput>
    deleteMany?: Enumerable<ProductImagesScalarWhereInput>
  }

  export type ProductCreateNestedOneWithoutPriceHistoryInput = {
    create?: XOR<ProductCreateWithoutPriceHistoryInput, ProductUncheckedCreateWithoutPriceHistoryInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPriceHistoryInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutPriceHistoryNestedInput = {
    create?: XOR<ProductCreateWithoutPriceHistoryInput, ProductUncheckedCreateWithoutPriceHistoryInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPriceHistoryInput
    upsert?: ProductUpsertWithoutPriceHistoryInput
    connect?: ProductWhereUniqueInput
    update?: XOR<ProductUpdateWithoutPriceHistoryInput, ProductUncheckedUpdateWithoutPriceHistoryInput>
  }

  export type QuantityHistoryCreateNestedManyWithoutProductAviableSizesInput = {
    create?: XOR<Enumerable<QuantityHistoryCreateWithoutProductAviableSizesInput>, Enumerable<QuantityHistoryUncheckedCreateWithoutProductAviableSizesInput>>
    connectOrCreate?: Enumerable<QuantityHistoryCreateOrConnectWithoutProductAviableSizesInput>
    createMany?: QuantityHistoryCreateManyProductAviableSizesInputEnvelope
    connect?: Enumerable<QuantityHistoryWhereUniqueInput>
  }

  export type ProductColorCreateNestedOneWithoutColorSizeInput = {
    create?: XOR<ProductColorCreateWithoutColorSizeInput, ProductColorUncheckedCreateWithoutColorSizeInput>
    connectOrCreate?: ProductColorCreateOrConnectWithoutColorSizeInput
    connect?: ProductColorWhereUniqueInput
  }

  export type ProductTypeSizeCreateNestedOneWithoutAviableSizesInput = {
    create?: XOR<ProductTypeSizeCreateWithoutAviableSizesInput, ProductTypeSizeUncheckedCreateWithoutAviableSizesInput>
    connectOrCreate?: ProductTypeSizeCreateOrConnectWithoutAviableSizesInput
    connect?: ProductTypeSizeWhereUniqueInput
  }

  export type QuantityHistoryUncheckedCreateNestedManyWithoutProductAviableSizesInput = {
    create?: XOR<Enumerable<QuantityHistoryCreateWithoutProductAviableSizesInput>, Enumerable<QuantityHistoryUncheckedCreateWithoutProductAviableSizesInput>>
    connectOrCreate?: Enumerable<QuantityHistoryCreateOrConnectWithoutProductAviableSizesInput>
    createMany?: QuantityHistoryCreateManyProductAviableSizesInputEnvelope
    connect?: Enumerable<QuantityHistoryWhereUniqueInput>
  }

  export type QuantityHistoryUpdateManyWithoutProductAviableSizesNestedInput = {
    create?: XOR<Enumerable<QuantityHistoryCreateWithoutProductAviableSizesInput>, Enumerable<QuantityHistoryUncheckedCreateWithoutProductAviableSizesInput>>
    connectOrCreate?: Enumerable<QuantityHistoryCreateOrConnectWithoutProductAviableSizesInput>
    upsert?: Enumerable<QuantityHistoryUpsertWithWhereUniqueWithoutProductAviableSizesInput>
    createMany?: QuantityHistoryCreateManyProductAviableSizesInputEnvelope
    set?: Enumerable<QuantityHistoryWhereUniqueInput>
    disconnect?: Enumerable<QuantityHistoryWhereUniqueInput>
    delete?: Enumerable<QuantityHistoryWhereUniqueInput>
    connect?: Enumerable<QuantityHistoryWhereUniqueInput>
    update?: Enumerable<QuantityHistoryUpdateWithWhereUniqueWithoutProductAviableSizesInput>
    updateMany?: Enumerable<QuantityHistoryUpdateManyWithWhereWithoutProductAviableSizesInput>
    deleteMany?: Enumerable<QuantityHistoryScalarWhereInput>
  }

  export type ProductColorUpdateOneRequiredWithoutColorSizeNestedInput = {
    create?: XOR<ProductColorCreateWithoutColorSizeInput, ProductColorUncheckedCreateWithoutColorSizeInput>
    connectOrCreate?: ProductColorCreateOrConnectWithoutColorSizeInput
    upsert?: ProductColorUpsertWithoutColorSizeInput
    connect?: ProductColorWhereUniqueInput
    update?: XOR<ProductColorUpdateWithoutColorSizeInput, ProductColorUncheckedUpdateWithoutColorSizeInput>
  }

  export type ProductTypeSizeUpdateOneRequiredWithoutAviableSizesNestedInput = {
    create?: XOR<ProductTypeSizeCreateWithoutAviableSizesInput, ProductTypeSizeUncheckedCreateWithoutAviableSizesInput>
    connectOrCreate?: ProductTypeSizeCreateOrConnectWithoutAviableSizesInput
    upsert?: ProductTypeSizeUpsertWithoutAviableSizesInput
    connect?: ProductTypeSizeWhereUniqueInput
    update?: XOR<ProductTypeSizeUpdateWithoutAviableSizesInput, ProductTypeSizeUncheckedUpdateWithoutAviableSizesInput>
  }

  export type QuantityHistoryUncheckedUpdateManyWithoutProductAviableSizesNestedInput = {
    create?: XOR<Enumerable<QuantityHistoryCreateWithoutProductAviableSizesInput>, Enumerable<QuantityHistoryUncheckedCreateWithoutProductAviableSizesInput>>
    connectOrCreate?: Enumerable<QuantityHistoryCreateOrConnectWithoutProductAviableSizesInput>
    upsert?: Enumerable<QuantityHistoryUpsertWithWhereUniqueWithoutProductAviableSizesInput>
    createMany?: QuantityHistoryCreateManyProductAviableSizesInputEnvelope
    set?: Enumerable<QuantityHistoryWhereUniqueInput>
    disconnect?: Enumerable<QuantityHistoryWhereUniqueInput>
    delete?: Enumerable<QuantityHistoryWhereUniqueInput>
    connect?: Enumerable<QuantityHistoryWhereUniqueInput>
    update?: Enumerable<QuantityHistoryUpdateWithWhereUniqueWithoutProductAviableSizesInput>
    updateMany?: Enumerable<QuantityHistoryUpdateManyWithWhereWithoutProductAviableSizesInput>
    deleteMany?: Enumerable<QuantityHistoryScalarWhereInput>
  }

  export type ProductCreateNestedOneWithoutSeasonalDressesInput = {
    create?: XOR<ProductCreateWithoutSeasonalDressesInput, ProductUncheckedCreateWithoutSeasonalDressesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutSeasonalDressesInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutSeasonalDressesNestedInput = {
    create?: XOR<ProductCreateWithoutSeasonalDressesInput, ProductUncheckedCreateWithoutSeasonalDressesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutSeasonalDressesInput
    upsert?: ProductUpsertWithoutSeasonalDressesInput
    connect?: ProductWhereUniqueInput
    update?: XOR<ProductUpdateWithoutSeasonalDressesInput, ProductUncheckedUpdateWithoutSeasonalDressesInput>
  }

  export type ProductColorCreateNestedOneWithoutProductImagesInput = {
    create?: XOR<ProductColorCreateWithoutProductImagesInput, ProductColorUncheckedCreateWithoutProductImagesInput>
    connectOrCreate?: ProductColorCreateOrConnectWithoutProductImagesInput
    connect?: ProductColorWhereUniqueInput
  }

  export type ProductColorUpdateOneWithoutProductImagesNestedInput = {
    create?: XOR<ProductColorCreateWithoutProductImagesInput, ProductColorUncheckedCreateWithoutProductImagesInput>
    connectOrCreate?: ProductColorCreateOrConnectWithoutProductImagesInput
    upsert?: ProductColorUpsertWithoutProductImagesInput
    disconnect?: boolean
    delete?: boolean
    connect?: ProductColorWhereUniqueInput
    update?: XOR<ProductColorUpdateWithoutProductImagesInput, ProductColorUncheckedUpdateWithoutProductImagesInput>
  }

  export type ProductCreateNestedOneWithoutCommonDescriptionInput = {
    create?: XOR<ProductCreateWithoutCommonDescriptionInput, ProductUncheckedCreateWithoutCommonDescriptionInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCommonDescriptionInput
    connect?: ProductWhereUniqueInput
  }

  export type TopDescriptionCreateNestedManyWithoutCommonDescriptionInput = {
    create?: XOR<Enumerable<TopDescriptionCreateWithoutCommonDescriptionInput>, Enumerable<TopDescriptionUncheckedCreateWithoutCommonDescriptionInput>>
    connectOrCreate?: Enumerable<TopDescriptionCreateOrConnectWithoutCommonDescriptionInput>
    createMany?: TopDescriptionCreateManyCommonDescriptionInputEnvelope
    connect?: Enumerable<TopDescriptionWhereUniqueInput>
  }

  export type BottomDescriptionCreateNestedManyWithoutCommonDescriptionInput = {
    create?: XOR<Enumerable<BottomDescriptionCreateWithoutCommonDescriptionInput>, Enumerable<BottomDescriptionUncheckedCreateWithoutCommonDescriptionInput>>
    connectOrCreate?: Enumerable<BottomDescriptionCreateOrConnectWithoutCommonDescriptionInput>
    createMany?: BottomDescriptionCreateManyCommonDescriptionInputEnvelope
    connect?: Enumerable<BottomDescriptionWhereUniqueInput>
  }

  export type KurtasDescriptionCreateNestedManyWithoutCommonDescriptionInput = {
    create?: XOR<Enumerable<KurtasDescriptionCreateWithoutCommonDescriptionInput>, Enumerable<KurtasDescriptionUncheckedCreateWithoutCommonDescriptionInput>>
    connectOrCreate?: Enumerable<KurtasDescriptionCreateOrConnectWithoutCommonDescriptionInput>
    createMany?: KurtasDescriptionCreateManyCommonDescriptionInputEnvelope
    connect?: Enumerable<KurtasDescriptionWhereUniqueInput>
  }

  export type ShoesDescriptionCreateNestedManyWithoutCommonDescriptionInput = {
    create?: XOR<Enumerable<ShoesDescriptionCreateWithoutCommonDescriptionInput>, Enumerable<ShoesDescriptionUncheckedCreateWithoutCommonDescriptionInput>>
    connectOrCreate?: Enumerable<ShoesDescriptionCreateOrConnectWithoutCommonDescriptionInput>
    createMany?: ShoesDescriptionCreateManyCommonDescriptionInputEnvelope
    connect?: Enumerable<ShoesDescriptionWhereUniqueInput>
  }

  export type InnersDescriptionCreateNestedManyWithoutCommonDescriptionInput = {
    create?: XOR<Enumerable<InnersDescriptionCreateWithoutCommonDescriptionInput>, Enumerable<InnersDescriptionUncheckedCreateWithoutCommonDescriptionInput>>
    connectOrCreate?: Enumerable<InnersDescriptionCreateOrConnectWithoutCommonDescriptionInput>
    createMany?: InnersDescriptionCreateManyCommonDescriptionInputEnvelope
    connect?: Enumerable<InnersDescriptionWhereUniqueInput>
  }

  export type WatchesDescriptionCreateNestedManyWithoutCommonDescriptionInput = {
    create?: XOR<Enumerable<WatchesDescriptionCreateWithoutCommonDescriptionInput>, Enumerable<WatchesDescriptionUncheckedCreateWithoutCommonDescriptionInput>>
    connectOrCreate?: Enumerable<WatchesDescriptionCreateOrConnectWithoutCommonDescriptionInput>
    createMany?: WatchesDescriptionCreateManyCommonDescriptionInputEnvelope
    connect?: Enumerable<WatchesDescriptionWhereUniqueInput>
  }

  export type PerfumesDescriptionCreateNestedManyWithoutCommonDescriptionInput = {
    create?: XOR<Enumerable<PerfumesDescriptionCreateWithoutCommonDescriptionInput>, Enumerable<PerfumesDescriptionUncheckedCreateWithoutCommonDescriptionInput>>
    connectOrCreate?: Enumerable<PerfumesDescriptionCreateOrConnectWithoutCommonDescriptionInput>
    createMany?: PerfumesDescriptionCreateManyCommonDescriptionInputEnvelope
    connect?: Enumerable<PerfumesDescriptionWhereUniqueInput>
  }

  export type TopDescriptionUncheckedCreateNestedManyWithoutCommonDescriptionInput = {
    create?: XOR<Enumerable<TopDescriptionCreateWithoutCommonDescriptionInput>, Enumerable<TopDescriptionUncheckedCreateWithoutCommonDescriptionInput>>
    connectOrCreate?: Enumerable<TopDescriptionCreateOrConnectWithoutCommonDescriptionInput>
    createMany?: TopDescriptionCreateManyCommonDescriptionInputEnvelope
    connect?: Enumerable<TopDescriptionWhereUniqueInput>
  }

  export type BottomDescriptionUncheckedCreateNestedManyWithoutCommonDescriptionInput = {
    create?: XOR<Enumerable<BottomDescriptionCreateWithoutCommonDescriptionInput>, Enumerable<BottomDescriptionUncheckedCreateWithoutCommonDescriptionInput>>
    connectOrCreate?: Enumerable<BottomDescriptionCreateOrConnectWithoutCommonDescriptionInput>
    createMany?: BottomDescriptionCreateManyCommonDescriptionInputEnvelope
    connect?: Enumerable<BottomDescriptionWhereUniqueInput>
  }

  export type KurtasDescriptionUncheckedCreateNestedManyWithoutCommonDescriptionInput = {
    create?: XOR<Enumerable<KurtasDescriptionCreateWithoutCommonDescriptionInput>, Enumerable<KurtasDescriptionUncheckedCreateWithoutCommonDescriptionInput>>
    connectOrCreate?: Enumerable<KurtasDescriptionCreateOrConnectWithoutCommonDescriptionInput>
    createMany?: KurtasDescriptionCreateManyCommonDescriptionInputEnvelope
    connect?: Enumerable<KurtasDescriptionWhereUniqueInput>
  }

  export type ShoesDescriptionUncheckedCreateNestedManyWithoutCommonDescriptionInput = {
    create?: XOR<Enumerable<ShoesDescriptionCreateWithoutCommonDescriptionInput>, Enumerable<ShoesDescriptionUncheckedCreateWithoutCommonDescriptionInput>>
    connectOrCreate?: Enumerable<ShoesDescriptionCreateOrConnectWithoutCommonDescriptionInput>
    createMany?: ShoesDescriptionCreateManyCommonDescriptionInputEnvelope
    connect?: Enumerable<ShoesDescriptionWhereUniqueInput>
  }

  export type InnersDescriptionUncheckedCreateNestedManyWithoutCommonDescriptionInput = {
    create?: XOR<Enumerable<InnersDescriptionCreateWithoutCommonDescriptionInput>, Enumerable<InnersDescriptionUncheckedCreateWithoutCommonDescriptionInput>>
    connectOrCreate?: Enumerable<InnersDescriptionCreateOrConnectWithoutCommonDescriptionInput>
    createMany?: InnersDescriptionCreateManyCommonDescriptionInputEnvelope
    connect?: Enumerable<InnersDescriptionWhereUniqueInput>
  }

  export type WatchesDescriptionUncheckedCreateNestedManyWithoutCommonDescriptionInput = {
    create?: XOR<Enumerable<WatchesDescriptionCreateWithoutCommonDescriptionInput>, Enumerable<WatchesDescriptionUncheckedCreateWithoutCommonDescriptionInput>>
    connectOrCreate?: Enumerable<WatchesDescriptionCreateOrConnectWithoutCommonDescriptionInput>
    createMany?: WatchesDescriptionCreateManyCommonDescriptionInputEnvelope
    connect?: Enumerable<WatchesDescriptionWhereUniqueInput>
  }

  export type PerfumesDescriptionUncheckedCreateNestedManyWithoutCommonDescriptionInput = {
    create?: XOR<Enumerable<PerfumesDescriptionCreateWithoutCommonDescriptionInput>, Enumerable<PerfumesDescriptionUncheckedCreateWithoutCommonDescriptionInput>>
    connectOrCreate?: Enumerable<PerfumesDescriptionCreateOrConnectWithoutCommonDescriptionInput>
    createMany?: PerfumesDescriptionCreateManyCommonDescriptionInputEnvelope
    connect?: Enumerable<PerfumesDescriptionWhereUniqueInput>
  }

  export type ProductUpdateOneRequiredWithoutCommonDescriptionNestedInput = {
    create?: XOR<ProductCreateWithoutCommonDescriptionInput, ProductUncheckedCreateWithoutCommonDescriptionInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCommonDescriptionInput
    upsert?: ProductUpsertWithoutCommonDescriptionInput
    connect?: ProductWhereUniqueInput
    update?: XOR<ProductUpdateWithoutCommonDescriptionInput, ProductUncheckedUpdateWithoutCommonDescriptionInput>
  }

  export type TopDescriptionUpdateManyWithoutCommonDescriptionNestedInput = {
    create?: XOR<Enumerable<TopDescriptionCreateWithoutCommonDescriptionInput>, Enumerable<TopDescriptionUncheckedCreateWithoutCommonDescriptionInput>>
    connectOrCreate?: Enumerable<TopDescriptionCreateOrConnectWithoutCommonDescriptionInput>
    upsert?: Enumerable<TopDescriptionUpsertWithWhereUniqueWithoutCommonDescriptionInput>
    createMany?: TopDescriptionCreateManyCommonDescriptionInputEnvelope
    set?: Enumerable<TopDescriptionWhereUniqueInput>
    disconnect?: Enumerable<TopDescriptionWhereUniqueInput>
    delete?: Enumerable<TopDescriptionWhereUniqueInput>
    connect?: Enumerable<TopDescriptionWhereUniqueInput>
    update?: Enumerable<TopDescriptionUpdateWithWhereUniqueWithoutCommonDescriptionInput>
    updateMany?: Enumerable<TopDescriptionUpdateManyWithWhereWithoutCommonDescriptionInput>
    deleteMany?: Enumerable<TopDescriptionScalarWhereInput>
  }

  export type BottomDescriptionUpdateManyWithoutCommonDescriptionNestedInput = {
    create?: XOR<Enumerable<BottomDescriptionCreateWithoutCommonDescriptionInput>, Enumerable<BottomDescriptionUncheckedCreateWithoutCommonDescriptionInput>>
    connectOrCreate?: Enumerable<BottomDescriptionCreateOrConnectWithoutCommonDescriptionInput>
    upsert?: Enumerable<BottomDescriptionUpsertWithWhereUniqueWithoutCommonDescriptionInput>
    createMany?: BottomDescriptionCreateManyCommonDescriptionInputEnvelope
    set?: Enumerable<BottomDescriptionWhereUniqueInput>
    disconnect?: Enumerable<BottomDescriptionWhereUniqueInput>
    delete?: Enumerable<BottomDescriptionWhereUniqueInput>
    connect?: Enumerable<BottomDescriptionWhereUniqueInput>
    update?: Enumerable<BottomDescriptionUpdateWithWhereUniqueWithoutCommonDescriptionInput>
    updateMany?: Enumerable<BottomDescriptionUpdateManyWithWhereWithoutCommonDescriptionInput>
    deleteMany?: Enumerable<BottomDescriptionScalarWhereInput>
  }

  export type KurtasDescriptionUpdateManyWithoutCommonDescriptionNestedInput = {
    create?: XOR<Enumerable<KurtasDescriptionCreateWithoutCommonDescriptionInput>, Enumerable<KurtasDescriptionUncheckedCreateWithoutCommonDescriptionInput>>
    connectOrCreate?: Enumerable<KurtasDescriptionCreateOrConnectWithoutCommonDescriptionInput>
    upsert?: Enumerable<KurtasDescriptionUpsertWithWhereUniqueWithoutCommonDescriptionInput>
    createMany?: KurtasDescriptionCreateManyCommonDescriptionInputEnvelope
    set?: Enumerable<KurtasDescriptionWhereUniqueInput>
    disconnect?: Enumerable<KurtasDescriptionWhereUniqueInput>
    delete?: Enumerable<KurtasDescriptionWhereUniqueInput>
    connect?: Enumerable<KurtasDescriptionWhereUniqueInput>
    update?: Enumerable<KurtasDescriptionUpdateWithWhereUniqueWithoutCommonDescriptionInput>
    updateMany?: Enumerable<KurtasDescriptionUpdateManyWithWhereWithoutCommonDescriptionInput>
    deleteMany?: Enumerable<KurtasDescriptionScalarWhereInput>
  }

  export type ShoesDescriptionUpdateManyWithoutCommonDescriptionNestedInput = {
    create?: XOR<Enumerable<ShoesDescriptionCreateWithoutCommonDescriptionInput>, Enumerable<ShoesDescriptionUncheckedCreateWithoutCommonDescriptionInput>>
    connectOrCreate?: Enumerable<ShoesDescriptionCreateOrConnectWithoutCommonDescriptionInput>
    upsert?: Enumerable<ShoesDescriptionUpsertWithWhereUniqueWithoutCommonDescriptionInput>
    createMany?: ShoesDescriptionCreateManyCommonDescriptionInputEnvelope
    set?: Enumerable<ShoesDescriptionWhereUniqueInput>
    disconnect?: Enumerable<ShoesDescriptionWhereUniqueInput>
    delete?: Enumerable<ShoesDescriptionWhereUniqueInput>
    connect?: Enumerable<ShoesDescriptionWhereUniqueInput>
    update?: Enumerable<ShoesDescriptionUpdateWithWhereUniqueWithoutCommonDescriptionInput>
    updateMany?: Enumerable<ShoesDescriptionUpdateManyWithWhereWithoutCommonDescriptionInput>
    deleteMany?: Enumerable<ShoesDescriptionScalarWhereInput>
  }

  export type InnersDescriptionUpdateManyWithoutCommonDescriptionNestedInput = {
    create?: XOR<Enumerable<InnersDescriptionCreateWithoutCommonDescriptionInput>, Enumerable<InnersDescriptionUncheckedCreateWithoutCommonDescriptionInput>>
    connectOrCreate?: Enumerable<InnersDescriptionCreateOrConnectWithoutCommonDescriptionInput>
    upsert?: Enumerable<InnersDescriptionUpsertWithWhereUniqueWithoutCommonDescriptionInput>
    createMany?: InnersDescriptionCreateManyCommonDescriptionInputEnvelope
    set?: Enumerable<InnersDescriptionWhereUniqueInput>
    disconnect?: Enumerable<InnersDescriptionWhereUniqueInput>
    delete?: Enumerable<InnersDescriptionWhereUniqueInput>
    connect?: Enumerable<InnersDescriptionWhereUniqueInput>
    update?: Enumerable<InnersDescriptionUpdateWithWhereUniqueWithoutCommonDescriptionInput>
    updateMany?: Enumerable<InnersDescriptionUpdateManyWithWhereWithoutCommonDescriptionInput>
    deleteMany?: Enumerable<InnersDescriptionScalarWhereInput>
  }

  export type WatchesDescriptionUpdateManyWithoutCommonDescriptionNestedInput = {
    create?: XOR<Enumerable<WatchesDescriptionCreateWithoutCommonDescriptionInput>, Enumerable<WatchesDescriptionUncheckedCreateWithoutCommonDescriptionInput>>
    connectOrCreate?: Enumerable<WatchesDescriptionCreateOrConnectWithoutCommonDescriptionInput>
    upsert?: Enumerable<WatchesDescriptionUpsertWithWhereUniqueWithoutCommonDescriptionInput>
    createMany?: WatchesDescriptionCreateManyCommonDescriptionInputEnvelope
    set?: Enumerable<WatchesDescriptionWhereUniqueInput>
    disconnect?: Enumerable<WatchesDescriptionWhereUniqueInput>
    delete?: Enumerable<WatchesDescriptionWhereUniqueInput>
    connect?: Enumerable<WatchesDescriptionWhereUniqueInput>
    update?: Enumerable<WatchesDescriptionUpdateWithWhereUniqueWithoutCommonDescriptionInput>
    updateMany?: Enumerable<WatchesDescriptionUpdateManyWithWhereWithoutCommonDescriptionInput>
    deleteMany?: Enumerable<WatchesDescriptionScalarWhereInput>
  }

  export type PerfumesDescriptionUpdateManyWithoutCommonDescriptionNestedInput = {
    create?: XOR<Enumerable<PerfumesDescriptionCreateWithoutCommonDescriptionInput>, Enumerable<PerfumesDescriptionUncheckedCreateWithoutCommonDescriptionInput>>
    connectOrCreate?: Enumerable<PerfumesDescriptionCreateOrConnectWithoutCommonDescriptionInput>
    upsert?: Enumerable<PerfumesDescriptionUpsertWithWhereUniqueWithoutCommonDescriptionInput>
    createMany?: PerfumesDescriptionCreateManyCommonDescriptionInputEnvelope
    set?: Enumerable<PerfumesDescriptionWhereUniqueInput>
    disconnect?: Enumerable<PerfumesDescriptionWhereUniqueInput>
    delete?: Enumerable<PerfumesDescriptionWhereUniqueInput>
    connect?: Enumerable<PerfumesDescriptionWhereUniqueInput>
    update?: Enumerable<PerfumesDescriptionUpdateWithWhereUniqueWithoutCommonDescriptionInput>
    updateMany?: Enumerable<PerfumesDescriptionUpdateManyWithWhereWithoutCommonDescriptionInput>
    deleteMany?: Enumerable<PerfumesDescriptionScalarWhereInput>
  }

  export type TopDescriptionUncheckedUpdateManyWithoutCommonDescriptionNestedInput = {
    create?: XOR<Enumerable<TopDescriptionCreateWithoutCommonDescriptionInput>, Enumerable<TopDescriptionUncheckedCreateWithoutCommonDescriptionInput>>
    connectOrCreate?: Enumerable<TopDescriptionCreateOrConnectWithoutCommonDescriptionInput>
    upsert?: Enumerable<TopDescriptionUpsertWithWhereUniqueWithoutCommonDescriptionInput>
    createMany?: TopDescriptionCreateManyCommonDescriptionInputEnvelope
    set?: Enumerable<TopDescriptionWhereUniqueInput>
    disconnect?: Enumerable<TopDescriptionWhereUniqueInput>
    delete?: Enumerable<TopDescriptionWhereUniqueInput>
    connect?: Enumerable<TopDescriptionWhereUniqueInput>
    update?: Enumerable<TopDescriptionUpdateWithWhereUniqueWithoutCommonDescriptionInput>
    updateMany?: Enumerable<TopDescriptionUpdateManyWithWhereWithoutCommonDescriptionInput>
    deleteMany?: Enumerable<TopDescriptionScalarWhereInput>
  }

  export type BottomDescriptionUncheckedUpdateManyWithoutCommonDescriptionNestedInput = {
    create?: XOR<Enumerable<BottomDescriptionCreateWithoutCommonDescriptionInput>, Enumerable<BottomDescriptionUncheckedCreateWithoutCommonDescriptionInput>>
    connectOrCreate?: Enumerable<BottomDescriptionCreateOrConnectWithoutCommonDescriptionInput>
    upsert?: Enumerable<BottomDescriptionUpsertWithWhereUniqueWithoutCommonDescriptionInput>
    createMany?: BottomDescriptionCreateManyCommonDescriptionInputEnvelope
    set?: Enumerable<BottomDescriptionWhereUniqueInput>
    disconnect?: Enumerable<BottomDescriptionWhereUniqueInput>
    delete?: Enumerable<BottomDescriptionWhereUniqueInput>
    connect?: Enumerable<BottomDescriptionWhereUniqueInput>
    update?: Enumerable<BottomDescriptionUpdateWithWhereUniqueWithoutCommonDescriptionInput>
    updateMany?: Enumerable<BottomDescriptionUpdateManyWithWhereWithoutCommonDescriptionInput>
    deleteMany?: Enumerable<BottomDescriptionScalarWhereInput>
  }

  export type KurtasDescriptionUncheckedUpdateManyWithoutCommonDescriptionNestedInput = {
    create?: XOR<Enumerable<KurtasDescriptionCreateWithoutCommonDescriptionInput>, Enumerable<KurtasDescriptionUncheckedCreateWithoutCommonDescriptionInput>>
    connectOrCreate?: Enumerable<KurtasDescriptionCreateOrConnectWithoutCommonDescriptionInput>
    upsert?: Enumerable<KurtasDescriptionUpsertWithWhereUniqueWithoutCommonDescriptionInput>
    createMany?: KurtasDescriptionCreateManyCommonDescriptionInputEnvelope
    set?: Enumerable<KurtasDescriptionWhereUniqueInput>
    disconnect?: Enumerable<KurtasDescriptionWhereUniqueInput>
    delete?: Enumerable<KurtasDescriptionWhereUniqueInput>
    connect?: Enumerable<KurtasDescriptionWhereUniqueInput>
    update?: Enumerable<KurtasDescriptionUpdateWithWhereUniqueWithoutCommonDescriptionInput>
    updateMany?: Enumerable<KurtasDescriptionUpdateManyWithWhereWithoutCommonDescriptionInput>
    deleteMany?: Enumerable<KurtasDescriptionScalarWhereInput>
  }

  export type ShoesDescriptionUncheckedUpdateManyWithoutCommonDescriptionNestedInput = {
    create?: XOR<Enumerable<ShoesDescriptionCreateWithoutCommonDescriptionInput>, Enumerable<ShoesDescriptionUncheckedCreateWithoutCommonDescriptionInput>>
    connectOrCreate?: Enumerable<ShoesDescriptionCreateOrConnectWithoutCommonDescriptionInput>
    upsert?: Enumerable<ShoesDescriptionUpsertWithWhereUniqueWithoutCommonDescriptionInput>
    createMany?: ShoesDescriptionCreateManyCommonDescriptionInputEnvelope
    set?: Enumerable<ShoesDescriptionWhereUniqueInput>
    disconnect?: Enumerable<ShoesDescriptionWhereUniqueInput>
    delete?: Enumerable<ShoesDescriptionWhereUniqueInput>
    connect?: Enumerable<ShoesDescriptionWhereUniqueInput>
    update?: Enumerable<ShoesDescriptionUpdateWithWhereUniqueWithoutCommonDescriptionInput>
    updateMany?: Enumerable<ShoesDescriptionUpdateManyWithWhereWithoutCommonDescriptionInput>
    deleteMany?: Enumerable<ShoesDescriptionScalarWhereInput>
  }

  export type InnersDescriptionUncheckedUpdateManyWithoutCommonDescriptionNestedInput = {
    create?: XOR<Enumerable<InnersDescriptionCreateWithoutCommonDescriptionInput>, Enumerable<InnersDescriptionUncheckedCreateWithoutCommonDescriptionInput>>
    connectOrCreate?: Enumerable<InnersDescriptionCreateOrConnectWithoutCommonDescriptionInput>
    upsert?: Enumerable<InnersDescriptionUpsertWithWhereUniqueWithoutCommonDescriptionInput>
    createMany?: InnersDescriptionCreateManyCommonDescriptionInputEnvelope
    set?: Enumerable<InnersDescriptionWhereUniqueInput>
    disconnect?: Enumerable<InnersDescriptionWhereUniqueInput>
    delete?: Enumerable<InnersDescriptionWhereUniqueInput>
    connect?: Enumerable<InnersDescriptionWhereUniqueInput>
    update?: Enumerable<InnersDescriptionUpdateWithWhereUniqueWithoutCommonDescriptionInput>
    updateMany?: Enumerable<InnersDescriptionUpdateManyWithWhereWithoutCommonDescriptionInput>
    deleteMany?: Enumerable<InnersDescriptionScalarWhereInput>
  }

  export type WatchesDescriptionUncheckedUpdateManyWithoutCommonDescriptionNestedInput = {
    create?: XOR<Enumerable<WatchesDescriptionCreateWithoutCommonDescriptionInput>, Enumerable<WatchesDescriptionUncheckedCreateWithoutCommonDescriptionInput>>
    connectOrCreate?: Enumerable<WatchesDescriptionCreateOrConnectWithoutCommonDescriptionInput>
    upsert?: Enumerable<WatchesDescriptionUpsertWithWhereUniqueWithoutCommonDescriptionInput>
    createMany?: WatchesDescriptionCreateManyCommonDescriptionInputEnvelope
    set?: Enumerable<WatchesDescriptionWhereUniqueInput>
    disconnect?: Enumerable<WatchesDescriptionWhereUniqueInput>
    delete?: Enumerable<WatchesDescriptionWhereUniqueInput>
    connect?: Enumerable<WatchesDescriptionWhereUniqueInput>
    update?: Enumerable<WatchesDescriptionUpdateWithWhereUniqueWithoutCommonDescriptionInput>
    updateMany?: Enumerable<WatchesDescriptionUpdateManyWithWhereWithoutCommonDescriptionInput>
    deleteMany?: Enumerable<WatchesDescriptionScalarWhereInput>
  }

  export type PerfumesDescriptionUncheckedUpdateManyWithoutCommonDescriptionNestedInput = {
    create?: XOR<Enumerable<PerfumesDescriptionCreateWithoutCommonDescriptionInput>, Enumerable<PerfumesDescriptionUncheckedCreateWithoutCommonDescriptionInput>>
    connectOrCreate?: Enumerable<PerfumesDescriptionCreateOrConnectWithoutCommonDescriptionInput>
    upsert?: Enumerable<PerfumesDescriptionUpsertWithWhereUniqueWithoutCommonDescriptionInput>
    createMany?: PerfumesDescriptionCreateManyCommonDescriptionInputEnvelope
    set?: Enumerable<PerfumesDescriptionWhereUniqueInput>
    disconnect?: Enumerable<PerfumesDescriptionWhereUniqueInput>
    delete?: Enumerable<PerfumesDescriptionWhereUniqueInput>
    connect?: Enumerable<PerfumesDescriptionWhereUniqueInput>
    update?: Enumerable<PerfumesDescriptionUpdateWithWhereUniqueWithoutCommonDescriptionInput>
    updateMany?: Enumerable<PerfumesDescriptionUpdateManyWithWhereWithoutCommonDescriptionInput>
    deleteMany?: Enumerable<PerfumesDescriptionScalarWhereInput>
  }

  export type CommonDescriptionCreateNestedOneWithoutTopDescriptionInput = {
    create?: XOR<CommonDescriptionCreateWithoutTopDescriptionInput, CommonDescriptionUncheckedCreateWithoutTopDescriptionInput>
    connectOrCreate?: CommonDescriptionCreateOrConnectWithoutTopDescriptionInput
    connect?: CommonDescriptionWhereUniqueInput
  }

  export type SleeveTypeCreateNestedOneWithoutTopDescriptionInput = {
    create?: XOR<SleeveTypeCreateWithoutTopDescriptionInput, SleeveTypeUncheckedCreateWithoutTopDescriptionInput>
    connectOrCreate?: SleeveTypeCreateOrConnectWithoutTopDescriptionInput
    connect?: SleeveTypeWhereUniqueInput
  }

  export type NeckTypeCreateNestedOneWithoutTopDescriptionInput = {
    create?: XOR<NeckTypeCreateWithoutTopDescriptionInput, NeckTypeUncheckedCreateWithoutTopDescriptionInput>
    connectOrCreate?: NeckTypeCreateOrConnectWithoutTopDescriptionInput
    connect?: NeckTypeWhereUniqueInput
  }

  export type BottomDescriptionCreateNestedManyWithoutTopDescriptionInput = {
    create?: XOR<Enumerable<BottomDescriptionCreateWithoutTopDescriptionInput>, Enumerable<BottomDescriptionUncheckedCreateWithoutTopDescriptionInput>>
    connectOrCreate?: Enumerable<BottomDescriptionCreateOrConnectWithoutTopDescriptionInput>
    createMany?: BottomDescriptionCreateManyTopDescriptionInputEnvelope
    connect?: Enumerable<BottomDescriptionWhereUniqueInput>
  }

  export type BottomDescriptionUncheckedCreateNestedManyWithoutTopDescriptionInput = {
    create?: XOR<Enumerable<BottomDescriptionCreateWithoutTopDescriptionInput>, Enumerable<BottomDescriptionUncheckedCreateWithoutTopDescriptionInput>>
    connectOrCreate?: Enumerable<BottomDescriptionCreateOrConnectWithoutTopDescriptionInput>
    createMany?: BottomDescriptionCreateManyTopDescriptionInputEnvelope
    connect?: Enumerable<BottomDescriptionWhereUniqueInput>
  }

  export type CommonDescriptionUpdateOneWithoutTopDescriptionNestedInput = {
    create?: XOR<CommonDescriptionCreateWithoutTopDescriptionInput, CommonDescriptionUncheckedCreateWithoutTopDescriptionInput>
    connectOrCreate?: CommonDescriptionCreateOrConnectWithoutTopDescriptionInput
    upsert?: CommonDescriptionUpsertWithoutTopDescriptionInput
    disconnect?: boolean
    delete?: boolean
    connect?: CommonDescriptionWhereUniqueInput
    update?: XOR<CommonDescriptionUpdateWithoutTopDescriptionInput, CommonDescriptionUncheckedUpdateWithoutTopDescriptionInput>
  }

  export type SleeveTypeUpdateOneRequiredWithoutTopDescriptionNestedInput = {
    create?: XOR<SleeveTypeCreateWithoutTopDescriptionInput, SleeveTypeUncheckedCreateWithoutTopDescriptionInput>
    connectOrCreate?: SleeveTypeCreateOrConnectWithoutTopDescriptionInput
    upsert?: SleeveTypeUpsertWithoutTopDescriptionInput
    connect?: SleeveTypeWhereUniqueInput
    update?: XOR<SleeveTypeUpdateWithoutTopDescriptionInput, SleeveTypeUncheckedUpdateWithoutTopDescriptionInput>
  }

  export type NeckTypeUpdateOneRequiredWithoutTopDescriptionNestedInput = {
    create?: XOR<NeckTypeCreateWithoutTopDescriptionInput, NeckTypeUncheckedCreateWithoutTopDescriptionInput>
    connectOrCreate?: NeckTypeCreateOrConnectWithoutTopDescriptionInput
    upsert?: NeckTypeUpsertWithoutTopDescriptionInput
    connect?: NeckTypeWhereUniqueInput
    update?: XOR<NeckTypeUpdateWithoutTopDescriptionInput, NeckTypeUncheckedUpdateWithoutTopDescriptionInput>
  }

  export type BottomDescriptionUpdateManyWithoutTopDescriptionNestedInput = {
    create?: XOR<Enumerable<BottomDescriptionCreateWithoutTopDescriptionInput>, Enumerable<BottomDescriptionUncheckedCreateWithoutTopDescriptionInput>>
    connectOrCreate?: Enumerable<BottomDescriptionCreateOrConnectWithoutTopDescriptionInput>
    upsert?: Enumerable<BottomDescriptionUpsertWithWhereUniqueWithoutTopDescriptionInput>
    createMany?: BottomDescriptionCreateManyTopDescriptionInputEnvelope
    set?: Enumerable<BottomDescriptionWhereUniqueInput>
    disconnect?: Enumerable<BottomDescriptionWhereUniqueInput>
    delete?: Enumerable<BottomDescriptionWhereUniqueInput>
    connect?: Enumerable<BottomDescriptionWhereUniqueInput>
    update?: Enumerable<BottomDescriptionUpdateWithWhereUniqueWithoutTopDescriptionInput>
    updateMany?: Enumerable<BottomDescriptionUpdateManyWithWhereWithoutTopDescriptionInput>
    deleteMany?: Enumerable<BottomDescriptionScalarWhereInput>
  }

  export type BottomDescriptionUncheckedUpdateManyWithoutTopDescriptionNestedInput = {
    create?: XOR<Enumerable<BottomDescriptionCreateWithoutTopDescriptionInput>, Enumerable<BottomDescriptionUncheckedCreateWithoutTopDescriptionInput>>
    connectOrCreate?: Enumerable<BottomDescriptionCreateOrConnectWithoutTopDescriptionInput>
    upsert?: Enumerable<BottomDescriptionUpsertWithWhereUniqueWithoutTopDescriptionInput>
    createMany?: BottomDescriptionCreateManyTopDescriptionInputEnvelope
    set?: Enumerable<BottomDescriptionWhereUniqueInput>
    disconnect?: Enumerable<BottomDescriptionWhereUniqueInput>
    delete?: Enumerable<BottomDescriptionWhereUniqueInput>
    connect?: Enumerable<BottomDescriptionWhereUniqueInput>
    update?: Enumerable<BottomDescriptionUpdateWithWhereUniqueWithoutTopDescriptionInput>
    updateMany?: Enumerable<BottomDescriptionUpdateManyWithWhereWithoutTopDescriptionInput>
    deleteMany?: Enumerable<BottomDescriptionScalarWhereInput>
  }

  export type TypesOfBottomCreateNestedOneWithoutDescriptionInput = {
    create?: XOR<TypesOfBottomCreateWithoutDescriptionInput, TypesOfBottomUncheckedCreateWithoutDescriptionInput>
    connectOrCreate?: TypesOfBottomCreateOrConnectWithoutDescriptionInput
    connect?: TypesOfBottomWhereUniqueInput
  }

  export type TypesOfPleatsCreateNestedOneWithoutDescriptionInput = {
    create?: XOR<TypesOfPleatsCreateWithoutDescriptionInput, TypesOfPleatsUncheckedCreateWithoutDescriptionInput>
    connectOrCreate?: TypesOfPleatsCreateOrConnectWithoutDescriptionInput
    connect?: TypesOfPleatsWhereUniqueInput
  }

  export type TypesOfLengthBottomCreateNestedOneWithoutDescriptionInput = {
    create?: XOR<TypesOfLengthBottomCreateWithoutDescriptionInput, TypesOfLengthBottomUncheckedCreateWithoutDescriptionInput>
    connectOrCreate?: TypesOfLengthBottomCreateOrConnectWithoutDescriptionInput
    connect?: TypesOfLengthBottomWhereUniqueInput
  }

  export type CommonDescriptionCreateNestedOneWithoutPantDescriptionInput = {
    create?: XOR<CommonDescriptionCreateWithoutPantDescriptionInput, CommonDescriptionUncheckedCreateWithoutPantDescriptionInput>
    connectOrCreate?: CommonDescriptionCreateOrConnectWithoutPantDescriptionInput
    connect?: CommonDescriptionWhereUniqueInput
  }

  export type KurtasDescriptionCreateNestedOneWithoutBottomDescriptionInput = {
    create?: XOR<KurtasDescriptionCreateWithoutBottomDescriptionInput, KurtasDescriptionUncheckedCreateWithoutBottomDescriptionInput>
    connectOrCreate?: KurtasDescriptionCreateOrConnectWithoutBottomDescriptionInput
    connect?: KurtasDescriptionWhereUniqueInput
  }

  export type TopDescriptionCreateNestedOneWithoutBottomDescriptionInput = {
    create?: XOR<TopDescriptionCreateWithoutBottomDescriptionInput, TopDescriptionUncheckedCreateWithoutBottomDescriptionInput>
    connectOrCreate?: TopDescriptionCreateOrConnectWithoutBottomDescriptionInput
    connect?: TopDescriptionWhereUniqueInput
  }

  export type TypesOfBottomUpdateOneRequiredWithoutDescriptionNestedInput = {
    create?: XOR<TypesOfBottomCreateWithoutDescriptionInput, TypesOfBottomUncheckedCreateWithoutDescriptionInput>
    connectOrCreate?: TypesOfBottomCreateOrConnectWithoutDescriptionInput
    upsert?: TypesOfBottomUpsertWithoutDescriptionInput
    connect?: TypesOfBottomWhereUniqueInput
    update?: XOR<TypesOfBottomUpdateWithoutDescriptionInput, TypesOfBottomUncheckedUpdateWithoutDescriptionInput>
  }

  export type TypesOfPleatsUpdateOneRequiredWithoutDescriptionNestedInput = {
    create?: XOR<TypesOfPleatsCreateWithoutDescriptionInput, TypesOfPleatsUncheckedCreateWithoutDescriptionInput>
    connectOrCreate?: TypesOfPleatsCreateOrConnectWithoutDescriptionInput
    upsert?: TypesOfPleatsUpsertWithoutDescriptionInput
    connect?: TypesOfPleatsWhereUniqueInput
    update?: XOR<TypesOfPleatsUpdateWithoutDescriptionInput, TypesOfPleatsUncheckedUpdateWithoutDescriptionInput>
  }

  export type TypesOfLengthBottomUpdateOneRequiredWithoutDescriptionNestedInput = {
    create?: XOR<TypesOfLengthBottomCreateWithoutDescriptionInput, TypesOfLengthBottomUncheckedCreateWithoutDescriptionInput>
    connectOrCreate?: TypesOfLengthBottomCreateOrConnectWithoutDescriptionInput
    upsert?: TypesOfLengthBottomUpsertWithoutDescriptionInput
    connect?: TypesOfLengthBottomWhereUniqueInput
    update?: XOR<TypesOfLengthBottomUpdateWithoutDescriptionInput, TypesOfLengthBottomUncheckedUpdateWithoutDescriptionInput>
  }

  export type CommonDescriptionUpdateOneRequiredWithoutPantDescriptionNestedInput = {
    create?: XOR<CommonDescriptionCreateWithoutPantDescriptionInput, CommonDescriptionUncheckedCreateWithoutPantDescriptionInput>
    connectOrCreate?: CommonDescriptionCreateOrConnectWithoutPantDescriptionInput
    upsert?: CommonDescriptionUpsertWithoutPantDescriptionInput
    connect?: CommonDescriptionWhereUniqueInput
    update?: XOR<CommonDescriptionUpdateWithoutPantDescriptionInput, CommonDescriptionUncheckedUpdateWithoutPantDescriptionInput>
  }

  export type KurtasDescriptionUpdateOneWithoutBottomDescriptionNestedInput = {
    create?: XOR<KurtasDescriptionCreateWithoutBottomDescriptionInput, KurtasDescriptionUncheckedCreateWithoutBottomDescriptionInput>
    connectOrCreate?: KurtasDescriptionCreateOrConnectWithoutBottomDescriptionInput
    upsert?: KurtasDescriptionUpsertWithoutBottomDescriptionInput
    disconnect?: boolean
    delete?: boolean
    connect?: KurtasDescriptionWhereUniqueInput
    update?: XOR<KurtasDescriptionUpdateWithoutBottomDescriptionInput, KurtasDescriptionUncheckedUpdateWithoutBottomDescriptionInput>
  }

  export type TopDescriptionUpdateOneWithoutBottomDescriptionNestedInput = {
    create?: XOR<TopDescriptionCreateWithoutBottomDescriptionInput, TopDescriptionUncheckedCreateWithoutBottomDescriptionInput>
    connectOrCreate?: TopDescriptionCreateOrConnectWithoutBottomDescriptionInput
    upsert?: TopDescriptionUpsertWithoutBottomDescriptionInput
    disconnect?: boolean
    delete?: boolean
    connect?: TopDescriptionWhereUniqueInput
    update?: XOR<TopDescriptionUpdateWithoutBottomDescriptionInput, TopDescriptionUncheckedUpdateWithoutBottomDescriptionInput>
  }

  export type KurtasLengthTypeCreateNestedOneWithoutKurtasDescriptionInput = {
    create?: XOR<KurtasLengthTypeCreateWithoutKurtasDescriptionInput, KurtasLengthTypeUncheckedCreateWithoutKurtasDescriptionInput>
    connectOrCreate?: KurtasLengthTypeCreateOrConnectWithoutKurtasDescriptionInput
    connect?: KurtasLengthTypeWhereUniqueInput
  }

  export type NeckTypeCreateNestedOneWithoutKurtasDescriptionInput = {
    create?: XOR<NeckTypeCreateWithoutKurtasDescriptionInput, NeckTypeUncheckedCreateWithoutKurtasDescriptionInput>
    connectOrCreate?: NeckTypeCreateOrConnectWithoutKurtasDescriptionInput
    connect?: NeckTypeWhereUniqueInput
  }

  export type SleeveTypeCreateNestedOneWithoutKurtasDescriptionInput = {
    create?: XOR<SleeveTypeCreateWithoutKurtasDescriptionInput, SleeveTypeUncheckedCreateWithoutKurtasDescriptionInput>
    connectOrCreate?: SleeveTypeCreateOrConnectWithoutKurtasDescriptionInput
    connect?: SleeveTypeWhereUniqueInput
  }

  export type CommonDescriptionCreateNestedOneWithoutKurtasDescriptionInput = {
    create?: XOR<CommonDescriptionCreateWithoutKurtasDescriptionInput, CommonDescriptionUncheckedCreateWithoutKurtasDescriptionInput>
    connectOrCreate?: CommonDescriptionCreateOrConnectWithoutKurtasDescriptionInput
    connect?: CommonDescriptionWhereUniqueInput
  }

  export type BottomDescriptionCreateNestedManyWithoutKurtasDescriptionInput = {
    create?: XOR<Enumerable<BottomDescriptionCreateWithoutKurtasDescriptionInput>, Enumerable<BottomDescriptionUncheckedCreateWithoutKurtasDescriptionInput>>
    connectOrCreate?: Enumerable<BottomDescriptionCreateOrConnectWithoutKurtasDescriptionInput>
    createMany?: BottomDescriptionCreateManyKurtasDescriptionInputEnvelope
    connect?: Enumerable<BottomDescriptionWhereUniqueInput>
  }

  export type BottomDescriptionUncheckedCreateNestedManyWithoutKurtasDescriptionInput = {
    create?: XOR<Enumerable<BottomDescriptionCreateWithoutKurtasDescriptionInput>, Enumerable<BottomDescriptionUncheckedCreateWithoutKurtasDescriptionInput>>
    connectOrCreate?: Enumerable<BottomDescriptionCreateOrConnectWithoutKurtasDescriptionInput>
    createMany?: BottomDescriptionCreateManyKurtasDescriptionInputEnvelope
    connect?: Enumerable<BottomDescriptionWhereUniqueInput>
  }

  export type KurtasLengthTypeUpdateOneRequiredWithoutKurtasDescriptionNestedInput = {
    create?: XOR<KurtasLengthTypeCreateWithoutKurtasDescriptionInput, KurtasLengthTypeUncheckedCreateWithoutKurtasDescriptionInput>
    connectOrCreate?: KurtasLengthTypeCreateOrConnectWithoutKurtasDescriptionInput
    upsert?: KurtasLengthTypeUpsertWithoutKurtasDescriptionInput
    connect?: KurtasLengthTypeWhereUniqueInput
    update?: XOR<KurtasLengthTypeUpdateWithoutKurtasDescriptionInput, KurtasLengthTypeUncheckedUpdateWithoutKurtasDescriptionInput>
  }

  export type NeckTypeUpdateOneRequiredWithoutKurtasDescriptionNestedInput = {
    create?: XOR<NeckTypeCreateWithoutKurtasDescriptionInput, NeckTypeUncheckedCreateWithoutKurtasDescriptionInput>
    connectOrCreate?: NeckTypeCreateOrConnectWithoutKurtasDescriptionInput
    upsert?: NeckTypeUpsertWithoutKurtasDescriptionInput
    connect?: NeckTypeWhereUniqueInput
    update?: XOR<NeckTypeUpdateWithoutKurtasDescriptionInput, NeckTypeUncheckedUpdateWithoutKurtasDescriptionInput>
  }

  export type SleeveTypeUpdateOneRequiredWithoutKurtasDescriptionNestedInput = {
    create?: XOR<SleeveTypeCreateWithoutKurtasDescriptionInput, SleeveTypeUncheckedCreateWithoutKurtasDescriptionInput>
    connectOrCreate?: SleeveTypeCreateOrConnectWithoutKurtasDescriptionInput
    upsert?: SleeveTypeUpsertWithoutKurtasDescriptionInput
    connect?: SleeveTypeWhereUniqueInput
    update?: XOR<SleeveTypeUpdateWithoutKurtasDescriptionInput, SleeveTypeUncheckedUpdateWithoutKurtasDescriptionInput>
  }

  export type CommonDescriptionUpdateOneRequiredWithoutKurtasDescriptionNestedInput = {
    create?: XOR<CommonDescriptionCreateWithoutKurtasDescriptionInput, CommonDescriptionUncheckedCreateWithoutKurtasDescriptionInput>
    connectOrCreate?: CommonDescriptionCreateOrConnectWithoutKurtasDescriptionInput
    upsert?: CommonDescriptionUpsertWithoutKurtasDescriptionInput
    connect?: CommonDescriptionWhereUniqueInput
    update?: XOR<CommonDescriptionUpdateWithoutKurtasDescriptionInput, CommonDescriptionUncheckedUpdateWithoutKurtasDescriptionInput>
  }

  export type BottomDescriptionUpdateManyWithoutKurtasDescriptionNestedInput = {
    create?: XOR<Enumerable<BottomDescriptionCreateWithoutKurtasDescriptionInput>, Enumerable<BottomDescriptionUncheckedCreateWithoutKurtasDescriptionInput>>
    connectOrCreate?: Enumerable<BottomDescriptionCreateOrConnectWithoutKurtasDescriptionInput>
    upsert?: Enumerable<BottomDescriptionUpsertWithWhereUniqueWithoutKurtasDescriptionInput>
    createMany?: BottomDescriptionCreateManyKurtasDescriptionInputEnvelope
    set?: Enumerable<BottomDescriptionWhereUniqueInput>
    disconnect?: Enumerable<BottomDescriptionWhereUniqueInput>
    delete?: Enumerable<BottomDescriptionWhereUniqueInput>
    connect?: Enumerable<BottomDescriptionWhereUniqueInput>
    update?: Enumerable<BottomDescriptionUpdateWithWhereUniqueWithoutKurtasDescriptionInput>
    updateMany?: Enumerable<BottomDescriptionUpdateManyWithWhereWithoutKurtasDescriptionInput>
    deleteMany?: Enumerable<BottomDescriptionScalarWhereInput>
  }

  export type BottomDescriptionUncheckedUpdateManyWithoutKurtasDescriptionNestedInput = {
    create?: XOR<Enumerable<BottomDescriptionCreateWithoutKurtasDescriptionInput>, Enumerable<BottomDescriptionUncheckedCreateWithoutKurtasDescriptionInput>>
    connectOrCreate?: Enumerable<BottomDescriptionCreateOrConnectWithoutKurtasDescriptionInput>
    upsert?: Enumerable<BottomDescriptionUpsertWithWhereUniqueWithoutKurtasDescriptionInput>
    createMany?: BottomDescriptionCreateManyKurtasDescriptionInputEnvelope
    set?: Enumerable<BottomDescriptionWhereUniqueInput>
    disconnect?: Enumerable<BottomDescriptionWhereUniqueInput>
    delete?: Enumerable<BottomDescriptionWhereUniqueInput>
    connect?: Enumerable<BottomDescriptionWhereUniqueInput>
    update?: Enumerable<BottomDescriptionUpdateWithWhereUniqueWithoutKurtasDescriptionInput>
    updateMany?: Enumerable<BottomDescriptionUpdateManyWithWhereWithoutKurtasDescriptionInput>
    deleteMany?: Enumerable<BottomDescriptionScalarWhereInput>
  }

  export type WarrantyCreateNestedManyWithoutShoesDescriptionInput = {
    create?: XOR<Enumerable<WarrantyCreateWithoutShoesDescriptionInput>, Enumerable<WarrantyUncheckedCreateWithoutShoesDescriptionInput>>
    connectOrCreate?: Enumerable<WarrantyCreateOrConnectWithoutShoesDescriptionInput>
    createMany?: WarrantyCreateManyShoesDescriptionInputEnvelope
    connect?: Enumerable<WarrantyWhereUniqueInput>
  }

  export type CommonDescriptionCreateNestedOneWithoutShoesDescriptionInput = {
    create?: XOR<CommonDescriptionCreateWithoutShoesDescriptionInput, CommonDescriptionUncheckedCreateWithoutShoesDescriptionInput>
    connectOrCreate?: CommonDescriptionCreateOrConnectWithoutShoesDescriptionInput
    connect?: CommonDescriptionWhereUniqueInput
  }

  export type WarrantyUncheckedCreateNestedManyWithoutShoesDescriptionInput = {
    create?: XOR<Enumerable<WarrantyCreateWithoutShoesDescriptionInput>, Enumerable<WarrantyUncheckedCreateWithoutShoesDescriptionInput>>
    connectOrCreate?: Enumerable<WarrantyCreateOrConnectWithoutShoesDescriptionInput>
    createMany?: WarrantyCreateManyShoesDescriptionInputEnvelope
    connect?: Enumerable<WarrantyWhereUniqueInput>
  }

  export type WarrantyUpdateManyWithoutShoesDescriptionNestedInput = {
    create?: XOR<Enumerable<WarrantyCreateWithoutShoesDescriptionInput>, Enumerable<WarrantyUncheckedCreateWithoutShoesDescriptionInput>>
    connectOrCreate?: Enumerable<WarrantyCreateOrConnectWithoutShoesDescriptionInput>
    upsert?: Enumerable<WarrantyUpsertWithWhereUniqueWithoutShoesDescriptionInput>
    createMany?: WarrantyCreateManyShoesDescriptionInputEnvelope
    set?: Enumerable<WarrantyWhereUniqueInput>
    disconnect?: Enumerable<WarrantyWhereUniqueInput>
    delete?: Enumerable<WarrantyWhereUniqueInput>
    connect?: Enumerable<WarrantyWhereUniqueInput>
    update?: Enumerable<WarrantyUpdateWithWhereUniqueWithoutShoesDescriptionInput>
    updateMany?: Enumerable<WarrantyUpdateManyWithWhereWithoutShoesDescriptionInput>
    deleteMany?: Enumerable<WarrantyScalarWhereInput>
  }

  export type CommonDescriptionUpdateOneRequiredWithoutShoesDescriptionNestedInput = {
    create?: XOR<CommonDescriptionCreateWithoutShoesDescriptionInput, CommonDescriptionUncheckedCreateWithoutShoesDescriptionInput>
    connectOrCreate?: CommonDescriptionCreateOrConnectWithoutShoesDescriptionInput
    upsert?: CommonDescriptionUpsertWithoutShoesDescriptionInput
    connect?: CommonDescriptionWhereUniqueInput
    update?: XOR<CommonDescriptionUpdateWithoutShoesDescriptionInput, CommonDescriptionUncheckedUpdateWithoutShoesDescriptionInput>
  }

  export type WarrantyUncheckedUpdateManyWithoutShoesDescriptionNestedInput = {
    create?: XOR<Enumerable<WarrantyCreateWithoutShoesDescriptionInput>, Enumerable<WarrantyUncheckedCreateWithoutShoesDescriptionInput>>
    connectOrCreate?: Enumerable<WarrantyCreateOrConnectWithoutShoesDescriptionInput>
    upsert?: Enumerable<WarrantyUpsertWithWhereUniqueWithoutShoesDescriptionInput>
    createMany?: WarrantyCreateManyShoesDescriptionInputEnvelope
    set?: Enumerable<WarrantyWhereUniqueInput>
    disconnect?: Enumerable<WarrantyWhereUniqueInput>
    delete?: Enumerable<WarrantyWhereUniqueInput>
    connect?: Enumerable<WarrantyWhereUniqueInput>
    update?: Enumerable<WarrantyUpdateWithWhereUniqueWithoutShoesDescriptionInput>
    updateMany?: Enumerable<WarrantyUpdateManyWithWhereWithoutShoesDescriptionInput>
    deleteMany?: Enumerable<WarrantyScalarWhereInput>
  }

  export type WarrantyCreateNestedManyWithoutWatchesInput = {
    create?: XOR<Enumerable<WarrantyCreateWithoutWatchesInput>, Enumerable<WarrantyUncheckedCreateWithoutWatchesInput>>
    connectOrCreate?: Enumerable<WarrantyCreateOrConnectWithoutWatchesInput>
    createMany?: WarrantyCreateManyWatchesInputEnvelope
    connect?: Enumerable<WarrantyWhereUniqueInput>
  }

  export type CommonDescriptionCreateNestedOneWithoutWatchesDescriptionInput = {
    create?: XOR<CommonDescriptionCreateWithoutWatchesDescriptionInput, CommonDescriptionUncheckedCreateWithoutWatchesDescriptionInput>
    connectOrCreate?: CommonDescriptionCreateOrConnectWithoutWatchesDescriptionInput
    connect?: CommonDescriptionWhereUniqueInput
  }

  export type WarrantyUncheckedCreateNestedManyWithoutWatchesInput = {
    create?: XOR<Enumerable<WarrantyCreateWithoutWatchesInput>, Enumerable<WarrantyUncheckedCreateWithoutWatchesInput>>
    connectOrCreate?: Enumerable<WarrantyCreateOrConnectWithoutWatchesInput>
    createMany?: WarrantyCreateManyWatchesInputEnvelope
    connect?: Enumerable<WarrantyWhereUniqueInput>
  }

  export type WarrantyUpdateManyWithoutWatchesNestedInput = {
    create?: XOR<Enumerable<WarrantyCreateWithoutWatchesInput>, Enumerable<WarrantyUncheckedCreateWithoutWatchesInput>>
    connectOrCreate?: Enumerable<WarrantyCreateOrConnectWithoutWatchesInput>
    upsert?: Enumerable<WarrantyUpsertWithWhereUniqueWithoutWatchesInput>
    createMany?: WarrantyCreateManyWatchesInputEnvelope
    set?: Enumerable<WarrantyWhereUniqueInput>
    disconnect?: Enumerable<WarrantyWhereUniqueInput>
    delete?: Enumerable<WarrantyWhereUniqueInput>
    connect?: Enumerable<WarrantyWhereUniqueInput>
    update?: Enumerable<WarrantyUpdateWithWhereUniqueWithoutWatchesInput>
    updateMany?: Enumerable<WarrantyUpdateManyWithWhereWithoutWatchesInput>
    deleteMany?: Enumerable<WarrantyScalarWhereInput>
  }

  export type CommonDescriptionUpdateOneRequiredWithoutWatchesDescriptionNestedInput = {
    create?: XOR<CommonDescriptionCreateWithoutWatchesDescriptionInput, CommonDescriptionUncheckedCreateWithoutWatchesDescriptionInput>
    connectOrCreate?: CommonDescriptionCreateOrConnectWithoutWatchesDescriptionInput
    upsert?: CommonDescriptionUpsertWithoutWatchesDescriptionInput
    connect?: CommonDescriptionWhereUniqueInput
    update?: XOR<CommonDescriptionUpdateWithoutWatchesDescriptionInput, CommonDescriptionUncheckedUpdateWithoutWatchesDescriptionInput>
  }

  export type WarrantyUncheckedUpdateManyWithoutWatchesNestedInput = {
    create?: XOR<Enumerable<WarrantyCreateWithoutWatchesInput>, Enumerable<WarrantyUncheckedCreateWithoutWatchesInput>>
    connectOrCreate?: Enumerable<WarrantyCreateOrConnectWithoutWatchesInput>
    upsert?: Enumerable<WarrantyUpsertWithWhereUniqueWithoutWatchesInput>
    createMany?: WarrantyCreateManyWatchesInputEnvelope
    set?: Enumerable<WarrantyWhereUniqueInput>
    disconnect?: Enumerable<WarrantyWhereUniqueInput>
    delete?: Enumerable<WarrantyWhereUniqueInput>
    connect?: Enumerable<WarrantyWhereUniqueInput>
    update?: Enumerable<WarrantyUpdateWithWhereUniqueWithoutWatchesInput>
    updateMany?: Enumerable<WarrantyUpdateManyWithWhereWithoutWatchesInput>
    deleteMany?: Enumerable<WarrantyScalarWhereInput>
  }

  export type CommonDescriptionCreateNestedOneWithoutPerfumesDescriptionInput = {
    create?: XOR<CommonDescriptionCreateWithoutPerfumesDescriptionInput, CommonDescriptionUncheckedCreateWithoutPerfumesDescriptionInput>
    connectOrCreate?: CommonDescriptionCreateOrConnectWithoutPerfumesDescriptionInput
    connect?: CommonDescriptionWhereUniqueInput
  }

  export type CommonDescriptionUpdateOneRequiredWithoutPerfumesDescriptionNestedInput = {
    create?: XOR<CommonDescriptionCreateWithoutPerfumesDescriptionInput, CommonDescriptionUncheckedCreateWithoutPerfumesDescriptionInput>
    connectOrCreate?: CommonDescriptionCreateOrConnectWithoutPerfumesDescriptionInput
    upsert?: CommonDescriptionUpsertWithoutPerfumesDescriptionInput
    connect?: CommonDescriptionWhereUniqueInput
    update?: XOR<CommonDescriptionUpdateWithoutPerfumesDescriptionInput, CommonDescriptionUncheckedUpdateWithoutPerfumesDescriptionInput>
  }

  export type SleeveTypeCreateNestedOneWithoutInnersDescriptionInput = {
    create?: XOR<SleeveTypeCreateWithoutInnersDescriptionInput, SleeveTypeUncheckedCreateWithoutInnersDescriptionInput>
    connectOrCreate?: SleeveTypeCreateOrConnectWithoutInnersDescriptionInput
    connect?: SleeveTypeWhereUniqueInput
  }

  export type NeckTypeCreateNestedOneWithoutInnersDescriptionInput = {
    create?: XOR<NeckTypeCreateWithoutInnersDescriptionInput, NeckTypeUncheckedCreateWithoutInnersDescriptionInput>
    connectOrCreate?: NeckTypeCreateOrConnectWithoutInnersDescriptionInput
    connect?: NeckTypeWhereUniqueInput
  }

  export type CommonDescriptionCreateNestedOneWithoutInnerDescriptionInput = {
    create?: XOR<CommonDescriptionCreateWithoutInnerDescriptionInput, CommonDescriptionUncheckedCreateWithoutInnerDescriptionInput>
    connectOrCreate?: CommonDescriptionCreateOrConnectWithoutInnerDescriptionInput
    connect?: CommonDescriptionWhereUniqueInput
  }

  export type SleeveTypeUpdateOneWithoutInnersDescriptionNestedInput = {
    create?: XOR<SleeveTypeCreateWithoutInnersDescriptionInput, SleeveTypeUncheckedCreateWithoutInnersDescriptionInput>
    connectOrCreate?: SleeveTypeCreateOrConnectWithoutInnersDescriptionInput
    upsert?: SleeveTypeUpsertWithoutInnersDescriptionInput
    disconnect?: boolean
    delete?: boolean
    connect?: SleeveTypeWhereUniqueInput
    update?: XOR<SleeveTypeUpdateWithoutInnersDescriptionInput, SleeveTypeUncheckedUpdateWithoutInnersDescriptionInput>
  }

  export type NeckTypeUpdateOneWithoutInnersDescriptionNestedInput = {
    create?: XOR<NeckTypeCreateWithoutInnersDescriptionInput, NeckTypeUncheckedCreateWithoutInnersDescriptionInput>
    connectOrCreate?: NeckTypeCreateOrConnectWithoutInnersDescriptionInput
    upsert?: NeckTypeUpsertWithoutInnersDescriptionInput
    disconnect?: boolean
    delete?: boolean
    connect?: NeckTypeWhereUniqueInput
    update?: XOR<NeckTypeUpdateWithoutInnersDescriptionInput, NeckTypeUncheckedUpdateWithoutInnersDescriptionInput>
  }

  export type CommonDescriptionUpdateOneRequiredWithoutInnerDescriptionNestedInput = {
    create?: XOR<CommonDescriptionCreateWithoutInnerDescriptionInput, CommonDescriptionUncheckedCreateWithoutInnerDescriptionInput>
    connectOrCreate?: CommonDescriptionCreateOrConnectWithoutInnerDescriptionInput
    upsert?: CommonDescriptionUpsertWithoutInnerDescriptionInput
    connect?: CommonDescriptionWhereUniqueInput
    update?: XOR<CommonDescriptionUpdateWithoutInnerDescriptionInput, CommonDescriptionUncheckedUpdateWithoutInnerDescriptionInput>
  }

  export type ShoesDescriptionCreateNestedOneWithoutWarrantyInput = {
    create?: XOR<ShoesDescriptionCreateWithoutWarrantyInput, ShoesDescriptionUncheckedCreateWithoutWarrantyInput>
    connectOrCreate?: ShoesDescriptionCreateOrConnectWithoutWarrantyInput
    connect?: ShoesDescriptionWhereUniqueInput
  }

  export type WatchesDescriptionCreateNestedOneWithoutWarrantyInput = {
    create?: XOR<WatchesDescriptionCreateWithoutWarrantyInput, WatchesDescriptionUncheckedCreateWithoutWarrantyInput>
    connectOrCreate?: WatchesDescriptionCreateOrConnectWithoutWarrantyInput
    connect?: WatchesDescriptionWhereUniqueInput
  }

  export type ShoesDescriptionUpdateOneWithoutWarrantyNestedInput = {
    create?: XOR<ShoesDescriptionCreateWithoutWarrantyInput, ShoesDescriptionUncheckedCreateWithoutWarrantyInput>
    connectOrCreate?: ShoesDescriptionCreateOrConnectWithoutWarrantyInput
    upsert?: ShoesDescriptionUpsertWithoutWarrantyInput
    disconnect?: boolean
    delete?: boolean
    connect?: ShoesDescriptionWhereUniqueInput
    update?: XOR<ShoesDescriptionUpdateWithoutWarrantyInput, ShoesDescriptionUncheckedUpdateWithoutWarrantyInput>
  }

  export type WatchesDescriptionUpdateOneWithoutWarrantyNestedInput = {
    create?: XOR<WatchesDescriptionCreateWithoutWarrantyInput, WatchesDescriptionUncheckedCreateWithoutWarrantyInput>
    connectOrCreate?: WatchesDescriptionCreateOrConnectWithoutWarrantyInput
    upsert?: WatchesDescriptionUpsertWithoutWarrantyInput
    disconnect?: boolean
    delete?: boolean
    connect?: WatchesDescriptionWhereUniqueInput
    update?: XOR<WatchesDescriptionUpdateWithoutWarrantyInput, WatchesDescriptionUncheckedUpdateWithoutWarrantyInput>
  }

  export type KurtasDescriptionCreateNestedManyWithoutSleeveTypeInput = {
    create?: XOR<Enumerable<KurtasDescriptionCreateWithoutSleeveTypeInput>, Enumerable<KurtasDescriptionUncheckedCreateWithoutSleeveTypeInput>>
    connectOrCreate?: Enumerable<KurtasDescriptionCreateOrConnectWithoutSleeveTypeInput>
    createMany?: KurtasDescriptionCreateManySleeveTypeInputEnvelope
    connect?: Enumerable<KurtasDescriptionWhereUniqueInput>
  }

  export type InnersDescriptionCreateNestedManyWithoutSleeveTypeInput = {
    create?: XOR<Enumerable<InnersDescriptionCreateWithoutSleeveTypeInput>, Enumerable<InnersDescriptionUncheckedCreateWithoutSleeveTypeInput>>
    connectOrCreate?: Enumerable<InnersDescriptionCreateOrConnectWithoutSleeveTypeInput>
    createMany?: InnersDescriptionCreateManySleeveTypeInputEnvelope
    connect?: Enumerable<InnersDescriptionWhereUniqueInput>
  }

  export type TopDescriptionCreateNestedManyWithoutSleeveTypeInput = {
    create?: XOR<Enumerable<TopDescriptionCreateWithoutSleeveTypeInput>, Enumerable<TopDescriptionUncheckedCreateWithoutSleeveTypeInput>>
    connectOrCreate?: Enumerable<TopDescriptionCreateOrConnectWithoutSleeveTypeInput>
    createMany?: TopDescriptionCreateManySleeveTypeInputEnvelope
    connect?: Enumerable<TopDescriptionWhereUniqueInput>
  }

  export type KurtasDescriptionUncheckedCreateNestedManyWithoutSleeveTypeInput = {
    create?: XOR<Enumerable<KurtasDescriptionCreateWithoutSleeveTypeInput>, Enumerable<KurtasDescriptionUncheckedCreateWithoutSleeveTypeInput>>
    connectOrCreate?: Enumerable<KurtasDescriptionCreateOrConnectWithoutSleeveTypeInput>
    createMany?: KurtasDescriptionCreateManySleeveTypeInputEnvelope
    connect?: Enumerable<KurtasDescriptionWhereUniqueInput>
  }

  export type InnersDescriptionUncheckedCreateNestedManyWithoutSleeveTypeInput = {
    create?: XOR<Enumerable<InnersDescriptionCreateWithoutSleeveTypeInput>, Enumerable<InnersDescriptionUncheckedCreateWithoutSleeveTypeInput>>
    connectOrCreate?: Enumerable<InnersDescriptionCreateOrConnectWithoutSleeveTypeInput>
    createMany?: InnersDescriptionCreateManySleeveTypeInputEnvelope
    connect?: Enumerable<InnersDescriptionWhereUniqueInput>
  }

  export type TopDescriptionUncheckedCreateNestedManyWithoutSleeveTypeInput = {
    create?: XOR<Enumerable<TopDescriptionCreateWithoutSleeveTypeInput>, Enumerable<TopDescriptionUncheckedCreateWithoutSleeveTypeInput>>
    connectOrCreate?: Enumerable<TopDescriptionCreateOrConnectWithoutSleeveTypeInput>
    createMany?: TopDescriptionCreateManySleeveTypeInputEnvelope
    connect?: Enumerable<TopDescriptionWhereUniqueInput>
  }

  export type KurtasDescriptionUpdateManyWithoutSleeveTypeNestedInput = {
    create?: XOR<Enumerable<KurtasDescriptionCreateWithoutSleeveTypeInput>, Enumerable<KurtasDescriptionUncheckedCreateWithoutSleeveTypeInput>>
    connectOrCreate?: Enumerable<KurtasDescriptionCreateOrConnectWithoutSleeveTypeInput>
    upsert?: Enumerable<KurtasDescriptionUpsertWithWhereUniqueWithoutSleeveTypeInput>
    createMany?: KurtasDescriptionCreateManySleeveTypeInputEnvelope
    set?: Enumerable<KurtasDescriptionWhereUniqueInput>
    disconnect?: Enumerable<KurtasDescriptionWhereUniqueInput>
    delete?: Enumerable<KurtasDescriptionWhereUniqueInput>
    connect?: Enumerable<KurtasDescriptionWhereUniqueInput>
    update?: Enumerable<KurtasDescriptionUpdateWithWhereUniqueWithoutSleeveTypeInput>
    updateMany?: Enumerable<KurtasDescriptionUpdateManyWithWhereWithoutSleeveTypeInput>
    deleteMany?: Enumerable<KurtasDescriptionScalarWhereInput>
  }

  export type InnersDescriptionUpdateManyWithoutSleeveTypeNestedInput = {
    create?: XOR<Enumerable<InnersDescriptionCreateWithoutSleeveTypeInput>, Enumerable<InnersDescriptionUncheckedCreateWithoutSleeveTypeInput>>
    connectOrCreate?: Enumerable<InnersDescriptionCreateOrConnectWithoutSleeveTypeInput>
    upsert?: Enumerable<InnersDescriptionUpsertWithWhereUniqueWithoutSleeveTypeInput>
    createMany?: InnersDescriptionCreateManySleeveTypeInputEnvelope
    set?: Enumerable<InnersDescriptionWhereUniqueInput>
    disconnect?: Enumerable<InnersDescriptionWhereUniqueInput>
    delete?: Enumerable<InnersDescriptionWhereUniqueInput>
    connect?: Enumerable<InnersDescriptionWhereUniqueInput>
    update?: Enumerable<InnersDescriptionUpdateWithWhereUniqueWithoutSleeveTypeInput>
    updateMany?: Enumerable<InnersDescriptionUpdateManyWithWhereWithoutSleeveTypeInput>
    deleteMany?: Enumerable<InnersDescriptionScalarWhereInput>
  }

  export type TopDescriptionUpdateManyWithoutSleeveTypeNestedInput = {
    create?: XOR<Enumerable<TopDescriptionCreateWithoutSleeveTypeInput>, Enumerable<TopDescriptionUncheckedCreateWithoutSleeveTypeInput>>
    connectOrCreate?: Enumerable<TopDescriptionCreateOrConnectWithoutSleeveTypeInput>
    upsert?: Enumerable<TopDescriptionUpsertWithWhereUniqueWithoutSleeveTypeInput>
    createMany?: TopDescriptionCreateManySleeveTypeInputEnvelope
    set?: Enumerable<TopDescriptionWhereUniqueInput>
    disconnect?: Enumerable<TopDescriptionWhereUniqueInput>
    delete?: Enumerable<TopDescriptionWhereUniqueInput>
    connect?: Enumerable<TopDescriptionWhereUniqueInput>
    update?: Enumerable<TopDescriptionUpdateWithWhereUniqueWithoutSleeveTypeInput>
    updateMany?: Enumerable<TopDescriptionUpdateManyWithWhereWithoutSleeveTypeInput>
    deleteMany?: Enumerable<TopDescriptionScalarWhereInput>
  }

  export type KurtasDescriptionUncheckedUpdateManyWithoutSleeveTypeNestedInput = {
    create?: XOR<Enumerable<KurtasDescriptionCreateWithoutSleeveTypeInput>, Enumerable<KurtasDescriptionUncheckedCreateWithoutSleeveTypeInput>>
    connectOrCreate?: Enumerable<KurtasDescriptionCreateOrConnectWithoutSleeveTypeInput>
    upsert?: Enumerable<KurtasDescriptionUpsertWithWhereUniqueWithoutSleeveTypeInput>
    createMany?: KurtasDescriptionCreateManySleeveTypeInputEnvelope
    set?: Enumerable<KurtasDescriptionWhereUniqueInput>
    disconnect?: Enumerable<KurtasDescriptionWhereUniqueInput>
    delete?: Enumerable<KurtasDescriptionWhereUniqueInput>
    connect?: Enumerable<KurtasDescriptionWhereUniqueInput>
    update?: Enumerable<KurtasDescriptionUpdateWithWhereUniqueWithoutSleeveTypeInput>
    updateMany?: Enumerable<KurtasDescriptionUpdateManyWithWhereWithoutSleeveTypeInput>
    deleteMany?: Enumerable<KurtasDescriptionScalarWhereInput>
  }

  export type InnersDescriptionUncheckedUpdateManyWithoutSleeveTypeNestedInput = {
    create?: XOR<Enumerable<InnersDescriptionCreateWithoutSleeveTypeInput>, Enumerable<InnersDescriptionUncheckedCreateWithoutSleeveTypeInput>>
    connectOrCreate?: Enumerable<InnersDescriptionCreateOrConnectWithoutSleeveTypeInput>
    upsert?: Enumerable<InnersDescriptionUpsertWithWhereUniqueWithoutSleeveTypeInput>
    createMany?: InnersDescriptionCreateManySleeveTypeInputEnvelope
    set?: Enumerable<InnersDescriptionWhereUniqueInput>
    disconnect?: Enumerable<InnersDescriptionWhereUniqueInput>
    delete?: Enumerable<InnersDescriptionWhereUniqueInput>
    connect?: Enumerable<InnersDescriptionWhereUniqueInput>
    update?: Enumerable<InnersDescriptionUpdateWithWhereUniqueWithoutSleeveTypeInput>
    updateMany?: Enumerable<InnersDescriptionUpdateManyWithWhereWithoutSleeveTypeInput>
    deleteMany?: Enumerable<InnersDescriptionScalarWhereInput>
  }

  export type TopDescriptionUncheckedUpdateManyWithoutSleeveTypeNestedInput = {
    create?: XOR<Enumerable<TopDescriptionCreateWithoutSleeveTypeInput>, Enumerable<TopDescriptionUncheckedCreateWithoutSleeveTypeInput>>
    connectOrCreate?: Enumerable<TopDescriptionCreateOrConnectWithoutSleeveTypeInput>
    upsert?: Enumerable<TopDescriptionUpsertWithWhereUniqueWithoutSleeveTypeInput>
    createMany?: TopDescriptionCreateManySleeveTypeInputEnvelope
    set?: Enumerable<TopDescriptionWhereUniqueInput>
    disconnect?: Enumerable<TopDescriptionWhereUniqueInput>
    delete?: Enumerable<TopDescriptionWhereUniqueInput>
    connect?: Enumerable<TopDescriptionWhereUniqueInput>
    update?: Enumerable<TopDescriptionUpdateWithWhereUniqueWithoutSleeveTypeInput>
    updateMany?: Enumerable<TopDescriptionUpdateManyWithWhereWithoutSleeveTypeInput>
    deleteMany?: Enumerable<TopDescriptionScalarWhereInput>
  }

  export type KurtasDescriptionCreateNestedManyWithoutNeckTypeInput = {
    create?: XOR<Enumerable<KurtasDescriptionCreateWithoutNeckTypeInput>, Enumerable<KurtasDescriptionUncheckedCreateWithoutNeckTypeInput>>
    connectOrCreate?: Enumerable<KurtasDescriptionCreateOrConnectWithoutNeckTypeInput>
    createMany?: KurtasDescriptionCreateManyNeckTypeInputEnvelope
    connect?: Enumerable<KurtasDescriptionWhereUniqueInput>
  }

  export type InnersDescriptionCreateNestedManyWithoutNeckTypeInput = {
    create?: XOR<Enumerable<InnersDescriptionCreateWithoutNeckTypeInput>, Enumerable<InnersDescriptionUncheckedCreateWithoutNeckTypeInput>>
    connectOrCreate?: Enumerable<InnersDescriptionCreateOrConnectWithoutNeckTypeInput>
    createMany?: InnersDescriptionCreateManyNeckTypeInputEnvelope
    connect?: Enumerable<InnersDescriptionWhereUniqueInput>
  }

  export type TopDescriptionCreateNestedManyWithoutNeckTypeInput = {
    create?: XOR<Enumerable<TopDescriptionCreateWithoutNeckTypeInput>, Enumerable<TopDescriptionUncheckedCreateWithoutNeckTypeInput>>
    connectOrCreate?: Enumerable<TopDescriptionCreateOrConnectWithoutNeckTypeInput>
    createMany?: TopDescriptionCreateManyNeckTypeInputEnvelope
    connect?: Enumerable<TopDescriptionWhereUniqueInput>
  }

  export type KurtasDescriptionUncheckedCreateNestedManyWithoutNeckTypeInput = {
    create?: XOR<Enumerable<KurtasDescriptionCreateWithoutNeckTypeInput>, Enumerable<KurtasDescriptionUncheckedCreateWithoutNeckTypeInput>>
    connectOrCreate?: Enumerable<KurtasDescriptionCreateOrConnectWithoutNeckTypeInput>
    createMany?: KurtasDescriptionCreateManyNeckTypeInputEnvelope
    connect?: Enumerable<KurtasDescriptionWhereUniqueInput>
  }

  export type InnersDescriptionUncheckedCreateNestedManyWithoutNeckTypeInput = {
    create?: XOR<Enumerable<InnersDescriptionCreateWithoutNeckTypeInput>, Enumerable<InnersDescriptionUncheckedCreateWithoutNeckTypeInput>>
    connectOrCreate?: Enumerable<InnersDescriptionCreateOrConnectWithoutNeckTypeInput>
    createMany?: InnersDescriptionCreateManyNeckTypeInputEnvelope
    connect?: Enumerable<InnersDescriptionWhereUniqueInput>
  }

  export type TopDescriptionUncheckedCreateNestedManyWithoutNeckTypeInput = {
    create?: XOR<Enumerable<TopDescriptionCreateWithoutNeckTypeInput>, Enumerable<TopDescriptionUncheckedCreateWithoutNeckTypeInput>>
    connectOrCreate?: Enumerable<TopDescriptionCreateOrConnectWithoutNeckTypeInput>
    createMany?: TopDescriptionCreateManyNeckTypeInputEnvelope
    connect?: Enumerable<TopDescriptionWhereUniqueInput>
  }

  export type KurtasDescriptionUpdateManyWithoutNeckTypeNestedInput = {
    create?: XOR<Enumerable<KurtasDescriptionCreateWithoutNeckTypeInput>, Enumerable<KurtasDescriptionUncheckedCreateWithoutNeckTypeInput>>
    connectOrCreate?: Enumerable<KurtasDescriptionCreateOrConnectWithoutNeckTypeInput>
    upsert?: Enumerable<KurtasDescriptionUpsertWithWhereUniqueWithoutNeckTypeInput>
    createMany?: KurtasDescriptionCreateManyNeckTypeInputEnvelope
    set?: Enumerable<KurtasDescriptionWhereUniqueInput>
    disconnect?: Enumerable<KurtasDescriptionWhereUniqueInput>
    delete?: Enumerable<KurtasDescriptionWhereUniqueInput>
    connect?: Enumerable<KurtasDescriptionWhereUniqueInput>
    update?: Enumerable<KurtasDescriptionUpdateWithWhereUniqueWithoutNeckTypeInput>
    updateMany?: Enumerable<KurtasDescriptionUpdateManyWithWhereWithoutNeckTypeInput>
    deleteMany?: Enumerable<KurtasDescriptionScalarWhereInput>
  }

  export type InnersDescriptionUpdateManyWithoutNeckTypeNestedInput = {
    create?: XOR<Enumerable<InnersDescriptionCreateWithoutNeckTypeInput>, Enumerable<InnersDescriptionUncheckedCreateWithoutNeckTypeInput>>
    connectOrCreate?: Enumerable<InnersDescriptionCreateOrConnectWithoutNeckTypeInput>
    upsert?: Enumerable<InnersDescriptionUpsertWithWhereUniqueWithoutNeckTypeInput>
    createMany?: InnersDescriptionCreateManyNeckTypeInputEnvelope
    set?: Enumerable<InnersDescriptionWhereUniqueInput>
    disconnect?: Enumerable<InnersDescriptionWhereUniqueInput>
    delete?: Enumerable<InnersDescriptionWhereUniqueInput>
    connect?: Enumerable<InnersDescriptionWhereUniqueInput>
    update?: Enumerable<InnersDescriptionUpdateWithWhereUniqueWithoutNeckTypeInput>
    updateMany?: Enumerable<InnersDescriptionUpdateManyWithWhereWithoutNeckTypeInput>
    deleteMany?: Enumerable<InnersDescriptionScalarWhereInput>
  }

  export type TopDescriptionUpdateManyWithoutNeckTypeNestedInput = {
    create?: XOR<Enumerable<TopDescriptionCreateWithoutNeckTypeInput>, Enumerable<TopDescriptionUncheckedCreateWithoutNeckTypeInput>>
    connectOrCreate?: Enumerable<TopDescriptionCreateOrConnectWithoutNeckTypeInput>
    upsert?: Enumerable<TopDescriptionUpsertWithWhereUniqueWithoutNeckTypeInput>
    createMany?: TopDescriptionCreateManyNeckTypeInputEnvelope
    set?: Enumerable<TopDescriptionWhereUniqueInput>
    disconnect?: Enumerable<TopDescriptionWhereUniqueInput>
    delete?: Enumerable<TopDescriptionWhereUniqueInput>
    connect?: Enumerable<TopDescriptionWhereUniqueInput>
    update?: Enumerable<TopDescriptionUpdateWithWhereUniqueWithoutNeckTypeInput>
    updateMany?: Enumerable<TopDescriptionUpdateManyWithWhereWithoutNeckTypeInput>
    deleteMany?: Enumerable<TopDescriptionScalarWhereInput>
  }

  export type KurtasDescriptionUncheckedUpdateManyWithoutNeckTypeNestedInput = {
    create?: XOR<Enumerable<KurtasDescriptionCreateWithoutNeckTypeInput>, Enumerable<KurtasDescriptionUncheckedCreateWithoutNeckTypeInput>>
    connectOrCreate?: Enumerable<KurtasDescriptionCreateOrConnectWithoutNeckTypeInput>
    upsert?: Enumerable<KurtasDescriptionUpsertWithWhereUniqueWithoutNeckTypeInput>
    createMany?: KurtasDescriptionCreateManyNeckTypeInputEnvelope
    set?: Enumerable<KurtasDescriptionWhereUniqueInput>
    disconnect?: Enumerable<KurtasDescriptionWhereUniqueInput>
    delete?: Enumerable<KurtasDescriptionWhereUniqueInput>
    connect?: Enumerable<KurtasDescriptionWhereUniqueInput>
    update?: Enumerable<KurtasDescriptionUpdateWithWhereUniqueWithoutNeckTypeInput>
    updateMany?: Enumerable<KurtasDescriptionUpdateManyWithWhereWithoutNeckTypeInput>
    deleteMany?: Enumerable<KurtasDescriptionScalarWhereInput>
  }

  export type InnersDescriptionUncheckedUpdateManyWithoutNeckTypeNestedInput = {
    create?: XOR<Enumerable<InnersDescriptionCreateWithoutNeckTypeInput>, Enumerable<InnersDescriptionUncheckedCreateWithoutNeckTypeInput>>
    connectOrCreate?: Enumerable<InnersDescriptionCreateOrConnectWithoutNeckTypeInput>
    upsert?: Enumerable<InnersDescriptionUpsertWithWhereUniqueWithoutNeckTypeInput>
    createMany?: InnersDescriptionCreateManyNeckTypeInputEnvelope
    set?: Enumerable<InnersDescriptionWhereUniqueInput>
    disconnect?: Enumerable<InnersDescriptionWhereUniqueInput>
    delete?: Enumerable<InnersDescriptionWhereUniqueInput>
    connect?: Enumerable<InnersDescriptionWhereUniqueInput>
    update?: Enumerable<InnersDescriptionUpdateWithWhereUniqueWithoutNeckTypeInput>
    updateMany?: Enumerable<InnersDescriptionUpdateManyWithWhereWithoutNeckTypeInput>
    deleteMany?: Enumerable<InnersDescriptionScalarWhereInput>
  }

  export type TopDescriptionUncheckedUpdateManyWithoutNeckTypeNestedInput = {
    create?: XOR<Enumerable<TopDescriptionCreateWithoutNeckTypeInput>, Enumerable<TopDescriptionUncheckedCreateWithoutNeckTypeInput>>
    connectOrCreate?: Enumerable<TopDescriptionCreateOrConnectWithoutNeckTypeInput>
    upsert?: Enumerable<TopDescriptionUpsertWithWhereUniqueWithoutNeckTypeInput>
    createMany?: TopDescriptionCreateManyNeckTypeInputEnvelope
    set?: Enumerable<TopDescriptionWhereUniqueInput>
    disconnect?: Enumerable<TopDescriptionWhereUniqueInput>
    delete?: Enumerable<TopDescriptionWhereUniqueInput>
    connect?: Enumerable<TopDescriptionWhereUniqueInput>
    update?: Enumerable<TopDescriptionUpdateWithWhereUniqueWithoutNeckTypeInput>
    updateMany?: Enumerable<TopDescriptionUpdateManyWithWhereWithoutNeckTypeInput>
    deleteMany?: Enumerable<TopDescriptionScalarWhereInput>
  }

  export type KurtasDescriptionCreateNestedManyWithoutKurtasLengthTypeInput = {
    create?: XOR<Enumerable<KurtasDescriptionCreateWithoutKurtasLengthTypeInput>, Enumerable<KurtasDescriptionUncheckedCreateWithoutKurtasLengthTypeInput>>
    connectOrCreate?: Enumerable<KurtasDescriptionCreateOrConnectWithoutKurtasLengthTypeInput>
    createMany?: KurtasDescriptionCreateManyKurtasLengthTypeInputEnvelope
    connect?: Enumerable<KurtasDescriptionWhereUniqueInput>
  }

  export type KurtasDescriptionUncheckedCreateNestedManyWithoutKurtasLengthTypeInput = {
    create?: XOR<Enumerable<KurtasDescriptionCreateWithoutKurtasLengthTypeInput>, Enumerable<KurtasDescriptionUncheckedCreateWithoutKurtasLengthTypeInput>>
    connectOrCreate?: Enumerable<KurtasDescriptionCreateOrConnectWithoutKurtasLengthTypeInput>
    createMany?: KurtasDescriptionCreateManyKurtasLengthTypeInputEnvelope
    connect?: Enumerable<KurtasDescriptionWhereUniqueInput>
  }

  export type KurtasDescriptionUpdateManyWithoutKurtasLengthTypeNestedInput = {
    create?: XOR<Enumerable<KurtasDescriptionCreateWithoutKurtasLengthTypeInput>, Enumerable<KurtasDescriptionUncheckedCreateWithoutKurtasLengthTypeInput>>
    connectOrCreate?: Enumerable<KurtasDescriptionCreateOrConnectWithoutKurtasLengthTypeInput>
    upsert?: Enumerable<KurtasDescriptionUpsertWithWhereUniqueWithoutKurtasLengthTypeInput>
    createMany?: KurtasDescriptionCreateManyKurtasLengthTypeInputEnvelope
    set?: Enumerable<KurtasDescriptionWhereUniqueInput>
    disconnect?: Enumerable<KurtasDescriptionWhereUniqueInput>
    delete?: Enumerable<KurtasDescriptionWhereUniqueInput>
    connect?: Enumerable<KurtasDescriptionWhereUniqueInput>
    update?: Enumerable<KurtasDescriptionUpdateWithWhereUniqueWithoutKurtasLengthTypeInput>
    updateMany?: Enumerable<KurtasDescriptionUpdateManyWithWhereWithoutKurtasLengthTypeInput>
    deleteMany?: Enumerable<KurtasDescriptionScalarWhereInput>
  }

  export type KurtasDescriptionUncheckedUpdateManyWithoutKurtasLengthTypeNestedInput = {
    create?: XOR<Enumerable<KurtasDescriptionCreateWithoutKurtasLengthTypeInput>, Enumerable<KurtasDescriptionUncheckedCreateWithoutKurtasLengthTypeInput>>
    connectOrCreate?: Enumerable<KurtasDescriptionCreateOrConnectWithoutKurtasLengthTypeInput>
    upsert?: Enumerable<KurtasDescriptionUpsertWithWhereUniqueWithoutKurtasLengthTypeInput>
    createMany?: KurtasDescriptionCreateManyKurtasLengthTypeInputEnvelope
    set?: Enumerable<KurtasDescriptionWhereUniqueInput>
    disconnect?: Enumerable<KurtasDescriptionWhereUniqueInput>
    delete?: Enumerable<KurtasDescriptionWhereUniqueInput>
    connect?: Enumerable<KurtasDescriptionWhereUniqueInput>
    update?: Enumerable<KurtasDescriptionUpdateWithWhereUniqueWithoutKurtasLengthTypeInput>
    updateMany?: Enumerable<KurtasDescriptionUpdateManyWithWhereWithoutKurtasLengthTypeInput>
    deleteMany?: Enumerable<KurtasDescriptionScalarWhereInput>
  }

  export type BottomDescriptionCreateNestedManyWithoutTypesOfPantsInput = {
    create?: XOR<Enumerable<BottomDescriptionCreateWithoutTypesOfPantsInput>, Enumerable<BottomDescriptionUncheckedCreateWithoutTypesOfPantsInput>>
    connectOrCreate?: Enumerable<BottomDescriptionCreateOrConnectWithoutTypesOfPantsInput>
    createMany?: BottomDescriptionCreateManyTypesOfPantsInputEnvelope
    connect?: Enumerable<BottomDescriptionWhereUniqueInput>
  }

  export type BottomDescriptionUncheckedCreateNestedManyWithoutTypesOfPantsInput = {
    create?: XOR<Enumerable<BottomDescriptionCreateWithoutTypesOfPantsInput>, Enumerable<BottomDescriptionUncheckedCreateWithoutTypesOfPantsInput>>
    connectOrCreate?: Enumerable<BottomDescriptionCreateOrConnectWithoutTypesOfPantsInput>
    createMany?: BottomDescriptionCreateManyTypesOfPantsInputEnvelope
    connect?: Enumerable<BottomDescriptionWhereUniqueInput>
  }

  export type BottomDescriptionUpdateManyWithoutTypesOfPantsNestedInput = {
    create?: XOR<Enumerable<BottomDescriptionCreateWithoutTypesOfPantsInput>, Enumerable<BottomDescriptionUncheckedCreateWithoutTypesOfPantsInput>>
    connectOrCreate?: Enumerable<BottomDescriptionCreateOrConnectWithoutTypesOfPantsInput>
    upsert?: Enumerable<BottomDescriptionUpsertWithWhereUniqueWithoutTypesOfPantsInput>
    createMany?: BottomDescriptionCreateManyTypesOfPantsInputEnvelope
    set?: Enumerable<BottomDescriptionWhereUniqueInput>
    disconnect?: Enumerable<BottomDescriptionWhereUniqueInput>
    delete?: Enumerable<BottomDescriptionWhereUniqueInput>
    connect?: Enumerable<BottomDescriptionWhereUniqueInput>
    update?: Enumerable<BottomDescriptionUpdateWithWhereUniqueWithoutTypesOfPantsInput>
    updateMany?: Enumerable<BottomDescriptionUpdateManyWithWhereWithoutTypesOfPantsInput>
    deleteMany?: Enumerable<BottomDescriptionScalarWhereInput>
  }

  export type BottomDescriptionUncheckedUpdateManyWithoutTypesOfPantsNestedInput = {
    create?: XOR<Enumerable<BottomDescriptionCreateWithoutTypesOfPantsInput>, Enumerable<BottomDescriptionUncheckedCreateWithoutTypesOfPantsInput>>
    connectOrCreate?: Enumerable<BottomDescriptionCreateOrConnectWithoutTypesOfPantsInput>
    upsert?: Enumerable<BottomDescriptionUpsertWithWhereUniqueWithoutTypesOfPantsInput>
    createMany?: BottomDescriptionCreateManyTypesOfPantsInputEnvelope
    set?: Enumerable<BottomDescriptionWhereUniqueInput>
    disconnect?: Enumerable<BottomDescriptionWhereUniqueInput>
    delete?: Enumerable<BottomDescriptionWhereUniqueInput>
    connect?: Enumerable<BottomDescriptionWhereUniqueInput>
    update?: Enumerable<BottomDescriptionUpdateWithWhereUniqueWithoutTypesOfPantsInput>
    updateMany?: Enumerable<BottomDescriptionUpdateManyWithWhereWithoutTypesOfPantsInput>
    deleteMany?: Enumerable<BottomDescriptionScalarWhereInput>
  }

  export type BottomDescriptionCreateNestedManyWithoutTypesOfPleatsInput = {
    create?: XOR<Enumerable<BottomDescriptionCreateWithoutTypesOfPleatsInput>, Enumerable<BottomDescriptionUncheckedCreateWithoutTypesOfPleatsInput>>
    connectOrCreate?: Enumerable<BottomDescriptionCreateOrConnectWithoutTypesOfPleatsInput>
    createMany?: BottomDescriptionCreateManyTypesOfPleatsInputEnvelope
    connect?: Enumerable<BottomDescriptionWhereUniqueInput>
  }

  export type BottomDescriptionUncheckedCreateNestedManyWithoutTypesOfPleatsInput = {
    create?: XOR<Enumerable<BottomDescriptionCreateWithoutTypesOfPleatsInput>, Enumerable<BottomDescriptionUncheckedCreateWithoutTypesOfPleatsInput>>
    connectOrCreate?: Enumerable<BottomDescriptionCreateOrConnectWithoutTypesOfPleatsInput>
    createMany?: BottomDescriptionCreateManyTypesOfPleatsInputEnvelope
    connect?: Enumerable<BottomDescriptionWhereUniqueInput>
  }

  export type BottomDescriptionUpdateManyWithoutTypesOfPleatsNestedInput = {
    create?: XOR<Enumerable<BottomDescriptionCreateWithoutTypesOfPleatsInput>, Enumerable<BottomDescriptionUncheckedCreateWithoutTypesOfPleatsInput>>
    connectOrCreate?: Enumerable<BottomDescriptionCreateOrConnectWithoutTypesOfPleatsInput>
    upsert?: Enumerable<BottomDescriptionUpsertWithWhereUniqueWithoutTypesOfPleatsInput>
    createMany?: BottomDescriptionCreateManyTypesOfPleatsInputEnvelope
    set?: Enumerable<BottomDescriptionWhereUniqueInput>
    disconnect?: Enumerable<BottomDescriptionWhereUniqueInput>
    delete?: Enumerable<BottomDescriptionWhereUniqueInput>
    connect?: Enumerable<BottomDescriptionWhereUniqueInput>
    update?: Enumerable<BottomDescriptionUpdateWithWhereUniqueWithoutTypesOfPleatsInput>
    updateMany?: Enumerable<BottomDescriptionUpdateManyWithWhereWithoutTypesOfPleatsInput>
    deleteMany?: Enumerable<BottomDescriptionScalarWhereInput>
  }

  export type BottomDescriptionUncheckedUpdateManyWithoutTypesOfPleatsNestedInput = {
    create?: XOR<Enumerable<BottomDescriptionCreateWithoutTypesOfPleatsInput>, Enumerable<BottomDescriptionUncheckedCreateWithoutTypesOfPleatsInput>>
    connectOrCreate?: Enumerable<BottomDescriptionCreateOrConnectWithoutTypesOfPleatsInput>
    upsert?: Enumerable<BottomDescriptionUpsertWithWhereUniqueWithoutTypesOfPleatsInput>
    createMany?: BottomDescriptionCreateManyTypesOfPleatsInputEnvelope
    set?: Enumerable<BottomDescriptionWhereUniqueInput>
    disconnect?: Enumerable<BottomDescriptionWhereUniqueInput>
    delete?: Enumerable<BottomDescriptionWhereUniqueInput>
    connect?: Enumerable<BottomDescriptionWhereUniqueInput>
    update?: Enumerable<BottomDescriptionUpdateWithWhereUniqueWithoutTypesOfPleatsInput>
    updateMany?: Enumerable<BottomDescriptionUpdateManyWithWhereWithoutTypesOfPleatsInput>
    deleteMany?: Enumerable<BottomDescriptionScalarWhereInput>
  }

  export type BottomDescriptionCreateNestedManyWithoutTypesOfLengthInput = {
    create?: XOR<Enumerable<BottomDescriptionCreateWithoutTypesOfLengthInput>, Enumerable<BottomDescriptionUncheckedCreateWithoutTypesOfLengthInput>>
    connectOrCreate?: Enumerable<BottomDescriptionCreateOrConnectWithoutTypesOfLengthInput>
    createMany?: BottomDescriptionCreateManyTypesOfLengthInputEnvelope
    connect?: Enumerable<BottomDescriptionWhereUniqueInput>
  }

  export type BottomDescriptionUncheckedCreateNestedManyWithoutTypesOfLengthInput = {
    create?: XOR<Enumerable<BottomDescriptionCreateWithoutTypesOfLengthInput>, Enumerable<BottomDescriptionUncheckedCreateWithoutTypesOfLengthInput>>
    connectOrCreate?: Enumerable<BottomDescriptionCreateOrConnectWithoutTypesOfLengthInput>
    createMany?: BottomDescriptionCreateManyTypesOfLengthInputEnvelope
    connect?: Enumerable<BottomDescriptionWhereUniqueInput>
  }

  export type BottomDescriptionUpdateManyWithoutTypesOfLengthNestedInput = {
    create?: XOR<Enumerable<BottomDescriptionCreateWithoutTypesOfLengthInput>, Enumerable<BottomDescriptionUncheckedCreateWithoutTypesOfLengthInput>>
    connectOrCreate?: Enumerable<BottomDescriptionCreateOrConnectWithoutTypesOfLengthInput>
    upsert?: Enumerable<BottomDescriptionUpsertWithWhereUniqueWithoutTypesOfLengthInput>
    createMany?: BottomDescriptionCreateManyTypesOfLengthInputEnvelope
    set?: Enumerable<BottomDescriptionWhereUniqueInput>
    disconnect?: Enumerable<BottomDescriptionWhereUniqueInput>
    delete?: Enumerable<BottomDescriptionWhereUniqueInput>
    connect?: Enumerable<BottomDescriptionWhereUniqueInput>
    update?: Enumerable<BottomDescriptionUpdateWithWhereUniqueWithoutTypesOfLengthInput>
    updateMany?: Enumerable<BottomDescriptionUpdateManyWithWhereWithoutTypesOfLengthInput>
    deleteMany?: Enumerable<BottomDescriptionScalarWhereInput>
  }

  export type BottomDescriptionUncheckedUpdateManyWithoutTypesOfLengthNestedInput = {
    create?: XOR<Enumerable<BottomDescriptionCreateWithoutTypesOfLengthInput>, Enumerable<BottomDescriptionUncheckedCreateWithoutTypesOfLengthInput>>
    connectOrCreate?: Enumerable<BottomDescriptionCreateOrConnectWithoutTypesOfLengthInput>
    upsert?: Enumerable<BottomDescriptionUpsertWithWhereUniqueWithoutTypesOfLengthInput>
    createMany?: BottomDescriptionCreateManyTypesOfLengthInputEnvelope
    set?: Enumerable<BottomDescriptionWhereUniqueInput>
    disconnect?: Enumerable<BottomDescriptionWhereUniqueInput>
    delete?: Enumerable<BottomDescriptionWhereUniqueInput>
    connect?: Enumerable<BottomDescriptionWhereUniqueInput>
    update?: Enumerable<BottomDescriptionUpdateWithWhereUniqueWithoutTypesOfLengthInput>
    updateMany?: Enumerable<BottomDescriptionUpdateManyWithWhereWithoutTypesOfLengthInput>
    deleteMany?: Enumerable<BottomDescriptionScalarWhereInput>
  }

  export type ProductAviableSizesCreateNestedOneWithoutHistoryInput = {
    create?: XOR<ProductAviableSizesCreateWithoutHistoryInput, ProductAviableSizesUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: ProductAviableSizesCreateOrConnectWithoutHistoryInput
    connect?: ProductAviableSizesWhereUniqueInput
  }

  export type ProductAviableSizesUpdateOneRequiredWithoutHistoryNestedInput = {
    create?: XOR<ProductAviableSizesCreateWithoutHistoryInput, ProductAviableSizesUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: ProductAviableSizesCreateOrConnectWithoutHistoryInput
    upsert?: ProductAviableSizesUpsertWithoutHistoryInput
    connect?: ProductAviableSizesWhereUniqueInput
    update?: XOR<ProductAviableSizesUpdateWithoutHistoryInput, ProductAviableSizesUncheckedUpdateWithoutHistoryInput>
  }

  export type ProductCreateNestedOneWithoutOfferInput = {
    create?: XOR<ProductCreateWithoutOfferInput, ProductUncheckedCreateWithoutOfferInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOfferInput
    connect?: ProductWhereUniqueInput
  }

  export type OfferValidityCreateNestedManyWithoutOfferInput = {
    create?: XOR<Enumerable<OfferValidityCreateWithoutOfferInput>, Enumerable<OfferValidityUncheckedCreateWithoutOfferInput>>
    connectOrCreate?: Enumerable<OfferValidityCreateOrConnectWithoutOfferInput>
    createMany?: OfferValidityCreateManyOfferInputEnvelope
    connect?: Enumerable<OfferValidityWhereUniqueInput>
  }

  export type OfferValidityUncheckedCreateNestedManyWithoutOfferInput = {
    create?: XOR<Enumerable<OfferValidityCreateWithoutOfferInput>, Enumerable<OfferValidityUncheckedCreateWithoutOfferInput>>
    connectOrCreate?: Enumerable<OfferValidityCreateOrConnectWithoutOfferInput>
    createMany?: OfferValidityCreateManyOfferInputEnvelope
    connect?: Enumerable<OfferValidityWhereUniqueInput>
  }

  export type ProductUpdateOneRequiredWithoutOfferNestedInput = {
    create?: XOR<ProductCreateWithoutOfferInput, ProductUncheckedCreateWithoutOfferInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOfferInput
    upsert?: ProductUpsertWithoutOfferInput
    connect?: ProductWhereUniqueInput
    update?: XOR<ProductUpdateWithoutOfferInput, ProductUncheckedUpdateWithoutOfferInput>
  }

  export type OfferValidityUpdateManyWithoutOfferNestedInput = {
    create?: XOR<Enumerable<OfferValidityCreateWithoutOfferInput>, Enumerable<OfferValidityUncheckedCreateWithoutOfferInput>>
    connectOrCreate?: Enumerable<OfferValidityCreateOrConnectWithoutOfferInput>
    upsert?: Enumerable<OfferValidityUpsertWithWhereUniqueWithoutOfferInput>
    createMany?: OfferValidityCreateManyOfferInputEnvelope
    set?: Enumerable<OfferValidityWhereUniqueInput>
    disconnect?: Enumerable<OfferValidityWhereUniqueInput>
    delete?: Enumerable<OfferValidityWhereUniqueInput>
    connect?: Enumerable<OfferValidityWhereUniqueInput>
    update?: Enumerable<OfferValidityUpdateWithWhereUniqueWithoutOfferInput>
    updateMany?: Enumerable<OfferValidityUpdateManyWithWhereWithoutOfferInput>
    deleteMany?: Enumerable<OfferValidityScalarWhereInput>
  }

  export type OfferValidityUncheckedUpdateManyWithoutOfferNestedInput = {
    create?: XOR<Enumerable<OfferValidityCreateWithoutOfferInput>, Enumerable<OfferValidityUncheckedCreateWithoutOfferInput>>
    connectOrCreate?: Enumerable<OfferValidityCreateOrConnectWithoutOfferInput>
    upsert?: Enumerable<OfferValidityUpsertWithWhereUniqueWithoutOfferInput>
    createMany?: OfferValidityCreateManyOfferInputEnvelope
    set?: Enumerable<OfferValidityWhereUniqueInput>
    disconnect?: Enumerable<OfferValidityWhereUniqueInput>
    delete?: Enumerable<OfferValidityWhereUniqueInput>
    connect?: Enumerable<OfferValidityWhereUniqueInput>
    update?: Enumerable<OfferValidityUpdateWithWhereUniqueWithoutOfferInput>
    updateMany?: Enumerable<OfferValidityUpdateManyWithWhereWithoutOfferInput>
    deleteMany?: Enumerable<OfferValidityScalarWhereInput>
  }

  export type OfferCreateNestedOneWithoutOfferValidityInput = {
    create?: XOR<OfferCreateWithoutOfferValidityInput, OfferUncheckedCreateWithoutOfferValidityInput>
    connectOrCreate?: OfferCreateOrConnectWithoutOfferValidityInput
    connect?: OfferWhereUniqueInput
  }

  export type OfferPromotionPeriodsCreateNestedOneWithoutOfferValidityInput = {
    create?: XOR<OfferPromotionPeriodsCreateWithoutOfferValidityInput, OfferPromotionPeriodsUncheckedCreateWithoutOfferValidityInput>
    connectOrCreate?: OfferPromotionPeriodsCreateOrConnectWithoutOfferValidityInput
    connect?: OfferPromotionPeriodsWhereUniqueInput
  }

  export type OfferUpdateOneWithoutOfferValidityNestedInput = {
    create?: XOR<OfferCreateWithoutOfferValidityInput, OfferUncheckedCreateWithoutOfferValidityInput>
    connectOrCreate?: OfferCreateOrConnectWithoutOfferValidityInput
    upsert?: OfferUpsertWithoutOfferValidityInput
    disconnect?: boolean
    delete?: boolean
    connect?: OfferWhereUniqueInput
    update?: XOR<OfferUpdateWithoutOfferValidityInput, OfferUncheckedUpdateWithoutOfferValidityInput>
  }

  export type OfferPromotionPeriodsUpdateOneWithoutOfferValidityNestedInput = {
    create?: XOR<OfferPromotionPeriodsCreateWithoutOfferValidityInput, OfferPromotionPeriodsUncheckedCreateWithoutOfferValidityInput>
    connectOrCreate?: OfferPromotionPeriodsCreateOrConnectWithoutOfferValidityInput
    upsert?: OfferPromotionPeriodsUpsertWithoutOfferValidityInput
    disconnect?: boolean
    delete?: boolean
    connect?: OfferPromotionPeriodsWhereUniqueInput
    update?: XOR<OfferPromotionPeriodsUpdateWithoutOfferValidityInput, OfferPromotionPeriodsUncheckedUpdateWithoutOfferValidityInput>
  }

  export type OfferValidityCreateNestedOneWithoutOfferPromotionPeriodInput = {
    create?: XOR<OfferValidityCreateWithoutOfferPromotionPeriodInput, OfferValidityUncheckedCreateWithoutOfferPromotionPeriodInput>
    connectOrCreate?: OfferValidityCreateOrConnectWithoutOfferPromotionPeriodInput
    connect?: OfferValidityWhereUniqueInput
  }

  export type OfferValidityUncheckedCreateNestedOneWithoutOfferPromotionPeriodInput = {
    create?: XOR<OfferValidityCreateWithoutOfferPromotionPeriodInput, OfferValidityUncheckedCreateWithoutOfferPromotionPeriodInput>
    connectOrCreate?: OfferValidityCreateOrConnectWithoutOfferPromotionPeriodInput
    connect?: OfferValidityWhereUniqueInput
  }

  export type OfferValidityUpdateOneWithoutOfferPromotionPeriodNestedInput = {
    create?: XOR<OfferValidityCreateWithoutOfferPromotionPeriodInput, OfferValidityUncheckedCreateWithoutOfferPromotionPeriodInput>
    connectOrCreate?: OfferValidityCreateOrConnectWithoutOfferPromotionPeriodInput
    upsert?: OfferValidityUpsertWithoutOfferPromotionPeriodInput
    disconnect?: boolean
    delete?: boolean
    connect?: OfferValidityWhereUniqueInput
    update?: XOR<OfferValidityUpdateWithoutOfferPromotionPeriodInput, OfferValidityUncheckedUpdateWithoutOfferPromotionPeriodInput>
  }

  export type OfferValidityUncheckedUpdateOneWithoutOfferPromotionPeriodNestedInput = {
    create?: XOR<OfferValidityCreateWithoutOfferPromotionPeriodInput, OfferValidityUncheckedCreateWithoutOfferPromotionPeriodInput>
    connectOrCreate?: OfferValidityCreateOrConnectWithoutOfferPromotionPeriodInput
    upsert?: OfferValidityUpsertWithoutOfferPromotionPeriodInput
    disconnect?: boolean
    delete?: boolean
    connect?: OfferValidityWhereUniqueInput
    update?: XOR<OfferValidityUpdateWithoutOfferPromotionPeriodInput, OfferValidityUncheckedUpdateWithoutOfferPromotionPeriodInput>
  }

  export type UserCreateNestedOneWithoutAddCartInput = {
    create?: XOR<UserCreateWithoutAddCartInput, UserUncheckedCreateWithoutAddCartInput>
    connectOrCreate?: UserCreateOrConnectWithoutAddCartInput
    connect?: UserWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutCartInput = {
    create?: XOR<ProductCreateWithoutCartInput, ProductUncheckedCreateWithoutCartInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCartInput
    connect?: ProductWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAddCartNestedInput = {
    create?: XOR<UserCreateWithoutAddCartInput, UserUncheckedCreateWithoutAddCartInput>
    connectOrCreate?: UserCreateOrConnectWithoutAddCartInput
    upsert?: UserUpsertWithoutAddCartInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutAddCartInput, UserUncheckedUpdateWithoutAddCartInput>
  }

  export type ProductUpdateOneRequiredWithoutCartNestedInput = {
    create?: XOR<ProductCreateWithoutCartInput, ProductUncheckedCreateWithoutCartInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCartInput
    upsert?: ProductUpsertWithoutCartInput
    connect?: ProductWhereUniqueInput
    update?: XOR<ProductUpdateWithoutCartInput, ProductUncheckedUpdateWithoutCartInput>
  }

  export type WishlistItemCreateNestedManyWithoutWishlistInput = {
    create?: XOR<Enumerable<WishlistItemCreateWithoutWishlistInput>, Enumerable<WishlistItemUncheckedCreateWithoutWishlistInput>>
    connectOrCreate?: Enumerable<WishlistItemCreateOrConnectWithoutWishlistInput>
    createMany?: WishlistItemCreateManyWishlistInputEnvelope
    connect?: Enumerable<WishlistItemWhereUniqueInput>
  }

  export type UserCreateNestedOneWithoutWishlistInput = {
    create?: XOR<UserCreateWithoutWishlistInput, UserUncheckedCreateWithoutWishlistInput>
    connectOrCreate?: UserCreateOrConnectWithoutWishlistInput
    connect?: UserWhereUniqueInput
  }

  export type WishlistItemUncheckedCreateNestedManyWithoutWishlistInput = {
    create?: XOR<Enumerable<WishlistItemCreateWithoutWishlistInput>, Enumerable<WishlistItemUncheckedCreateWithoutWishlistInput>>
    connectOrCreate?: Enumerable<WishlistItemCreateOrConnectWithoutWishlistInput>
    createMany?: WishlistItemCreateManyWishlistInputEnvelope
    connect?: Enumerable<WishlistItemWhereUniqueInput>
  }

  export type WishlistItemUpdateManyWithoutWishlistNestedInput = {
    create?: XOR<Enumerable<WishlistItemCreateWithoutWishlistInput>, Enumerable<WishlistItemUncheckedCreateWithoutWishlistInput>>
    connectOrCreate?: Enumerable<WishlistItemCreateOrConnectWithoutWishlistInput>
    upsert?: Enumerable<WishlistItemUpsertWithWhereUniqueWithoutWishlistInput>
    createMany?: WishlistItemCreateManyWishlistInputEnvelope
    set?: Enumerable<WishlistItemWhereUniqueInput>
    disconnect?: Enumerable<WishlistItemWhereUniqueInput>
    delete?: Enumerable<WishlistItemWhereUniqueInput>
    connect?: Enumerable<WishlistItemWhereUniqueInput>
    update?: Enumerable<WishlistItemUpdateWithWhereUniqueWithoutWishlistInput>
    updateMany?: Enumerable<WishlistItemUpdateManyWithWhereWithoutWishlistInput>
    deleteMany?: Enumerable<WishlistItemScalarWhereInput>
  }

  export type UserUpdateOneRequiredWithoutWishlistNestedInput = {
    create?: XOR<UserCreateWithoutWishlistInput, UserUncheckedCreateWithoutWishlistInput>
    connectOrCreate?: UserCreateOrConnectWithoutWishlistInput
    upsert?: UserUpsertWithoutWishlistInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutWishlistInput, UserUncheckedUpdateWithoutWishlistInput>
  }

  export type WishlistItemUncheckedUpdateManyWithoutWishlistNestedInput = {
    create?: XOR<Enumerable<WishlistItemCreateWithoutWishlistInput>, Enumerable<WishlistItemUncheckedCreateWithoutWishlistInput>>
    connectOrCreate?: Enumerable<WishlistItemCreateOrConnectWithoutWishlistInput>
    upsert?: Enumerable<WishlistItemUpsertWithWhereUniqueWithoutWishlistInput>
    createMany?: WishlistItemCreateManyWishlistInputEnvelope
    set?: Enumerable<WishlistItemWhereUniqueInput>
    disconnect?: Enumerable<WishlistItemWhereUniqueInput>
    delete?: Enumerable<WishlistItemWhereUniqueInput>
    connect?: Enumerable<WishlistItemWhereUniqueInput>
    update?: Enumerable<WishlistItemUpdateWithWhereUniqueWithoutWishlistInput>
    updateMany?: Enumerable<WishlistItemUpdateManyWithWhereWithoutWishlistInput>
    deleteMany?: Enumerable<WishlistItemScalarWhereInput>
  }

  export type WishlistCreateNestedOneWithoutItemsInput = {
    create?: XOR<WishlistCreateWithoutItemsInput, WishlistUncheckedCreateWithoutItemsInput>
    connectOrCreate?: WishlistCreateOrConnectWithoutItemsInput
    connect?: WishlistWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutWishlistItemInput = {
    create?: XOR<ProductCreateWithoutWishlistItemInput, ProductUncheckedCreateWithoutWishlistItemInput>
    connectOrCreate?: ProductCreateOrConnectWithoutWishlistItemInput
    connect?: ProductWhereUniqueInput
  }

  export type WishlistUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<WishlistCreateWithoutItemsInput, WishlistUncheckedCreateWithoutItemsInput>
    connectOrCreate?: WishlistCreateOrConnectWithoutItemsInput
    upsert?: WishlistUpsertWithoutItemsInput
    connect?: WishlistWhereUniqueInput
    update?: XOR<WishlistUpdateWithoutItemsInput, WishlistUncheckedUpdateWithoutItemsInput>
  }

  export type ProductUpdateOneRequiredWithoutWishlistItemNestedInput = {
    create?: XOR<ProductCreateWithoutWishlistItemInput, ProductUncheckedCreateWithoutWishlistItemInput>
    connectOrCreate?: ProductCreateOrConnectWithoutWishlistItemInput
    upsert?: ProductUpsertWithoutWishlistItemInput
    connect?: ProductWhereUniqueInput
    update?: XOR<ProductUpdateWithoutWishlistItemInput, ProductUncheckedUpdateWithoutWishlistItemInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type UserCreateWithoutRolesInput = {
    username: string
    email: string
    mobile: string
    token?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userProduct?: ProductCreateNestedManyWithoutUserInput
    userAddress?: UserAddressCreateNestedManyWithoutUserInput
    addCart?: CartCreateNestedManyWithoutUserInput
    wishlist?: WishlistCreateNestedManyWithoutUserInput
    loginRequests?: UserLoginRequestCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewCreateNestedManyWithoutUserInput
    order?: OrderCreateNestedManyWithoutUserInput
    userSearchItems?: SearchItemsCreateNestedManyWithoutUserInput
    password?: UserPasswordCreateNestedManyWithoutUserInput
    gender: GenderCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRolesInput = {
    id?: number
    username: string
    email: string
    mobile: string
    token?: string | null
    genderId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userProduct?: ProductUncheckedCreateNestedManyWithoutUserInput
    userAddress?: UserAddressUncheckedCreateNestedManyWithoutUserInput
    addCart?: CartUncheckedCreateNestedManyWithoutUserInput
    wishlist?: WishlistUncheckedCreateNestedManyWithoutUserInput
    loginRequests?: UserLoginRequestUncheckedCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewUncheckedCreateNestedManyWithoutUserInput
    order?: OrderUncheckedCreateNestedManyWithoutUserInput
    userSearchItems?: SearchItemsUncheckedCreateNestedManyWithoutUserInput
    password?: UserPasswordUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRolesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
  }

  export type UserCreateManyRolesInputEnvelope = {
    data: Enumerable<UserCreateManyRolesInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutRolesInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutRolesInput, UserUncheckedUpdateWithoutRolesInput>
    create: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
  }

  export type UserUpdateWithWhereUniqueWithoutRolesInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutRolesInput, UserUncheckedUpdateWithoutRolesInput>
  }

  export type UserUpdateManyWithWhereWithoutRolesInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutUserInput>
  }

  export type UserScalarWhereInput = {
    AND?: Enumerable<UserScalarWhereInput>
    OR?: Enumerable<UserScalarWhereInput>
    NOT?: Enumerable<UserScalarWhereInput>
    id?: IntFilter | number
    username?: StringFilter | string
    email?: StringFilter | string
    mobile?: StringFilter | string
    token?: StringNullableFilter | string | null
    roleId?: IntFilter | number
    genderId?: IntFilter | number
    isActive?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type GenderCreateWithoutProductCategoryInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user?: UserCreateNestedManyWithoutGenderInput
  }

  export type GenderUncheckedCreateWithoutProductCategoryInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user?: UserUncheckedCreateNestedManyWithoutGenderInput
  }

  export type GenderCreateOrConnectWithoutProductCategoryInput = {
    where: GenderWhereUniqueInput
    create: XOR<GenderCreateWithoutProductCategoryInput, GenderUncheckedCreateWithoutProductCategoryInput>
  }

  export type ProductTypeCreateWithoutProductCategoryInput = {
    itemsName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sizes?: ProductTypeSizeCreateNestedManyWithoutProductTypeInput
    product?: ProductCreateNestedManyWithoutProductTypeInput
  }

  export type ProductTypeUncheckedCreateWithoutProductCategoryInput = {
    id?: number
    itemsName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sizes?: ProductTypeSizeUncheckedCreateNestedManyWithoutProductTypeInput
    product?: ProductUncheckedCreateNestedManyWithoutProductTypeInput
  }

  export type ProductTypeCreateOrConnectWithoutProductCategoryInput = {
    where: ProductTypeWhereUniqueInput
    create: XOR<ProductTypeCreateWithoutProductCategoryInput, ProductTypeUncheckedCreateWithoutProductCategoryInput>
  }

  export type ProductTypeCreateManyProductCategoryInputEnvelope = {
    data: Enumerable<ProductTypeCreateManyProductCategoryInput>
    skipDuplicates?: boolean
  }

  export type GenderUpsertWithoutProductCategoryInput = {
    update: XOR<GenderUpdateWithoutProductCategoryInput, GenderUncheckedUpdateWithoutProductCategoryInput>
    create: XOR<GenderCreateWithoutProductCategoryInput, GenderUncheckedCreateWithoutProductCategoryInput>
  }

  export type GenderUpdateWithoutProductCategoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateManyWithoutGenderNestedInput
  }

  export type GenderUncheckedUpdateWithoutProductCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUncheckedUpdateManyWithoutGenderNestedInput
  }

  export type ProductTypeUpsertWithWhereUniqueWithoutProductCategoryInput = {
    where: ProductTypeWhereUniqueInput
    update: XOR<ProductTypeUpdateWithoutProductCategoryInput, ProductTypeUncheckedUpdateWithoutProductCategoryInput>
    create: XOR<ProductTypeCreateWithoutProductCategoryInput, ProductTypeUncheckedCreateWithoutProductCategoryInput>
  }

  export type ProductTypeUpdateWithWhereUniqueWithoutProductCategoryInput = {
    where: ProductTypeWhereUniqueInput
    data: XOR<ProductTypeUpdateWithoutProductCategoryInput, ProductTypeUncheckedUpdateWithoutProductCategoryInput>
  }

  export type ProductTypeUpdateManyWithWhereWithoutProductCategoryInput = {
    where: ProductTypeScalarWhereInput
    data: XOR<ProductTypeUpdateManyMutationInput, ProductTypeUncheckedUpdateManyWithoutProductTypeInput>
  }

  export type ProductTypeScalarWhereInput = {
    AND?: Enumerable<ProductTypeScalarWhereInput>
    OR?: Enumerable<ProductTypeScalarWhereInput>
    NOT?: Enumerable<ProductTypeScalarWhereInput>
    id?: IntFilter | number
    itemsName?: StringFilter | string
    productCategoryId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type ProductCategoryCreateWithoutProductTypeInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    gender: GenderCreateNestedOneWithoutProductCategoryInput
  }

  export type ProductCategoryUncheckedCreateWithoutProductTypeInput = {
    id?: number
    name: string
    genderId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ProductCategoryCreateOrConnectWithoutProductTypeInput = {
    where: ProductCategoryWhereUniqueInput
    create: XOR<ProductCategoryCreateWithoutProductTypeInput, ProductCategoryUncheckedCreateWithoutProductTypeInput>
  }

  export type ProductTypeSizeCreateWithoutProductTypeInput = {
    size: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    aviableSizes?: ProductAviableSizesCreateNestedManyWithoutProductTypeSizeInput
  }

  export type ProductTypeSizeUncheckedCreateWithoutProductTypeInput = {
    id?: number
    size: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    aviableSizes?: ProductAviableSizesUncheckedCreateNestedManyWithoutProductTypeSizeInput
  }

  export type ProductTypeSizeCreateOrConnectWithoutProductTypeInput = {
    where: ProductTypeSizeWhereUniqueInput
    create: XOR<ProductTypeSizeCreateWithoutProductTypeInput, ProductTypeSizeUncheckedCreateWithoutProductTypeInput>
  }

  export type ProductTypeSizeCreateManyProductTypeInputEnvelope = {
    data: Enumerable<ProductTypeSizeCreateManyProductTypeInput>
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutProductTypeInput = {
    syncId: number
    title: string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    isActive?: boolean
    color?: ProductColorCreateNestedManyWithoutProductInput
    offer?: OfferCreateNestedManyWithoutProductInput
    seasonalDresses?: SeasonalDressesCreateNestedManyWithoutProductInput
    user?: UserCreateNestedOneWithoutUserProductInput
    priceHistory?: PriceHistoryCreateNestedManyWithoutProductInput
    commonDescription?: CommonDescriptionCreateNestedManyWithoutProductInput
    delivery?: DeleveryPeriodCreateNestedManyWithoutProductInput
    returns?: ReturnedProductCreateNestedManyWithoutProductInput
    cart?: CartCreateNestedManyWithoutProductInput
    wishlistItem?: WishlistItemCreateNestedManyWithoutProductInput
    productReviews?: ProductReviewCreateNestedManyWithoutProductInput
    order?: OrderCreateNestedManyWithoutProductInput
    productOwner?: ProductOwnerCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProductTypeInput = {
    id?: number
    syncId: number
    title: string
    price: number
    productOwnerId?: number | null
    userId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    isActive?: boolean
    color?: ProductColorUncheckedCreateNestedManyWithoutProductInput
    offer?: OfferUncheckedCreateNestedManyWithoutProductInput
    seasonalDresses?: SeasonalDressesUncheckedCreateNestedManyWithoutProductInput
    priceHistory?: PriceHistoryUncheckedCreateNestedManyWithoutProductInput
    commonDescription?: CommonDescriptionUncheckedCreateNestedManyWithoutProductInput
    delivery?: DeleveryPeriodUncheckedCreateNestedManyWithoutProductInput
    returns?: ReturnedProductUncheckedCreateNestedManyWithoutProductInput
    cart?: CartUncheckedCreateNestedManyWithoutProductInput
    wishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutProductInput
    productReviews?: ProductReviewUncheckedCreateNestedManyWithoutProductInput
    order?: OrderUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProductTypeInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProductTypeInput, ProductUncheckedCreateWithoutProductTypeInput>
  }

  export type ProductCreateManyProductTypeInputEnvelope = {
    data: Enumerable<ProductCreateManyProductTypeInput>
    skipDuplicates?: boolean
  }

  export type ProductCategoryUpsertWithoutProductTypeInput = {
    update: XOR<ProductCategoryUpdateWithoutProductTypeInput, ProductCategoryUncheckedUpdateWithoutProductTypeInput>
    create: XOR<ProductCategoryCreateWithoutProductTypeInput, ProductCategoryUncheckedCreateWithoutProductTypeInput>
  }

  export type ProductCategoryUpdateWithoutProductTypeInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: GenderUpdateOneRequiredWithoutProductCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateWithoutProductTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    genderId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductTypeSizeUpsertWithWhereUniqueWithoutProductTypeInput = {
    where: ProductTypeSizeWhereUniqueInput
    update: XOR<ProductTypeSizeUpdateWithoutProductTypeInput, ProductTypeSizeUncheckedUpdateWithoutProductTypeInput>
    create: XOR<ProductTypeSizeCreateWithoutProductTypeInput, ProductTypeSizeUncheckedCreateWithoutProductTypeInput>
  }

  export type ProductTypeSizeUpdateWithWhereUniqueWithoutProductTypeInput = {
    where: ProductTypeSizeWhereUniqueInput
    data: XOR<ProductTypeSizeUpdateWithoutProductTypeInput, ProductTypeSizeUncheckedUpdateWithoutProductTypeInput>
  }

  export type ProductTypeSizeUpdateManyWithWhereWithoutProductTypeInput = {
    where: ProductTypeSizeScalarWhereInput
    data: XOR<ProductTypeSizeUpdateManyMutationInput, ProductTypeSizeUncheckedUpdateManyWithoutSizesInput>
  }

  export type ProductTypeSizeScalarWhereInput = {
    AND?: Enumerable<ProductTypeSizeScalarWhereInput>
    OR?: Enumerable<ProductTypeSizeScalarWhereInput>
    NOT?: Enumerable<ProductTypeSizeScalarWhereInput>
    id?: IntFilter | number
    size?: StringFilter | string
    ietmsId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type ProductUpsertWithWhereUniqueWithoutProductTypeInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutProductTypeInput, ProductUncheckedUpdateWithoutProductTypeInput>
    create: XOR<ProductCreateWithoutProductTypeInput, ProductUncheckedCreateWithoutProductTypeInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutProductTypeInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutProductTypeInput, ProductUncheckedUpdateWithoutProductTypeInput>
  }

  export type ProductUpdateManyWithWhereWithoutProductTypeInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductScalarWhereInput = {
    AND?: Enumerable<ProductScalarWhereInput>
    OR?: Enumerable<ProductScalarWhereInput>
    NOT?: Enumerable<ProductScalarWhereInput>
    id?: IntFilter | number
    syncId?: IntFilter | number
    title?: StringFilter | string
    price?: FloatFilter | number
    productTypeId?: IntFilter | number
    productOwnerId?: IntNullableFilter | number | null
    userId?: IntNullableFilter | number | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    isActive?: BoolFilter | boolean
  }

  export type ProductAviableSizesCreateWithoutProductTypeSizeInput = {
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    history?: QuantityHistoryCreateNestedManyWithoutProductAviableSizesInput
    productColor: ProductColorCreateNestedOneWithoutColorSizeInput
  }

  export type ProductAviableSizesUncheckedCreateWithoutProductTypeSizeInput = {
    id?: number
    quantity: number
    productColorId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    history?: QuantityHistoryUncheckedCreateNestedManyWithoutProductAviableSizesInput
  }

  export type ProductAviableSizesCreateOrConnectWithoutProductTypeSizeInput = {
    where: ProductAviableSizesWhereUniqueInput
    create: XOR<ProductAviableSizesCreateWithoutProductTypeSizeInput, ProductAviableSizesUncheckedCreateWithoutProductTypeSizeInput>
  }

  export type ProductAviableSizesCreateManyProductTypeSizeInputEnvelope = {
    data: Enumerable<ProductAviableSizesCreateManyProductTypeSizeInput>
    skipDuplicates?: boolean
  }

  export type ProductTypeCreateWithoutSizesInput = {
    itemsName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    ProductCategory: ProductCategoryCreateNestedOneWithoutProductTypeInput
    product?: ProductCreateNestedManyWithoutProductTypeInput
  }

  export type ProductTypeUncheckedCreateWithoutSizesInput = {
    id?: number
    itemsName: string
    productCategoryId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    product?: ProductUncheckedCreateNestedManyWithoutProductTypeInput
  }

  export type ProductTypeCreateOrConnectWithoutSizesInput = {
    where: ProductTypeWhereUniqueInput
    create: XOR<ProductTypeCreateWithoutSizesInput, ProductTypeUncheckedCreateWithoutSizesInput>
  }

  export type ProductAviableSizesUpsertWithWhereUniqueWithoutProductTypeSizeInput = {
    where: ProductAviableSizesWhereUniqueInput
    update: XOR<ProductAviableSizesUpdateWithoutProductTypeSizeInput, ProductAviableSizesUncheckedUpdateWithoutProductTypeSizeInput>
    create: XOR<ProductAviableSizesCreateWithoutProductTypeSizeInput, ProductAviableSizesUncheckedCreateWithoutProductTypeSizeInput>
  }

  export type ProductAviableSizesUpdateWithWhereUniqueWithoutProductTypeSizeInput = {
    where: ProductAviableSizesWhereUniqueInput
    data: XOR<ProductAviableSizesUpdateWithoutProductTypeSizeInput, ProductAviableSizesUncheckedUpdateWithoutProductTypeSizeInput>
  }

  export type ProductAviableSizesUpdateManyWithWhereWithoutProductTypeSizeInput = {
    where: ProductAviableSizesScalarWhereInput
    data: XOR<ProductAviableSizesUpdateManyMutationInput, ProductAviableSizesUncheckedUpdateManyWithoutAviableSizesInput>
  }

  export type ProductAviableSizesScalarWhereInput = {
    AND?: Enumerable<ProductAviableSizesScalarWhereInput>
    OR?: Enumerable<ProductAviableSizesScalarWhereInput>
    NOT?: Enumerable<ProductAviableSizesScalarWhereInput>
    id?: IntFilter | number
    quantity?: IntFilter | number
    productColorId?: IntFilter | number
    productTypeSizeId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type ProductTypeUpsertWithoutSizesInput = {
    update: XOR<ProductTypeUpdateWithoutSizesInput, ProductTypeUncheckedUpdateWithoutSizesInput>
    create: XOR<ProductTypeCreateWithoutSizesInput, ProductTypeUncheckedCreateWithoutSizesInput>
  }

  export type ProductTypeUpdateWithoutSizesInput = {
    itemsName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ProductCategory?: ProductCategoryUpdateOneRequiredWithoutProductTypeNestedInput
    product?: ProductUpdateManyWithoutProductTypeNestedInput
  }

  export type ProductTypeUncheckedUpdateWithoutSizesInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemsName?: StringFieldUpdateOperationsInput | string
    productCategoryId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    product?: ProductUncheckedUpdateManyWithoutProductTypeNestedInput
  }

  export type ProductCategoryCreateWithoutGenderInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    productType?: ProductTypeCreateNestedManyWithoutProductCategoryInput
  }

  export type ProductCategoryUncheckedCreateWithoutGenderInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    productType?: ProductTypeUncheckedCreateNestedManyWithoutProductCategoryInput
  }

  export type ProductCategoryCreateOrConnectWithoutGenderInput = {
    where: ProductCategoryWhereUniqueInput
    create: XOR<ProductCategoryCreateWithoutGenderInput, ProductCategoryUncheckedCreateWithoutGenderInput>
  }

  export type ProductCategoryCreateManyGenderInputEnvelope = {
    data: Enumerable<ProductCategoryCreateManyGenderInput>
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutGenderInput = {
    username: string
    email: string
    mobile: string
    token?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userProduct?: ProductCreateNestedManyWithoutUserInput
    userAddress?: UserAddressCreateNestedManyWithoutUserInput
    addCart?: CartCreateNestedManyWithoutUserInput
    wishlist?: WishlistCreateNestedManyWithoutUserInput
    loginRequests?: UserLoginRequestCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewCreateNestedManyWithoutUserInput
    order?: OrderCreateNestedManyWithoutUserInput
    userSearchItems?: SearchItemsCreateNestedManyWithoutUserInput
    password?: UserPasswordCreateNestedManyWithoutUserInput
    roles?: RolesCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutGenderInput = {
    id?: number
    username: string
    email: string
    mobile: string
    token?: string | null
    roleId?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userProduct?: ProductUncheckedCreateNestedManyWithoutUserInput
    userAddress?: UserAddressUncheckedCreateNestedManyWithoutUserInput
    addCart?: CartUncheckedCreateNestedManyWithoutUserInput
    wishlist?: WishlistUncheckedCreateNestedManyWithoutUserInput
    loginRequests?: UserLoginRequestUncheckedCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewUncheckedCreateNestedManyWithoutUserInput
    order?: OrderUncheckedCreateNestedManyWithoutUserInput
    userSearchItems?: SearchItemsUncheckedCreateNestedManyWithoutUserInput
    password?: UserPasswordUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutGenderInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGenderInput, UserUncheckedCreateWithoutGenderInput>
  }

  export type UserCreateManyGenderInputEnvelope = {
    data: Enumerable<UserCreateManyGenderInput>
    skipDuplicates?: boolean
  }

  export type ProductCategoryUpsertWithWhereUniqueWithoutGenderInput = {
    where: ProductCategoryWhereUniqueInput
    update: XOR<ProductCategoryUpdateWithoutGenderInput, ProductCategoryUncheckedUpdateWithoutGenderInput>
    create: XOR<ProductCategoryCreateWithoutGenderInput, ProductCategoryUncheckedCreateWithoutGenderInput>
  }

  export type ProductCategoryUpdateWithWhereUniqueWithoutGenderInput = {
    where: ProductCategoryWhereUniqueInput
    data: XOR<ProductCategoryUpdateWithoutGenderInput, ProductCategoryUncheckedUpdateWithoutGenderInput>
  }

  export type ProductCategoryUpdateManyWithWhereWithoutGenderInput = {
    where: ProductCategoryScalarWhereInput
    data: XOR<ProductCategoryUpdateManyMutationInput, ProductCategoryUncheckedUpdateManyWithoutProductCategoryInput>
  }

  export type ProductCategoryScalarWhereInput = {
    AND?: Enumerable<ProductCategoryScalarWhereInput>
    OR?: Enumerable<ProductCategoryScalarWhereInput>
    NOT?: Enumerable<ProductCategoryScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    genderId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type UserUpsertWithWhereUniqueWithoutGenderInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutGenderInput, UserUncheckedUpdateWithoutGenderInput>
    create: XOR<UserCreateWithoutGenderInput, UserUncheckedCreateWithoutGenderInput>
  }

  export type UserUpdateWithWhereUniqueWithoutGenderInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutGenderInput, UserUncheckedUpdateWithoutGenderInput>
  }

  export type UserUpdateManyWithWhereWithoutGenderInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutUserInput>
  }

  export type StateCreateWithoutCountryInput = {
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    district?: AddressCreateNestedManyWithoutStateInput
  }

  export type StateUncheckedCreateWithoutCountryInput = {
    id?: number
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    district?: AddressUncheckedCreateNestedManyWithoutStateInput
  }

  export type StateCreateOrConnectWithoutCountryInput = {
    where: StateWhereUniqueInput
    create: XOR<StateCreateWithoutCountryInput, StateUncheckedCreateWithoutCountryInput>
  }

  export type StateCreateManyCountryInputEnvelope = {
    data: Enumerable<StateCreateManyCountryInput>
    skipDuplicates?: boolean
  }

  export type StateUpsertWithWhereUniqueWithoutCountryInput = {
    where: StateWhereUniqueInput
    update: XOR<StateUpdateWithoutCountryInput, StateUncheckedUpdateWithoutCountryInput>
    create: XOR<StateCreateWithoutCountryInput, StateUncheckedCreateWithoutCountryInput>
  }

  export type StateUpdateWithWhereUniqueWithoutCountryInput = {
    where: StateWhereUniqueInput
    data: XOR<StateUpdateWithoutCountryInput, StateUncheckedUpdateWithoutCountryInput>
  }

  export type StateUpdateManyWithWhereWithoutCountryInput = {
    where: StateScalarWhereInput
    data: XOR<StateUpdateManyMutationInput, StateUncheckedUpdateManyWithoutStateInput>
  }

  export type StateScalarWhereInput = {
    AND?: Enumerable<StateScalarWhereInput>
    OR?: Enumerable<StateScalarWhereInput>
    NOT?: Enumerable<StateScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    countryId?: IntFilter | number
    isActive?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type CountryCreateWithoutStateInput = {
    name: string
    timezoneOffset: number
    dialCode: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type CountryUncheckedCreateWithoutStateInput = {
    id?: number
    name: string
    timezoneOffset: number
    dialCode: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type CountryCreateOrConnectWithoutStateInput = {
    where: CountryWhereUniqueInput
    create: XOR<CountryCreateWithoutStateInput, CountryUncheckedCreateWithoutStateInput>
  }

  export type AddressCreateWithoutStateInput = {
    doorNumber: string
    streetName: string
    pinCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userAddress?: UserAddressCreateNestedManyWithoutAddressInput
  }

  export type AddressUncheckedCreateWithoutStateInput = {
    id?: number
    doorNumber: string
    streetName: string
    pinCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userAddress?: UserAddressUncheckedCreateNestedManyWithoutAddressInput
  }

  export type AddressCreateOrConnectWithoutStateInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutStateInput, AddressUncheckedCreateWithoutStateInput>
  }

  export type AddressCreateManyStateInputEnvelope = {
    data: Enumerable<AddressCreateManyStateInput>
    skipDuplicates?: boolean
  }

  export type CountryUpsertWithoutStateInput = {
    update: XOR<CountryUpdateWithoutStateInput, CountryUncheckedUpdateWithoutStateInput>
    create: XOR<CountryCreateWithoutStateInput, CountryUncheckedCreateWithoutStateInput>
  }

  export type CountryUpdateWithoutStateInput = {
    name?: StringFieldUpdateOperationsInput | string
    timezoneOffset?: IntFieldUpdateOperationsInput | number
    dialCode?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CountryUncheckedUpdateWithoutStateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    timezoneOffset?: IntFieldUpdateOperationsInput | number
    dialCode?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AddressUpsertWithWhereUniqueWithoutStateInput = {
    where: AddressWhereUniqueInput
    update: XOR<AddressUpdateWithoutStateInput, AddressUncheckedUpdateWithoutStateInput>
    create: XOR<AddressCreateWithoutStateInput, AddressUncheckedCreateWithoutStateInput>
  }

  export type AddressUpdateWithWhereUniqueWithoutStateInput = {
    where: AddressWhereUniqueInput
    data: XOR<AddressUpdateWithoutStateInput, AddressUncheckedUpdateWithoutStateInput>
  }

  export type AddressUpdateManyWithWhereWithoutStateInput = {
    where: AddressScalarWhereInput
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyWithoutDistrictInput>
  }

  export type AddressScalarWhereInput = {
    AND?: Enumerable<AddressScalarWhereInput>
    OR?: Enumerable<AddressScalarWhereInput>
    NOT?: Enumerable<AddressScalarWhereInput>
    id?: IntFilter | number
    doorNumber?: StringFilter | string
    streetName?: StringFilter | string
    pinCode?: StringFilter | string
    stateId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type StateCreateWithoutDistrictInput = {
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    country: CountryCreateNestedOneWithoutStateInput
  }

  export type StateUncheckedCreateWithoutDistrictInput = {
    id?: number
    name: string
    countryId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type StateCreateOrConnectWithoutDistrictInput = {
    where: StateWhereUniqueInput
    create: XOR<StateCreateWithoutDistrictInput, StateUncheckedCreateWithoutDistrictInput>
  }

  export type UserAddressCreateWithoutAddressInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutUserAddressInput
  }

  export type UserAddressUncheckedCreateWithoutAddressInput = {
    id?: number
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UserAddressCreateOrConnectWithoutAddressInput = {
    where: UserAddressWhereUniqueInput
    create: XOR<UserAddressCreateWithoutAddressInput, UserAddressUncheckedCreateWithoutAddressInput>
  }

  export type UserAddressCreateManyAddressInputEnvelope = {
    data: Enumerable<UserAddressCreateManyAddressInput>
    skipDuplicates?: boolean
  }

  export type StateUpsertWithoutDistrictInput = {
    update: XOR<StateUpdateWithoutDistrictInput, StateUncheckedUpdateWithoutDistrictInput>
    create: XOR<StateCreateWithoutDistrictInput, StateUncheckedCreateWithoutDistrictInput>
  }

  export type StateUpdateWithoutDistrictInput = {
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: CountryUpdateOneRequiredWithoutStateNestedInput
  }

  export type StateUncheckedUpdateWithoutDistrictInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    countryId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserAddressUpsertWithWhereUniqueWithoutAddressInput = {
    where: UserAddressWhereUniqueInput
    update: XOR<UserAddressUpdateWithoutAddressInput, UserAddressUncheckedUpdateWithoutAddressInput>
    create: XOR<UserAddressCreateWithoutAddressInput, UserAddressUncheckedCreateWithoutAddressInput>
  }

  export type UserAddressUpdateWithWhereUniqueWithoutAddressInput = {
    where: UserAddressWhereUniqueInput
    data: XOR<UserAddressUpdateWithoutAddressInput, UserAddressUncheckedUpdateWithoutAddressInput>
  }

  export type UserAddressUpdateManyWithWhereWithoutAddressInput = {
    where: UserAddressScalarWhereInput
    data: XOR<UserAddressUpdateManyMutationInput, UserAddressUncheckedUpdateManyWithoutUserAddressInput>
  }

  export type UserAddressScalarWhereInput = {
    AND?: Enumerable<UserAddressScalarWhereInput>
    OR?: Enumerable<UserAddressScalarWhereInput>
    NOT?: Enumerable<UserAddressScalarWhereInput>
    id?: IntFilter | number
    addressId?: IntFilter | number
    userId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type AddressCreateWithoutUserAddressInput = {
    doorNumber: string
    streetName: string
    pinCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    state: StateCreateNestedOneWithoutDistrictInput
  }

  export type AddressUncheckedCreateWithoutUserAddressInput = {
    id?: number
    doorNumber: string
    streetName: string
    pinCode: string
    stateId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AddressCreateOrConnectWithoutUserAddressInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutUserAddressInput, AddressUncheckedCreateWithoutUserAddressInput>
  }

  export type UserCreateWithoutUserAddressInput = {
    username: string
    email: string
    mobile: string
    token?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userProduct?: ProductCreateNestedManyWithoutUserInput
    addCart?: CartCreateNestedManyWithoutUserInput
    wishlist?: WishlistCreateNestedManyWithoutUserInput
    loginRequests?: UserLoginRequestCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewCreateNestedManyWithoutUserInput
    order?: OrderCreateNestedManyWithoutUserInput
    userSearchItems?: SearchItemsCreateNestedManyWithoutUserInput
    password?: UserPasswordCreateNestedManyWithoutUserInput
    roles?: RolesCreateNestedOneWithoutUserInput
    gender: GenderCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserAddressInput = {
    id?: number
    username: string
    email: string
    mobile: string
    token?: string | null
    roleId?: number
    genderId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userProduct?: ProductUncheckedCreateNestedManyWithoutUserInput
    addCart?: CartUncheckedCreateNestedManyWithoutUserInput
    wishlist?: WishlistUncheckedCreateNestedManyWithoutUserInput
    loginRequests?: UserLoginRequestUncheckedCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewUncheckedCreateNestedManyWithoutUserInput
    order?: OrderUncheckedCreateNestedManyWithoutUserInput
    userSearchItems?: SearchItemsUncheckedCreateNestedManyWithoutUserInput
    password?: UserPasswordUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserAddressInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserAddressInput, UserUncheckedCreateWithoutUserAddressInput>
  }

  export type AddressUpsertWithoutUserAddressInput = {
    update: XOR<AddressUpdateWithoutUserAddressInput, AddressUncheckedUpdateWithoutUserAddressInput>
    create: XOR<AddressCreateWithoutUserAddressInput, AddressUncheckedCreateWithoutUserAddressInput>
  }

  export type AddressUpdateWithoutUserAddressInput = {
    doorNumber?: StringFieldUpdateOperationsInput | string
    streetName?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    state?: StateUpdateOneRequiredWithoutDistrictNestedInput
  }

  export type AddressUncheckedUpdateWithoutUserAddressInput = {
    id?: IntFieldUpdateOperationsInput | number
    doorNumber?: StringFieldUpdateOperationsInput | string
    streetName?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    stateId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUpsertWithoutUserAddressInput = {
    update: XOR<UserUpdateWithoutUserAddressInput, UserUncheckedUpdateWithoutUserAddressInput>
    create: XOR<UserCreateWithoutUserAddressInput, UserUncheckedCreateWithoutUserAddressInput>
  }

  export type UserUpdateWithoutUserAddressInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userProduct?: ProductUpdateManyWithoutUserNestedInput
    addCart?: CartUpdateManyWithoutUserNestedInput
    wishlist?: WishlistUpdateManyWithoutUserNestedInput
    loginRequests?: UserLoginRequestUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUpdateManyWithoutUserNestedInput
    order?: OrderUpdateManyWithoutUserNestedInput
    userSearchItems?: SearchItemsUpdateManyWithoutUserNestedInput
    password?: UserPasswordUpdateManyWithoutUserNestedInput
    roles?: RolesUpdateOneRequiredWithoutUserNestedInput
    gender?: GenderUpdateOneRequiredWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserAddressInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: IntFieldUpdateOperationsInput | number
    genderId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userProduct?: ProductUncheckedUpdateManyWithoutUserNestedInput
    addCart?: CartUncheckedUpdateManyWithoutUserNestedInput
    wishlist?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    loginRequests?: UserLoginRequestUncheckedUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUncheckedUpdateManyWithoutUserNestedInput
    order?: OrderUncheckedUpdateManyWithoutUserNestedInput
    userSearchItems?: SearchItemsUncheckedUpdateManyWithoutUserNestedInput
    password?: UserPasswordUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProductCreateWithoutUserInput = {
    syncId: number
    title: string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    isActive?: boolean
    color?: ProductColorCreateNestedManyWithoutProductInput
    offer?: OfferCreateNestedManyWithoutProductInput
    seasonalDresses?: SeasonalDressesCreateNestedManyWithoutProductInput
    productType: ProductTypeCreateNestedOneWithoutProductInput
    priceHistory?: PriceHistoryCreateNestedManyWithoutProductInput
    commonDescription?: CommonDescriptionCreateNestedManyWithoutProductInput
    delivery?: DeleveryPeriodCreateNestedManyWithoutProductInput
    returns?: ReturnedProductCreateNestedManyWithoutProductInput
    cart?: CartCreateNestedManyWithoutProductInput
    wishlistItem?: WishlistItemCreateNestedManyWithoutProductInput
    productReviews?: ProductReviewCreateNestedManyWithoutProductInput
    order?: OrderCreateNestedManyWithoutProductInput
    productOwner?: ProductOwnerCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutUserInput = {
    id?: number
    syncId: number
    title: string
    price: number
    productTypeId: number
    productOwnerId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    isActive?: boolean
    color?: ProductColorUncheckedCreateNestedManyWithoutProductInput
    offer?: OfferUncheckedCreateNestedManyWithoutProductInput
    seasonalDresses?: SeasonalDressesUncheckedCreateNestedManyWithoutProductInput
    priceHistory?: PriceHistoryUncheckedCreateNestedManyWithoutProductInput
    commonDescription?: CommonDescriptionUncheckedCreateNestedManyWithoutProductInput
    delivery?: DeleveryPeriodUncheckedCreateNestedManyWithoutProductInput
    returns?: ReturnedProductUncheckedCreateNestedManyWithoutProductInput
    cart?: CartUncheckedCreateNestedManyWithoutProductInput
    wishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutProductInput
    productReviews?: ProductReviewUncheckedCreateNestedManyWithoutProductInput
    order?: OrderUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutUserInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutUserInput, ProductUncheckedCreateWithoutUserInput>
  }

  export type ProductCreateManyUserInputEnvelope = {
    data: Enumerable<ProductCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type UserAddressCreateWithoutUserInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    address: AddressCreateNestedOneWithoutUserAddressInput
  }

  export type UserAddressUncheckedCreateWithoutUserInput = {
    id?: number
    addressId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UserAddressCreateOrConnectWithoutUserInput = {
    where: UserAddressWhereUniqueInput
    create: XOR<UserAddressCreateWithoutUserInput, UserAddressUncheckedCreateWithoutUserInput>
  }

  export type UserAddressCreateManyUserInputEnvelope = {
    data: Enumerable<UserAddressCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type CartCreateWithoutUserInput = {
    isCheckedOut: boolean
    isRemoved: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    product: ProductCreateNestedOneWithoutCartInput
  }

  export type CartUncheckedCreateWithoutUserInput = {
    id?: number
    productId: number
    isCheckedOut: boolean
    isRemoved: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type CartCreateOrConnectWithoutUserInput = {
    where: CartWhereUniqueInput
    create: XOR<CartCreateWithoutUserInput, CartUncheckedCreateWithoutUserInput>
  }

  export type CartCreateManyUserInputEnvelope = {
    data: Enumerable<CartCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type WishlistCreateWithoutUserInput = {
    items?: WishlistItemCreateNestedManyWithoutWishlistInput
  }

  export type WishlistUncheckedCreateWithoutUserInput = {
    id?: number
    items?: WishlistItemUncheckedCreateNestedManyWithoutWishlistInput
  }

  export type WishlistCreateOrConnectWithoutUserInput = {
    where: WishlistWhereUniqueInput
    create: XOR<WishlistCreateWithoutUserInput, WishlistUncheckedCreateWithoutUserInput>
  }

  export type WishlistCreateManyUserInputEnvelope = {
    data: Enumerable<WishlistCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type UserLoginRequestCreateWithoutUserInput = {
    email: string
    mobile?: string | null
    otp: string
    isUsed?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UserLoginRequestUncheckedCreateWithoutUserInput = {
    id?: number
    email: string
    mobile?: string | null
    otp: string
    isUsed?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UserLoginRequestCreateOrConnectWithoutUserInput = {
    where: UserLoginRequestWhereUniqueInput
    create: XOR<UserLoginRequestCreateWithoutUserInput, UserLoginRequestUncheckedCreateWithoutUserInput>
  }

  export type UserLoginRequestCreateManyUserInputEnvelope = {
    data: Enumerable<UserLoginRequestCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type ProductReviewCreateWithoutUserInput = {
    review: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    product: ProductCreateNestedOneWithoutProductReviewsInput
  }

  export type ProductReviewUncheckedCreateWithoutUserInput = {
    id?: number
    productId: number
    review: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ProductReviewCreateOrConnectWithoutUserInput = {
    where: ProductReviewWhereUniqueInput
    create: XOR<ProductReviewCreateWithoutUserInput, ProductReviewUncheckedCreateWithoutUserInput>
  }

  export type ProductReviewCreateManyUserInputEnvelope = {
    data: Enumerable<ProductReviewCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutUserInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    product: ProductCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutUserInput = {
    id?: number
    productId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type OrderCreateOrConnectWithoutUserInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
  }

  export type OrderCreateManyUserInputEnvelope = {
    data: Enumerable<OrderCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type SearchItemsCreateWithoutUserInput = {
    searchName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type SearchItemsUncheckedCreateWithoutUserInput = {
    id?: number
    searchName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type SearchItemsCreateOrConnectWithoutUserInput = {
    where: SearchItemsWhereUniqueInput
    create: XOR<SearchItemsCreateWithoutUserInput, SearchItemsUncheckedCreateWithoutUserInput>
  }

  export type SearchItemsCreateManyUserInputEnvelope = {
    data: Enumerable<SearchItemsCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type UserPasswordCreateWithoutUserInput = {
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UserPasswordUncheckedCreateWithoutUserInput = {
    id?: number
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UserPasswordCreateOrConnectWithoutUserInput = {
    where: UserPasswordWhereUniqueInput
    create: XOR<UserPasswordCreateWithoutUserInput, UserPasswordUncheckedCreateWithoutUserInput>
  }

  export type UserPasswordCreateManyUserInputEnvelope = {
    data: Enumerable<UserPasswordCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type RolesCreateWithoutUserInput = {
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type RolesUncheckedCreateWithoutUserInput = {
    id?: number
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type RolesCreateOrConnectWithoutUserInput = {
    where: RolesWhereUniqueInput
    create: XOR<RolesCreateWithoutUserInput, RolesUncheckedCreateWithoutUserInput>
  }

  export type GenderCreateWithoutUserInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    productCategory?: ProductCategoryCreateNestedManyWithoutGenderInput
  }

  export type GenderUncheckedCreateWithoutUserInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    productCategory?: ProductCategoryUncheckedCreateNestedManyWithoutGenderInput
  }

  export type GenderCreateOrConnectWithoutUserInput = {
    where: GenderWhereUniqueInput
    create: XOR<GenderCreateWithoutUserInput, GenderUncheckedCreateWithoutUserInput>
  }

  export type ProductUpsertWithWhereUniqueWithoutUserInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutUserInput, ProductUncheckedUpdateWithoutUserInput>
    create: XOR<ProductCreateWithoutUserInput, ProductUncheckedCreateWithoutUserInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutUserInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutUserInput, ProductUncheckedUpdateWithoutUserInput>
  }

  export type ProductUpdateManyWithWhereWithoutUserInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutUserProductInput>
  }

  export type UserAddressUpsertWithWhereUniqueWithoutUserInput = {
    where: UserAddressWhereUniqueInput
    update: XOR<UserAddressUpdateWithoutUserInput, UserAddressUncheckedUpdateWithoutUserInput>
    create: XOR<UserAddressCreateWithoutUserInput, UserAddressUncheckedCreateWithoutUserInput>
  }

  export type UserAddressUpdateWithWhereUniqueWithoutUserInput = {
    where: UserAddressWhereUniqueInput
    data: XOR<UserAddressUpdateWithoutUserInput, UserAddressUncheckedUpdateWithoutUserInput>
  }

  export type UserAddressUpdateManyWithWhereWithoutUserInput = {
    where: UserAddressScalarWhereInput
    data: XOR<UserAddressUpdateManyMutationInput, UserAddressUncheckedUpdateManyWithoutUserAddressInput>
  }

  export type CartUpsertWithWhereUniqueWithoutUserInput = {
    where: CartWhereUniqueInput
    update: XOR<CartUpdateWithoutUserInput, CartUncheckedUpdateWithoutUserInput>
    create: XOR<CartCreateWithoutUserInput, CartUncheckedCreateWithoutUserInput>
  }

  export type CartUpdateWithWhereUniqueWithoutUserInput = {
    where: CartWhereUniqueInput
    data: XOR<CartUpdateWithoutUserInput, CartUncheckedUpdateWithoutUserInput>
  }

  export type CartUpdateManyWithWhereWithoutUserInput = {
    where: CartScalarWhereInput
    data: XOR<CartUpdateManyMutationInput, CartUncheckedUpdateManyWithoutAddCartInput>
  }

  export type CartScalarWhereInput = {
    AND?: Enumerable<CartScalarWhereInput>
    OR?: Enumerable<CartScalarWhereInput>
    NOT?: Enumerable<CartScalarWhereInput>
    id?: IntFilter | number
    userId?: IntFilter | number
    productId?: IntFilter | number
    isCheckedOut?: BoolFilter | boolean
    isRemoved?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type WishlistUpsertWithWhereUniqueWithoutUserInput = {
    where: WishlistWhereUniqueInput
    update: XOR<WishlistUpdateWithoutUserInput, WishlistUncheckedUpdateWithoutUserInput>
    create: XOR<WishlistCreateWithoutUserInput, WishlistUncheckedCreateWithoutUserInput>
  }

  export type WishlistUpdateWithWhereUniqueWithoutUserInput = {
    where: WishlistWhereUniqueInput
    data: XOR<WishlistUpdateWithoutUserInput, WishlistUncheckedUpdateWithoutUserInput>
  }

  export type WishlistUpdateManyWithWhereWithoutUserInput = {
    where: WishlistScalarWhereInput
    data: XOR<WishlistUpdateManyMutationInput, WishlistUncheckedUpdateManyWithoutWishlistInput>
  }

  export type WishlistScalarWhereInput = {
    AND?: Enumerable<WishlistScalarWhereInput>
    OR?: Enumerable<WishlistScalarWhereInput>
    NOT?: Enumerable<WishlistScalarWhereInput>
    id?: IntFilter | number
    userId?: IntFilter | number
  }

  export type UserLoginRequestUpsertWithWhereUniqueWithoutUserInput = {
    where: UserLoginRequestWhereUniqueInput
    update: XOR<UserLoginRequestUpdateWithoutUserInput, UserLoginRequestUncheckedUpdateWithoutUserInput>
    create: XOR<UserLoginRequestCreateWithoutUserInput, UserLoginRequestUncheckedCreateWithoutUserInput>
  }

  export type UserLoginRequestUpdateWithWhereUniqueWithoutUserInput = {
    where: UserLoginRequestWhereUniqueInput
    data: XOR<UserLoginRequestUpdateWithoutUserInput, UserLoginRequestUncheckedUpdateWithoutUserInput>
  }

  export type UserLoginRequestUpdateManyWithWhereWithoutUserInput = {
    where: UserLoginRequestScalarWhereInput
    data: XOR<UserLoginRequestUpdateManyMutationInput, UserLoginRequestUncheckedUpdateManyWithoutLoginRequestsInput>
  }

  export type UserLoginRequestScalarWhereInput = {
    AND?: Enumerable<UserLoginRequestScalarWhereInput>
    OR?: Enumerable<UserLoginRequestScalarWhereInput>
    NOT?: Enumerable<UserLoginRequestScalarWhereInput>
    id?: IntFilter | number
    userId?: IntFilter | number
    email?: StringFilter | string
    mobile?: StringNullableFilter | string | null
    otp?: StringFilter | string
    isUsed?: BoolFilter | boolean
    isActive?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type ProductReviewUpsertWithWhereUniqueWithoutUserInput = {
    where: ProductReviewWhereUniqueInput
    update: XOR<ProductReviewUpdateWithoutUserInput, ProductReviewUncheckedUpdateWithoutUserInput>
    create: XOR<ProductReviewCreateWithoutUserInput, ProductReviewUncheckedCreateWithoutUserInput>
  }

  export type ProductReviewUpdateWithWhereUniqueWithoutUserInput = {
    where: ProductReviewWhereUniqueInput
    data: XOR<ProductReviewUpdateWithoutUserInput, ProductReviewUncheckedUpdateWithoutUserInput>
  }

  export type ProductReviewUpdateManyWithWhereWithoutUserInput = {
    where: ProductReviewScalarWhereInput
    data: XOR<ProductReviewUpdateManyMutationInput, ProductReviewUncheckedUpdateManyWithoutProductReviewInput>
  }

  export type ProductReviewScalarWhereInput = {
    AND?: Enumerable<ProductReviewScalarWhereInput>
    OR?: Enumerable<ProductReviewScalarWhereInput>
    NOT?: Enumerable<ProductReviewScalarWhereInput>
    id?: IntFilter | number
    productId?: IntFilter | number
    userId?: IntFilter | number
    review?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type OrderUpsertWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutUserInput, OrderUncheckedUpdateWithoutUserInput>
    create: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutUserInput, OrderUncheckedUpdateWithoutUserInput>
  }

  export type OrderUpdateManyWithWhereWithoutUserInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutOrderInput>
  }

  export type OrderScalarWhereInput = {
    AND?: Enumerable<OrderScalarWhereInput>
    OR?: Enumerable<OrderScalarWhereInput>
    NOT?: Enumerable<OrderScalarWhereInput>
    id?: IntFilter | number
    userId?: IntFilter | number
    productId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type SearchItemsUpsertWithWhereUniqueWithoutUserInput = {
    where: SearchItemsWhereUniqueInput
    update: XOR<SearchItemsUpdateWithoutUserInput, SearchItemsUncheckedUpdateWithoutUserInput>
    create: XOR<SearchItemsCreateWithoutUserInput, SearchItemsUncheckedCreateWithoutUserInput>
  }

  export type SearchItemsUpdateWithWhereUniqueWithoutUserInput = {
    where: SearchItemsWhereUniqueInput
    data: XOR<SearchItemsUpdateWithoutUserInput, SearchItemsUncheckedUpdateWithoutUserInput>
  }

  export type SearchItemsUpdateManyWithWhereWithoutUserInput = {
    where: SearchItemsScalarWhereInput
    data: XOR<SearchItemsUpdateManyMutationInput, SearchItemsUncheckedUpdateManyWithoutUserSearchItemsInput>
  }

  export type SearchItemsScalarWhereInput = {
    AND?: Enumerable<SearchItemsScalarWhereInput>
    OR?: Enumerable<SearchItemsScalarWhereInput>
    NOT?: Enumerable<SearchItemsScalarWhereInput>
    id?: IntFilter | number
    searchName?: StringFilter | string
    userId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type UserPasswordUpsertWithWhereUniqueWithoutUserInput = {
    where: UserPasswordWhereUniqueInput
    update: XOR<UserPasswordUpdateWithoutUserInput, UserPasswordUncheckedUpdateWithoutUserInput>
    create: XOR<UserPasswordCreateWithoutUserInput, UserPasswordUncheckedCreateWithoutUserInput>
  }

  export type UserPasswordUpdateWithWhereUniqueWithoutUserInput = {
    where: UserPasswordWhereUniqueInput
    data: XOR<UserPasswordUpdateWithoutUserInput, UserPasswordUncheckedUpdateWithoutUserInput>
  }

  export type UserPasswordUpdateManyWithWhereWithoutUserInput = {
    where: UserPasswordScalarWhereInput
    data: XOR<UserPasswordUpdateManyMutationInput, UserPasswordUncheckedUpdateManyWithoutPasswordInput>
  }

  export type UserPasswordScalarWhereInput = {
    AND?: Enumerable<UserPasswordScalarWhereInput>
    OR?: Enumerable<UserPasswordScalarWhereInput>
    NOT?: Enumerable<UserPasswordScalarWhereInput>
    id?: IntFilter | number
    password?: StringFilter | string
    userId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type RolesUpsertWithoutUserInput = {
    update: XOR<RolesUpdateWithoutUserInput, RolesUncheckedUpdateWithoutUserInput>
    create: XOR<RolesCreateWithoutUserInput, RolesUncheckedCreateWithoutUserInput>
  }

  export type RolesUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RolesUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GenderUpsertWithoutUserInput = {
    update: XOR<GenderUpdateWithoutUserInput, GenderUncheckedUpdateWithoutUserInput>
    create: XOR<GenderCreateWithoutUserInput, GenderUncheckedCreateWithoutUserInput>
  }

  export type GenderUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productCategory?: ProductCategoryUpdateManyWithoutGenderNestedInput
  }

  export type GenderUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productCategory?: ProductCategoryUncheckedUpdateManyWithoutGenderNestedInput
  }

  export type ProductCreateWithoutProductOwnerInput = {
    syncId: number
    title: string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    isActive?: boolean
    color?: ProductColorCreateNestedManyWithoutProductInput
    offer?: OfferCreateNestedManyWithoutProductInput
    seasonalDresses?: SeasonalDressesCreateNestedManyWithoutProductInput
    productType: ProductTypeCreateNestedOneWithoutProductInput
    user?: UserCreateNestedOneWithoutUserProductInput
    priceHistory?: PriceHistoryCreateNestedManyWithoutProductInput
    commonDescription?: CommonDescriptionCreateNestedManyWithoutProductInput
    delivery?: DeleveryPeriodCreateNestedManyWithoutProductInput
    returns?: ReturnedProductCreateNestedManyWithoutProductInput
    cart?: CartCreateNestedManyWithoutProductInput
    wishlistItem?: WishlistItemCreateNestedManyWithoutProductInput
    productReviews?: ProductReviewCreateNestedManyWithoutProductInput
    order?: OrderCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProductOwnerInput = {
    id?: number
    syncId: number
    title: string
    price: number
    productTypeId: number
    userId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    isActive?: boolean
    color?: ProductColorUncheckedCreateNestedManyWithoutProductInput
    offer?: OfferUncheckedCreateNestedManyWithoutProductInput
    seasonalDresses?: SeasonalDressesUncheckedCreateNestedManyWithoutProductInput
    priceHistory?: PriceHistoryUncheckedCreateNestedManyWithoutProductInput
    commonDescription?: CommonDescriptionUncheckedCreateNestedManyWithoutProductInput
    delivery?: DeleveryPeriodUncheckedCreateNestedManyWithoutProductInput
    returns?: ReturnedProductUncheckedCreateNestedManyWithoutProductInput
    cart?: CartUncheckedCreateNestedManyWithoutProductInput
    wishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutProductInput
    productReviews?: ProductReviewUncheckedCreateNestedManyWithoutProductInput
    order?: OrderUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProductOwnerInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProductOwnerInput, ProductUncheckedCreateWithoutProductOwnerInput>
  }

  export type ProductCreateManyProductOwnerInputEnvelope = {
    data: Enumerable<ProductCreateManyProductOwnerInput>
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithWhereUniqueWithoutProductOwnerInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutProductOwnerInput, ProductUncheckedUpdateWithoutProductOwnerInput>
    create: XOR<ProductCreateWithoutProductOwnerInput, ProductUncheckedCreateWithoutProductOwnerInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutProductOwnerInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutProductOwnerInput, ProductUncheckedUpdateWithoutProductOwnerInput>
  }

  export type ProductUpdateManyWithWhereWithoutProductOwnerInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutProductInput>
  }

  export type UserCreateWithoutPasswordInput = {
    username: string
    email: string
    mobile: string
    token?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userProduct?: ProductCreateNestedManyWithoutUserInput
    userAddress?: UserAddressCreateNestedManyWithoutUserInput
    addCart?: CartCreateNestedManyWithoutUserInput
    wishlist?: WishlistCreateNestedManyWithoutUserInput
    loginRequests?: UserLoginRequestCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewCreateNestedManyWithoutUserInput
    order?: OrderCreateNestedManyWithoutUserInput
    userSearchItems?: SearchItemsCreateNestedManyWithoutUserInput
    roles?: RolesCreateNestedOneWithoutUserInput
    gender: GenderCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPasswordInput = {
    id?: number
    username: string
    email: string
    mobile: string
    token?: string | null
    roleId?: number
    genderId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userProduct?: ProductUncheckedCreateNestedManyWithoutUserInput
    userAddress?: UserAddressUncheckedCreateNestedManyWithoutUserInput
    addCart?: CartUncheckedCreateNestedManyWithoutUserInput
    wishlist?: WishlistUncheckedCreateNestedManyWithoutUserInput
    loginRequests?: UserLoginRequestUncheckedCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewUncheckedCreateNestedManyWithoutUserInput
    order?: OrderUncheckedCreateNestedManyWithoutUserInput
    userSearchItems?: SearchItemsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPasswordInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPasswordInput, UserUncheckedCreateWithoutPasswordInput>
  }

  export type UserUpsertWithoutPasswordInput = {
    update: XOR<UserUpdateWithoutPasswordInput, UserUncheckedUpdateWithoutPasswordInput>
    create: XOR<UserCreateWithoutPasswordInput, UserUncheckedCreateWithoutPasswordInput>
  }

  export type UserUpdateWithoutPasswordInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userProduct?: ProductUpdateManyWithoutUserNestedInput
    userAddress?: UserAddressUpdateManyWithoutUserNestedInput
    addCart?: CartUpdateManyWithoutUserNestedInput
    wishlist?: WishlistUpdateManyWithoutUserNestedInput
    loginRequests?: UserLoginRequestUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUpdateManyWithoutUserNestedInput
    order?: OrderUpdateManyWithoutUserNestedInput
    userSearchItems?: SearchItemsUpdateManyWithoutUserNestedInput
    roles?: RolesUpdateOneRequiredWithoutUserNestedInput
    gender?: GenderUpdateOneRequiredWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPasswordInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: IntFieldUpdateOperationsInput | number
    genderId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userProduct?: ProductUncheckedUpdateManyWithoutUserNestedInput
    userAddress?: UserAddressUncheckedUpdateManyWithoutUserNestedInput
    addCart?: CartUncheckedUpdateManyWithoutUserNestedInput
    wishlist?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    loginRequests?: UserLoginRequestUncheckedUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUncheckedUpdateManyWithoutUserNestedInput
    order?: OrderUncheckedUpdateManyWithoutUserNestedInput
    userSearchItems?: SearchItemsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutUserSearchItemsInput = {
    username: string
    email: string
    mobile: string
    token?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userProduct?: ProductCreateNestedManyWithoutUserInput
    userAddress?: UserAddressCreateNestedManyWithoutUserInput
    addCart?: CartCreateNestedManyWithoutUserInput
    wishlist?: WishlistCreateNestedManyWithoutUserInput
    loginRequests?: UserLoginRequestCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewCreateNestedManyWithoutUserInput
    order?: OrderCreateNestedManyWithoutUserInput
    password?: UserPasswordCreateNestedManyWithoutUserInput
    roles?: RolesCreateNestedOneWithoutUserInput
    gender: GenderCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserSearchItemsInput = {
    id?: number
    username: string
    email: string
    mobile: string
    token?: string | null
    roleId?: number
    genderId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userProduct?: ProductUncheckedCreateNestedManyWithoutUserInput
    userAddress?: UserAddressUncheckedCreateNestedManyWithoutUserInput
    addCart?: CartUncheckedCreateNestedManyWithoutUserInput
    wishlist?: WishlistUncheckedCreateNestedManyWithoutUserInput
    loginRequests?: UserLoginRequestUncheckedCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewUncheckedCreateNestedManyWithoutUserInput
    order?: OrderUncheckedCreateNestedManyWithoutUserInput
    password?: UserPasswordUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserSearchItemsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserSearchItemsInput, UserUncheckedCreateWithoutUserSearchItemsInput>
  }

  export type UserUpsertWithoutUserSearchItemsInput = {
    update: XOR<UserUpdateWithoutUserSearchItemsInput, UserUncheckedUpdateWithoutUserSearchItemsInput>
    create: XOR<UserCreateWithoutUserSearchItemsInput, UserUncheckedCreateWithoutUserSearchItemsInput>
  }

  export type UserUpdateWithoutUserSearchItemsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userProduct?: ProductUpdateManyWithoutUserNestedInput
    userAddress?: UserAddressUpdateManyWithoutUserNestedInput
    addCart?: CartUpdateManyWithoutUserNestedInput
    wishlist?: WishlistUpdateManyWithoutUserNestedInput
    loginRequests?: UserLoginRequestUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUpdateManyWithoutUserNestedInput
    order?: OrderUpdateManyWithoutUserNestedInput
    password?: UserPasswordUpdateManyWithoutUserNestedInput
    roles?: RolesUpdateOneRequiredWithoutUserNestedInput
    gender?: GenderUpdateOneRequiredWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserSearchItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: IntFieldUpdateOperationsInput | number
    genderId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userProduct?: ProductUncheckedUpdateManyWithoutUserNestedInput
    userAddress?: UserAddressUncheckedUpdateManyWithoutUserNestedInput
    addCart?: CartUncheckedUpdateManyWithoutUserNestedInput
    wishlist?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    loginRequests?: UserLoginRequestUncheckedUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUncheckedUpdateManyWithoutUserNestedInput
    order?: OrderUncheckedUpdateManyWithoutUserNestedInput
    password?: UserPasswordUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutOrderInput = {
    username: string
    email: string
    mobile: string
    token?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userProduct?: ProductCreateNestedManyWithoutUserInput
    userAddress?: UserAddressCreateNestedManyWithoutUserInput
    addCart?: CartCreateNestedManyWithoutUserInput
    wishlist?: WishlistCreateNestedManyWithoutUserInput
    loginRequests?: UserLoginRequestCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewCreateNestedManyWithoutUserInput
    userSearchItems?: SearchItemsCreateNestedManyWithoutUserInput
    password?: UserPasswordCreateNestedManyWithoutUserInput
    roles?: RolesCreateNestedOneWithoutUserInput
    gender: GenderCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOrderInput = {
    id?: number
    username: string
    email: string
    mobile: string
    token?: string | null
    roleId?: number
    genderId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userProduct?: ProductUncheckedCreateNestedManyWithoutUserInput
    userAddress?: UserAddressUncheckedCreateNestedManyWithoutUserInput
    addCart?: CartUncheckedCreateNestedManyWithoutUserInput
    wishlist?: WishlistUncheckedCreateNestedManyWithoutUserInput
    loginRequests?: UserLoginRequestUncheckedCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewUncheckedCreateNestedManyWithoutUserInput
    userSearchItems?: SearchItemsUncheckedCreateNestedManyWithoutUserInput
    password?: UserPasswordUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOrderInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrderInput, UserUncheckedCreateWithoutOrderInput>
  }

  export type ProductCreateWithoutOrderInput = {
    syncId: number
    title: string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    isActive?: boolean
    color?: ProductColorCreateNestedManyWithoutProductInput
    offer?: OfferCreateNestedManyWithoutProductInput
    seasonalDresses?: SeasonalDressesCreateNestedManyWithoutProductInput
    productType: ProductTypeCreateNestedOneWithoutProductInput
    user?: UserCreateNestedOneWithoutUserProductInput
    priceHistory?: PriceHistoryCreateNestedManyWithoutProductInput
    commonDescription?: CommonDescriptionCreateNestedManyWithoutProductInput
    delivery?: DeleveryPeriodCreateNestedManyWithoutProductInput
    returns?: ReturnedProductCreateNestedManyWithoutProductInput
    cart?: CartCreateNestedManyWithoutProductInput
    wishlistItem?: WishlistItemCreateNestedManyWithoutProductInput
    productReviews?: ProductReviewCreateNestedManyWithoutProductInput
    productOwner?: ProductOwnerCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutOrderInput = {
    id?: number
    syncId: number
    title: string
    price: number
    productTypeId: number
    productOwnerId?: number | null
    userId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    isActive?: boolean
    color?: ProductColorUncheckedCreateNestedManyWithoutProductInput
    offer?: OfferUncheckedCreateNestedManyWithoutProductInput
    seasonalDresses?: SeasonalDressesUncheckedCreateNestedManyWithoutProductInput
    priceHistory?: PriceHistoryUncheckedCreateNestedManyWithoutProductInput
    commonDescription?: CommonDescriptionUncheckedCreateNestedManyWithoutProductInput
    delivery?: DeleveryPeriodUncheckedCreateNestedManyWithoutProductInput
    returns?: ReturnedProductUncheckedCreateNestedManyWithoutProductInput
    cart?: CartUncheckedCreateNestedManyWithoutProductInput
    wishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutProductInput
    productReviews?: ProductReviewUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutOrderInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutOrderInput, ProductUncheckedCreateWithoutOrderInput>
  }

  export type UserUpsertWithoutOrderInput = {
    update: XOR<UserUpdateWithoutOrderInput, UserUncheckedUpdateWithoutOrderInput>
    create: XOR<UserCreateWithoutOrderInput, UserUncheckedCreateWithoutOrderInput>
  }

  export type UserUpdateWithoutOrderInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userProduct?: ProductUpdateManyWithoutUserNestedInput
    userAddress?: UserAddressUpdateManyWithoutUserNestedInput
    addCart?: CartUpdateManyWithoutUserNestedInput
    wishlist?: WishlistUpdateManyWithoutUserNestedInput
    loginRequests?: UserLoginRequestUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUpdateManyWithoutUserNestedInput
    userSearchItems?: SearchItemsUpdateManyWithoutUserNestedInput
    password?: UserPasswordUpdateManyWithoutUserNestedInput
    roles?: RolesUpdateOneRequiredWithoutUserNestedInput
    gender?: GenderUpdateOneRequiredWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: IntFieldUpdateOperationsInput | number
    genderId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userProduct?: ProductUncheckedUpdateManyWithoutUserNestedInput
    userAddress?: UserAddressUncheckedUpdateManyWithoutUserNestedInput
    addCart?: CartUncheckedUpdateManyWithoutUserNestedInput
    wishlist?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    loginRequests?: UserLoginRequestUncheckedUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUncheckedUpdateManyWithoutUserNestedInput
    userSearchItems?: SearchItemsUncheckedUpdateManyWithoutUserNestedInput
    password?: UserPasswordUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProductUpsertWithoutOrderInput = {
    update: XOR<ProductUpdateWithoutOrderInput, ProductUncheckedUpdateWithoutOrderInput>
    create: XOR<ProductCreateWithoutOrderInput, ProductUncheckedCreateWithoutOrderInput>
  }

  export type ProductUpdateWithoutOrderInput = {
    syncId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    color?: ProductColorUpdateManyWithoutProductNestedInput
    offer?: OfferUpdateManyWithoutProductNestedInput
    seasonalDresses?: SeasonalDressesUpdateManyWithoutProductNestedInput
    productType?: ProductTypeUpdateOneRequiredWithoutProductNestedInput
    user?: UserUpdateOneWithoutUserProductNestedInput
    priceHistory?: PriceHistoryUpdateManyWithoutProductNestedInput
    commonDescription?: CommonDescriptionUpdateManyWithoutProductNestedInput
    delivery?: DeleveryPeriodUpdateManyWithoutProductNestedInput
    returns?: ReturnedProductUpdateManyWithoutProductNestedInput
    cart?: CartUpdateManyWithoutProductNestedInput
    wishlistItem?: WishlistItemUpdateManyWithoutProductNestedInput
    productReviews?: ProductReviewUpdateManyWithoutProductNestedInput
    productOwner?: ProductOwnerUpdateOneWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    syncId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    productTypeId?: IntFieldUpdateOperationsInput | number
    productOwnerId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    color?: ProductColorUncheckedUpdateManyWithoutProductNestedInput
    offer?: OfferUncheckedUpdateManyWithoutProductNestedInput
    seasonalDresses?: SeasonalDressesUncheckedUpdateManyWithoutProductNestedInput
    priceHistory?: PriceHistoryUncheckedUpdateManyWithoutProductNestedInput
    commonDescription?: CommonDescriptionUncheckedUpdateManyWithoutProductNestedInput
    delivery?: DeleveryPeriodUncheckedUpdateManyWithoutProductNestedInput
    returns?: ReturnedProductUncheckedUpdateManyWithoutProductNestedInput
    cart?: CartUncheckedUpdateManyWithoutProductNestedInput
    wishlistItem?: WishlistItemUncheckedUpdateManyWithoutProductNestedInput
    productReviews?: ProductReviewUncheckedUpdateManyWithoutProductNestedInput
  }

  export type UserCreateWithoutLoginRequestsInput = {
    username: string
    email: string
    mobile: string
    token?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userProduct?: ProductCreateNestedManyWithoutUserInput
    userAddress?: UserAddressCreateNestedManyWithoutUserInput
    addCart?: CartCreateNestedManyWithoutUserInput
    wishlist?: WishlistCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewCreateNestedManyWithoutUserInput
    order?: OrderCreateNestedManyWithoutUserInput
    userSearchItems?: SearchItemsCreateNestedManyWithoutUserInput
    password?: UserPasswordCreateNestedManyWithoutUserInput
    roles?: RolesCreateNestedOneWithoutUserInput
    gender: GenderCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLoginRequestsInput = {
    id?: number
    username: string
    email: string
    mobile: string
    token?: string | null
    roleId?: number
    genderId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userProduct?: ProductUncheckedCreateNestedManyWithoutUserInput
    userAddress?: UserAddressUncheckedCreateNestedManyWithoutUserInput
    addCart?: CartUncheckedCreateNestedManyWithoutUserInput
    wishlist?: WishlistUncheckedCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewUncheckedCreateNestedManyWithoutUserInput
    order?: OrderUncheckedCreateNestedManyWithoutUserInput
    userSearchItems?: SearchItemsUncheckedCreateNestedManyWithoutUserInput
    password?: UserPasswordUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLoginRequestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLoginRequestsInput, UserUncheckedCreateWithoutLoginRequestsInput>
  }

  export type UserUpsertWithoutLoginRequestsInput = {
    update: XOR<UserUpdateWithoutLoginRequestsInput, UserUncheckedUpdateWithoutLoginRequestsInput>
    create: XOR<UserCreateWithoutLoginRequestsInput, UserUncheckedCreateWithoutLoginRequestsInput>
  }

  export type UserUpdateWithoutLoginRequestsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userProduct?: ProductUpdateManyWithoutUserNestedInput
    userAddress?: UserAddressUpdateManyWithoutUserNestedInput
    addCart?: CartUpdateManyWithoutUserNestedInput
    wishlist?: WishlistUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUpdateManyWithoutUserNestedInput
    order?: OrderUpdateManyWithoutUserNestedInput
    userSearchItems?: SearchItemsUpdateManyWithoutUserNestedInput
    password?: UserPasswordUpdateManyWithoutUserNestedInput
    roles?: RolesUpdateOneRequiredWithoutUserNestedInput
    gender?: GenderUpdateOneRequiredWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLoginRequestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: IntFieldUpdateOperationsInput | number
    genderId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userProduct?: ProductUncheckedUpdateManyWithoutUserNestedInput
    userAddress?: UserAddressUncheckedUpdateManyWithoutUserNestedInput
    addCart?: CartUncheckedUpdateManyWithoutUserNestedInput
    wishlist?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUncheckedUpdateManyWithoutUserNestedInput
    order?: OrderUncheckedUpdateManyWithoutUserNestedInput
    userSearchItems?: SearchItemsUncheckedUpdateManyWithoutUserNestedInput
    password?: UserPasswordUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProductColorCreateWithoutProductInput = {
    colors: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    colorSize?: ProductAviableSizesCreateNestedManyWithoutProductColorInput
    productImages?: ProductImagesCreateNestedManyWithoutProductColorInput
  }

  export type ProductColorUncheckedCreateWithoutProductInput = {
    id?: number
    colors: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    colorSize?: ProductAviableSizesUncheckedCreateNestedManyWithoutProductColorInput
    productImages?: ProductImagesUncheckedCreateNestedManyWithoutProductColorInput
  }

  export type ProductColorCreateOrConnectWithoutProductInput = {
    where: ProductColorWhereUniqueInput
    create: XOR<ProductColorCreateWithoutProductInput, ProductColorUncheckedCreateWithoutProductInput>
  }

  export type ProductColorCreateManyProductInputEnvelope = {
    data: Enumerable<ProductColorCreateManyProductInput>
    skipDuplicates?: boolean
  }

  export type OfferCreateWithoutProductInput = {
    offerPercntage: number
    offerPrice: number
    currentPrice: number
    offerQuantity: number
    currentQuantity: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    offerValidity?: OfferValidityCreateNestedManyWithoutOfferInput
  }

  export type OfferUncheckedCreateWithoutProductInput = {
    id?: number
    offerPercntage: number
    offerPrice: number
    currentPrice: number
    offerQuantity: number
    currentQuantity: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    offerValidity?: OfferValidityUncheckedCreateNestedManyWithoutOfferInput
  }

  export type OfferCreateOrConnectWithoutProductInput = {
    where: OfferWhereUniqueInput
    create: XOR<OfferCreateWithoutProductInput, OfferUncheckedCreateWithoutProductInput>
  }

  export type OfferCreateManyProductInputEnvelope = {
    data: Enumerable<OfferCreateManyProductInput>
    skipDuplicates?: boolean
  }

  export type SeasonalDressesCreateWithoutProductInput = {
    seasonal: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type SeasonalDressesUncheckedCreateWithoutProductInput = {
    id?: number
    seasonal: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type SeasonalDressesCreateOrConnectWithoutProductInput = {
    where: SeasonalDressesWhereUniqueInput
    create: XOR<SeasonalDressesCreateWithoutProductInput, SeasonalDressesUncheckedCreateWithoutProductInput>
  }

  export type SeasonalDressesCreateManyProductInputEnvelope = {
    data: Enumerable<SeasonalDressesCreateManyProductInput>
    skipDuplicates?: boolean
  }

  export type ProductTypeCreateWithoutProductInput = {
    itemsName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    ProductCategory: ProductCategoryCreateNestedOneWithoutProductTypeInput
    sizes?: ProductTypeSizeCreateNestedManyWithoutProductTypeInput
  }

  export type ProductTypeUncheckedCreateWithoutProductInput = {
    id?: number
    itemsName: string
    productCategoryId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sizes?: ProductTypeSizeUncheckedCreateNestedManyWithoutProductTypeInput
  }

  export type ProductTypeCreateOrConnectWithoutProductInput = {
    where: ProductTypeWhereUniqueInput
    create: XOR<ProductTypeCreateWithoutProductInput, ProductTypeUncheckedCreateWithoutProductInput>
  }

  export type UserCreateWithoutUserProductInput = {
    username: string
    email: string
    mobile: string
    token?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userAddress?: UserAddressCreateNestedManyWithoutUserInput
    addCart?: CartCreateNestedManyWithoutUserInput
    wishlist?: WishlistCreateNestedManyWithoutUserInput
    loginRequests?: UserLoginRequestCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewCreateNestedManyWithoutUserInput
    order?: OrderCreateNestedManyWithoutUserInput
    userSearchItems?: SearchItemsCreateNestedManyWithoutUserInput
    password?: UserPasswordCreateNestedManyWithoutUserInput
    roles?: RolesCreateNestedOneWithoutUserInput
    gender: GenderCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserProductInput = {
    id?: number
    username: string
    email: string
    mobile: string
    token?: string | null
    roleId?: number
    genderId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userAddress?: UserAddressUncheckedCreateNestedManyWithoutUserInput
    addCart?: CartUncheckedCreateNestedManyWithoutUserInput
    wishlist?: WishlistUncheckedCreateNestedManyWithoutUserInput
    loginRequests?: UserLoginRequestUncheckedCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewUncheckedCreateNestedManyWithoutUserInput
    order?: OrderUncheckedCreateNestedManyWithoutUserInput
    userSearchItems?: SearchItemsUncheckedCreateNestedManyWithoutUserInput
    password?: UserPasswordUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserProductInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserProductInput, UserUncheckedCreateWithoutUserProductInput>
  }

  export type PriceHistoryCreateWithoutProductInput = {
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PriceHistoryUncheckedCreateWithoutProductInput = {
    id?: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PriceHistoryCreateOrConnectWithoutProductInput = {
    where: PriceHistoryWhereUniqueInput
    create: XOR<PriceHistoryCreateWithoutProductInput, PriceHistoryUncheckedCreateWithoutProductInput>
  }

  export type PriceHistoryCreateManyProductInputEnvelope = {
    data: Enumerable<PriceHistoryCreateManyProductInput>
    skipDuplicates?: boolean
  }

  export type CommonDescriptionCreateWithoutProductInput = {
    fit?: string | null
    materail: string
    care: string
    brandName: string
    origin: string
    occasion: string
    specialFeature?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    topDescription?: TopDescriptionCreateNestedManyWithoutCommonDescriptionInput
    pantDescription?: BottomDescriptionCreateNestedManyWithoutCommonDescriptionInput
    kurtasDescription?: KurtasDescriptionCreateNestedManyWithoutCommonDescriptionInput
    shoesDescription?: ShoesDescriptionCreateNestedManyWithoutCommonDescriptionInput
    innerDescription?: InnersDescriptionCreateNestedManyWithoutCommonDescriptionInput
    watchesDescription?: WatchesDescriptionCreateNestedManyWithoutCommonDescriptionInput
    perfumesDescription?: PerfumesDescriptionCreateNestedManyWithoutCommonDescriptionInput
  }

  export type CommonDescriptionUncheckedCreateWithoutProductInput = {
    id?: number
    fit?: string | null
    materail: string
    care: string
    brandName: string
    origin: string
    occasion: string
    specialFeature?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    topDescription?: TopDescriptionUncheckedCreateNestedManyWithoutCommonDescriptionInput
    pantDescription?: BottomDescriptionUncheckedCreateNestedManyWithoutCommonDescriptionInput
    kurtasDescription?: KurtasDescriptionUncheckedCreateNestedManyWithoutCommonDescriptionInput
    shoesDescription?: ShoesDescriptionUncheckedCreateNestedManyWithoutCommonDescriptionInput
    innerDescription?: InnersDescriptionUncheckedCreateNestedManyWithoutCommonDescriptionInput
    watchesDescription?: WatchesDescriptionUncheckedCreateNestedManyWithoutCommonDescriptionInput
    perfumesDescription?: PerfumesDescriptionUncheckedCreateNestedManyWithoutCommonDescriptionInput
  }

  export type CommonDescriptionCreateOrConnectWithoutProductInput = {
    where: CommonDescriptionWhereUniqueInput
    create: XOR<CommonDescriptionCreateWithoutProductInput, CommonDescriptionUncheckedCreateWithoutProductInput>
  }

  export type CommonDescriptionCreateManyProductInputEnvelope = {
    data: Enumerable<CommonDescriptionCreateManyProductInput>
    skipDuplicates?: boolean
  }

  export type DeleveryPeriodCreateWithoutProductInput = {
    deliveryForMetroCitys: number
    deliveryForOtherCitys: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type DeleveryPeriodUncheckedCreateWithoutProductInput = {
    id?: number
    deliveryForMetroCitys: number
    deliveryForOtherCitys: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type DeleveryPeriodCreateOrConnectWithoutProductInput = {
    where: DeleveryPeriodWhereUniqueInput
    create: XOR<DeleveryPeriodCreateWithoutProductInput, DeleveryPeriodUncheckedCreateWithoutProductInput>
  }

  export type DeleveryPeriodCreateManyProductInputEnvelope = {
    data: Enumerable<DeleveryPeriodCreateManyProductInput>
    skipDuplicates?: boolean
  }

  export type ReturnedProductCreateWithoutProductInput = {
    returns: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ReturnedProductUncheckedCreateWithoutProductInput = {
    id?: number
    returns: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ReturnedProductCreateOrConnectWithoutProductInput = {
    where: ReturnedProductWhereUniqueInput
    create: XOR<ReturnedProductCreateWithoutProductInput, ReturnedProductUncheckedCreateWithoutProductInput>
  }

  export type ReturnedProductCreateManyProductInputEnvelope = {
    data: Enumerable<ReturnedProductCreateManyProductInput>
    skipDuplicates?: boolean
  }

  export type CartCreateWithoutProductInput = {
    isCheckedOut: boolean
    isRemoved: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutAddCartInput
  }

  export type CartUncheckedCreateWithoutProductInput = {
    id?: number
    userId: number
    isCheckedOut: boolean
    isRemoved: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type CartCreateOrConnectWithoutProductInput = {
    where: CartWhereUniqueInput
    create: XOR<CartCreateWithoutProductInput, CartUncheckedCreateWithoutProductInput>
  }

  export type CartCreateManyProductInputEnvelope = {
    data: Enumerable<CartCreateManyProductInput>
    skipDuplicates?: boolean
  }

  export type WishlistItemCreateWithoutProductInput = {
    wishlist: WishlistCreateNestedOneWithoutItemsInput
  }

  export type WishlistItemUncheckedCreateWithoutProductInput = {
    id?: number
    wishlistId: number
  }

  export type WishlistItemCreateOrConnectWithoutProductInput = {
    where: WishlistItemWhereUniqueInput
    create: XOR<WishlistItemCreateWithoutProductInput, WishlistItemUncheckedCreateWithoutProductInput>
  }

  export type WishlistItemCreateManyProductInputEnvelope = {
    data: Enumerable<WishlistItemCreateManyProductInput>
    skipDuplicates?: boolean
  }

  export type ProductReviewCreateWithoutProductInput = {
    review: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutProductReviewInput
  }

  export type ProductReviewUncheckedCreateWithoutProductInput = {
    id?: number
    userId: number
    review: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ProductReviewCreateOrConnectWithoutProductInput = {
    where: ProductReviewWhereUniqueInput
    create: XOR<ProductReviewCreateWithoutProductInput, ProductReviewUncheckedCreateWithoutProductInput>
  }

  export type ProductReviewCreateManyProductInputEnvelope = {
    data: Enumerable<ProductReviewCreateManyProductInput>
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutProductInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutProductInput = {
    id?: number
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type OrderCreateOrConnectWithoutProductInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutProductInput, OrderUncheckedCreateWithoutProductInput>
  }

  export type OrderCreateManyProductInputEnvelope = {
    data: Enumerable<OrderCreateManyProductInput>
    skipDuplicates?: boolean
  }

  export type ProductOwnerCreateWithoutProductInput = {
    syncUserId: number
    ownerName: string
    ownerEmail: string
    ownerMobile: string
    storeName: string
    storeAddress: string
    storeCity: string
    storePincode: string
    storeState: string
    customerCareEmail: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ProductOwnerUncheckedCreateWithoutProductInput = {
    id?: number
    syncUserId: number
    ownerName: string
    ownerEmail: string
    ownerMobile: string
    storeName: string
    storeAddress: string
    storeCity: string
    storePincode: string
    storeState: string
    customerCareEmail: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ProductOwnerCreateOrConnectWithoutProductInput = {
    where: ProductOwnerWhereUniqueInput
    create: XOR<ProductOwnerCreateWithoutProductInput, ProductOwnerUncheckedCreateWithoutProductInput>
  }

  export type ProductColorUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductColorWhereUniqueInput
    update: XOR<ProductColorUpdateWithoutProductInput, ProductColorUncheckedUpdateWithoutProductInput>
    create: XOR<ProductColorCreateWithoutProductInput, ProductColorUncheckedCreateWithoutProductInput>
  }

  export type ProductColorUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductColorWhereUniqueInput
    data: XOR<ProductColorUpdateWithoutProductInput, ProductColorUncheckedUpdateWithoutProductInput>
  }

  export type ProductColorUpdateManyWithWhereWithoutProductInput = {
    where: ProductColorScalarWhereInput
    data: XOR<ProductColorUpdateManyMutationInput, ProductColorUncheckedUpdateManyWithoutColorInput>
  }

  export type ProductColorScalarWhereInput = {
    AND?: Enumerable<ProductColorScalarWhereInput>
    OR?: Enumerable<ProductColorScalarWhereInput>
    NOT?: Enumerable<ProductColorScalarWhereInput>
    id?: IntFilter | number
    productId?: IntFilter | number
    colors?: StringFilter | string
    isActive?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type OfferUpsertWithWhereUniqueWithoutProductInput = {
    where: OfferWhereUniqueInput
    update: XOR<OfferUpdateWithoutProductInput, OfferUncheckedUpdateWithoutProductInput>
    create: XOR<OfferCreateWithoutProductInput, OfferUncheckedCreateWithoutProductInput>
  }

  export type OfferUpdateWithWhereUniqueWithoutProductInput = {
    where: OfferWhereUniqueInput
    data: XOR<OfferUpdateWithoutProductInput, OfferUncheckedUpdateWithoutProductInput>
  }

  export type OfferUpdateManyWithWhereWithoutProductInput = {
    where: OfferScalarWhereInput
    data: XOR<OfferUpdateManyMutationInput, OfferUncheckedUpdateManyWithoutOfferInput>
  }

  export type OfferScalarWhereInput = {
    AND?: Enumerable<OfferScalarWhereInput>
    OR?: Enumerable<OfferScalarWhereInput>
    NOT?: Enumerable<OfferScalarWhereInput>
    id?: IntFilter | number
    productId?: IntFilter | number
    offerPercntage?: FloatFilter | number
    offerPrice?: FloatFilter | number
    currentPrice?: FloatFilter | number
    offerQuantity?: IntFilter | number
    currentQuantity?: IntFilter | number
    isActive?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type SeasonalDressesUpsertWithWhereUniqueWithoutProductInput = {
    where: SeasonalDressesWhereUniqueInput
    update: XOR<SeasonalDressesUpdateWithoutProductInput, SeasonalDressesUncheckedUpdateWithoutProductInput>
    create: XOR<SeasonalDressesCreateWithoutProductInput, SeasonalDressesUncheckedCreateWithoutProductInput>
  }

  export type SeasonalDressesUpdateWithWhereUniqueWithoutProductInput = {
    where: SeasonalDressesWhereUniqueInput
    data: XOR<SeasonalDressesUpdateWithoutProductInput, SeasonalDressesUncheckedUpdateWithoutProductInput>
  }

  export type SeasonalDressesUpdateManyWithWhereWithoutProductInput = {
    where: SeasonalDressesScalarWhereInput
    data: XOR<SeasonalDressesUpdateManyMutationInput, SeasonalDressesUncheckedUpdateManyWithoutSeasonalDressesInput>
  }

  export type SeasonalDressesScalarWhereInput = {
    AND?: Enumerable<SeasonalDressesScalarWhereInput>
    OR?: Enumerable<SeasonalDressesScalarWhereInput>
    NOT?: Enumerable<SeasonalDressesScalarWhereInput>
    id?: IntFilter | number
    seasonal?: StringFilter | string
    productId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type ProductTypeUpsertWithoutProductInput = {
    update: XOR<ProductTypeUpdateWithoutProductInput, ProductTypeUncheckedUpdateWithoutProductInput>
    create: XOR<ProductTypeCreateWithoutProductInput, ProductTypeUncheckedCreateWithoutProductInput>
  }

  export type ProductTypeUpdateWithoutProductInput = {
    itemsName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ProductCategory?: ProductCategoryUpdateOneRequiredWithoutProductTypeNestedInput
    sizes?: ProductTypeSizeUpdateManyWithoutProductTypeNestedInput
  }

  export type ProductTypeUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemsName?: StringFieldUpdateOperationsInput | string
    productCategoryId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sizes?: ProductTypeSizeUncheckedUpdateManyWithoutProductTypeNestedInput
  }

  export type UserUpsertWithoutUserProductInput = {
    update: XOR<UserUpdateWithoutUserProductInput, UserUncheckedUpdateWithoutUserProductInput>
    create: XOR<UserCreateWithoutUserProductInput, UserUncheckedCreateWithoutUserProductInput>
  }

  export type UserUpdateWithoutUserProductInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userAddress?: UserAddressUpdateManyWithoutUserNestedInput
    addCart?: CartUpdateManyWithoutUserNestedInput
    wishlist?: WishlistUpdateManyWithoutUserNestedInput
    loginRequests?: UserLoginRequestUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUpdateManyWithoutUserNestedInput
    order?: OrderUpdateManyWithoutUserNestedInput
    userSearchItems?: SearchItemsUpdateManyWithoutUserNestedInput
    password?: UserPasswordUpdateManyWithoutUserNestedInput
    roles?: RolesUpdateOneRequiredWithoutUserNestedInput
    gender?: GenderUpdateOneRequiredWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: IntFieldUpdateOperationsInput | number
    genderId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userAddress?: UserAddressUncheckedUpdateManyWithoutUserNestedInput
    addCart?: CartUncheckedUpdateManyWithoutUserNestedInput
    wishlist?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    loginRequests?: UserLoginRequestUncheckedUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUncheckedUpdateManyWithoutUserNestedInput
    order?: OrderUncheckedUpdateManyWithoutUserNestedInput
    userSearchItems?: SearchItemsUncheckedUpdateManyWithoutUserNestedInput
    password?: UserPasswordUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PriceHistoryUpsertWithWhereUniqueWithoutProductInput = {
    where: PriceHistoryWhereUniqueInput
    update: XOR<PriceHistoryUpdateWithoutProductInput, PriceHistoryUncheckedUpdateWithoutProductInput>
    create: XOR<PriceHistoryCreateWithoutProductInput, PriceHistoryUncheckedCreateWithoutProductInput>
  }

  export type PriceHistoryUpdateWithWhereUniqueWithoutProductInput = {
    where: PriceHistoryWhereUniqueInput
    data: XOR<PriceHistoryUpdateWithoutProductInput, PriceHistoryUncheckedUpdateWithoutProductInput>
  }

  export type PriceHistoryUpdateManyWithWhereWithoutProductInput = {
    where: PriceHistoryScalarWhereInput
    data: XOR<PriceHistoryUpdateManyMutationInput, PriceHistoryUncheckedUpdateManyWithoutPriceHistoryInput>
  }

  export type PriceHistoryScalarWhereInput = {
    AND?: Enumerable<PriceHistoryScalarWhereInput>
    OR?: Enumerable<PriceHistoryScalarWhereInput>
    NOT?: Enumerable<PriceHistoryScalarWhereInput>
    id?: IntFilter | number
    price?: IntFilter | number
    productId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type CommonDescriptionUpsertWithWhereUniqueWithoutProductInput = {
    where: CommonDescriptionWhereUniqueInput
    update: XOR<CommonDescriptionUpdateWithoutProductInput, CommonDescriptionUncheckedUpdateWithoutProductInput>
    create: XOR<CommonDescriptionCreateWithoutProductInput, CommonDescriptionUncheckedCreateWithoutProductInput>
  }

  export type CommonDescriptionUpdateWithWhereUniqueWithoutProductInput = {
    where: CommonDescriptionWhereUniqueInput
    data: XOR<CommonDescriptionUpdateWithoutProductInput, CommonDescriptionUncheckedUpdateWithoutProductInput>
  }

  export type CommonDescriptionUpdateManyWithWhereWithoutProductInput = {
    where: CommonDescriptionScalarWhereInput
    data: XOR<CommonDescriptionUpdateManyMutationInput, CommonDescriptionUncheckedUpdateManyWithoutCommonDescriptionInput>
  }

  export type CommonDescriptionScalarWhereInput = {
    AND?: Enumerable<CommonDescriptionScalarWhereInput>
    OR?: Enumerable<CommonDescriptionScalarWhereInput>
    NOT?: Enumerable<CommonDescriptionScalarWhereInput>
    id?: IntFilter | number
    fit?: StringNullableFilter | string | null
    materail?: StringFilter | string
    care?: StringFilter | string
    brandName?: StringFilter | string
    origin?: StringFilter | string
    productId?: IntFilter | number
    occasion?: StringFilter | string
    specialFeature?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type DeleveryPeriodUpsertWithWhereUniqueWithoutProductInput = {
    where: DeleveryPeriodWhereUniqueInput
    update: XOR<DeleveryPeriodUpdateWithoutProductInput, DeleveryPeriodUncheckedUpdateWithoutProductInput>
    create: XOR<DeleveryPeriodCreateWithoutProductInput, DeleveryPeriodUncheckedCreateWithoutProductInput>
  }

  export type DeleveryPeriodUpdateWithWhereUniqueWithoutProductInput = {
    where: DeleveryPeriodWhereUniqueInput
    data: XOR<DeleveryPeriodUpdateWithoutProductInput, DeleveryPeriodUncheckedUpdateWithoutProductInput>
  }

  export type DeleveryPeriodUpdateManyWithWhereWithoutProductInput = {
    where: DeleveryPeriodScalarWhereInput
    data: XOR<DeleveryPeriodUpdateManyMutationInput, DeleveryPeriodUncheckedUpdateManyWithoutDeliveryInput>
  }

  export type DeleveryPeriodScalarWhereInput = {
    AND?: Enumerable<DeleveryPeriodScalarWhereInput>
    OR?: Enumerable<DeleveryPeriodScalarWhereInput>
    NOT?: Enumerable<DeleveryPeriodScalarWhereInput>
    id?: IntFilter | number
    productId?: IntFilter | number
    deliveryForMetroCitys?: IntFilter | number
    deliveryForOtherCitys?: IntFilter | number
    isActive?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type ReturnedProductUpsertWithWhereUniqueWithoutProductInput = {
    where: ReturnedProductWhereUniqueInput
    update: XOR<ReturnedProductUpdateWithoutProductInput, ReturnedProductUncheckedUpdateWithoutProductInput>
    create: XOR<ReturnedProductCreateWithoutProductInput, ReturnedProductUncheckedCreateWithoutProductInput>
  }

  export type ReturnedProductUpdateWithWhereUniqueWithoutProductInput = {
    where: ReturnedProductWhereUniqueInput
    data: XOR<ReturnedProductUpdateWithoutProductInput, ReturnedProductUncheckedUpdateWithoutProductInput>
  }

  export type ReturnedProductUpdateManyWithWhereWithoutProductInput = {
    where: ReturnedProductScalarWhereInput
    data: XOR<ReturnedProductUpdateManyMutationInput, ReturnedProductUncheckedUpdateManyWithoutReturnsInput>
  }

  export type ReturnedProductScalarWhereInput = {
    AND?: Enumerable<ReturnedProductScalarWhereInput>
    OR?: Enumerable<ReturnedProductScalarWhereInput>
    NOT?: Enumerable<ReturnedProductScalarWhereInput>
    id?: IntFilter | number
    productId?: IntFilter | number
    returns?: IntFilter | number
    isActive?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type CartUpsertWithWhereUniqueWithoutProductInput = {
    where: CartWhereUniqueInput
    update: XOR<CartUpdateWithoutProductInput, CartUncheckedUpdateWithoutProductInput>
    create: XOR<CartCreateWithoutProductInput, CartUncheckedCreateWithoutProductInput>
  }

  export type CartUpdateWithWhereUniqueWithoutProductInput = {
    where: CartWhereUniqueInput
    data: XOR<CartUpdateWithoutProductInput, CartUncheckedUpdateWithoutProductInput>
  }

  export type CartUpdateManyWithWhereWithoutProductInput = {
    where: CartScalarWhereInput
    data: XOR<CartUpdateManyMutationInput, CartUncheckedUpdateManyWithoutCartInput>
  }

  export type WishlistItemUpsertWithWhereUniqueWithoutProductInput = {
    where: WishlistItemWhereUniqueInput
    update: XOR<WishlistItemUpdateWithoutProductInput, WishlistItemUncheckedUpdateWithoutProductInput>
    create: XOR<WishlistItemCreateWithoutProductInput, WishlistItemUncheckedCreateWithoutProductInput>
  }

  export type WishlistItemUpdateWithWhereUniqueWithoutProductInput = {
    where: WishlistItemWhereUniqueInput
    data: XOR<WishlistItemUpdateWithoutProductInput, WishlistItemUncheckedUpdateWithoutProductInput>
  }

  export type WishlistItemUpdateManyWithWhereWithoutProductInput = {
    where: WishlistItemScalarWhereInput
    data: XOR<WishlistItemUpdateManyMutationInput, WishlistItemUncheckedUpdateManyWithoutWishlistItemInput>
  }

  export type WishlistItemScalarWhereInput = {
    AND?: Enumerable<WishlistItemScalarWhereInput>
    OR?: Enumerable<WishlistItemScalarWhereInput>
    NOT?: Enumerable<WishlistItemScalarWhereInput>
    id?: IntFilter | number
    wishlistId?: IntFilter | number
    productId?: IntFilter | number
  }

  export type ProductReviewUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductReviewWhereUniqueInput
    update: XOR<ProductReviewUpdateWithoutProductInput, ProductReviewUncheckedUpdateWithoutProductInput>
    create: XOR<ProductReviewCreateWithoutProductInput, ProductReviewUncheckedCreateWithoutProductInput>
  }

  export type ProductReviewUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductReviewWhereUniqueInput
    data: XOR<ProductReviewUpdateWithoutProductInput, ProductReviewUncheckedUpdateWithoutProductInput>
  }

  export type ProductReviewUpdateManyWithWhereWithoutProductInput = {
    where: ProductReviewScalarWhereInput
    data: XOR<ProductReviewUpdateManyMutationInput, ProductReviewUncheckedUpdateManyWithoutProductReviewsInput>
  }

  export type OrderUpsertWithWhereUniqueWithoutProductInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutProductInput, OrderUncheckedUpdateWithoutProductInput>
    create: XOR<OrderCreateWithoutProductInput, OrderUncheckedCreateWithoutProductInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutProductInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutProductInput, OrderUncheckedUpdateWithoutProductInput>
  }

  export type OrderUpdateManyWithWhereWithoutProductInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutOrderInput>
  }

  export type ProductOwnerUpsertWithoutProductInput = {
    update: XOR<ProductOwnerUpdateWithoutProductInput, ProductOwnerUncheckedUpdateWithoutProductInput>
    create: XOR<ProductOwnerCreateWithoutProductInput, ProductOwnerUncheckedCreateWithoutProductInput>
  }

  export type ProductOwnerUpdateWithoutProductInput = {
    syncUserId?: IntFieldUpdateOperationsInput | number
    ownerName?: StringFieldUpdateOperationsInput | string
    ownerEmail?: StringFieldUpdateOperationsInput | string
    ownerMobile?: StringFieldUpdateOperationsInput | string
    storeName?: StringFieldUpdateOperationsInput | string
    storeAddress?: StringFieldUpdateOperationsInput | string
    storeCity?: StringFieldUpdateOperationsInput | string
    storePincode?: StringFieldUpdateOperationsInput | string
    storeState?: StringFieldUpdateOperationsInput | string
    customerCareEmail?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductOwnerUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    syncUserId?: IntFieldUpdateOperationsInput | number
    ownerName?: StringFieldUpdateOperationsInput | string
    ownerEmail?: StringFieldUpdateOperationsInput | string
    ownerMobile?: StringFieldUpdateOperationsInput | string
    storeName?: StringFieldUpdateOperationsInput | string
    storeAddress?: StringFieldUpdateOperationsInput | string
    storeCity?: StringFieldUpdateOperationsInput | string
    storePincode?: StringFieldUpdateOperationsInput | string
    storeState?: StringFieldUpdateOperationsInput | string
    customerCareEmail?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductCreateWithoutProductReviewsInput = {
    syncId: number
    title: string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    isActive?: boolean
    color?: ProductColorCreateNestedManyWithoutProductInput
    offer?: OfferCreateNestedManyWithoutProductInput
    seasonalDresses?: SeasonalDressesCreateNestedManyWithoutProductInput
    productType: ProductTypeCreateNestedOneWithoutProductInput
    user?: UserCreateNestedOneWithoutUserProductInput
    priceHistory?: PriceHistoryCreateNestedManyWithoutProductInput
    commonDescription?: CommonDescriptionCreateNestedManyWithoutProductInput
    delivery?: DeleveryPeriodCreateNestedManyWithoutProductInput
    returns?: ReturnedProductCreateNestedManyWithoutProductInput
    cart?: CartCreateNestedManyWithoutProductInput
    wishlistItem?: WishlistItemCreateNestedManyWithoutProductInput
    order?: OrderCreateNestedManyWithoutProductInput
    productOwner?: ProductOwnerCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProductReviewsInput = {
    id?: number
    syncId: number
    title: string
    price: number
    productTypeId: number
    productOwnerId?: number | null
    userId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    isActive?: boolean
    color?: ProductColorUncheckedCreateNestedManyWithoutProductInput
    offer?: OfferUncheckedCreateNestedManyWithoutProductInput
    seasonalDresses?: SeasonalDressesUncheckedCreateNestedManyWithoutProductInput
    priceHistory?: PriceHistoryUncheckedCreateNestedManyWithoutProductInput
    commonDescription?: CommonDescriptionUncheckedCreateNestedManyWithoutProductInput
    delivery?: DeleveryPeriodUncheckedCreateNestedManyWithoutProductInput
    returns?: ReturnedProductUncheckedCreateNestedManyWithoutProductInput
    cart?: CartUncheckedCreateNestedManyWithoutProductInput
    wishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutProductInput
    order?: OrderUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProductReviewsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProductReviewsInput, ProductUncheckedCreateWithoutProductReviewsInput>
  }

  export type UserCreateWithoutProductReviewInput = {
    username: string
    email: string
    mobile: string
    token?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userProduct?: ProductCreateNestedManyWithoutUserInput
    userAddress?: UserAddressCreateNestedManyWithoutUserInput
    addCart?: CartCreateNestedManyWithoutUserInput
    wishlist?: WishlistCreateNestedManyWithoutUserInput
    loginRequests?: UserLoginRequestCreateNestedManyWithoutUserInput
    order?: OrderCreateNestedManyWithoutUserInput
    userSearchItems?: SearchItemsCreateNestedManyWithoutUserInput
    password?: UserPasswordCreateNestedManyWithoutUserInput
    roles?: RolesCreateNestedOneWithoutUserInput
    gender: GenderCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProductReviewInput = {
    id?: number
    username: string
    email: string
    mobile: string
    token?: string | null
    roleId?: number
    genderId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userProduct?: ProductUncheckedCreateNestedManyWithoutUserInput
    userAddress?: UserAddressUncheckedCreateNestedManyWithoutUserInput
    addCart?: CartUncheckedCreateNestedManyWithoutUserInput
    wishlist?: WishlistUncheckedCreateNestedManyWithoutUserInput
    loginRequests?: UserLoginRequestUncheckedCreateNestedManyWithoutUserInput
    order?: OrderUncheckedCreateNestedManyWithoutUserInput
    userSearchItems?: SearchItemsUncheckedCreateNestedManyWithoutUserInput
    password?: UserPasswordUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProductReviewInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProductReviewInput, UserUncheckedCreateWithoutProductReviewInput>
  }

  export type ProductUpsertWithoutProductReviewsInput = {
    update: XOR<ProductUpdateWithoutProductReviewsInput, ProductUncheckedUpdateWithoutProductReviewsInput>
    create: XOR<ProductCreateWithoutProductReviewsInput, ProductUncheckedCreateWithoutProductReviewsInput>
  }

  export type ProductUpdateWithoutProductReviewsInput = {
    syncId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    color?: ProductColorUpdateManyWithoutProductNestedInput
    offer?: OfferUpdateManyWithoutProductNestedInput
    seasonalDresses?: SeasonalDressesUpdateManyWithoutProductNestedInput
    productType?: ProductTypeUpdateOneRequiredWithoutProductNestedInput
    user?: UserUpdateOneWithoutUserProductNestedInput
    priceHistory?: PriceHistoryUpdateManyWithoutProductNestedInput
    commonDescription?: CommonDescriptionUpdateManyWithoutProductNestedInput
    delivery?: DeleveryPeriodUpdateManyWithoutProductNestedInput
    returns?: ReturnedProductUpdateManyWithoutProductNestedInput
    cart?: CartUpdateManyWithoutProductNestedInput
    wishlistItem?: WishlistItemUpdateManyWithoutProductNestedInput
    order?: OrderUpdateManyWithoutProductNestedInput
    productOwner?: ProductOwnerUpdateOneWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutProductReviewsInput = {
    id?: IntFieldUpdateOperationsInput | number
    syncId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    productTypeId?: IntFieldUpdateOperationsInput | number
    productOwnerId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    color?: ProductColorUncheckedUpdateManyWithoutProductNestedInput
    offer?: OfferUncheckedUpdateManyWithoutProductNestedInput
    seasonalDresses?: SeasonalDressesUncheckedUpdateManyWithoutProductNestedInput
    priceHistory?: PriceHistoryUncheckedUpdateManyWithoutProductNestedInput
    commonDescription?: CommonDescriptionUncheckedUpdateManyWithoutProductNestedInput
    delivery?: DeleveryPeriodUncheckedUpdateManyWithoutProductNestedInput
    returns?: ReturnedProductUncheckedUpdateManyWithoutProductNestedInput
    cart?: CartUncheckedUpdateManyWithoutProductNestedInput
    wishlistItem?: WishlistItemUncheckedUpdateManyWithoutProductNestedInput
    order?: OrderUncheckedUpdateManyWithoutProductNestedInput
  }

  export type UserUpsertWithoutProductReviewInput = {
    update: XOR<UserUpdateWithoutProductReviewInput, UserUncheckedUpdateWithoutProductReviewInput>
    create: XOR<UserCreateWithoutProductReviewInput, UserUncheckedCreateWithoutProductReviewInput>
  }

  export type UserUpdateWithoutProductReviewInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userProduct?: ProductUpdateManyWithoutUserNestedInput
    userAddress?: UserAddressUpdateManyWithoutUserNestedInput
    addCart?: CartUpdateManyWithoutUserNestedInput
    wishlist?: WishlistUpdateManyWithoutUserNestedInput
    loginRequests?: UserLoginRequestUpdateManyWithoutUserNestedInput
    order?: OrderUpdateManyWithoutUserNestedInput
    userSearchItems?: SearchItemsUpdateManyWithoutUserNestedInput
    password?: UserPasswordUpdateManyWithoutUserNestedInput
    roles?: RolesUpdateOneRequiredWithoutUserNestedInput
    gender?: GenderUpdateOneRequiredWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProductReviewInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: IntFieldUpdateOperationsInput | number
    genderId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userProduct?: ProductUncheckedUpdateManyWithoutUserNestedInput
    userAddress?: UserAddressUncheckedUpdateManyWithoutUserNestedInput
    addCart?: CartUncheckedUpdateManyWithoutUserNestedInput
    wishlist?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    loginRequests?: UserLoginRequestUncheckedUpdateManyWithoutUserNestedInput
    order?: OrderUncheckedUpdateManyWithoutUserNestedInput
    userSearchItems?: SearchItemsUncheckedUpdateManyWithoutUserNestedInput
    password?: UserPasswordUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProductCreateWithoutReturnsInput = {
    syncId: number
    title: string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    isActive?: boolean
    color?: ProductColorCreateNestedManyWithoutProductInput
    offer?: OfferCreateNestedManyWithoutProductInput
    seasonalDresses?: SeasonalDressesCreateNestedManyWithoutProductInput
    productType: ProductTypeCreateNestedOneWithoutProductInput
    user?: UserCreateNestedOneWithoutUserProductInput
    priceHistory?: PriceHistoryCreateNestedManyWithoutProductInput
    commonDescription?: CommonDescriptionCreateNestedManyWithoutProductInput
    delivery?: DeleveryPeriodCreateNestedManyWithoutProductInput
    cart?: CartCreateNestedManyWithoutProductInput
    wishlistItem?: WishlistItemCreateNestedManyWithoutProductInput
    productReviews?: ProductReviewCreateNestedManyWithoutProductInput
    order?: OrderCreateNestedManyWithoutProductInput
    productOwner?: ProductOwnerCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutReturnsInput = {
    id?: number
    syncId: number
    title: string
    price: number
    productTypeId: number
    productOwnerId?: number | null
    userId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    isActive?: boolean
    color?: ProductColorUncheckedCreateNestedManyWithoutProductInput
    offer?: OfferUncheckedCreateNestedManyWithoutProductInput
    seasonalDresses?: SeasonalDressesUncheckedCreateNestedManyWithoutProductInput
    priceHistory?: PriceHistoryUncheckedCreateNestedManyWithoutProductInput
    commonDescription?: CommonDescriptionUncheckedCreateNestedManyWithoutProductInput
    delivery?: DeleveryPeriodUncheckedCreateNestedManyWithoutProductInput
    cart?: CartUncheckedCreateNestedManyWithoutProductInput
    wishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutProductInput
    productReviews?: ProductReviewUncheckedCreateNestedManyWithoutProductInput
    order?: OrderUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutReturnsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutReturnsInput, ProductUncheckedCreateWithoutReturnsInput>
  }

  export type ProductUpsertWithoutReturnsInput = {
    update: XOR<ProductUpdateWithoutReturnsInput, ProductUncheckedUpdateWithoutReturnsInput>
    create: XOR<ProductCreateWithoutReturnsInput, ProductUncheckedCreateWithoutReturnsInput>
  }

  export type ProductUpdateWithoutReturnsInput = {
    syncId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    color?: ProductColorUpdateManyWithoutProductNestedInput
    offer?: OfferUpdateManyWithoutProductNestedInput
    seasonalDresses?: SeasonalDressesUpdateManyWithoutProductNestedInput
    productType?: ProductTypeUpdateOneRequiredWithoutProductNestedInput
    user?: UserUpdateOneWithoutUserProductNestedInput
    priceHistory?: PriceHistoryUpdateManyWithoutProductNestedInput
    commonDescription?: CommonDescriptionUpdateManyWithoutProductNestedInput
    delivery?: DeleveryPeriodUpdateManyWithoutProductNestedInput
    cart?: CartUpdateManyWithoutProductNestedInput
    wishlistItem?: WishlistItemUpdateManyWithoutProductNestedInput
    productReviews?: ProductReviewUpdateManyWithoutProductNestedInput
    order?: OrderUpdateManyWithoutProductNestedInput
    productOwner?: ProductOwnerUpdateOneWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutReturnsInput = {
    id?: IntFieldUpdateOperationsInput | number
    syncId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    productTypeId?: IntFieldUpdateOperationsInput | number
    productOwnerId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    color?: ProductColorUncheckedUpdateManyWithoutProductNestedInput
    offer?: OfferUncheckedUpdateManyWithoutProductNestedInput
    seasonalDresses?: SeasonalDressesUncheckedUpdateManyWithoutProductNestedInput
    priceHistory?: PriceHistoryUncheckedUpdateManyWithoutProductNestedInput
    commonDescription?: CommonDescriptionUncheckedUpdateManyWithoutProductNestedInput
    delivery?: DeleveryPeriodUncheckedUpdateManyWithoutProductNestedInput
    cart?: CartUncheckedUpdateManyWithoutProductNestedInput
    wishlistItem?: WishlistItemUncheckedUpdateManyWithoutProductNestedInput
    productReviews?: ProductReviewUncheckedUpdateManyWithoutProductNestedInput
    order?: OrderUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateWithoutDeliveryInput = {
    syncId: number
    title: string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    isActive?: boolean
    color?: ProductColorCreateNestedManyWithoutProductInput
    offer?: OfferCreateNestedManyWithoutProductInput
    seasonalDresses?: SeasonalDressesCreateNestedManyWithoutProductInput
    productType: ProductTypeCreateNestedOneWithoutProductInput
    user?: UserCreateNestedOneWithoutUserProductInput
    priceHistory?: PriceHistoryCreateNestedManyWithoutProductInput
    commonDescription?: CommonDescriptionCreateNestedManyWithoutProductInput
    returns?: ReturnedProductCreateNestedManyWithoutProductInput
    cart?: CartCreateNestedManyWithoutProductInput
    wishlistItem?: WishlistItemCreateNestedManyWithoutProductInput
    productReviews?: ProductReviewCreateNestedManyWithoutProductInput
    order?: OrderCreateNestedManyWithoutProductInput
    productOwner?: ProductOwnerCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutDeliveryInput = {
    id?: number
    syncId: number
    title: string
    price: number
    productTypeId: number
    productOwnerId?: number | null
    userId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    isActive?: boolean
    color?: ProductColorUncheckedCreateNestedManyWithoutProductInput
    offer?: OfferUncheckedCreateNestedManyWithoutProductInput
    seasonalDresses?: SeasonalDressesUncheckedCreateNestedManyWithoutProductInput
    priceHistory?: PriceHistoryUncheckedCreateNestedManyWithoutProductInput
    commonDescription?: CommonDescriptionUncheckedCreateNestedManyWithoutProductInput
    returns?: ReturnedProductUncheckedCreateNestedManyWithoutProductInput
    cart?: CartUncheckedCreateNestedManyWithoutProductInput
    wishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutProductInput
    productReviews?: ProductReviewUncheckedCreateNestedManyWithoutProductInput
    order?: OrderUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutDeliveryInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutDeliveryInput, ProductUncheckedCreateWithoutDeliveryInput>
  }

  export type ProductUpsertWithoutDeliveryInput = {
    update: XOR<ProductUpdateWithoutDeliveryInput, ProductUncheckedUpdateWithoutDeliveryInput>
    create: XOR<ProductCreateWithoutDeliveryInput, ProductUncheckedCreateWithoutDeliveryInput>
  }

  export type ProductUpdateWithoutDeliveryInput = {
    syncId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    color?: ProductColorUpdateManyWithoutProductNestedInput
    offer?: OfferUpdateManyWithoutProductNestedInput
    seasonalDresses?: SeasonalDressesUpdateManyWithoutProductNestedInput
    productType?: ProductTypeUpdateOneRequiredWithoutProductNestedInput
    user?: UserUpdateOneWithoutUserProductNestedInput
    priceHistory?: PriceHistoryUpdateManyWithoutProductNestedInput
    commonDescription?: CommonDescriptionUpdateManyWithoutProductNestedInput
    returns?: ReturnedProductUpdateManyWithoutProductNestedInput
    cart?: CartUpdateManyWithoutProductNestedInput
    wishlistItem?: WishlistItemUpdateManyWithoutProductNestedInput
    productReviews?: ProductReviewUpdateManyWithoutProductNestedInput
    order?: OrderUpdateManyWithoutProductNestedInput
    productOwner?: ProductOwnerUpdateOneWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutDeliveryInput = {
    id?: IntFieldUpdateOperationsInput | number
    syncId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    productTypeId?: IntFieldUpdateOperationsInput | number
    productOwnerId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    color?: ProductColorUncheckedUpdateManyWithoutProductNestedInput
    offer?: OfferUncheckedUpdateManyWithoutProductNestedInput
    seasonalDresses?: SeasonalDressesUncheckedUpdateManyWithoutProductNestedInput
    priceHistory?: PriceHistoryUncheckedUpdateManyWithoutProductNestedInput
    commonDescription?: CommonDescriptionUncheckedUpdateManyWithoutProductNestedInput
    returns?: ReturnedProductUncheckedUpdateManyWithoutProductNestedInput
    cart?: CartUncheckedUpdateManyWithoutProductNestedInput
    wishlistItem?: WishlistItemUncheckedUpdateManyWithoutProductNestedInput
    productReviews?: ProductReviewUncheckedUpdateManyWithoutProductNestedInput
    order?: OrderUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateWithoutColorInput = {
    syncId: number
    title: string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    isActive?: boolean
    offer?: OfferCreateNestedManyWithoutProductInput
    seasonalDresses?: SeasonalDressesCreateNestedManyWithoutProductInput
    productType: ProductTypeCreateNestedOneWithoutProductInput
    user?: UserCreateNestedOneWithoutUserProductInput
    priceHistory?: PriceHistoryCreateNestedManyWithoutProductInput
    commonDescription?: CommonDescriptionCreateNestedManyWithoutProductInput
    delivery?: DeleveryPeriodCreateNestedManyWithoutProductInput
    returns?: ReturnedProductCreateNestedManyWithoutProductInput
    cart?: CartCreateNestedManyWithoutProductInput
    wishlistItem?: WishlistItemCreateNestedManyWithoutProductInput
    productReviews?: ProductReviewCreateNestedManyWithoutProductInput
    order?: OrderCreateNestedManyWithoutProductInput
    productOwner?: ProductOwnerCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutColorInput = {
    id?: number
    syncId: number
    title: string
    price: number
    productTypeId: number
    productOwnerId?: number | null
    userId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    isActive?: boolean
    offer?: OfferUncheckedCreateNestedManyWithoutProductInput
    seasonalDresses?: SeasonalDressesUncheckedCreateNestedManyWithoutProductInput
    priceHistory?: PriceHistoryUncheckedCreateNestedManyWithoutProductInput
    commonDescription?: CommonDescriptionUncheckedCreateNestedManyWithoutProductInput
    delivery?: DeleveryPeriodUncheckedCreateNestedManyWithoutProductInput
    returns?: ReturnedProductUncheckedCreateNestedManyWithoutProductInput
    cart?: CartUncheckedCreateNestedManyWithoutProductInput
    wishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutProductInput
    productReviews?: ProductReviewUncheckedCreateNestedManyWithoutProductInput
    order?: OrderUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutColorInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutColorInput, ProductUncheckedCreateWithoutColorInput>
  }

  export type ProductAviableSizesCreateWithoutProductColorInput = {
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    history?: QuantityHistoryCreateNestedManyWithoutProductAviableSizesInput
    productTypeSize: ProductTypeSizeCreateNestedOneWithoutAviableSizesInput
  }

  export type ProductAviableSizesUncheckedCreateWithoutProductColorInput = {
    id?: number
    quantity: number
    productTypeSizeId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    history?: QuantityHistoryUncheckedCreateNestedManyWithoutProductAviableSizesInput
  }

  export type ProductAviableSizesCreateOrConnectWithoutProductColorInput = {
    where: ProductAviableSizesWhereUniqueInput
    create: XOR<ProductAviableSizesCreateWithoutProductColorInput, ProductAviableSizesUncheckedCreateWithoutProductColorInput>
  }

  export type ProductAviableSizesCreateManyProductColorInputEnvelope = {
    data: Enumerable<ProductAviableSizesCreateManyProductColorInput>
    skipDuplicates?: boolean
  }

  export type ProductImagesCreateWithoutProductColorInput = {
    imageUrl: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ProductImagesUncheckedCreateWithoutProductColorInput = {
    id?: number
    imageUrl: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ProductImagesCreateOrConnectWithoutProductColorInput = {
    where: ProductImagesWhereUniqueInput
    create: XOR<ProductImagesCreateWithoutProductColorInput, ProductImagesUncheckedCreateWithoutProductColorInput>
  }

  export type ProductImagesCreateManyProductColorInputEnvelope = {
    data: Enumerable<ProductImagesCreateManyProductColorInput>
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithoutColorInput = {
    update: XOR<ProductUpdateWithoutColorInput, ProductUncheckedUpdateWithoutColorInput>
    create: XOR<ProductCreateWithoutColorInput, ProductUncheckedCreateWithoutColorInput>
  }

  export type ProductUpdateWithoutColorInput = {
    syncId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    offer?: OfferUpdateManyWithoutProductNestedInput
    seasonalDresses?: SeasonalDressesUpdateManyWithoutProductNestedInput
    productType?: ProductTypeUpdateOneRequiredWithoutProductNestedInput
    user?: UserUpdateOneWithoutUserProductNestedInput
    priceHistory?: PriceHistoryUpdateManyWithoutProductNestedInput
    commonDescription?: CommonDescriptionUpdateManyWithoutProductNestedInput
    delivery?: DeleveryPeriodUpdateManyWithoutProductNestedInput
    returns?: ReturnedProductUpdateManyWithoutProductNestedInput
    cart?: CartUpdateManyWithoutProductNestedInput
    wishlistItem?: WishlistItemUpdateManyWithoutProductNestedInput
    productReviews?: ProductReviewUpdateManyWithoutProductNestedInput
    order?: OrderUpdateManyWithoutProductNestedInput
    productOwner?: ProductOwnerUpdateOneWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutColorInput = {
    id?: IntFieldUpdateOperationsInput | number
    syncId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    productTypeId?: IntFieldUpdateOperationsInput | number
    productOwnerId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    offer?: OfferUncheckedUpdateManyWithoutProductNestedInput
    seasonalDresses?: SeasonalDressesUncheckedUpdateManyWithoutProductNestedInput
    priceHistory?: PriceHistoryUncheckedUpdateManyWithoutProductNestedInput
    commonDescription?: CommonDescriptionUncheckedUpdateManyWithoutProductNestedInput
    delivery?: DeleveryPeriodUncheckedUpdateManyWithoutProductNestedInput
    returns?: ReturnedProductUncheckedUpdateManyWithoutProductNestedInput
    cart?: CartUncheckedUpdateManyWithoutProductNestedInput
    wishlistItem?: WishlistItemUncheckedUpdateManyWithoutProductNestedInput
    productReviews?: ProductReviewUncheckedUpdateManyWithoutProductNestedInput
    order?: OrderUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductAviableSizesUpsertWithWhereUniqueWithoutProductColorInput = {
    where: ProductAviableSizesWhereUniqueInput
    update: XOR<ProductAviableSizesUpdateWithoutProductColorInput, ProductAviableSizesUncheckedUpdateWithoutProductColorInput>
    create: XOR<ProductAviableSizesCreateWithoutProductColorInput, ProductAviableSizesUncheckedCreateWithoutProductColorInput>
  }

  export type ProductAviableSizesUpdateWithWhereUniqueWithoutProductColorInput = {
    where: ProductAviableSizesWhereUniqueInput
    data: XOR<ProductAviableSizesUpdateWithoutProductColorInput, ProductAviableSizesUncheckedUpdateWithoutProductColorInput>
  }

  export type ProductAviableSizesUpdateManyWithWhereWithoutProductColorInput = {
    where: ProductAviableSizesScalarWhereInput
    data: XOR<ProductAviableSizesUpdateManyMutationInput, ProductAviableSizesUncheckedUpdateManyWithoutColorSizeInput>
  }

  export type ProductImagesUpsertWithWhereUniqueWithoutProductColorInput = {
    where: ProductImagesWhereUniqueInput
    update: XOR<ProductImagesUpdateWithoutProductColorInput, ProductImagesUncheckedUpdateWithoutProductColorInput>
    create: XOR<ProductImagesCreateWithoutProductColorInput, ProductImagesUncheckedCreateWithoutProductColorInput>
  }

  export type ProductImagesUpdateWithWhereUniqueWithoutProductColorInput = {
    where: ProductImagesWhereUniqueInput
    data: XOR<ProductImagesUpdateWithoutProductColorInput, ProductImagesUncheckedUpdateWithoutProductColorInput>
  }

  export type ProductImagesUpdateManyWithWhereWithoutProductColorInput = {
    where: ProductImagesScalarWhereInput
    data: XOR<ProductImagesUpdateManyMutationInput, ProductImagesUncheckedUpdateManyWithoutProductImagesInput>
  }

  export type ProductImagesScalarWhereInput = {
    AND?: Enumerable<ProductImagesScalarWhereInput>
    OR?: Enumerable<ProductImagesScalarWhereInput>
    NOT?: Enumerable<ProductImagesScalarWhereInput>
    id?: IntFilter | number
    imageUrl?: StringFilter | string
    productColorId?: IntFilter | number
    isActive?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type ProductCreateWithoutPriceHistoryInput = {
    syncId: number
    title: string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    isActive?: boolean
    color?: ProductColorCreateNestedManyWithoutProductInput
    offer?: OfferCreateNestedManyWithoutProductInput
    seasonalDresses?: SeasonalDressesCreateNestedManyWithoutProductInput
    productType: ProductTypeCreateNestedOneWithoutProductInput
    user?: UserCreateNestedOneWithoutUserProductInput
    commonDescription?: CommonDescriptionCreateNestedManyWithoutProductInput
    delivery?: DeleveryPeriodCreateNestedManyWithoutProductInput
    returns?: ReturnedProductCreateNestedManyWithoutProductInput
    cart?: CartCreateNestedManyWithoutProductInput
    wishlistItem?: WishlistItemCreateNestedManyWithoutProductInput
    productReviews?: ProductReviewCreateNestedManyWithoutProductInput
    order?: OrderCreateNestedManyWithoutProductInput
    productOwner?: ProductOwnerCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutPriceHistoryInput = {
    id?: number
    syncId: number
    title: string
    price: number
    productTypeId: number
    productOwnerId?: number | null
    userId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    isActive?: boolean
    color?: ProductColorUncheckedCreateNestedManyWithoutProductInput
    offer?: OfferUncheckedCreateNestedManyWithoutProductInput
    seasonalDresses?: SeasonalDressesUncheckedCreateNestedManyWithoutProductInput
    commonDescription?: CommonDescriptionUncheckedCreateNestedManyWithoutProductInput
    delivery?: DeleveryPeriodUncheckedCreateNestedManyWithoutProductInput
    returns?: ReturnedProductUncheckedCreateNestedManyWithoutProductInput
    cart?: CartUncheckedCreateNestedManyWithoutProductInput
    wishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutProductInput
    productReviews?: ProductReviewUncheckedCreateNestedManyWithoutProductInput
    order?: OrderUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutPriceHistoryInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutPriceHistoryInput, ProductUncheckedCreateWithoutPriceHistoryInput>
  }

  export type ProductUpsertWithoutPriceHistoryInput = {
    update: XOR<ProductUpdateWithoutPriceHistoryInput, ProductUncheckedUpdateWithoutPriceHistoryInput>
    create: XOR<ProductCreateWithoutPriceHistoryInput, ProductUncheckedCreateWithoutPriceHistoryInput>
  }

  export type ProductUpdateWithoutPriceHistoryInput = {
    syncId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    color?: ProductColorUpdateManyWithoutProductNestedInput
    offer?: OfferUpdateManyWithoutProductNestedInput
    seasonalDresses?: SeasonalDressesUpdateManyWithoutProductNestedInput
    productType?: ProductTypeUpdateOneRequiredWithoutProductNestedInput
    user?: UserUpdateOneWithoutUserProductNestedInput
    commonDescription?: CommonDescriptionUpdateManyWithoutProductNestedInput
    delivery?: DeleveryPeriodUpdateManyWithoutProductNestedInput
    returns?: ReturnedProductUpdateManyWithoutProductNestedInput
    cart?: CartUpdateManyWithoutProductNestedInput
    wishlistItem?: WishlistItemUpdateManyWithoutProductNestedInput
    productReviews?: ProductReviewUpdateManyWithoutProductNestedInput
    order?: OrderUpdateManyWithoutProductNestedInput
    productOwner?: ProductOwnerUpdateOneWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutPriceHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    syncId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    productTypeId?: IntFieldUpdateOperationsInput | number
    productOwnerId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    color?: ProductColorUncheckedUpdateManyWithoutProductNestedInput
    offer?: OfferUncheckedUpdateManyWithoutProductNestedInput
    seasonalDresses?: SeasonalDressesUncheckedUpdateManyWithoutProductNestedInput
    commonDescription?: CommonDescriptionUncheckedUpdateManyWithoutProductNestedInput
    delivery?: DeleveryPeriodUncheckedUpdateManyWithoutProductNestedInput
    returns?: ReturnedProductUncheckedUpdateManyWithoutProductNestedInput
    cart?: CartUncheckedUpdateManyWithoutProductNestedInput
    wishlistItem?: WishlistItemUncheckedUpdateManyWithoutProductNestedInput
    productReviews?: ProductReviewUncheckedUpdateManyWithoutProductNestedInput
    order?: OrderUncheckedUpdateManyWithoutProductNestedInput
  }

  export type QuantityHistoryCreateWithoutProductAviableSizesInput = {
    quantity: number
    timestamp?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type QuantityHistoryUncheckedCreateWithoutProductAviableSizesInput = {
    id?: number
    quantity: number
    timestamp?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type QuantityHistoryCreateOrConnectWithoutProductAviableSizesInput = {
    where: QuantityHistoryWhereUniqueInput
    create: XOR<QuantityHistoryCreateWithoutProductAviableSizesInput, QuantityHistoryUncheckedCreateWithoutProductAviableSizesInput>
  }

  export type QuantityHistoryCreateManyProductAviableSizesInputEnvelope = {
    data: Enumerable<QuantityHistoryCreateManyProductAviableSizesInput>
    skipDuplicates?: boolean
  }

  export type ProductColorCreateWithoutColorSizeInput = {
    colors: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    product: ProductCreateNestedOneWithoutColorInput
    productImages?: ProductImagesCreateNestedManyWithoutProductColorInput
  }

  export type ProductColorUncheckedCreateWithoutColorSizeInput = {
    id?: number
    productId: number
    colors: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    productImages?: ProductImagesUncheckedCreateNestedManyWithoutProductColorInput
  }

  export type ProductColorCreateOrConnectWithoutColorSizeInput = {
    where: ProductColorWhereUniqueInput
    create: XOR<ProductColorCreateWithoutColorSizeInput, ProductColorUncheckedCreateWithoutColorSizeInput>
  }

  export type ProductTypeSizeCreateWithoutAviableSizesInput = {
    size: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    productType: ProductTypeCreateNestedOneWithoutSizesInput
  }

  export type ProductTypeSizeUncheckedCreateWithoutAviableSizesInput = {
    id?: number
    size: string
    ietmsId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ProductTypeSizeCreateOrConnectWithoutAviableSizesInput = {
    where: ProductTypeSizeWhereUniqueInput
    create: XOR<ProductTypeSizeCreateWithoutAviableSizesInput, ProductTypeSizeUncheckedCreateWithoutAviableSizesInput>
  }

  export type QuantityHistoryUpsertWithWhereUniqueWithoutProductAviableSizesInput = {
    where: QuantityHistoryWhereUniqueInput
    update: XOR<QuantityHistoryUpdateWithoutProductAviableSizesInput, QuantityHistoryUncheckedUpdateWithoutProductAviableSizesInput>
    create: XOR<QuantityHistoryCreateWithoutProductAviableSizesInput, QuantityHistoryUncheckedCreateWithoutProductAviableSizesInput>
  }

  export type QuantityHistoryUpdateWithWhereUniqueWithoutProductAviableSizesInput = {
    where: QuantityHistoryWhereUniqueInput
    data: XOR<QuantityHistoryUpdateWithoutProductAviableSizesInput, QuantityHistoryUncheckedUpdateWithoutProductAviableSizesInput>
  }

  export type QuantityHistoryUpdateManyWithWhereWithoutProductAviableSizesInput = {
    where: QuantityHistoryScalarWhereInput
    data: XOR<QuantityHistoryUpdateManyMutationInput, QuantityHistoryUncheckedUpdateManyWithoutHistoryInput>
  }

  export type QuantityHistoryScalarWhereInput = {
    AND?: Enumerable<QuantityHistoryScalarWhereInput>
    OR?: Enumerable<QuantityHistoryScalarWhereInput>
    NOT?: Enumerable<QuantityHistoryScalarWhereInput>
    id?: IntFilter | number
    quantity?: IntFilter | number
    productAviableSizesId?: IntFilter | number
    timestamp?: DateTimeFilter | Date | string
    isActive?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type ProductColorUpsertWithoutColorSizeInput = {
    update: XOR<ProductColorUpdateWithoutColorSizeInput, ProductColorUncheckedUpdateWithoutColorSizeInput>
    create: XOR<ProductColorCreateWithoutColorSizeInput, ProductColorUncheckedCreateWithoutColorSizeInput>
  }

  export type ProductColorUpdateWithoutColorSizeInput = {
    colors?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    product?: ProductUpdateOneRequiredWithoutColorNestedInput
    productImages?: ProductImagesUpdateManyWithoutProductColorNestedInput
  }

  export type ProductColorUncheckedUpdateWithoutColorSizeInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    colors?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productImages?: ProductImagesUncheckedUpdateManyWithoutProductColorNestedInput
  }

  export type ProductTypeSizeUpsertWithoutAviableSizesInput = {
    update: XOR<ProductTypeSizeUpdateWithoutAviableSizesInput, ProductTypeSizeUncheckedUpdateWithoutAviableSizesInput>
    create: XOR<ProductTypeSizeCreateWithoutAviableSizesInput, ProductTypeSizeUncheckedCreateWithoutAviableSizesInput>
  }

  export type ProductTypeSizeUpdateWithoutAviableSizesInput = {
    size?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productType?: ProductTypeUpdateOneRequiredWithoutSizesNestedInput
  }

  export type ProductTypeSizeUncheckedUpdateWithoutAviableSizesInput = {
    id?: IntFieldUpdateOperationsInput | number
    size?: StringFieldUpdateOperationsInput | string
    ietmsId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductCreateWithoutSeasonalDressesInput = {
    syncId: number
    title: string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    isActive?: boolean
    color?: ProductColorCreateNestedManyWithoutProductInput
    offer?: OfferCreateNestedManyWithoutProductInput
    productType: ProductTypeCreateNestedOneWithoutProductInput
    user?: UserCreateNestedOneWithoutUserProductInput
    priceHistory?: PriceHistoryCreateNestedManyWithoutProductInput
    commonDescription?: CommonDescriptionCreateNestedManyWithoutProductInput
    delivery?: DeleveryPeriodCreateNestedManyWithoutProductInput
    returns?: ReturnedProductCreateNestedManyWithoutProductInput
    cart?: CartCreateNestedManyWithoutProductInput
    wishlistItem?: WishlistItemCreateNestedManyWithoutProductInput
    productReviews?: ProductReviewCreateNestedManyWithoutProductInput
    order?: OrderCreateNestedManyWithoutProductInput
    productOwner?: ProductOwnerCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutSeasonalDressesInput = {
    id?: number
    syncId: number
    title: string
    price: number
    productTypeId: number
    productOwnerId?: number | null
    userId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    isActive?: boolean
    color?: ProductColorUncheckedCreateNestedManyWithoutProductInput
    offer?: OfferUncheckedCreateNestedManyWithoutProductInput
    priceHistory?: PriceHistoryUncheckedCreateNestedManyWithoutProductInput
    commonDescription?: CommonDescriptionUncheckedCreateNestedManyWithoutProductInput
    delivery?: DeleveryPeriodUncheckedCreateNestedManyWithoutProductInput
    returns?: ReturnedProductUncheckedCreateNestedManyWithoutProductInput
    cart?: CartUncheckedCreateNestedManyWithoutProductInput
    wishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutProductInput
    productReviews?: ProductReviewUncheckedCreateNestedManyWithoutProductInput
    order?: OrderUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutSeasonalDressesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutSeasonalDressesInput, ProductUncheckedCreateWithoutSeasonalDressesInput>
  }

  export type ProductUpsertWithoutSeasonalDressesInput = {
    update: XOR<ProductUpdateWithoutSeasonalDressesInput, ProductUncheckedUpdateWithoutSeasonalDressesInput>
    create: XOR<ProductCreateWithoutSeasonalDressesInput, ProductUncheckedCreateWithoutSeasonalDressesInput>
  }

  export type ProductUpdateWithoutSeasonalDressesInput = {
    syncId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    color?: ProductColorUpdateManyWithoutProductNestedInput
    offer?: OfferUpdateManyWithoutProductNestedInput
    productType?: ProductTypeUpdateOneRequiredWithoutProductNestedInput
    user?: UserUpdateOneWithoutUserProductNestedInput
    priceHistory?: PriceHistoryUpdateManyWithoutProductNestedInput
    commonDescription?: CommonDescriptionUpdateManyWithoutProductNestedInput
    delivery?: DeleveryPeriodUpdateManyWithoutProductNestedInput
    returns?: ReturnedProductUpdateManyWithoutProductNestedInput
    cart?: CartUpdateManyWithoutProductNestedInput
    wishlistItem?: WishlistItemUpdateManyWithoutProductNestedInput
    productReviews?: ProductReviewUpdateManyWithoutProductNestedInput
    order?: OrderUpdateManyWithoutProductNestedInput
    productOwner?: ProductOwnerUpdateOneWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutSeasonalDressesInput = {
    id?: IntFieldUpdateOperationsInput | number
    syncId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    productTypeId?: IntFieldUpdateOperationsInput | number
    productOwnerId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    color?: ProductColorUncheckedUpdateManyWithoutProductNestedInput
    offer?: OfferUncheckedUpdateManyWithoutProductNestedInput
    priceHistory?: PriceHistoryUncheckedUpdateManyWithoutProductNestedInput
    commonDescription?: CommonDescriptionUncheckedUpdateManyWithoutProductNestedInput
    delivery?: DeleveryPeriodUncheckedUpdateManyWithoutProductNestedInput
    returns?: ReturnedProductUncheckedUpdateManyWithoutProductNestedInput
    cart?: CartUncheckedUpdateManyWithoutProductNestedInput
    wishlistItem?: WishlistItemUncheckedUpdateManyWithoutProductNestedInput
    productReviews?: ProductReviewUncheckedUpdateManyWithoutProductNestedInput
    order?: OrderUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductColorCreateWithoutProductImagesInput = {
    colors: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    product: ProductCreateNestedOneWithoutColorInput
    colorSize?: ProductAviableSizesCreateNestedManyWithoutProductColorInput
  }

  export type ProductColorUncheckedCreateWithoutProductImagesInput = {
    id?: number
    productId: number
    colors: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    colorSize?: ProductAviableSizesUncheckedCreateNestedManyWithoutProductColorInput
  }

  export type ProductColorCreateOrConnectWithoutProductImagesInput = {
    where: ProductColorWhereUniqueInput
    create: XOR<ProductColorCreateWithoutProductImagesInput, ProductColorUncheckedCreateWithoutProductImagesInput>
  }

  export type ProductColorUpsertWithoutProductImagesInput = {
    update: XOR<ProductColorUpdateWithoutProductImagesInput, ProductColorUncheckedUpdateWithoutProductImagesInput>
    create: XOR<ProductColorCreateWithoutProductImagesInput, ProductColorUncheckedCreateWithoutProductImagesInput>
  }

  export type ProductColorUpdateWithoutProductImagesInput = {
    colors?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    product?: ProductUpdateOneRequiredWithoutColorNestedInput
    colorSize?: ProductAviableSizesUpdateManyWithoutProductColorNestedInput
  }

  export type ProductColorUncheckedUpdateWithoutProductImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    colors?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    colorSize?: ProductAviableSizesUncheckedUpdateManyWithoutProductColorNestedInput
  }

  export type ProductCreateWithoutCommonDescriptionInput = {
    syncId: number
    title: string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    isActive?: boolean
    color?: ProductColorCreateNestedManyWithoutProductInput
    offer?: OfferCreateNestedManyWithoutProductInput
    seasonalDresses?: SeasonalDressesCreateNestedManyWithoutProductInput
    productType: ProductTypeCreateNestedOneWithoutProductInput
    user?: UserCreateNestedOneWithoutUserProductInput
    priceHistory?: PriceHistoryCreateNestedManyWithoutProductInput
    delivery?: DeleveryPeriodCreateNestedManyWithoutProductInput
    returns?: ReturnedProductCreateNestedManyWithoutProductInput
    cart?: CartCreateNestedManyWithoutProductInput
    wishlistItem?: WishlistItemCreateNestedManyWithoutProductInput
    productReviews?: ProductReviewCreateNestedManyWithoutProductInput
    order?: OrderCreateNestedManyWithoutProductInput
    productOwner?: ProductOwnerCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutCommonDescriptionInput = {
    id?: number
    syncId: number
    title: string
    price: number
    productTypeId: number
    productOwnerId?: number | null
    userId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    isActive?: boolean
    color?: ProductColorUncheckedCreateNestedManyWithoutProductInput
    offer?: OfferUncheckedCreateNestedManyWithoutProductInput
    seasonalDresses?: SeasonalDressesUncheckedCreateNestedManyWithoutProductInput
    priceHistory?: PriceHistoryUncheckedCreateNestedManyWithoutProductInput
    delivery?: DeleveryPeriodUncheckedCreateNestedManyWithoutProductInput
    returns?: ReturnedProductUncheckedCreateNestedManyWithoutProductInput
    cart?: CartUncheckedCreateNestedManyWithoutProductInput
    wishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutProductInput
    productReviews?: ProductReviewUncheckedCreateNestedManyWithoutProductInput
    order?: OrderUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCommonDescriptionInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCommonDescriptionInput, ProductUncheckedCreateWithoutCommonDescriptionInput>
  }

  export type TopDescriptionCreateWithoutCommonDescriptionInput = {
    productDescription?: string | null
    weight?: number | null
    chest: number
    shoulder: number
    type?: string | null
    colorFamily?: string | null
    printAndPattern?: string | null
    length: number
    pocket: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sleeveType: SleeveTypeCreateNestedOneWithoutTopDescriptionInput
    neckType: NeckTypeCreateNestedOneWithoutTopDescriptionInput
    bottomDescription?: BottomDescriptionCreateNestedManyWithoutTopDescriptionInput
  }

  export type TopDescriptionUncheckedCreateWithoutCommonDescriptionInput = {
    id?: number
    productDescription?: string | null
    sleeveTypeId: number
    weight?: number | null
    chest: number
    shoulder: number
    neckTypeId: number
    type?: string | null
    colorFamily?: string | null
    printAndPattern?: string | null
    length: number
    pocket: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    bottomDescription?: BottomDescriptionUncheckedCreateNestedManyWithoutTopDescriptionInput
  }

  export type TopDescriptionCreateOrConnectWithoutCommonDescriptionInput = {
    where: TopDescriptionWhereUniqueInput
    create: XOR<TopDescriptionCreateWithoutCommonDescriptionInput, TopDescriptionUncheckedCreateWithoutCommonDescriptionInput>
  }

  export type TopDescriptionCreateManyCommonDescriptionInputEnvelope = {
    data: Enumerable<TopDescriptionCreateManyCommonDescriptionInput>
    skipDuplicates?: boolean
  }

  export type BottomDescriptionCreateWithoutCommonDescriptionInput = {
    productDescription?: string | null
    weight?: number | null
    printAndPattern: string
    length: number
    waist: number
    hip: number
    type?: string | null
    colorFamily?: string | null
    pocket?: string | null
    beltLoop?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    typesOfPants: TypesOfBottomCreateNestedOneWithoutDescriptionInput
    typesOfPleats: TypesOfPleatsCreateNestedOneWithoutDescriptionInput
    typesOfLength: TypesOfLengthBottomCreateNestedOneWithoutDescriptionInput
    kurtasDescription?: KurtasDescriptionCreateNestedOneWithoutBottomDescriptionInput
    topDescription?: TopDescriptionCreateNestedOneWithoutBottomDescriptionInput
  }

  export type BottomDescriptionUncheckedCreateWithoutCommonDescriptionInput = {
    id?: number
    productDescription?: string | null
    weight?: number | null
    printAndPattern: string
    length: number
    waist: number
    hip: number
    type?: string | null
    colorFamily?: string | null
    pocket?: string | null
    kurtasDescriptionId?: number | null
    topDescriptionId?: number | null
    beltLoop?: boolean
    typeOfPantId: number
    typesOfPleatsId: number
    typesOfLengthId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type BottomDescriptionCreateOrConnectWithoutCommonDescriptionInput = {
    where: BottomDescriptionWhereUniqueInput
    create: XOR<BottomDescriptionCreateWithoutCommonDescriptionInput, BottomDescriptionUncheckedCreateWithoutCommonDescriptionInput>
  }

  export type BottomDescriptionCreateManyCommonDescriptionInputEnvelope = {
    data: Enumerable<BottomDescriptionCreateManyCommonDescriptionInput>
    skipDuplicates?: boolean
  }

  export type KurtasDescriptionCreateWithoutCommonDescriptionInput = {
    work?: string | null
    productDescription: string
    chest: number
    shoulder: number
    transparencyOfTheFabric?: boolean
    weight?: number | null
    colorFamily?: string | null
    pocket: string
    type: string
    printAndpattern?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    kurtasLengthType: KurtasLengthTypeCreateNestedOneWithoutKurtasDescriptionInput
    neckType: NeckTypeCreateNestedOneWithoutKurtasDescriptionInput
    sleeveType: SleeveTypeCreateNestedOneWithoutKurtasDescriptionInput
    bottomDescription?: BottomDescriptionCreateNestedManyWithoutKurtasDescriptionInput
  }

  export type KurtasDescriptionUncheckedCreateWithoutCommonDescriptionInput = {
    id?: number
    work?: string | null
    productDescription: string
    chest: number
    shoulder: number
    transparencyOfTheFabric?: boolean
    kurtasLengthTypeId: number
    weight?: number | null
    colorFamily?: string | null
    pocket: string
    type: string
    printAndpattern?: string | null
    kurtasNeckTypeId: number
    kurtasSleeveTypeId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    bottomDescription?: BottomDescriptionUncheckedCreateNestedManyWithoutKurtasDescriptionInput
  }

  export type KurtasDescriptionCreateOrConnectWithoutCommonDescriptionInput = {
    where: KurtasDescriptionWhereUniqueInput
    create: XOR<KurtasDescriptionCreateWithoutCommonDescriptionInput, KurtasDescriptionUncheckedCreateWithoutCommonDescriptionInput>
  }

  export type KurtasDescriptionCreateManyCommonDescriptionInputEnvelope = {
    data: Enumerable<KurtasDescriptionCreateManyCommonDescriptionInput>
    skipDuplicates?: boolean
  }

  export type ShoesDescriptionCreateWithoutCommonDescriptionInput = {
    pattern?: string | null
    footLength: string
    type: string
    soleMaterial?: string | null
    printAndPattern?: string | null
    upperMaterial?: string | null
    closure?: string | null
    toeType: string
    weight?: number | null
    colorFamily?: string | null
    productDescription?: string | null
    packageContains?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    warranty?: WarrantyCreateNestedManyWithoutShoesDescriptionInput
  }

  export type ShoesDescriptionUncheckedCreateWithoutCommonDescriptionInput = {
    id?: number
    pattern?: string | null
    footLength: string
    type: string
    soleMaterial?: string | null
    printAndPattern?: string | null
    upperMaterial?: string | null
    closure?: string | null
    toeType: string
    weight?: number | null
    colorFamily?: string | null
    productDescription?: string | null
    packageContains?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    warranty?: WarrantyUncheckedCreateNestedManyWithoutShoesDescriptionInput
  }

  export type ShoesDescriptionCreateOrConnectWithoutCommonDescriptionInput = {
    where: ShoesDescriptionWhereUniqueInput
    create: XOR<ShoesDescriptionCreateWithoutCommonDescriptionInput, ShoesDescriptionUncheckedCreateWithoutCommonDescriptionInput>
  }

  export type ShoesDescriptionCreateManyCommonDescriptionInputEnvelope = {
    data: Enumerable<ShoesDescriptionCreateManyCommonDescriptionInput>
    skipDuplicates?: boolean
  }

  export type InnersDescriptionCreateWithoutCommonDescriptionInput = {
    type: string
    productDescription: string
    weight?: number | null
    length: number
    waistRise: number
    printAndPattern?: string | null
    packageContains: number
    lookAndFeel: string
    colorFamily?: string | null
    multiColors?: boolean
    sleeveType?: SleeveTypeCreateNestedOneWithoutInnersDescriptionInput
    neckType?: NeckTypeCreateNestedOneWithoutInnersDescriptionInput
  }

  export type InnersDescriptionUncheckedCreateWithoutCommonDescriptionInput = {
    id?: number
    type: string
    productDescription: string
    weight?: number | null
    length: number
    waistRise: number
    printAndPattern?: string | null
    packageContains: number
    lookAndFeel: string
    colorFamily?: string | null
    vestsSleeveTypeId?: number | null
    vestsNeckTypeId?: number | null
    multiColors?: boolean
  }

  export type InnersDescriptionCreateOrConnectWithoutCommonDescriptionInput = {
    where: InnersDescriptionWhereUniqueInput
    create: XOR<InnersDescriptionCreateWithoutCommonDescriptionInput, InnersDescriptionUncheckedCreateWithoutCommonDescriptionInput>
  }

  export type InnersDescriptionCreateManyCommonDescriptionInputEnvelope = {
    data: Enumerable<InnersDescriptionCreateManyCommonDescriptionInput>
    skipDuplicates?: boolean
  }

  export type WatchesDescriptionCreateWithoutCommonDescriptionInput = {
    type?: string | null
    weight: number
    model: string
    dialShape: string
    printAndPattern?: string | null
    dialDiameter: string
    dialColor: string
    strapColor: string
    colorFamily?: string | null
    productDescription?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    warranty?: WarrantyCreateNestedManyWithoutWatchesInput
  }

  export type WatchesDescriptionUncheckedCreateWithoutCommonDescriptionInput = {
    id?: number
    type?: string | null
    weight: number
    model: string
    dialShape: string
    printAndPattern?: string | null
    dialDiameter: string
    dialColor: string
    strapColor: string
    colorFamily?: string | null
    productDescription?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    warranty?: WarrantyUncheckedCreateNestedManyWithoutWatchesInput
  }

  export type WatchesDescriptionCreateOrConnectWithoutCommonDescriptionInput = {
    where: WatchesDescriptionWhereUniqueInput
    create: XOR<WatchesDescriptionCreateWithoutCommonDescriptionInput, WatchesDescriptionUncheckedCreateWithoutCommonDescriptionInput>
  }

  export type WatchesDescriptionCreateManyCommonDescriptionInputEnvelope = {
    data: Enumerable<WatchesDescriptionCreateManyCommonDescriptionInput>
    skipDuplicates?: boolean
  }

  export type PerfumesDescriptionCreateWithoutCommonDescriptionInput = {
    productDescription: string
    type?: string | null
    materialDescription: string
    weight: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PerfumesDescriptionUncheckedCreateWithoutCommonDescriptionInput = {
    id?: number
    productDescription: string
    type?: string | null
    materialDescription: string
    weight: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PerfumesDescriptionCreateOrConnectWithoutCommonDescriptionInput = {
    where: PerfumesDescriptionWhereUniqueInput
    create: XOR<PerfumesDescriptionCreateWithoutCommonDescriptionInput, PerfumesDescriptionUncheckedCreateWithoutCommonDescriptionInput>
  }

  export type PerfumesDescriptionCreateManyCommonDescriptionInputEnvelope = {
    data: Enumerable<PerfumesDescriptionCreateManyCommonDescriptionInput>
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithoutCommonDescriptionInput = {
    update: XOR<ProductUpdateWithoutCommonDescriptionInput, ProductUncheckedUpdateWithoutCommonDescriptionInput>
    create: XOR<ProductCreateWithoutCommonDescriptionInput, ProductUncheckedCreateWithoutCommonDescriptionInput>
  }

  export type ProductUpdateWithoutCommonDescriptionInput = {
    syncId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    color?: ProductColorUpdateManyWithoutProductNestedInput
    offer?: OfferUpdateManyWithoutProductNestedInput
    seasonalDresses?: SeasonalDressesUpdateManyWithoutProductNestedInput
    productType?: ProductTypeUpdateOneRequiredWithoutProductNestedInput
    user?: UserUpdateOneWithoutUserProductNestedInput
    priceHistory?: PriceHistoryUpdateManyWithoutProductNestedInput
    delivery?: DeleveryPeriodUpdateManyWithoutProductNestedInput
    returns?: ReturnedProductUpdateManyWithoutProductNestedInput
    cart?: CartUpdateManyWithoutProductNestedInput
    wishlistItem?: WishlistItemUpdateManyWithoutProductNestedInput
    productReviews?: ProductReviewUpdateManyWithoutProductNestedInput
    order?: OrderUpdateManyWithoutProductNestedInput
    productOwner?: ProductOwnerUpdateOneWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutCommonDescriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    syncId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    productTypeId?: IntFieldUpdateOperationsInput | number
    productOwnerId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    color?: ProductColorUncheckedUpdateManyWithoutProductNestedInput
    offer?: OfferUncheckedUpdateManyWithoutProductNestedInput
    seasonalDresses?: SeasonalDressesUncheckedUpdateManyWithoutProductNestedInput
    priceHistory?: PriceHistoryUncheckedUpdateManyWithoutProductNestedInput
    delivery?: DeleveryPeriodUncheckedUpdateManyWithoutProductNestedInput
    returns?: ReturnedProductUncheckedUpdateManyWithoutProductNestedInput
    cart?: CartUncheckedUpdateManyWithoutProductNestedInput
    wishlistItem?: WishlistItemUncheckedUpdateManyWithoutProductNestedInput
    productReviews?: ProductReviewUncheckedUpdateManyWithoutProductNestedInput
    order?: OrderUncheckedUpdateManyWithoutProductNestedInput
  }

  export type TopDescriptionUpsertWithWhereUniqueWithoutCommonDescriptionInput = {
    where: TopDescriptionWhereUniqueInput
    update: XOR<TopDescriptionUpdateWithoutCommonDescriptionInput, TopDescriptionUncheckedUpdateWithoutCommonDescriptionInput>
    create: XOR<TopDescriptionCreateWithoutCommonDescriptionInput, TopDescriptionUncheckedCreateWithoutCommonDescriptionInput>
  }

  export type TopDescriptionUpdateWithWhereUniqueWithoutCommonDescriptionInput = {
    where: TopDescriptionWhereUniqueInput
    data: XOR<TopDescriptionUpdateWithoutCommonDescriptionInput, TopDescriptionUncheckedUpdateWithoutCommonDescriptionInput>
  }

  export type TopDescriptionUpdateManyWithWhereWithoutCommonDescriptionInput = {
    where: TopDescriptionScalarWhereInput
    data: XOR<TopDescriptionUpdateManyMutationInput, TopDescriptionUncheckedUpdateManyWithoutTopDescriptionInput>
  }

  export type TopDescriptionScalarWhereInput = {
    AND?: Enumerable<TopDescriptionScalarWhereInput>
    OR?: Enumerable<TopDescriptionScalarWhereInput>
    NOT?: Enumerable<TopDescriptionScalarWhereInput>
    id?: IntFilter | number
    productDescription?: StringNullableFilter | string | null
    sleeveTypeId?: IntFilter | number
    weight?: IntNullableFilter | number | null
    chest?: IntFilter | number
    shoulder?: IntFilter | number
    neckTypeId?: IntFilter | number
    type?: StringNullableFilter | string | null
    colorFamily?: StringNullableFilter | string | null
    printAndPattern?: StringNullableFilter | string | null
    length?: IntFilter | number
    pocket?: StringFilter | string
    commonDescriptionId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type BottomDescriptionUpsertWithWhereUniqueWithoutCommonDescriptionInput = {
    where: BottomDescriptionWhereUniqueInput
    update: XOR<BottomDescriptionUpdateWithoutCommonDescriptionInput, BottomDescriptionUncheckedUpdateWithoutCommonDescriptionInput>
    create: XOR<BottomDescriptionCreateWithoutCommonDescriptionInput, BottomDescriptionUncheckedCreateWithoutCommonDescriptionInput>
  }

  export type BottomDescriptionUpdateWithWhereUniqueWithoutCommonDescriptionInput = {
    where: BottomDescriptionWhereUniqueInput
    data: XOR<BottomDescriptionUpdateWithoutCommonDescriptionInput, BottomDescriptionUncheckedUpdateWithoutCommonDescriptionInput>
  }

  export type BottomDescriptionUpdateManyWithWhereWithoutCommonDescriptionInput = {
    where: BottomDescriptionScalarWhereInput
    data: XOR<BottomDescriptionUpdateManyMutationInput, BottomDescriptionUncheckedUpdateManyWithoutPantDescriptionInput>
  }

  export type BottomDescriptionScalarWhereInput = {
    AND?: Enumerable<BottomDescriptionScalarWhereInput>
    OR?: Enumerable<BottomDescriptionScalarWhereInput>
    NOT?: Enumerable<BottomDescriptionScalarWhereInput>
    id?: IntFilter | number
    productDescription?: StringNullableFilter | string | null
    weight?: IntNullableFilter | number | null
    printAndPattern?: StringFilter | string
    length?: IntFilter | number
    waist?: IntFilter | number
    hip?: IntFilter | number
    commonDescriptionId?: IntFilter | number
    type?: StringNullableFilter | string | null
    colorFamily?: StringNullableFilter | string | null
    pocket?: StringNullableFilter | string | null
    kurtasDescriptionId?: IntNullableFilter | number | null
    topDescriptionId?: IntNullableFilter | number | null
    beltLoop?: BoolFilter | boolean
    typeOfPantId?: IntFilter | number
    typesOfPleatsId?: IntFilter | number
    typesOfLengthId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type KurtasDescriptionUpsertWithWhereUniqueWithoutCommonDescriptionInput = {
    where: KurtasDescriptionWhereUniqueInput
    update: XOR<KurtasDescriptionUpdateWithoutCommonDescriptionInput, KurtasDescriptionUncheckedUpdateWithoutCommonDescriptionInput>
    create: XOR<KurtasDescriptionCreateWithoutCommonDescriptionInput, KurtasDescriptionUncheckedCreateWithoutCommonDescriptionInput>
  }

  export type KurtasDescriptionUpdateWithWhereUniqueWithoutCommonDescriptionInput = {
    where: KurtasDescriptionWhereUniqueInput
    data: XOR<KurtasDescriptionUpdateWithoutCommonDescriptionInput, KurtasDescriptionUncheckedUpdateWithoutCommonDescriptionInput>
  }

  export type KurtasDescriptionUpdateManyWithWhereWithoutCommonDescriptionInput = {
    where: KurtasDescriptionScalarWhereInput
    data: XOR<KurtasDescriptionUpdateManyMutationInput, KurtasDescriptionUncheckedUpdateManyWithoutKurtasDescriptionInput>
  }

  export type KurtasDescriptionScalarWhereInput = {
    AND?: Enumerable<KurtasDescriptionScalarWhereInput>
    OR?: Enumerable<KurtasDescriptionScalarWhereInput>
    NOT?: Enumerable<KurtasDescriptionScalarWhereInput>
    id?: IntFilter | number
    work?: StringNullableFilter | string | null
    productDescription?: StringFilter | string
    chest?: IntFilter | number
    shoulder?: IntFilter | number
    transparencyOfTheFabric?: BoolFilter | boolean
    kurtasLengthTypeId?: IntFilter | number
    weight?: IntNullableFilter | number | null
    colorFamily?: StringNullableFilter | string | null
    pocket?: StringFilter | string
    type?: StringFilter | string
    printAndpattern?: StringNullableFilter | string | null
    kurtasNeckTypeId?: IntFilter | number
    kurtasSleeveTypeId?: IntFilter | number
    commonDescriptionId?: IntFilter | number
    isActive?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type ShoesDescriptionUpsertWithWhereUniqueWithoutCommonDescriptionInput = {
    where: ShoesDescriptionWhereUniqueInput
    update: XOR<ShoesDescriptionUpdateWithoutCommonDescriptionInput, ShoesDescriptionUncheckedUpdateWithoutCommonDescriptionInput>
    create: XOR<ShoesDescriptionCreateWithoutCommonDescriptionInput, ShoesDescriptionUncheckedCreateWithoutCommonDescriptionInput>
  }

  export type ShoesDescriptionUpdateWithWhereUniqueWithoutCommonDescriptionInput = {
    where: ShoesDescriptionWhereUniqueInput
    data: XOR<ShoesDescriptionUpdateWithoutCommonDescriptionInput, ShoesDescriptionUncheckedUpdateWithoutCommonDescriptionInput>
  }

  export type ShoesDescriptionUpdateManyWithWhereWithoutCommonDescriptionInput = {
    where: ShoesDescriptionScalarWhereInput
    data: XOR<ShoesDescriptionUpdateManyMutationInput, ShoesDescriptionUncheckedUpdateManyWithoutShoesDescriptionInput>
  }

  export type ShoesDescriptionScalarWhereInput = {
    AND?: Enumerable<ShoesDescriptionScalarWhereInput>
    OR?: Enumerable<ShoesDescriptionScalarWhereInput>
    NOT?: Enumerable<ShoesDescriptionScalarWhereInput>
    id?: IntFilter | number
    pattern?: StringNullableFilter | string | null
    footLength?: StringFilter | string
    type?: StringFilter | string
    soleMaterial?: StringNullableFilter | string | null
    printAndPattern?: StringNullableFilter | string | null
    upperMaterial?: StringNullableFilter | string | null
    closure?: StringNullableFilter | string | null
    toeType?: StringFilter | string
    weight?: IntNullableFilter | number | null
    colorFamily?: StringNullableFilter | string | null
    productDescription?: StringNullableFilter | string | null
    packageContains?: IntNullableFilter | number | null
    commonDescriptionId?: IntFilter | number
    isActive?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type InnersDescriptionUpsertWithWhereUniqueWithoutCommonDescriptionInput = {
    where: InnersDescriptionWhereUniqueInput
    update: XOR<InnersDescriptionUpdateWithoutCommonDescriptionInput, InnersDescriptionUncheckedUpdateWithoutCommonDescriptionInput>
    create: XOR<InnersDescriptionCreateWithoutCommonDescriptionInput, InnersDescriptionUncheckedCreateWithoutCommonDescriptionInput>
  }

  export type InnersDescriptionUpdateWithWhereUniqueWithoutCommonDescriptionInput = {
    where: InnersDescriptionWhereUniqueInput
    data: XOR<InnersDescriptionUpdateWithoutCommonDescriptionInput, InnersDescriptionUncheckedUpdateWithoutCommonDescriptionInput>
  }

  export type InnersDescriptionUpdateManyWithWhereWithoutCommonDescriptionInput = {
    where: InnersDescriptionScalarWhereInput
    data: XOR<InnersDescriptionUpdateManyMutationInput, InnersDescriptionUncheckedUpdateManyWithoutInnerDescriptionInput>
  }

  export type InnersDescriptionScalarWhereInput = {
    AND?: Enumerable<InnersDescriptionScalarWhereInput>
    OR?: Enumerable<InnersDescriptionScalarWhereInput>
    NOT?: Enumerable<InnersDescriptionScalarWhereInput>
    id?: IntFilter | number
    type?: StringFilter | string
    productDescription?: StringFilter | string
    weight?: IntNullableFilter | number | null
    length?: IntFilter | number
    waistRise?: IntFilter | number
    printAndPattern?: StringNullableFilter | string | null
    packageContains?: IntFilter | number
    lookAndFeel?: StringFilter | string
    colorFamily?: StringNullableFilter | string | null
    vestsSleeveTypeId?: IntNullableFilter | number | null
    vestsNeckTypeId?: IntNullableFilter | number | null
    commonDescriptionId?: IntFilter | number
    multiColors?: BoolFilter | boolean
  }

  export type WatchesDescriptionUpsertWithWhereUniqueWithoutCommonDescriptionInput = {
    where: WatchesDescriptionWhereUniqueInput
    update: XOR<WatchesDescriptionUpdateWithoutCommonDescriptionInput, WatchesDescriptionUncheckedUpdateWithoutCommonDescriptionInput>
    create: XOR<WatchesDescriptionCreateWithoutCommonDescriptionInput, WatchesDescriptionUncheckedCreateWithoutCommonDescriptionInput>
  }

  export type WatchesDescriptionUpdateWithWhereUniqueWithoutCommonDescriptionInput = {
    where: WatchesDescriptionWhereUniqueInput
    data: XOR<WatchesDescriptionUpdateWithoutCommonDescriptionInput, WatchesDescriptionUncheckedUpdateWithoutCommonDescriptionInput>
  }

  export type WatchesDescriptionUpdateManyWithWhereWithoutCommonDescriptionInput = {
    where: WatchesDescriptionScalarWhereInput
    data: XOR<WatchesDescriptionUpdateManyMutationInput, WatchesDescriptionUncheckedUpdateManyWithoutWatchesDescriptionInput>
  }

  export type WatchesDescriptionScalarWhereInput = {
    AND?: Enumerable<WatchesDescriptionScalarWhereInput>
    OR?: Enumerable<WatchesDescriptionScalarWhereInput>
    NOT?: Enumerable<WatchesDescriptionScalarWhereInput>
    id?: IntFilter | number
    type?: StringNullableFilter | string | null
    weight?: IntFilter | number
    model?: StringFilter | string
    dialShape?: StringFilter | string
    printAndPattern?: StringNullableFilter | string | null
    dialDiameter?: StringFilter | string
    dialColor?: StringFilter | string
    strapColor?: StringFilter | string
    colorFamily?: StringNullableFilter | string | null
    productDescription?: StringNullableFilter | string | null
    commonDescriptionId?: IntFilter | number
    isActive?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type PerfumesDescriptionUpsertWithWhereUniqueWithoutCommonDescriptionInput = {
    where: PerfumesDescriptionWhereUniqueInput
    update: XOR<PerfumesDescriptionUpdateWithoutCommonDescriptionInput, PerfumesDescriptionUncheckedUpdateWithoutCommonDescriptionInput>
    create: XOR<PerfumesDescriptionCreateWithoutCommonDescriptionInput, PerfumesDescriptionUncheckedCreateWithoutCommonDescriptionInput>
  }

  export type PerfumesDescriptionUpdateWithWhereUniqueWithoutCommonDescriptionInput = {
    where: PerfumesDescriptionWhereUniqueInput
    data: XOR<PerfumesDescriptionUpdateWithoutCommonDescriptionInput, PerfumesDescriptionUncheckedUpdateWithoutCommonDescriptionInput>
  }

  export type PerfumesDescriptionUpdateManyWithWhereWithoutCommonDescriptionInput = {
    where: PerfumesDescriptionScalarWhereInput
    data: XOR<PerfumesDescriptionUpdateManyMutationInput, PerfumesDescriptionUncheckedUpdateManyWithoutPerfumesDescriptionInput>
  }

  export type PerfumesDescriptionScalarWhereInput = {
    AND?: Enumerable<PerfumesDescriptionScalarWhereInput>
    OR?: Enumerable<PerfumesDescriptionScalarWhereInput>
    NOT?: Enumerable<PerfumesDescriptionScalarWhereInput>
    id?: IntFilter | number
    productDescription?: StringFilter | string
    type?: StringNullableFilter | string | null
    materialDescription?: StringFilter | string
    weight?: IntFilter | number
    commonDescriptionId?: IntFilter | number
    isActive?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type CommonDescriptionCreateWithoutTopDescriptionInput = {
    fit?: string | null
    materail: string
    care: string
    brandName: string
    origin: string
    occasion: string
    specialFeature?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    product: ProductCreateNestedOneWithoutCommonDescriptionInput
    pantDescription?: BottomDescriptionCreateNestedManyWithoutCommonDescriptionInput
    kurtasDescription?: KurtasDescriptionCreateNestedManyWithoutCommonDescriptionInput
    shoesDescription?: ShoesDescriptionCreateNestedManyWithoutCommonDescriptionInput
    innerDescription?: InnersDescriptionCreateNestedManyWithoutCommonDescriptionInput
    watchesDescription?: WatchesDescriptionCreateNestedManyWithoutCommonDescriptionInput
    perfumesDescription?: PerfumesDescriptionCreateNestedManyWithoutCommonDescriptionInput
  }

  export type CommonDescriptionUncheckedCreateWithoutTopDescriptionInput = {
    id?: number
    fit?: string | null
    materail: string
    care: string
    brandName: string
    origin: string
    productId: number
    occasion: string
    specialFeature?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    pantDescription?: BottomDescriptionUncheckedCreateNestedManyWithoutCommonDescriptionInput
    kurtasDescription?: KurtasDescriptionUncheckedCreateNestedManyWithoutCommonDescriptionInput
    shoesDescription?: ShoesDescriptionUncheckedCreateNestedManyWithoutCommonDescriptionInput
    innerDescription?: InnersDescriptionUncheckedCreateNestedManyWithoutCommonDescriptionInput
    watchesDescription?: WatchesDescriptionUncheckedCreateNestedManyWithoutCommonDescriptionInput
    perfumesDescription?: PerfumesDescriptionUncheckedCreateNestedManyWithoutCommonDescriptionInput
  }

  export type CommonDescriptionCreateOrConnectWithoutTopDescriptionInput = {
    where: CommonDescriptionWhereUniqueInput
    create: XOR<CommonDescriptionCreateWithoutTopDescriptionInput, CommonDescriptionUncheckedCreateWithoutTopDescriptionInput>
  }

  export type SleeveTypeCreateWithoutTopDescriptionInput = {
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    kurtasDescription?: KurtasDescriptionCreateNestedManyWithoutSleeveTypeInput
    innersDescription?: InnersDescriptionCreateNestedManyWithoutSleeveTypeInput
  }

  export type SleeveTypeUncheckedCreateWithoutTopDescriptionInput = {
    id?: number
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    kurtasDescription?: KurtasDescriptionUncheckedCreateNestedManyWithoutSleeveTypeInput
    innersDescription?: InnersDescriptionUncheckedCreateNestedManyWithoutSleeveTypeInput
  }

  export type SleeveTypeCreateOrConnectWithoutTopDescriptionInput = {
    where: SleeveTypeWhereUniqueInput
    create: XOR<SleeveTypeCreateWithoutTopDescriptionInput, SleeveTypeUncheckedCreateWithoutTopDescriptionInput>
  }

  export type NeckTypeCreateWithoutTopDescriptionInput = {
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    kurtasDescription?: KurtasDescriptionCreateNestedManyWithoutNeckTypeInput
    innersDescription?: InnersDescriptionCreateNestedManyWithoutNeckTypeInput
  }

  export type NeckTypeUncheckedCreateWithoutTopDescriptionInput = {
    id?: number
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    kurtasDescription?: KurtasDescriptionUncheckedCreateNestedManyWithoutNeckTypeInput
    innersDescription?: InnersDescriptionUncheckedCreateNestedManyWithoutNeckTypeInput
  }

  export type NeckTypeCreateOrConnectWithoutTopDescriptionInput = {
    where: NeckTypeWhereUniqueInput
    create: XOR<NeckTypeCreateWithoutTopDescriptionInput, NeckTypeUncheckedCreateWithoutTopDescriptionInput>
  }

  export type BottomDescriptionCreateWithoutTopDescriptionInput = {
    productDescription?: string | null
    weight?: number | null
    printAndPattern: string
    length: number
    waist: number
    hip: number
    type?: string | null
    colorFamily?: string | null
    pocket?: string | null
    beltLoop?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    typesOfPants: TypesOfBottomCreateNestedOneWithoutDescriptionInput
    typesOfPleats: TypesOfPleatsCreateNestedOneWithoutDescriptionInput
    typesOfLength: TypesOfLengthBottomCreateNestedOneWithoutDescriptionInput
    commonDescription: CommonDescriptionCreateNestedOneWithoutPantDescriptionInput
    kurtasDescription?: KurtasDescriptionCreateNestedOneWithoutBottomDescriptionInput
  }

  export type BottomDescriptionUncheckedCreateWithoutTopDescriptionInput = {
    id?: number
    productDescription?: string | null
    weight?: number | null
    printAndPattern: string
    length: number
    waist: number
    hip: number
    commonDescriptionId: number
    type?: string | null
    colorFamily?: string | null
    pocket?: string | null
    kurtasDescriptionId?: number | null
    beltLoop?: boolean
    typeOfPantId: number
    typesOfPleatsId: number
    typesOfLengthId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type BottomDescriptionCreateOrConnectWithoutTopDescriptionInput = {
    where: BottomDescriptionWhereUniqueInput
    create: XOR<BottomDescriptionCreateWithoutTopDescriptionInput, BottomDescriptionUncheckedCreateWithoutTopDescriptionInput>
  }

  export type BottomDescriptionCreateManyTopDescriptionInputEnvelope = {
    data: Enumerable<BottomDescriptionCreateManyTopDescriptionInput>
    skipDuplicates?: boolean
  }

  export type CommonDescriptionUpsertWithoutTopDescriptionInput = {
    update: XOR<CommonDescriptionUpdateWithoutTopDescriptionInput, CommonDescriptionUncheckedUpdateWithoutTopDescriptionInput>
    create: XOR<CommonDescriptionCreateWithoutTopDescriptionInput, CommonDescriptionUncheckedCreateWithoutTopDescriptionInput>
  }

  export type CommonDescriptionUpdateWithoutTopDescriptionInput = {
    fit?: NullableStringFieldUpdateOperationsInput | string | null
    materail?: StringFieldUpdateOperationsInput | string
    care?: StringFieldUpdateOperationsInput | string
    brandName?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    occasion?: StringFieldUpdateOperationsInput | string
    specialFeature?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    product?: ProductUpdateOneRequiredWithoutCommonDescriptionNestedInput
    pantDescription?: BottomDescriptionUpdateManyWithoutCommonDescriptionNestedInput
    kurtasDescription?: KurtasDescriptionUpdateManyWithoutCommonDescriptionNestedInput
    shoesDescription?: ShoesDescriptionUpdateManyWithoutCommonDescriptionNestedInput
    innerDescription?: InnersDescriptionUpdateManyWithoutCommonDescriptionNestedInput
    watchesDescription?: WatchesDescriptionUpdateManyWithoutCommonDescriptionNestedInput
    perfumesDescription?: PerfumesDescriptionUpdateManyWithoutCommonDescriptionNestedInput
  }

  export type CommonDescriptionUncheckedUpdateWithoutTopDescriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    fit?: NullableStringFieldUpdateOperationsInput | string | null
    materail?: StringFieldUpdateOperationsInput | string
    care?: StringFieldUpdateOperationsInput | string
    brandName?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    productId?: IntFieldUpdateOperationsInput | number
    occasion?: StringFieldUpdateOperationsInput | string
    specialFeature?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pantDescription?: BottomDescriptionUncheckedUpdateManyWithoutCommonDescriptionNestedInput
    kurtasDescription?: KurtasDescriptionUncheckedUpdateManyWithoutCommonDescriptionNestedInput
    shoesDescription?: ShoesDescriptionUncheckedUpdateManyWithoutCommonDescriptionNestedInput
    innerDescription?: InnersDescriptionUncheckedUpdateManyWithoutCommonDescriptionNestedInput
    watchesDescription?: WatchesDescriptionUncheckedUpdateManyWithoutCommonDescriptionNestedInput
    perfumesDescription?: PerfumesDescriptionUncheckedUpdateManyWithoutCommonDescriptionNestedInput
  }

  export type SleeveTypeUpsertWithoutTopDescriptionInput = {
    update: XOR<SleeveTypeUpdateWithoutTopDescriptionInput, SleeveTypeUncheckedUpdateWithoutTopDescriptionInput>
    create: XOR<SleeveTypeCreateWithoutTopDescriptionInput, SleeveTypeUncheckedCreateWithoutTopDescriptionInput>
  }

  export type SleeveTypeUpdateWithoutTopDescriptionInput = {
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kurtasDescription?: KurtasDescriptionUpdateManyWithoutSleeveTypeNestedInput
    innersDescription?: InnersDescriptionUpdateManyWithoutSleeveTypeNestedInput
  }

  export type SleeveTypeUncheckedUpdateWithoutTopDescriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kurtasDescription?: KurtasDescriptionUncheckedUpdateManyWithoutSleeveTypeNestedInput
    innersDescription?: InnersDescriptionUncheckedUpdateManyWithoutSleeveTypeNestedInput
  }

  export type NeckTypeUpsertWithoutTopDescriptionInput = {
    update: XOR<NeckTypeUpdateWithoutTopDescriptionInput, NeckTypeUncheckedUpdateWithoutTopDescriptionInput>
    create: XOR<NeckTypeCreateWithoutTopDescriptionInput, NeckTypeUncheckedCreateWithoutTopDescriptionInput>
  }

  export type NeckTypeUpdateWithoutTopDescriptionInput = {
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kurtasDescription?: KurtasDescriptionUpdateManyWithoutNeckTypeNestedInput
    innersDescription?: InnersDescriptionUpdateManyWithoutNeckTypeNestedInput
  }

  export type NeckTypeUncheckedUpdateWithoutTopDescriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kurtasDescription?: KurtasDescriptionUncheckedUpdateManyWithoutNeckTypeNestedInput
    innersDescription?: InnersDescriptionUncheckedUpdateManyWithoutNeckTypeNestedInput
  }

  export type BottomDescriptionUpsertWithWhereUniqueWithoutTopDescriptionInput = {
    where: BottomDescriptionWhereUniqueInput
    update: XOR<BottomDescriptionUpdateWithoutTopDescriptionInput, BottomDescriptionUncheckedUpdateWithoutTopDescriptionInput>
    create: XOR<BottomDescriptionCreateWithoutTopDescriptionInput, BottomDescriptionUncheckedCreateWithoutTopDescriptionInput>
  }

  export type BottomDescriptionUpdateWithWhereUniqueWithoutTopDescriptionInput = {
    where: BottomDescriptionWhereUniqueInput
    data: XOR<BottomDescriptionUpdateWithoutTopDescriptionInput, BottomDescriptionUncheckedUpdateWithoutTopDescriptionInput>
  }

  export type BottomDescriptionUpdateManyWithWhereWithoutTopDescriptionInput = {
    where: BottomDescriptionScalarWhereInput
    data: XOR<BottomDescriptionUpdateManyMutationInput, BottomDescriptionUncheckedUpdateManyWithoutBottomDescriptionInput>
  }

  export type TypesOfBottomCreateWithoutDescriptionInput = {
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type TypesOfBottomUncheckedCreateWithoutDescriptionInput = {
    id?: number
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type TypesOfBottomCreateOrConnectWithoutDescriptionInput = {
    where: TypesOfBottomWhereUniqueInput
    create: XOR<TypesOfBottomCreateWithoutDescriptionInput, TypesOfBottomUncheckedCreateWithoutDescriptionInput>
  }

  export type TypesOfPleatsCreateWithoutDescriptionInput = {
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type TypesOfPleatsUncheckedCreateWithoutDescriptionInput = {
    id?: number
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type TypesOfPleatsCreateOrConnectWithoutDescriptionInput = {
    where: TypesOfPleatsWhereUniqueInput
    create: XOR<TypesOfPleatsCreateWithoutDescriptionInput, TypesOfPleatsUncheckedCreateWithoutDescriptionInput>
  }

  export type TypesOfLengthBottomCreateWithoutDescriptionInput = {
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type TypesOfLengthBottomUncheckedCreateWithoutDescriptionInput = {
    id?: number
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type TypesOfLengthBottomCreateOrConnectWithoutDescriptionInput = {
    where: TypesOfLengthBottomWhereUniqueInput
    create: XOR<TypesOfLengthBottomCreateWithoutDescriptionInput, TypesOfLengthBottomUncheckedCreateWithoutDescriptionInput>
  }

  export type CommonDescriptionCreateWithoutPantDescriptionInput = {
    fit?: string | null
    materail: string
    care: string
    brandName: string
    origin: string
    occasion: string
    specialFeature?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    product: ProductCreateNestedOneWithoutCommonDescriptionInput
    topDescription?: TopDescriptionCreateNestedManyWithoutCommonDescriptionInput
    kurtasDescription?: KurtasDescriptionCreateNestedManyWithoutCommonDescriptionInput
    shoesDescription?: ShoesDescriptionCreateNestedManyWithoutCommonDescriptionInput
    innerDescription?: InnersDescriptionCreateNestedManyWithoutCommonDescriptionInput
    watchesDescription?: WatchesDescriptionCreateNestedManyWithoutCommonDescriptionInput
    perfumesDescription?: PerfumesDescriptionCreateNestedManyWithoutCommonDescriptionInput
  }

  export type CommonDescriptionUncheckedCreateWithoutPantDescriptionInput = {
    id?: number
    fit?: string | null
    materail: string
    care: string
    brandName: string
    origin: string
    productId: number
    occasion: string
    specialFeature?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    topDescription?: TopDescriptionUncheckedCreateNestedManyWithoutCommonDescriptionInput
    kurtasDescription?: KurtasDescriptionUncheckedCreateNestedManyWithoutCommonDescriptionInput
    shoesDescription?: ShoesDescriptionUncheckedCreateNestedManyWithoutCommonDescriptionInput
    innerDescription?: InnersDescriptionUncheckedCreateNestedManyWithoutCommonDescriptionInput
    watchesDescription?: WatchesDescriptionUncheckedCreateNestedManyWithoutCommonDescriptionInput
    perfumesDescription?: PerfumesDescriptionUncheckedCreateNestedManyWithoutCommonDescriptionInput
  }

  export type CommonDescriptionCreateOrConnectWithoutPantDescriptionInput = {
    where: CommonDescriptionWhereUniqueInput
    create: XOR<CommonDescriptionCreateWithoutPantDescriptionInput, CommonDescriptionUncheckedCreateWithoutPantDescriptionInput>
  }

  export type KurtasDescriptionCreateWithoutBottomDescriptionInput = {
    work?: string | null
    productDescription: string
    chest: number
    shoulder: number
    transparencyOfTheFabric?: boolean
    weight?: number | null
    colorFamily?: string | null
    pocket: string
    type: string
    printAndpattern?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    kurtasLengthType: KurtasLengthTypeCreateNestedOneWithoutKurtasDescriptionInput
    neckType: NeckTypeCreateNestedOneWithoutKurtasDescriptionInput
    sleeveType: SleeveTypeCreateNestedOneWithoutKurtasDescriptionInput
    commonDescription: CommonDescriptionCreateNestedOneWithoutKurtasDescriptionInput
  }

  export type KurtasDescriptionUncheckedCreateWithoutBottomDescriptionInput = {
    id?: number
    work?: string | null
    productDescription: string
    chest: number
    shoulder: number
    transparencyOfTheFabric?: boolean
    kurtasLengthTypeId: number
    weight?: number | null
    colorFamily?: string | null
    pocket: string
    type: string
    printAndpattern?: string | null
    kurtasNeckTypeId: number
    kurtasSleeveTypeId: number
    commonDescriptionId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type KurtasDescriptionCreateOrConnectWithoutBottomDescriptionInput = {
    where: KurtasDescriptionWhereUniqueInput
    create: XOR<KurtasDescriptionCreateWithoutBottomDescriptionInput, KurtasDescriptionUncheckedCreateWithoutBottomDescriptionInput>
  }

  export type TopDescriptionCreateWithoutBottomDescriptionInput = {
    productDescription?: string | null
    weight?: number | null
    chest: number
    shoulder: number
    type?: string | null
    colorFamily?: string | null
    printAndPattern?: string | null
    length: number
    pocket: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    commonDescription?: CommonDescriptionCreateNestedOneWithoutTopDescriptionInput
    sleeveType: SleeveTypeCreateNestedOneWithoutTopDescriptionInput
    neckType: NeckTypeCreateNestedOneWithoutTopDescriptionInput
  }

  export type TopDescriptionUncheckedCreateWithoutBottomDescriptionInput = {
    id?: number
    productDescription?: string | null
    sleeveTypeId: number
    weight?: number | null
    chest: number
    shoulder: number
    neckTypeId: number
    type?: string | null
    colorFamily?: string | null
    printAndPattern?: string | null
    length: number
    pocket: string
    commonDescriptionId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type TopDescriptionCreateOrConnectWithoutBottomDescriptionInput = {
    where: TopDescriptionWhereUniqueInput
    create: XOR<TopDescriptionCreateWithoutBottomDescriptionInput, TopDescriptionUncheckedCreateWithoutBottomDescriptionInput>
  }

  export type TypesOfBottomUpsertWithoutDescriptionInput = {
    update: XOR<TypesOfBottomUpdateWithoutDescriptionInput, TypesOfBottomUncheckedUpdateWithoutDescriptionInput>
    create: XOR<TypesOfBottomCreateWithoutDescriptionInput, TypesOfBottomUncheckedCreateWithoutDescriptionInput>
  }

  export type TypesOfBottomUpdateWithoutDescriptionInput = {
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TypesOfBottomUncheckedUpdateWithoutDescriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TypesOfPleatsUpsertWithoutDescriptionInput = {
    update: XOR<TypesOfPleatsUpdateWithoutDescriptionInput, TypesOfPleatsUncheckedUpdateWithoutDescriptionInput>
    create: XOR<TypesOfPleatsCreateWithoutDescriptionInput, TypesOfPleatsUncheckedCreateWithoutDescriptionInput>
  }

  export type TypesOfPleatsUpdateWithoutDescriptionInput = {
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TypesOfPleatsUncheckedUpdateWithoutDescriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TypesOfLengthBottomUpsertWithoutDescriptionInput = {
    update: XOR<TypesOfLengthBottomUpdateWithoutDescriptionInput, TypesOfLengthBottomUncheckedUpdateWithoutDescriptionInput>
    create: XOR<TypesOfLengthBottomCreateWithoutDescriptionInput, TypesOfLengthBottomUncheckedCreateWithoutDescriptionInput>
  }

  export type TypesOfLengthBottomUpdateWithoutDescriptionInput = {
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TypesOfLengthBottomUncheckedUpdateWithoutDescriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CommonDescriptionUpsertWithoutPantDescriptionInput = {
    update: XOR<CommonDescriptionUpdateWithoutPantDescriptionInput, CommonDescriptionUncheckedUpdateWithoutPantDescriptionInput>
    create: XOR<CommonDescriptionCreateWithoutPantDescriptionInput, CommonDescriptionUncheckedCreateWithoutPantDescriptionInput>
  }

  export type CommonDescriptionUpdateWithoutPantDescriptionInput = {
    fit?: NullableStringFieldUpdateOperationsInput | string | null
    materail?: StringFieldUpdateOperationsInput | string
    care?: StringFieldUpdateOperationsInput | string
    brandName?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    occasion?: StringFieldUpdateOperationsInput | string
    specialFeature?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    product?: ProductUpdateOneRequiredWithoutCommonDescriptionNestedInput
    topDescription?: TopDescriptionUpdateManyWithoutCommonDescriptionNestedInput
    kurtasDescription?: KurtasDescriptionUpdateManyWithoutCommonDescriptionNestedInput
    shoesDescription?: ShoesDescriptionUpdateManyWithoutCommonDescriptionNestedInput
    innerDescription?: InnersDescriptionUpdateManyWithoutCommonDescriptionNestedInput
    watchesDescription?: WatchesDescriptionUpdateManyWithoutCommonDescriptionNestedInput
    perfumesDescription?: PerfumesDescriptionUpdateManyWithoutCommonDescriptionNestedInput
  }

  export type CommonDescriptionUncheckedUpdateWithoutPantDescriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    fit?: NullableStringFieldUpdateOperationsInput | string | null
    materail?: StringFieldUpdateOperationsInput | string
    care?: StringFieldUpdateOperationsInput | string
    brandName?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    productId?: IntFieldUpdateOperationsInput | number
    occasion?: StringFieldUpdateOperationsInput | string
    specialFeature?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    topDescription?: TopDescriptionUncheckedUpdateManyWithoutCommonDescriptionNestedInput
    kurtasDescription?: KurtasDescriptionUncheckedUpdateManyWithoutCommonDescriptionNestedInput
    shoesDescription?: ShoesDescriptionUncheckedUpdateManyWithoutCommonDescriptionNestedInput
    innerDescription?: InnersDescriptionUncheckedUpdateManyWithoutCommonDescriptionNestedInput
    watchesDescription?: WatchesDescriptionUncheckedUpdateManyWithoutCommonDescriptionNestedInput
    perfumesDescription?: PerfumesDescriptionUncheckedUpdateManyWithoutCommonDescriptionNestedInput
  }

  export type KurtasDescriptionUpsertWithoutBottomDescriptionInput = {
    update: XOR<KurtasDescriptionUpdateWithoutBottomDescriptionInput, KurtasDescriptionUncheckedUpdateWithoutBottomDescriptionInput>
    create: XOR<KurtasDescriptionCreateWithoutBottomDescriptionInput, KurtasDescriptionUncheckedCreateWithoutBottomDescriptionInput>
  }

  export type KurtasDescriptionUpdateWithoutBottomDescriptionInput = {
    work?: NullableStringFieldUpdateOperationsInput | string | null
    productDescription?: StringFieldUpdateOperationsInput | string
    chest?: IntFieldUpdateOperationsInput | number
    shoulder?: IntFieldUpdateOperationsInput | number
    transparencyOfTheFabric?: BoolFieldUpdateOperationsInput | boolean
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    pocket?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    printAndpattern?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kurtasLengthType?: KurtasLengthTypeUpdateOneRequiredWithoutKurtasDescriptionNestedInput
    neckType?: NeckTypeUpdateOneRequiredWithoutKurtasDescriptionNestedInput
    sleeveType?: SleeveTypeUpdateOneRequiredWithoutKurtasDescriptionNestedInput
    commonDescription?: CommonDescriptionUpdateOneRequiredWithoutKurtasDescriptionNestedInput
  }

  export type KurtasDescriptionUncheckedUpdateWithoutBottomDescriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    work?: NullableStringFieldUpdateOperationsInput | string | null
    productDescription?: StringFieldUpdateOperationsInput | string
    chest?: IntFieldUpdateOperationsInput | number
    shoulder?: IntFieldUpdateOperationsInput | number
    transparencyOfTheFabric?: BoolFieldUpdateOperationsInput | boolean
    kurtasLengthTypeId?: IntFieldUpdateOperationsInput | number
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    pocket?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    printAndpattern?: NullableStringFieldUpdateOperationsInput | string | null
    kurtasNeckTypeId?: IntFieldUpdateOperationsInput | number
    kurtasSleeveTypeId?: IntFieldUpdateOperationsInput | number
    commonDescriptionId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TopDescriptionUpsertWithoutBottomDescriptionInput = {
    update: XOR<TopDescriptionUpdateWithoutBottomDescriptionInput, TopDescriptionUncheckedUpdateWithoutBottomDescriptionInput>
    create: XOR<TopDescriptionCreateWithoutBottomDescriptionInput, TopDescriptionUncheckedCreateWithoutBottomDescriptionInput>
  }

  export type TopDescriptionUpdateWithoutBottomDescriptionInput = {
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    chest?: IntFieldUpdateOperationsInput | number
    shoulder?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    printAndPattern?: NullableStringFieldUpdateOperationsInput | string | null
    length?: IntFieldUpdateOperationsInput | number
    pocket?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commonDescription?: CommonDescriptionUpdateOneWithoutTopDescriptionNestedInput
    sleeveType?: SleeveTypeUpdateOneRequiredWithoutTopDescriptionNestedInput
    neckType?: NeckTypeUpdateOneRequiredWithoutTopDescriptionNestedInput
  }

  export type TopDescriptionUncheckedUpdateWithoutBottomDescriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    sleeveTypeId?: IntFieldUpdateOperationsInput | number
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    chest?: IntFieldUpdateOperationsInput | number
    shoulder?: IntFieldUpdateOperationsInput | number
    neckTypeId?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    printAndPattern?: NullableStringFieldUpdateOperationsInput | string | null
    length?: IntFieldUpdateOperationsInput | number
    pocket?: StringFieldUpdateOperationsInput | string
    commonDescriptionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type KurtasLengthTypeCreateWithoutKurtasDescriptionInput = {
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type KurtasLengthTypeUncheckedCreateWithoutKurtasDescriptionInput = {
    id?: number
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type KurtasLengthTypeCreateOrConnectWithoutKurtasDescriptionInput = {
    where: KurtasLengthTypeWhereUniqueInput
    create: XOR<KurtasLengthTypeCreateWithoutKurtasDescriptionInput, KurtasLengthTypeUncheckedCreateWithoutKurtasDescriptionInput>
  }

  export type NeckTypeCreateWithoutKurtasDescriptionInput = {
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    innersDescription?: InnersDescriptionCreateNestedManyWithoutNeckTypeInput
    topDescription?: TopDescriptionCreateNestedManyWithoutNeckTypeInput
  }

  export type NeckTypeUncheckedCreateWithoutKurtasDescriptionInput = {
    id?: number
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    innersDescription?: InnersDescriptionUncheckedCreateNestedManyWithoutNeckTypeInput
    topDescription?: TopDescriptionUncheckedCreateNestedManyWithoutNeckTypeInput
  }

  export type NeckTypeCreateOrConnectWithoutKurtasDescriptionInput = {
    where: NeckTypeWhereUniqueInput
    create: XOR<NeckTypeCreateWithoutKurtasDescriptionInput, NeckTypeUncheckedCreateWithoutKurtasDescriptionInput>
  }

  export type SleeveTypeCreateWithoutKurtasDescriptionInput = {
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    innersDescription?: InnersDescriptionCreateNestedManyWithoutSleeveTypeInput
    topDescription?: TopDescriptionCreateNestedManyWithoutSleeveTypeInput
  }

  export type SleeveTypeUncheckedCreateWithoutKurtasDescriptionInput = {
    id?: number
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    innersDescription?: InnersDescriptionUncheckedCreateNestedManyWithoutSleeveTypeInput
    topDescription?: TopDescriptionUncheckedCreateNestedManyWithoutSleeveTypeInput
  }

  export type SleeveTypeCreateOrConnectWithoutKurtasDescriptionInput = {
    where: SleeveTypeWhereUniqueInput
    create: XOR<SleeveTypeCreateWithoutKurtasDescriptionInput, SleeveTypeUncheckedCreateWithoutKurtasDescriptionInput>
  }

  export type CommonDescriptionCreateWithoutKurtasDescriptionInput = {
    fit?: string | null
    materail: string
    care: string
    brandName: string
    origin: string
    occasion: string
    specialFeature?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    product: ProductCreateNestedOneWithoutCommonDescriptionInput
    topDescription?: TopDescriptionCreateNestedManyWithoutCommonDescriptionInput
    pantDescription?: BottomDescriptionCreateNestedManyWithoutCommonDescriptionInput
    shoesDescription?: ShoesDescriptionCreateNestedManyWithoutCommonDescriptionInput
    innerDescription?: InnersDescriptionCreateNestedManyWithoutCommonDescriptionInput
    watchesDescription?: WatchesDescriptionCreateNestedManyWithoutCommonDescriptionInput
    perfumesDescription?: PerfumesDescriptionCreateNestedManyWithoutCommonDescriptionInput
  }

  export type CommonDescriptionUncheckedCreateWithoutKurtasDescriptionInput = {
    id?: number
    fit?: string | null
    materail: string
    care: string
    brandName: string
    origin: string
    productId: number
    occasion: string
    specialFeature?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    topDescription?: TopDescriptionUncheckedCreateNestedManyWithoutCommonDescriptionInput
    pantDescription?: BottomDescriptionUncheckedCreateNestedManyWithoutCommonDescriptionInput
    shoesDescription?: ShoesDescriptionUncheckedCreateNestedManyWithoutCommonDescriptionInput
    innerDescription?: InnersDescriptionUncheckedCreateNestedManyWithoutCommonDescriptionInput
    watchesDescription?: WatchesDescriptionUncheckedCreateNestedManyWithoutCommonDescriptionInput
    perfumesDescription?: PerfumesDescriptionUncheckedCreateNestedManyWithoutCommonDescriptionInput
  }

  export type CommonDescriptionCreateOrConnectWithoutKurtasDescriptionInput = {
    where: CommonDescriptionWhereUniqueInput
    create: XOR<CommonDescriptionCreateWithoutKurtasDescriptionInput, CommonDescriptionUncheckedCreateWithoutKurtasDescriptionInput>
  }

  export type BottomDescriptionCreateWithoutKurtasDescriptionInput = {
    productDescription?: string | null
    weight?: number | null
    printAndPattern: string
    length: number
    waist: number
    hip: number
    type?: string | null
    colorFamily?: string | null
    pocket?: string | null
    beltLoop?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    typesOfPants: TypesOfBottomCreateNestedOneWithoutDescriptionInput
    typesOfPleats: TypesOfPleatsCreateNestedOneWithoutDescriptionInput
    typesOfLength: TypesOfLengthBottomCreateNestedOneWithoutDescriptionInput
    commonDescription: CommonDescriptionCreateNestedOneWithoutPantDescriptionInput
    topDescription?: TopDescriptionCreateNestedOneWithoutBottomDescriptionInput
  }

  export type BottomDescriptionUncheckedCreateWithoutKurtasDescriptionInput = {
    id?: number
    productDescription?: string | null
    weight?: number | null
    printAndPattern: string
    length: number
    waist: number
    hip: number
    commonDescriptionId: number
    type?: string | null
    colorFamily?: string | null
    pocket?: string | null
    topDescriptionId?: number | null
    beltLoop?: boolean
    typeOfPantId: number
    typesOfPleatsId: number
    typesOfLengthId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type BottomDescriptionCreateOrConnectWithoutKurtasDescriptionInput = {
    where: BottomDescriptionWhereUniqueInput
    create: XOR<BottomDescriptionCreateWithoutKurtasDescriptionInput, BottomDescriptionUncheckedCreateWithoutKurtasDescriptionInput>
  }

  export type BottomDescriptionCreateManyKurtasDescriptionInputEnvelope = {
    data: Enumerable<BottomDescriptionCreateManyKurtasDescriptionInput>
    skipDuplicates?: boolean
  }

  export type KurtasLengthTypeUpsertWithoutKurtasDescriptionInput = {
    update: XOR<KurtasLengthTypeUpdateWithoutKurtasDescriptionInput, KurtasLengthTypeUncheckedUpdateWithoutKurtasDescriptionInput>
    create: XOR<KurtasLengthTypeCreateWithoutKurtasDescriptionInput, KurtasLengthTypeUncheckedCreateWithoutKurtasDescriptionInput>
  }

  export type KurtasLengthTypeUpdateWithoutKurtasDescriptionInput = {
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type KurtasLengthTypeUncheckedUpdateWithoutKurtasDescriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NeckTypeUpsertWithoutKurtasDescriptionInput = {
    update: XOR<NeckTypeUpdateWithoutKurtasDescriptionInput, NeckTypeUncheckedUpdateWithoutKurtasDescriptionInput>
    create: XOR<NeckTypeCreateWithoutKurtasDescriptionInput, NeckTypeUncheckedCreateWithoutKurtasDescriptionInput>
  }

  export type NeckTypeUpdateWithoutKurtasDescriptionInput = {
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    innersDescription?: InnersDescriptionUpdateManyWithoutNeckTypeNestedInput
    topDescription?: TopDescriptionUpdateManyWithoutNeckTypeNestedInput
  }

  export type NeckTypeUncheckedUpdateWithoutKurtasDescriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    innersDescription?: InnersDescriptionUncheckedUpdateManyWithoutNeckTypeNestedInput
    topDescription?: TopDescriptionUncheckedUpdateManyWithoutNeckTypeNestedInput
  }

  export type SleeveTypeUpsertWithoutKurtasDescriptionInput = {
    update: XOR<SleeveTypeUpdateWithoutKurtasDescriptionInput, SleeveTypeUncheckedUpdateWithoutKurtasDescriptionInput>
    create: XOR<SleeveTypeCreateWithoutKurtasDescriptionInput, SleeveTypeUncheckedCreateWithoutKurtasDescriptionInput>
  }

  export type SleeveTypeUpdateWithoutKurtasDescriptionInput = {
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    innersDescription?: InnersDescriptionUpdateManyWithoutSleeveTypeNestedInput
    topDescription?: TopDescriptionUpdateManyWithoutSleeveTypeNestedInput
  }

  export type SleeveTypeUncheckedUpdateWithoutKurtasDescriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    innersDescription?: InnersDescriptionUncheckedUpdateManyWithoutSleeveTypeNestedInput
    topDescription?: TopDescriptionUncheckedUpdateManyWithoutSleeveTypeNestedInput
  }

  export type CommonDescriptionUpsertWithoutKurtasDescriptionInput = {
    update: XOR<CommonDescriptionUpdateWithoutKurtasDescriptionInput, CommonDescriptionUncheckedUpdateWithoutKurtasDescriptionInput>
    create: XOR<CommonDescriptionCreateWithoutKurtasDescriptionInput, CommonDescriptionUncheckedCreateWithoutKurtasDescriptionInput>
  }

  export type CommonDescriptionUpdateWithoutKurtasDescriptionInput = {
    fit?: NullableStringFieldUpdateOperationsInput | string | null
    materail?: StringFieldUpdateOperationsInput | string
    care?: StringFieldUpdateOperationsInput | string
    brandName?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    occasion?: StringFieldUpdateOperationsInput | string
    specialFeature?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    product?: ProductUpdateOneRequiredWithoutCommonDescriptionNestedInput
    topDescription?: TopDescriptionUpdateManyWithoutCommonDescriptionNestedInput
    pantDescription?: BottomDescriptionUpdateManyWithoutCommonDescriptionNestedInput
    shoesDescription?: ShoesDescriptionUpdateManyWithoutCommonDescriptionNestedInput
    innerDescription?: InnersDescriptionUpdateManyWithoutCommonDescriptionNestedInput
    watchesDescription?: WatchesDescriptionUpdateManyWithoutCommonDescriptionNestedInput
    perfumesDescription?: PerfumesDescriptionUpdateManyWithoutCommonDescriptionNestedInput
  }

  export type CommonDescriptionUncheckedUpdateWithoutKurtasDescriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    fit?: NullableStringFieldUpdateOperationsInput | string | null
    materail?: StringFieldUpdateOperationsInput | string
    care?: StringFieldUpdateOperationsInput | string
    brandName?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    productId?: IntFieldUpdateOperationsInput | number
    occasion?: StringFieldUpdateOperationsInput | string
    specialFeature?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    topDescription?: TopDescriptionUncheckedUpdateManyWithoutCommonDescriptionNestedInput
    pantDescription?: BottomDescriptionUncheckedUpdateManyWithoutCommonDescriptionNestedInput
    shoesDescription?: ShoesDescriptionUncheckedUpdateManyWithoutCommonDescriptionNestedInput
    innerDescription?: InnersDescriptionUncheckedUpdateManyWithoutCommonDescriptionNestedInput
    watchesDescription?: WatchesDescriptionUncheckedUpdateManyWithoutCommonDescriptionNestedInput
    perfumesDescription?: PerfumesDescriptionUncheckedUpdateManyWithoutCommonDescriptionNestedInput
  }

  export type BottomDescriptionUpsertWithWhereUniqueWithoutKurtasDescriptionInput = {
    where: BottomDescriptionWhereUniqueInput
    update: XOR<BottomDescriptionUpdateWithoutKurtasDescriptionInput, BottomDescriptionUncheckedUpdateWithoutKurtasDescriptionInput>
    create: XOR<BottomDescriptionCreateWithoutKurtasDescriptionInput, BottomDescriptionUncheckedCreateWithoutKurtasDescriptionInput>
  }

  export type BottomDescriptionUpdateWithWhereUniqueWithoutKurtasDescriptionInput = {
    where: BottomDescriptionWhereUniqueInput
    data: XOR<BottomDescriptionUpdateWithoutKurtasDescriptionInput, BottomDescriptionUncheckedUpdateWithoutKurtasDescriptionInput>
  }

  export type BottomDescriptionUpdateManyWithWhereWithoutKurtasDescriptionInput = {
    where: BottomDescriptionScalarWhereInput
    data: XOR<BottomDescriptionUpdateManyMutationInput, BottomDescriptionUncheckedUpdateManyWithoutBottomDescriptionInput>
  }

  export type WarrantyCreateWithoutShoesDescriptionInput = {
    warrantyPeriod: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    watches?: WatchesDescriptionCreateNestedOneWithoutWarrantyInput
  }

  export type WarrantyUncheckedCreateWithoutShoesDescriptionInput = {
    id?: number
    watchsId?: number | null
    warrantyPeriod: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type WarrantyCreateOrConnectWithoutShoesDescriptionInput = {
    where: WarrantyWhereUniqueInput
    create: XOR<WarrantyCreateWithoutShoesDescriptionInput, WarrantyUncheckedCreateWithoutShoesDescriptionInput>
  }

  export type WarrantyCreateManyShoesDescriptionInputEnvelope = {
    data: Enumerable<WarrantyCreateManyShoesDescriptionInput>
    skipDuplicates?: boolean
  }

  export type CommonDescriptionCreateWithoutShoesDescriptionInput = {
    fit?: string | null
    materail: string
    care: string
    brandName: string
    origin: string
    occasion: string
    specialFeature?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    product: ProductCreateNestedOneWithoutCommonDescriptionInput
    topDescription?: TopDescriptionCreateNestedManyWithoutCommonDescriptionInput
    pantDescription?: BottomDescriptionCreateNestedManyWithoutCommonDescriptionInput
    kurtasDescription?: KurtasDescriptionCreateNestedManyWithoutCommonDescriptionInput
    innerDescription?: InnersDescriptionCreateNestedManyWithoutCommonDescriptionInput
    watchesDescription?: WatchesDescriptionCreateNestedManyWithoutCommonDescriptionInput
    perfumesDescription?: PerfumesDescriptionCreateNestedManyWithoutCommonDescriptionInput
  }

  export type CommonDescriptionUncheckedCreateWithoutShoesDescriptionInput = {
    id?: number
    fit?: string | null
    materail: string
    care: string
    brandName: string
    origin: string
    productId: number
    occasion: string
    specialFeature?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    topDescription?: TopDescriptionUncheckedCreateNestedManyWithoutCommonDescriptionInput
    pantDescription?: BottomDescriptionUncheckedCreateNestedManyWithoutCommonDescriptionInput
    kurtasDescription?: KurtasDescriptionUncheckedCreateNestedManyWithoutCommonDescriptionInput
    innerDescription?: InnersDescriptionUncheckedCreateNestedManyWithoutCommonDescriptionInput
    watchesDescription?: WatchesDescriptionUncheckedCreateNestedManyWithoutCommonDescriptionInput
    perfumesDescription?: PerfumesDescriptionUncheckedCreateNestedManyWithoutCommonDescriptionInput
  }

  export type CommonDescriptionCreateOrConnectWithoutShoesDescriptionInput = {
    where: CommonDescriptionWhereUniqueInput
    create: XOR<CommonDescriptionCreateWithoutShoesDescriptionInput, CommonDescriptionUncheckedCreateWithoutShoesDescriptionInput>
  }

  export type WarrantyUpsertWithWhereUniqueWithoutShoesDescriptionInput = {
    where: WarrantyWhereUniqueInput
    update: XOR<WarrantyUpdateWithoutShoesDescriptionInput, WarrantyUncheckedUpdateWithoutShoesDescriptionInput>
    create: XOR<WarrantyCreateWithoutShoesDescriptionInput, WarrantyUncheckedCreateWithoutShoesDescriptionInput>
  }

  export type WarrantyUpdateWithWhereUniqueWithoutShoesDescriptionInput = {
    where: WarrantyWhereUniqueInput
    data: XOR<WarrantyUpdateWithoutShoesDescriptionInput, WarrantyUncheckedUpdateWithoutShoesDescriptionInput>
  }

  export type WarrantyUpdateManyWithWhereWithoutShoesDescriptionInput = {
    where: WarrantyScalarWhereInput
    data: XOR<WarrantyUpdateManyMutationInput, WarrantyUncheckedUpdateManyWithoutWarrantyInput>
  }

  export type WarrantyScalarWhereInput = {
    AND?: Enumerable<WarrantyScalarWhereInput>
    OR?: Enumerable<WarrantyScalarWhereInput>
    NOT?: Enumerable<WarrantyScalarWhereInput>
    id?: IntFilter | number
    shoesDescriptionId?: IntNullableFilter | number | null
    watchsId?: IntNullableFilter | number | null
    warrantyPeriod?: IntFilter | number
    isActive?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type CommonDescriptionUpsertWithoutShoesDescriptionInput = {
    update: XOR<CommonDescriptionUpdateWithoutShoesDescriptionInput, CommonDescriptionUncheckedUpdateWithoutShoesDescriptionInput>
    create: XOR<CommonDescriptionCreateWithoutShoesDescriptionInput, CommonDescriptionUncheckedCreateWithoutShoesDescriptionInput>
  }

  export type CommonDescriptionUpdateWithoutShoesDescriptionInput = {
    fit?: NullableStringFieldUpdateOperationsInput | string | null
    materail?: StringFieldUpdateOperationsInput | string
    care?: StringFieldUpdateOperationsInput | string
    brandName?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    occasion?: StringFieldUpdateOperationsInput | string
    specialFeature?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    product?: ProductUpdateOneRequiredWithoutCommonDescriptionNestedInput
    topDescription?: TopDescriptionUpdateManyWithoutCommonDescriptionNestedInput
    pantDescription?: BottomDescriptionUpdateManyWithoutCommonDescriptionNestedInput
    kurtasDescription?: KurtasDescriptionUpdateManyWithoutCommonDescriptionNestedInput
    innerDescription?: InnersDescriptionUpdateManyWithoutCommonDescriptionNestedInput
    watchesDescription?: WatchesDescriptionUpdateManyWithoutCommonDescriptionNestedInput
    perfumesDescription?: PerfumesDescriptionUpdateManyWithoutCommonDescriptionNestedInput
  }

  export type CommonDescriptionUncheckedUpdateWithoutShoesDescriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    fit?: NullableStringFieldUpdateOperationsInput | string | null
    materail?: StringFieldUpdateOperationsInput | string
    care?: StringFieldUpdateOperationsInput | string
    brandName?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    productId?: IntFieldUpdateOperationsInput | number
    occasion?: StringFieldUpdateOperationsInput | string
    specialFeature?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    topDescription?: TopDescriptionUncheckedUpdateManyWithoutCommonDescriptionNestedInput
    pantDescription?: BottomDescriptionUncheckedUpdateManyWithoutCommonDescriptionNestedInput
    kurtasDescription?: KurtasDescriptionUncheckedUpdateManyWithoutCommonDescriptionNestedInput
    innerDescription?: InnersDescriptionUncheckedUpdateManyWithoutCommonDescriptionNestedInput
    watchesDescription?: WatchesDescriptionUncheckedUpdateManyWithoutCommonDescriptionNestedInput
    perfumesDescription?: PerfumesDescriptionUncheckedUpdateManyWithoutCommonDescriptionNestedInput
  }

  export type WarrantyCreateWithoutWatchesInput = {
    warrantyPeriod: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    shoesDescription?: ShoesDescriptionCreateNestedOneWithoutWarrantyInput
  }

  export type WarrantyUncheckedCreateWithoutWatchesInput = {
    id?: number
    shoesDescriptionId?: number | null
    warrantyPeriod: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type WarrantyCreateOrConnectWithoutWatchesInput = {
    where: WarrantyWhereUniqueInput
    create: XOR<WarrantyCreateWithoutWatchesInput, WarrantyUncheckedCreateWithoutWatchesInput>
  }

  export type WarrantyCreateManyWatchesInputEnvelope = {
    data: Enumerable<WarrantyCreateManyWatchesInput>
    skipDuplicates?: boolean
  }

  export type CommonDescriptionCreateWithoutWatchesDescriptionInput = {
    fit?: string | null
    materail: string
    care: string
    brandName: string
    origin: string
    occasion: string
    specialFeature?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    product: ProductCreateNestedOneWithoutCommonDescriptionInput
    topDescription?: TopDescriptionCreateNestedManyWithoutCommonDescriptionInput
    pantDescription?: BottomDescriptionCreateNestedManyWithoutCommonDescriptionInput
    kurtasDescription?: KurtasDescriptionCreateNestedManyWithoutCommonDescriptionInput
    shoesDescription?: ShoesDescriptionCreateNestedManyWithoutCommonDescriptionInput
    innerDescription?: InnersDescriptionCreateNestedManyWithoutCommonDescriptionInput
    perfumesDescription?: PerfumesDescriptionCreateNestedManyWithoutCommonDescriptionInput
  }

  export type CommonDescriptionUncheckedCreateWithoutWatchesDescriptionInput = {
    id?: number
    fit?: string | null
    materail: string
    care: string
    brandName: string
    origin: string
    productId: number
    occasion: string
    specialFeature?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    topDescription?: TopDescriptionUncheckedCreateNestedManyWithoutCommonDescriptionInput
    pantDescription?: BottomDescriptionUncheckedCreateNestedManyWithoutCommonDescriptionInput
    kurtasDescription?: KurtasDescriptionUncheckedCreateNestedManyWithoutCommonDescriptionInput
    shoesDescription?: ShoesDescriptionUncheckedCreateNestedManyWithoutCommonDescriptionInput
    innerDescription?: InnersDescriptionUncheckedCreateNestedManyWithoutCommonDescriptionInput
    perfumesDescription?: PerfumesDescriptionUncheckedCreateNestedManyWithoutCommonDescriptionInput
  }

  export type CommonDescriptionCreateOrConnectWithoutWatchesDescriptionInput = {
    where: CommonDescriptionWhereUniqueInput
    create: XOR<CommonDescriptionCreateWithoutWatchesDescriptionInput, CommonDescriptionUncheckedCreateWithoutWatchesDescriptionInput>
  }

  export type WarrantyUpsertWithWhereUniqueWithoutWatchesInput = {
    where: WarrantyWhereUniqueInput
    update: XOR<WarrantyUpdateWithoutWatchesInput, WarrantyUncheckedUpdateWithoutWatchesInput>
    create: XOR<WarrantyCreateWithoutWatchesInput, WarrantyUncheckedCreateWithoutWatchesInput>
  }

  export type WarrantyUpdateWithWhereUniqueWithoutWatchesInput = {
    where: WarrantyWhereUniqueInput
    data: XOR<WarrantyUpdateWithoutWatchesInput, WarrantyUncheckedUpdateWithoutWatchesInput>
  }

  export type WarrantyUpdateManyWithWhereWithoutWatchesInput = {
    where: WarrantyScalarWhereInput
    data: XOR<WarrantyUpdateManyMutationInput, WarrantyUncheckedUpdateManyWithoutWarrantyInput>
  }

  export type CommonDescriptionUpsertWithoutWatchesDescriptionInput = {
    update: XOR<CommonDescriptionUpdateWithoutWatchesDescriptionInput, CommonDescriptionUncheckedUpdateWithoutWatchesDescriptionInput>
    create: XOR<CommonDescriptionCreateWithoutWatchesDescriptionInput, CommonDescriptionUncheckedCreateWithoutWatchesDescriptionInput>
  }

  export type CommonDescriptionUpdateWithoutWatchesDescriptionInput = {
    fit?: NullableStringFieldUpdateOperationsInput | string | null
    materail?: StringFieldUpdateOperationsInput | string
    care?: StringFieldUpdateOperationsInput | string
    brandName?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    occasion?: StringFieldUpdateOperationsInput | string
    specialFeature?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    product?: ProductUpdateOneRequiredWithoutCommonDescriptionNestedInput
    topDescription?: TopDescriptionUpdateManyWithoutCommonDescriptionNestedInput
    pantDescription?: BottomDescriptionUpdateManyWithoutCommonDescriptionNestedInput
    kurtasDescription?: KurtasDescriptionUpdateManyWithoutCommonDescriptionNestedInput
    shoesDescription?: ShoesDescriptionUpdateManyWithoutCommonDescriptionNestedInput
    innerDescription?: InnersDescriptionUpdateManyWithoutCommonDescriptionNestedInput
    perfumesDescription?: PerfumesDescriptionUpdateManyWithoutCommonDescriptionNestedInput
  }

  export type CommonDescriptionUncheckedUpdateWithoutWatchesDescriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    fit?: NullableStringFieldUpdateOperationsInput | string | null
    materail?: StringFieldUpdateOperationsInput | string
    care?: StringFieldUpdateOperationsInput | string
    brandName?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    productId?: IntFieldUpdateOperationsInput | number
    occasion?: StringFieldUpdateOperationsInput | string
    specialFeature?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    topDescription?: TopDescriptionUncheckedUpdateManyWithoutCommonDescriptionNestedInput
    pantDescription?: BottomDescriptionUncheckedUpdateManyWithoutCommonDescriptionNestedInput
    kurtasDescription?: KurtasDescriptionUncheckedUpdateManyWithoutCommonDescriptionNestedInput
    shoesDescription?: ShoesDescriptionUncheckedUpdateManyWithoutCommonDescriptionNestedInput
    innerDescription?: InnersDescriptionUncheckedUpdateManyWithoutCommonDescriptionNestedInput
    perfumesDescription?: PerfumesDescriptionUncheckedUpdateManyWithoutCommonDescriptionNestedInput
  }

  export type CommonDescriptionCreateWithoutPerfumesDescriptionInput = {
    fit?: string | null
    materail: string
    care: string
    brandName: string
    origin: string
    occasion: string
    specialFeature?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    product: ProductCreateNestedOneWithoutCommonDescriptionInput
    topDescription?: TopDescriptionCreateNestedManyWithoutCommonDescriptionInput
    pantDescription?: BottomDescriptionCreateNestedManyWithoutCommonDescriptionInput
    kurtasDescription?: KurtasDescriptionCreateNestedManyWithoutCommonDescriptionInput
    shoesDescription?: ShoesDescriptionCreateNestedManyWithoutCommonDescriptionInput
    innerDescription?: InnersDescriptionCreateNestedManyWithoutCommonDescriptionInput
    watchesDescription?: WatchesDescriptionCreateNestedManyWithoutCommonDescriptionInput
  }

  export type CommonDescriptionUncheckedCreateWithoutPerfumesDescriptionInput = {
    id?: number
    fit?: string | null
    materail: string
    care: string
    brandName: string
    origin: string
    productId: number
    occasion: string
    specialFeature?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    topDescription?: TopDescriptionUncheckedCreateNestedManyWithoutCommonDescriptionInput
    pantDescription?: BottomDescriptionUncheckedCreateNestedManyWithoutCommonDescriptionInput
    kurtasDescription?: KurtasDescriptionUncheckedCreateNestedManyWithoutCommonDescriptionInput
    shoesDescription?: ShoesDescriptionUncheckedCreateNestedManyWithoutCommonDescriptionInput
    innerDescription?: InnersDescriptionUncheckedCreateNestedManyWithoutCommonDescriptionInput
    watchesDescription?: WatchesDescriptionUncheckedCreateNestedManyWithoutCommonDescriptionInput
  }

  export type CommonDescriptionCreateOrConnectWithoutPerfumesDescriptionInput = {
    where: CommonDescriptionWhereUniqueInput
    create: XOR<CommonDescriptionCreateWithoutPerfumesDescriptionInput, CommonDescriptionUncheckedCreateWithoutPerfumesDescriptionInput>
  }

  export type CommonDescriptionUpsertWithoutPerfumesDescriptionInput = {
    update: XOR<CommonDescriptionUpdateWithoutPerfumesDescriptionInput, CommonDescriptionUncheckedUpdateWithoutPerfumesDescriptionInput>
    create: XOR<CommonDescriptionCreateWithoutPerfumesDescriptionInput, CommonDescriptionUncheckedCreateWithoutPerfumesDescriptionInput>
  }

  export type CommonDescriptionUpdateWithoutPerfumesDescriptionInput = {
    fit?: NullableStringFieldUpdateOperationsInput | string | null
    materail?: StringFieldUpdateOperationsInput | string
    care?: StringFieldUpdateOperationsInput | string
    brandName?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    occasion?: StringFieldUpdateOperationsInput | string
    specialFeature?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    product?: ProductUpdateOneRequiredWithoutCommonDescriptionNestedInput
    topDescription?: TopDescriptionUpdateManyWithoutCommonDescriptionNestedInput
    pantDescription?: BottomDescriptionUpdateManyWithoutCommonDescriptionNestedInput
    kurtasDescription?: KurtasDescriptionUpdateManyWithoutCommonDescriptionNestedInput
    shoesDescription?: ShoesDescriptionUpdateManyWithoutCommonDescriptionNestedInput
    innerDescription?: InnersDescriptionUpdateManyWithoutCommonDescriptionNestedInput
    watchesDescription?: WatchesDescriptionUpdateManyWithoutCommonDescriptionNestedInput
  }

  export type CommonDescriptionUncheckedUpdateWithoutPerfumesDescriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    fit?: NullableStringFieldUpdateOperationsInput | string | null
    materail?: StringFieldUpdateOperationsInput | string
    care?: StringFieldUpdateOperationsInput | string
    brandName?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    productId?: IntFieldUpdateOperationsInput | number
    occasion?: StringFieldUpdateOperationsInput | string
    specialFeature?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    topDescription?: TopDescriptionUncheckedUpdateManyWithoutCommonDescriptionNestedInput
    pantDescription?: BottomDescriptionUncheckedUpdateManyWithoutCommonDescriptionNestedInput
    kurtasDescription?: KurtasDescriptionUncheckedUpdateManyWithoutCommonDescriptionNestedInput
    shoesDescription?: ShoesDescriptionUncheckedUpdateManyWithoutCommonDescriptionNestedInput
    innerDescription?: InnersDescriptionUncheckedUpdateManyWithoutCommonDescriptionNestedInput
    watchesDescription?: WatchesDescriptionUncheckedUpdateManyWithoutCommonDescriptionNestedInput
  }

  export type SleeveTypeCreateWithoutInnersDescriptionInput = {
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    kurtasDescription?: KurtasDescriptionCreateNestedManyWithoutSleeveTypeInput
    topDescription?: TopDescriptionCreateNestedManyWithoutSleeveTypeInput
  }

  export type SleeveTypeUncheckedCreateWithoutInnersDescriptionInput = {
    id?: number
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    kurtasDescription?: KurtasDescriptionUncheckedCreateNestedManyWithoutSleeveTypeInput
    topDescription?: TopDescriptionUncheckedCreateNestedManyWithoutSleeveTypeInput
  }

  export type SleeveTypeCreateOrConnectWithoutInnersDescriptionInput = {
    where: SleeveTypeWhereUniqueInput
    create: XOR<SleeveTypeCreateWithoutInnersDescriptionInput, SleeveTypeUncheckedCreateWithoutInnersDescriptionInput>
  }

  export type NeckTypeCreateWithoutInnersDescriptionInput = {
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    kurtasDescription?: KurtasDescriptionCreateNestedManyWithoutNeckTypeInput
    topDescription?: TopDescriptionCreateNestedManyWithoutNeckTypeInput
  }

  export type NeckTypeUncheckedCreateWithoutInnersDescriptionInput = {
    id?: number
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    kurtasDescription?: KurtasDescriptionUncheckedCreateNestedManyWithoutNeckTypeInput
    topDescription?: TopDescriptionUncheckedCreateNestedManyWithoutNeckTypeInput
  }

  export type NeckTypeCreateOrConnectWithoutInnersDescriptionInput = {
    where: NeckTypeWhereUniqueInput
    create: XOR<NeckTypeCreateWithoutInnersDescriptionInput, NeckTypeUncheckedCreateWithoutInnersDescriptionInput>
  }

  export type CommonDescriptionCreateWithoutInnerDescriptionInput = {
    fit?: string | null
    materail: string
    care: string
    brandName: string
    origin: string
    occasion: string
    specialFeature?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    product: ProductCreateNestedOneWithoutCommonDescriptionInput
    topDescription?: TopDescriptionCreateNestedManyWithoutCommonDescriptionInput
    pantDescription?: BottomDescriptionCreateNestedManyWithoutCommonDescriptionInput
    kurtasDescription?: KurtasDescriptionCreateNestedManyWithoutCommonDescriptionInput
    shoesDescription?: ShoesDescriptionCreateNestedManyWithoutCommonDescriptionInput
    watchesDescription?: WatchesDescriptionCreateNestedManyWithoutCommonDescriptionInput
    perfumesDescription?: PerfumesDescriptionCreateNestedManyWithoutCommonDescriptionInput
  }

  export type CommonDescriptionUncheckedCreateWithoutInnerDescriptionInput = {
    id?: number
    fit?: string | null
    materail: string
    care: string
    brandName: string
    origin: string
    productId: number
    occasion: string
    specialFeature?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    topDescription?: TopDescriptionUncheckedCreateNestedManyWithoutCommonDescriptionInput
    pantDescription?: BottomDescriptionUncheckedCreateNestedManyWithoutCommonDescriptionInput
    kurtasDescription?: KurtasDescriptionUncheckedCreateNestedManyWithoutCommonDescriptionInput
    shoesDescription?: ShoesDescriptionUncheckedCreateNestedManyWithoutCommonDescriptionInput
    watchesDescription?: WatchesDescriptionUncheckedCreateNestedManyWithoutCommonDescriptionInput
    perfumesDescription?: PerfumesDescriptionUncheckedCreateNestedManyWithoutCommonDescriptionInput
  }

  export type CommonDescriptionCreateOrConnectWithoutInnerDescriptionInput = {
    where: CommonDescriptionWhereUniqueInput
    create: XOR<CommonDescriptionCreateWithoutInnerDescriptionInput, CommonDescriptionUncheckedCreateWithoutInnerDescriptionInput>
  }

  export type SleeveTypeUpsertWithoutInnersDescriptionInput = {
    update: XOR<SleeveTypeUpdateWithoutInnersDescriptionInput, SleeveTypeUncheckedUpdateWithoutInnersDescriptionInput>
    create: XOR<SleeveTypeCreateWithoutInnersDescriptionInput, SleeveTypeUncheckedCreateWithoutInnersDescriptionInput>
  }

  export type SleeveTypeUpdateWithoutInnersDescriptionInput = {
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kurtasDescription?: KurtasDescriptionUpdateManyWithoutSleeveTypeNestedInput
    topDescription?: TopDescriptionUpdateManyWithoutSleeveTypeNestedInput
  }

  export type SleeveTypeUncheckedUpdateWithoutInnersDescriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kurtasDescription?: KurtasDescriptionUncheckedUpdateManyWithoutSleeveTypeNestedInput
    topDescription?: TopDescriptionUncheckedUpdateManyWithoutSleeveTypeNestedInput
  }

  export type NeckTypeUpsertWithoutInnersDescriptionInput = {
    update: XOR<NeckTypeUpdateWithoutInnersDescriptionInput, NeckTypeUncheckedUpdateWithoutInnersDescriptionInput>
    create: XOR<NeckTypeCreateWithoutInnersDescriptionInput, NeckTypeUncheckedCreateWithoutInnersDescriptionInput>
  }

  export type NeckTypeUpdateWithoutInnersDescriptionInput = {
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kurtasDescription?: KurtasDescriptionUpdateManyWithoutNeckTypeNestedInput
    topDescription?: TopDescriptionUpdateManyWithoutNeckTypeNestedInput
  }

  export type NeckTypeUncheckedUpdateWithoutInnersDescriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kurtasDescription?: KurtasDescriptionUncheckedUpdateManyWithoutNeckTypeNestedInput
    topDescription?: TopDescriptionUncheckedUpdateManyWithoutNeckTypeNestedInput
  }

  export type CommonDescriptionUpsertWithoutInnerDescriptionInput = {
    update: XOR<CommonDescriptionUpdateWithoutInnerDescriptionInput, CommonDescriptionUncheckedUpdateWithoutInnerDescriptionInput>
    create: XOR<CommonDescriptionCreateWithoutInnerDescriptionInput, CommonDescriptionUncheckedCreateWithoutInnerDescriptionInput>
  }

  export type CommonDescriptionUpdateWithoutInnerDescriptionInput = {
    fit?: NullableStringFieldUpdateOperationsInput | string | null
    materail?: StringFieldUpdateOperationsInput | string
    care?: StringFieldUpdateOperationsInput | string
    brandName?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    occasion?: StringFieldUpdateOperationsInput | string
    specialFeature?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    product?: ProductUpdateOneRequiredWithoutCommonDescriptionNestedInput
    topDescription?: TopDescriptionUpdateManyWithoutCommonDescriptionNestedInput
    pantDescription?: BottomDescriptionUpdateManyWithoutCommonDescriptionNestedInput
    kurtasDescription?: KurtasDescriptionUpdateManyWithoutCommonDescriptionNestedInput
    shoesDescription?: ShoesDescriptionUpdateManyWithoutCommonDescriptionNestedInput
    watchesDescription?: WatchesDescriptionUpdateManyWithoutCommonDescriptionNestedInput
    perfumesDescription?: PerfumesDescriptionUpdateManyWithoutCommonDescriptionNestedInput
  }

  export type CommonDescriptionUncheckedUpdateWithoutInnerDescriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    fit?: NullableStringFieldUpdateOperationsInput | string | null
    materail?: StringFieldUpdateOperationsInput | string
    care?: StringFieldUpdateOperationsInput | string
    brandName?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    productId?: IntFieldUpdateOperationsInput | number
    occasion?: StringFieldUpdateOperationsInput | string
    specialFeature?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    topDescription?: TopDescriptionUncheckedUpdateManyWithoutCommonDescriptionNestedInput
    pantDescription?: BottomDescriptionUncheckedUpdateManyWithoutCommonDescriptionNestedInput
    kurtasDescription?: KurtasDescriptionUncheckedUpdateManyWithoutCommonDescriptionNestedInput
    shoesDescription?: ShoesDescriptionUncheckedUpdateManyWithoutCommonDescriptionNestedInput
    watchesDescription?: WatchesDescriptionUncheckedUpdateManyWithoutCommonDescriptionNestedInput
    perfumesDescription?: PerfumesDescriptionUncheckedUpdateManyWithoutCommonDescriptionNestedInput
  }

  export type ShoesDescriptionCreateWithoutWarrantyInput = {
    pattern?: string | null
    footLength: string
    type: string
    soleMaterial?: string | null
    printAndPattern?: string | null
    upperMaterial?: string | null
    closure?: string | null
    toeType: string
    weight?: number | null
    colorFamily?: string | null
    productDescription?: string | null
    packageContains?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    commonDescription: CommonDescriptionCreateNestedOneWithoutShoesDescriptionInput
  }

  export type ShoesDescriptionUncheckedCreateWithoutWarrantyInput = {
    id?: number
    pattern?: string | null
    footLength: string
    type: string
    soleMaterial?: string | null
    printAndPattern?: string | null
    upperMaterial?: string | null
    closure?: string | null
    toeType: string
    weight?: number | null
    colorFamily?: string | null
    productDescription?: string | null
    packageContains?: number | null
    commonDescriptionId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ShoesDescriptionCreateOrConnectWithoutWarrantyInput = {
    where: ShoesDescriptionWhereUniqueInput
    create: XOR<ShoesDescriptionCreateWithoutWarrantyInput, ShoesDescriptionUncheckedCreateWithoutWarrantyInput>
  }

  export type WatchesDescriptionCreateWithoutWarrantyInput = {
    type?: string | null
    weight: number
    model: string
    dialShape: string
    printAndPattern?: string | null
    dialDiameter: string
    dialColor: string
    strapColor: string
    colorFamily?: string | null
    productDescription?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    commonDescription: CommonDescriptionCreateNestedOneWithoutWatchesDescriptionInput
  }

  export type WatchesDescriptionUncheckedCreateWithoutWarrantyInput = {
    id?: number
    type?: string | null
    weight: number
    model: string
    dialShape: string
    printAndPattern?: string | null
    dialDiameter: string
    dialColor: string
    strapColor: string
    colorFamily?: string | null
    productDescription?: string | null
    commonDescriptionId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type WatchesDescriptionCreateOrConnectWithoutWarrantyInput = {
    where: WatchesDescriptionWhereUniqueInput
    create: XOR<WatchesDescriptionCreateWithoutWarrantyInput, WatchesDescriptionUncheckedCreateWithoutWarrantyInput>
  }

  export type ShoesDescriptionUpsertWithoutWarrantyInput = {
    update: XOR<ShoesDescriptionUpdateWithoutWarrantyInput, ShoesDescriptionUncheckedUpdateWithoutWarrantyInput>
    create: XOR<ShoesDescriptionCreateWithoutWarrantyInput, ShoesDescriptionUncheckedCreateWithoutWarrantyInput>
  }

  export type ShoesDescriptionUpdateWithoutWarrantyInput = {
    pattern?: NullableStringFieldUpdateOperationsInput | string | null
    footLength?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    soleMaterial?: NullableStringFieldUpdateOperationsInput | string | null
    printAndPattern?: NullableStringFieldUpdateOperationsInput | string | null
    upperMaterial?: NullableStringFieldUpdateOperationsInput | string | null
    closure?: NullableStringFieldUpdateOperationsInput | string | null
    toeType?: StringFieldUpdateOperationsInput | string
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    packageContains?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commonDescription?: CommonDescriptionUpdateOneRequiredWithoutShoesDescriptionNestedInput
  }

  export type ShoesDescriptionUncheckedUpdateWithoutWarrantyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pattern?: NullableStringFieldUpdateOperationsInput | string | null
    footLength?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    soleMaterial?: NullableStringFieldUpdateOperationsInput | string | null
    printAndPattern?: NullableStringFieldUpdateOperationsInput | string | null
    upperMaterial?: NullableStringFieldUpdateOperationsInput | string | null
    closure?: NullableStringFieldUpdateOperationsInput | string | null
    toeType?: StringFieldUpdateOperationsInput | string
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    packageContains?: NullableIntFieldUpdateOperationsInput | number | null
    commonDescriptionId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WatchesDescriptionUpsertWithoutWarrantyInput = {
    update: XOR<WatchesDescriptionUpdateWithoutWarrantyInput, WatchesDescriptionUncheckedUpdateWithoutWarrantyInput>
    create: XOR<WatchesDescriptionCreateWithoutWarrantyInput, WatchesDescriptionUncheckedCreateWithoutWarrantyInput>
  }

  export type WatchesDescriptionUpdateWithoutWarrantyInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: IntFieldUpdateOperationsInput | number
    model?: StringFieldUpdateOperationsInput | string
    dialShape?: StringFieldUpdateOperationsInput | string
    printAndPattern?: NullableStringFieldUpdateOperationsInput | string | null
    dialDiameter?: StringFieldUpdateOperationsInput | string
    dialColor?: StringFieldUpdateOperationsInput | string
    strapColor?: StringFieldUpdateOperationsInput | string
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commonDescription?: CommonDescriptionUpdateOneRequiredWithoutWatchesDescriptionNestedInput
  }

  export type WatchesDescriptionUncheckedUpdateWithoutWarrantyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: IntFieldUpdateOperationsInput | number
    model?: StringFieldUpdateOperationsInput | string
    dialShape?: StringFieldUpdateOperationsInput | string
    printAndPattern?: NullableStringFieldUpdateOperationsInput | string | null
    dialDiameter?: StringFieldUpdateOperationsInput | string
    dialColor?: StringFieldUpdateOperationsInput | string
    strapColor?: StringFieldUpdateOperationsInput | string
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    commonDescriptionId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type KurtasDescriptionCreateWithoutSleeveTypeInput = {
    work?: string | null
    productDescription: string
    chest: number
    shoulder: number
    transparencyOfTheFabric?: boolean
    weight?: number | null
    colorFamily?: string | null
    pocket: string
    type: string
    printAndpattern?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    kurtasLengthType: KurtasLengthTypeCreateNestedOneWithoutKurtasDescriptionInput
    neckType: NeckTypeCreateNestedOneWithoutKurtasDescriptionInput
    commonDescription: CommonDescriptionCreateNestedOneWithoutKurtasDescriptionInput
    bottomDescription?: BottomDescriptionCreateNestedManyWithoutKurtasDescriptionInput
  }

  export type KurtasDescriptionUncheckedCreateWithoutSleeveTypeInput = {
    id?: number
    work?: string | null
    productDescription: string
    chest: number
    shoulder: number
    transparencyOfTheFabric?: boolean
    kurtasLengthTypeId: number
    weight?: number | null
    colorFamily?: string | null
    pocket: string
    type: string
    printAndpattern?: string | null
    kurtasNeckTypeId: number
    commonDescriptionId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    bottomDescription?: BottomDescriptionUncheckedCreateNestedManyWithoutKurtasDescriptionInput
  }

  export type KurtasDescriptionCreateOrConnectWithoutSleeveTypeInput = {
    where: KurtasDescriptionWhereUniqueInput
    create: XOR<KurtasDescriptionCreateWithoutSleeveTypeInput, KurtasDescriptionUncheckedCreateWithoutSleeveTypeInput>
  }

  export type KurtasDescriptionCreateManySleeveTypeInputEnvelope = {
    data: Enumerable<KurtasDescriptionCreateManySleeveTypeInput>
    skipDuplicates?: boolean
  }

  export type InnersDescriptionCreateWithoutSleeveTypeInput = {
    type: string
    productDescription: string
    weight?: number | null
    length: number
    waistRise: number
    printAndPattern?: string | null
    packageContains: number
    lookAndFeel: string
    colorFamily?: string | null
    multiColors?: boolean
    neckType?: NeckTypeCreateNestedOneWithoutInnersDescriptionInput
    commonDescription: CommonDescriptionCreateNestedOneWithoutInnerDescriptionInput
  }

  export type InnersDescriptionUncheckedCreateWithoutSleeveTypeInput = {
    id?: number
    type: string
    productDescription: string
    weight?: number | null
    length: number
    waistRise: number
    printAndPattern?: string | null
    packageContains: number
    lookAndFeel: string
    colorFamily?: string | null
    vestsNeckTypeId?: number | null
    commonDescriptionId: number
    multiColors?: boolean
  }

  export type InnersDescriptionCreateOrConnectWithoutSleeveTypeInput = {
    where: InnersDescriptionWhereUniqueInput
    create: XOR<InnersDescriptionCreateWithoutSleeveTypeInput, InnersDescriptionUncheckedCreateWithoutSleeveTypeInput>
  }

  export type InnersDescriptionCreateManySleeveTypeInputEnvelope = {
    data: Enumerable<InnersDescriptionCreateManySleeveTypeInput>
    skipDuplicates?: boolean
  }

  export type TopDescriptionCreateWithoutSleeveTypeInput = {
    productDescription?: string | null
    weight?: number | null
    chest: number
    shoulder: number
    type?: string | null
    colorFamily?: string | null
    printAndPattern?: string | null
    length: number
    pocket: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    commonDescription?: CommonDescriptionCreateNestedOneWithoutTopDescriptionInput
    neckType: NeckTypeCreateNestedOneWithoutTopDescriptionInput
    bottomDescription?: BottomDescriptionCreateNestedManyWithoutTopDescriptionInput
  }

  export type TopDescriptionUncheckedCreateWithoutSleeveTypeInput = {
    id?: number
    productDescription?: string | null
    weight?: number | null
    chest: number
    shoulder: number
    neckTypeId: number
    type?: string | null
    colorFamily?: string | null
    printAndPattern?: string | null
    length: number
    pocket: string
    commonDescriptionId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    bottomDescription?: BottomDescriptionUncheckedCreateNestedManyWithoutTopDescriptionInput
  }

  export type TopDescriptionCreateOrConnectWithoutSleeveTypeInput = {
    where: TopDescriptionWhereUniqueInput
    create: XOR<TopDescriptionCreateWithoutSleeveTypeInput, TopDescriptionUncheckedCreateWithoutSleeveTypeInput>
  }

  export type TopDescriptionCreateManySleeveTypeInputEnvelope = {
    data: Enumerable<TopDescriptionCreateManySleeveTypeInput>
    skipDuplicates?: boolean
  }

  export type KurtasDescriptionUpsertWithWhereUniqueWithoutSleeveTypeInput = {
    where: KurtasDescriptionWhereUniqueInput
    update: XOR<KurtasDescriptionUpdateWithoutSleeveTypeInput, KurtasDescriptionUncheckedUpdateWithoutSleeveTypeInput>
    create: XOR<KurtasDescriptionCreateWithoutSleeveTypeInput, KurtasDescriptionUncheckedCreateWithoutSleeveTypeInput>
  }

  export type KurtasDescriptionUpdateWithWhereUniqueWithoutSleeveTypeInput = {
    where: KurtasDescriptionWhereUniqueInput
    data: XOR<KurtasDescriptionUpdateWithoutSleeveTypeInput, KurtasDescriptionUncheckedUpdateWithoutSleeveTypeInput>
  }

  export type KurtasDescriptionUpdateManyWithWhereWithoutSleeveTypeInput = {
    where: KurtasDescriptionScalarWhereInput
    data: XOR<KurtasDescriptionUpdateManyMutationInput, KurtasDescriptionUncheckedUpdateManyWithoutKurtasDescriptionInput>
  }

  export type InnersDescriptionUpsertWithWhereUniqueWithoutSleeveTypeInput = {
    where: InnersDescriptionWhereUniqueInput
    update: XOR<InnersDescriptionUpdateWithoutSleeveTypeInput, InnersDescriptionUncheckedUpdateWithoutSleeveTypeInput>
    create: XOR<InnersDescriptionCreateWithoutSleeveTypeInput, InnersDescriptionUncheckedCreateWithoutSleeveTypeInput>
  }

  export type InnersDescriptionUpdateWithWhereUniqueWithoutSleeveTypeInput = {
    where: InnersDescriptionWhereUniqueInput
    data: XOR<InnersDescriptionUpdateWithoutSleeveTypeInput, InnersDescriptionUncheckedUpdateWithoutSleeveTypeInput>
  }

  export type InnersDescriptionUpdateManyWithWhereWithoutSleeveTypeInput = {
    where: InnersDescriptionScalarWhereInput
    data: XOR<InnersDescriptionUpdateManyMutationInput, InnersDescriptionUncheckedUpdateManyWithoutInnersDescriptionInput>
  }

  export type TopDescriptionUpsertWithWhereUniqueWithoutSleeveTypeInput = {
    where: TopDescriptionWhereUniqueInput
    update: XOR<TopDescriptionUpdateWithoutSleeveTypeInput, TopDescriptionUncheckedUpdateWithoutSleeveTypeInput>
    create: XOR<TopDescriptionCreateWithoutSleeveTypeInput, TopDescriptionUncheckedCreateWithoutSleeveTypeInput>
  }

  export type TopDescriptionUpdateWithWhereUniqueWithoutSleeveTypeInput = {
    where: TopDescriptionWhereUniqueInput
    data: XOR<TopDescriptionUpdateWithoutSleeveTypeInput, TopDescriptionUncheckedUpdateWithoutSleeveTypeInput>
  }

  export type TopDescriptionUpdateManyWithWhereWithoutSleeveTypeInput = {
    where: TopDescriptionScalarWhereInput
    data: XOR<TopDescriptionUpdateManyMutationInput, TopDescriptionUncheckedUpdateManyWithoutTopDescriptionInput>
  }

  export type KurtasDescriptionCreateWithoutNeckTypeInput = {
    work?: string | null
    productDescription: string
    chest: number
    shoulder: number
    transparencyOfTheFabric?: boolean
    weight?: number | null
    colorFamily?: string | null
    pocket: string
    type: string
    printAndpattern?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    kurtasLengthType: KurtasLengthTypeCreateNestedOneWithoutKurtasDescriptionInput
    sleeveType: SleeveTypeCreateNestedOneWithoutKurtasDescriptionInput
    commonDescription: CommonDescriptionCreateNestedOneWithoutKurtasDescriptionInput
    bottomDescription?: BottomDescriptionCreateNestedManyWithoutKurtasDescriptionInput
  }

  export type KurtasDescriptionUncheckedCreateWithoutNeckTypeInput = {
    id?: number
    work?: string | null
    productDescription: string
    chest: number
    shoulder: number
    transparencyOfTheFabric?: boolean
    kurtasLengthTypeId: number
    weight?: number | null
    colorFamily?: string | null
    pocket: string
    type: string
    printAndpattern?: string | null
    kurtasSleeveTypeId: number
    commonDescriptionId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    bottomDescription?: BottomDescriptionUncheckedCreateNestedManyWithoutKurtasDescriptionInput
  }

  export type KurtasDescriptionCreateOrConnectWithoutNeckTypeInput = {
    where: KurtasDescriptionWhereUniqueInput
    create: XOR<KurtasDescriptionCreateWithoutNeckTypeInput, KurtasDescriptionUncheckedCreateWithoutNeckTypeInput>
  }

  export type KurtasDescriptionCreateManyNeckTypeInputEnvelope = {
    data: Enumerable<KurtasDescriptionCreateManyNeckTypeInput>
    skipDuplicates?: boolean
  }

  export type InnersDescriptionCreateWithoutNeckTypeInput = {
    type: string
    productDescription: string
    weight?: number | null
    length: number
    waistRise: number
    printAndPattern?: string | null
    packageContains: number
    lookAndFeel: string
    colorFamily?: string | null
    multiColors?: boolean
    sleeveType?: SleeveTypeCreateNestedOneWithoutInnersDescriptionInput
    commonDescription: CommonDescriptionCreateNestedOneWithoutInnerDescriptionInput
  }

  export type InnersDescriptionUncheckedCreateWithoutNeckTypeInput = {
    id?: number
    type: string
    productDescription: string
    weight?: number | null
    length: number
    waistRise: number
    printAndPattern?: string | null
    packageContains: number
    lookAndFeel: string
    colorFamily?: string | null
    vestsSleeveTypeId?: number | null
    commonDescriptionId: number
    multiColors?: boolean
  }

  export type InnersDescriptionCreateOrConnectWithoutNeckTypeInput = {
    where: InnersDescriptionWhereUniqueInput
    create: XOR<InnersDescriptionCreateWithoutNeckTypeInput, InnersDescriptionUncheckedCreateWithoutNeckTypeInput>
  }

  export type InnersDescriptionCreateManyNeckTypeInputEnvelope = {
    data: Enumerable<InnersDescriptionCreateManyNeckTypeInput>
    skipDuplicates?: boolean
  }

  export type TopDescriptionCreateWithoutNeckTypeInput = {
    productDescription?: string | null
    weight?: number | null
    chest: number
    shoulder: number
    type?: string | null
    colorFamily?: string | null
    printAndPattern?: string | null
    length: number
    pocket: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    commonDescription?: CommonDescriptionCreateNestedOneWithoutTopDescriptionInput
    sleeveType: SleeveTypeCreateNestedOneWithoutTopDescriptionInput
    bottomDescription?: BottomDescriptionCreateNestedManyWithoutTopDescriptionInput
  }

  export type TopDescriptionUncheckedCreateWithoutNeckTypeInput = {
    id?: number
    productDescription?: string | null
    sleeveTypeId: number
    weight?: number | null
    chest: number
    shoulder: number
    type?: string | null
    colorFamily?: string | null
    printAndPattern?: string | null
    length: number
    pocket: string
    commonDescriptionId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    bottomDescription?: BottomDescriptionUncheckedCreateNestedManyWithoutTopDescriptionInput
  }

  export type TopDescriptionCreateOrConnectWithoutNeckTypeInput = {
    where: TopDescriptionWhereUniqueInput
    create: XOR<TopDescriptionCreateWithoutNeckTypeInput, TopDescriptionUncheckedCreateWithoutNeckTypeInput>
  }

  export type TopDescriptionCreateManyNeckTypeInputEnvelope = {
    data: Enumerable<TopDescriptionCreateManyNeckTypeInput>
    skipDuplicates?: boolean
  }

  export type KurtasDescriptionUpsertWithWhereUniqueWithoutNeckTypeInput = {
    where: KurtasDescriptionWhereUniqueInput
    update: XOR<KurtasDescriptionUpdateWithoutNeckTypeInput, KurtasDescriptionUncheckedUpdateWithoutNeckTypeInput>
    create: XOR<KurtasDescriptionCreateWithoutNeckTypeInput, KurtasDescriptionUncheckedCreateWithoutNeckTypeInput>
  }

  export type KurtasDescriptionUpdateWithWhereUniqueWithoutNeckTypeInput = {
    where: KurtasDescriptionWhereUniqueInput
    data: XOR<KurtasDescriptionUpdateWithoutNeckTypeInput, KurtasDescriptionUncheckedUpdateWithoutNeckTypeInput>
  }

  export type KurtasDescriptionUpdateManyWithWhereWithoutNeckTypeInput = {
    where: KurtasDescriptionScalarWhereInput
    data: XOR<KurtasDescriptionUpdateManyMutationInput, KurtasDescriptionUncheckedUpdateManyWithoutKurtasDescriptionInput>
  }

  export type InnersDescriptionUpsertWithWhereUniqueWithoutNeckTypeInput = {
    where: InnersDescriptionWhereUniqueInput
    update: XOR<InnersDescriptionUpdateWithoutNeckTypeInput, InnersDescriptionUncheckedUpdateWithoutNeckTypeInput>
    create: XOR<InnersDescriptionCreateWithoutNeckTypeInput, InnersDescriptionUncheckedCreateWithoutNeckTypeInput>
  }

  export type InnersDescriptionUpdateWithWhereUniqueWithoutNeckTypeInput = {
    where: InnersDescriptionWhereUniqueInput
    data: XOR<InnersDescriptionUpdateWithoutNeckTypeInput, InnersDescriptionUncheckedUpdateWithoutNeckTypeInput>
  }

  export type InnersDescriptionUpdateManyWithWhereWithoutNeckTypeInput = {
    where: InnersDescriptionScalarWhereInput
    data: XOR<InnersDescriptionUpdateManyMutationInput, InnersDescriptionUncheckedUpdateManyWithoutInnersDescriptionInput>
  }

  export type TopDescriptionUpsertWithWhereUniqueWithoutNeckTypeInput = {
    where: TopDescriptionWhereUniqueInput
    update: XOR<TopDescriptionUpdateWithoutNeckTypeInput, TopDescriptionUncheckedUpdateWithoutNeckTypeInput>
    create: XOR<TopDescriptionCreateWithoutNeckTypeInput, TopDescriptionUncheckedCreateWithoutNeckTypeInput>
  }

  export type TopDescriptionUpdateWithWhereUniqueWithoutNeckTypeInput = {
    where: TopDescriptionWhereUniqueInput
    data: XOR<TopDescriptionUpdateWithoutNeckTypeInput, TopDescriptionUncheckedUpdateWithoutNeckTypeInput>
  }

  export type TopDescriptionUpdateManyWithWhereWithoutNeckTypeInput = {
    where: TopDescriptionScalarWhereInput
    data: XOR<TopDescriptionUpdateManyMutationInput, TopDescriptionUncheckedUpdateManyWithoutTopDescriptionInput>
  }

  export type KurtasDescriptionCreateWithoutKurtasLengthTypeInput = {
    work?: string | null
    productDescription: string
    chest: number
    shoulder: number
    transparencyOfTheFabric?: boolean
    weight?: number | null
    colorFamily?: string | null
    pocket: string
    type: string
    printAndpattern?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    neckType: NeckTypeCreateNestedOneWithoutKurtasDescriptionInput
    sleeveType: SleeveTypeCreateNestedOneWithoutKurtasDescriptionInput
    commonDescription: CommonDescriptionCreateNestedOneWithoutKurtasDescriptionInput
    bottomDescription?: BottomDescriptionCreateNestedManyWithoutKurtasDescriptionInput
  }

  export type KurtasDescriptionUncheckedCreateWithoutKurtasLengthTypeInput = {
    id?: number
    work?: string | null
    productDescription: string
    chest: number
    shoulder: number
    transparencyOfTheFabric?: boolean
    weight?: number | null
    colorFamily?: string | null
    pocket: string
    type: string
    printAndpattern?: string | null
    kurtasNeckTypeId: number
    kurtasSleeveTypeId: number
    commonDescriptionId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    bottomDescription?: BottomDescriptionUncheckedCreateNestedManyWithoutKurtasDescriptionInput
  }

  export type KurtasDescriptionCreateOrConnectWithoutKurtasLengthTypeInput = {
    where: KurtasDescriptionWhereUniqueInput
    create: XOR<KurtasDescriptionCreateWithoutKurtasLengthTypeInput, KurtasDescriptionUncheckedCreateWithoutKurtasLengthTypeInput>
  }

  export type KurtasDescriptionCreateManyKurtasLengthTypeInputEnvelope = {
    data: Enumerable<KurtasDescriptionCreateManyKurtasLengthTypeInput>
    skipDuplicates?: boolean
  }

  export type KurtasDescriptionUpsertWithWhereUniqueWithoutKurtasLengthTypeInput = {
    where: KurtasDescriptionWhereUniqueInput
    update: XOR<KurtasDescriptionUpdateWithoutKurtasLengthTypeInput, KurtasDescriptionUncheckedUpdateWithoutKurtasLengthTypeInput>
    create: XOR<KurtasDescriptionCreateWithoutKurtasLengthTypeInput, KurtasDescriptionUncheckedCreateWithoutKurtasLengthTypeInput>
  }

  export type KurtasDescriptionUpdateWithWhereUniqueWithoutKurtasLengthTypeInput = {
    where: KurtasDescriptionWhereUniqueInput
    data: XOR<KurtasDescriptionUpdateWithoutKurtasLengthTypeInput, KurtasDescriptionUncheckedUpdateWithoutKurtasLengthTypeInput>
  }

  export type KurtasDescriptionUpdateManyWithWhereWithoutKurtasLengthTypeInput = {
    where: KurtasDescriptionScalarWhereInput
    data: XOR<KurtasDescriptionUpdateManyMutationInput, KurtasDescriptionUncheckedUpdateManyWithoutKurtasDescriptionInput>
  }

  export type BottomDescriptionCreateWithoutTypesOfPantsInput = {
    productDescription?: string | null
    weight?: number | null
    printAndPattern: string
    length: number
    waist: number
    hip: number
    type?: string | null
    colorFamily?: string | null
    pocket?: string | null
    beltLoop?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    typesOfPleats: TypesOfPleatsCreateNestedOneWithoutDescriptionInput
    typesOfLength: TypesOfLengthBottomCreateNestedOneWithoutDescriptionInput
    commonDescription: CommonDescriptionCreateNestedOneWithoutPantDescriptionInput
    kurtasDescription?: KurtasDescriptionCreateNestedOneWithoutBottomDescriptionInput
    topDescription?: TopDescriptionCreateNestedOneWithoutBottomDescriptionInput
  }

  export type BottomDescriptionUncheckedCreateWithoutTypesOfPantsInput = {
    id?: number
    productDescription?: string | null
    weight?: number | null
    printAndPattern: string
    length: number
    waist: number
    hip: number
    commonDescriptionId: number
    type?: string | null
    colorFamily?: string | null
    pocket?: string | null
    kurtasDescriptionId?: number | null
    topDescriptionId?: number | null
    beltLoop?: boolean
    typesOfPleatsId: number
    typesOfLengthId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type BottomDescriptionCreateOrConnectWithoutTypesOfPantsInput = {
    where: BottomDescriptionWhereUniqueInput
    create: XOR<BottomDescriptionCreateWithoutTypesOfPantsInput, BottomDescriptionUncheckedCreateWithoutTypesOfPantsInput>
  }

  export type BottomDescriptionCreateManyTypesOfPantsInputEnvelope = {
    data: Enumerable<BottomDescriptionCreateManyTypesOfPantsInput>
    skipDuplicates?: boolean
  }

  export type BottomDescriptionUpsertWithWhereUniqueWithoutTypesOfPantsInput = {
    where: BottomDescriptionWhereUniqueInput
    update: XOR<BottomDescriptionUpdateWithoutTypesOfPantsInput, BottomDescriptionUncheckedUpdateWithoutTypesOfPantsInput>
    create: XOR<BottomDescriptionCreateWithoutTypesOfPantsInput, BottomDescriptionUncheckedCreateWithoutTypesOfPantsInput>
  }

  export type BottomDescriptionUpdateWithWhereUniqueWithoutTypesOfPantsInput = {
    where: BottomDescriptionWhereUniqueInput
    data: XOR<BottomDescriptionUpdateWithoutTypesOfPantsInput, BottomDescriptionUncheckedUpdateWithoutTypesOfPantsInput>
  }

  export type BottomDescriptionUpdateManyWithWhereWithoutTypesOfPantsInput = {
    where: BottomDescriptionScalarWhereInput
    data: XOR<BottomDescriptionUpdateManyMutationInput, BottomDescriptionUncheckedUpdateManyWithoutDescriptionInput>
  }

  export type BottomDescriptionCreateWithoutTypesOfPleatsInput = {
    productDescription?: string | null
    weight?: number | null
    printAndPattern: string
    length: number
    waist: number
    hip: number
    type?: string | null
    colorFamily?: string | null
    pocket?: string | null
    beltLoop?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    typesOfPants: TypesOfBottomCreateNestedOneWithoutDescriptionInput
    typesOfLength: TypesOfLengthBottomCreateNestedOneWithoutDescriptionInput
    commonDescription: CommonDescriptionCreateNestedOneWithoutPantDescriptionInput
    kurtasDescription?: KurtasDescriptionCreateNestedOneWithoutBottomDescriptionInput
    topDescription?: TopDescriptionCreateNestedOneWithoutBottomDescriptionInput
  }

  export type BottomDescriptionUncheckedCreateWithoutTypesOfPleatsInput = {
    id?: number
    productDescription?: string | null
    weight?: number | null
    printAndPattern: string
    length: number
    waist: number
    hip: number
    commonDescriptionId: number
    type?: string | null
    colorFamily?: string | null
    pocket?: string | null
    kurtasDescriptionId?: number | null
    topDescriptionId?: number | null
    beltLoop?: boolean
    typeOfPantId: number
    typesOfLengthId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type BottomDescriptionCreateOrConnectWithoutTypesOfPleatsInput = {
    where: BottomDescriptionWhereUniqueInput
    create: XOR<BottomDescriptionCreateWithoutTypesOfPleatsInput, BottomDescriptionUncheckedCreateWithoutTypesOfPleatsInput>
  }

  export type BottomDescriptionCreateManyTypesOfPleatsInputEnvelope = {
    data: Enumerable<BottomDescriptionCreateManyTypesOfPleatsInput>
    skipDuplicates?: boolean
  }

  export type BottomDescriptionUpsertWithWhereUniqueWithoutTypesOfPleatsInput = {
    where: BottomDescriptionWhereUniqueInput
    update: XOR<BottomDescriptionUpdateWithoutTypesOfPleatsInput, BottomDescriptionUncheckedUpdateWithoutTypesOfPleatsInput>
    create: XOR<BottomDescriptionCreateWithoutTypesOfPleatsInput, BottomDescriptionUncheckedCreateWithoutTypesOfPleatsInput>
  }

  export type BottomDescriptionUpdateWithWhereUniqueWithoutTypesOfPleatsInput = {
    where: BottomDescriptionWhereUniqueInput
    data: XOR<BottomDescriptionUpdateWithoutTypesOfPleatsInput, BottomDescriptionUncheckedUpdateWithoutTypesOfPleatsInput>
  }

  export type BottomDescriptionUpdateManyWithWhereWithoutTypesOfPleatsInput = {
    where: BottomDescriptionScalarWhereInput
    data: XOR<BottomDescriptionUpdateManyMutationInput, BottomDescriptionUncheckedUpdateManyWithoutDescriptionInput>
  }

  export type BottomDescriptionCreateWithoutTypesOfLengthInput = {
    productDescription?: string | null
    weight?: number | null
    printAndPattern: string
    length: number
    waist: number
    hip: number
    type?: string | null
    colorFamily?: string | null
    pocket?: string | null
    beltLoop?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    typesOfPants: TypesOfBottomCreateNestedOneWithoutDescriptionInput
    typesOfPleats: TypesOfPleatsCreateNestedOneWithoutDescriptionInput
    commonDescription: CommonDescriptionCreateNestedOneWithoutPantDescriptionInput
    kurtasDescription?: KurtasDescriptionCreateNestedOneWithoutBottomDescriptionInput
    topDescription?: TopDescriptionCreateNestedOneWithoutBottomDescriptionInput
  }

  export type BottomDescriptionUncheckedCreateWithoutTypesOfLengthInput = {
    id?: number
    productDescription?: string | null
    weight?: number | null
    printAndPattern: string
    length: number
    waist: number
    hip: number
    commonDescriptionId: number
    type?: string | null
    colorFamily?: string | null
    pocket?: string | null
    kurtasDescriptionId?: number | null
    topDescriptionId?: number | null
    beltLoop?: boolean
    typeOfPantId: number
    typesOfPleatsId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type BottomDescriptionCreateOrConnectWithoutTypesOfLengthInput = {
    where: BottomDescriptionWhereUniqueInput
    create: XOR<BottomDescriptionCreateWithoutTypesOfLengthInput, BottomDescriptionUncheckedCreateWithoutTypesOfLengthInput>
  }

  export type BottomDescriptionCreateManyTypesOfLengthInputEnvelope = {
    data: Enumerable<BottomDescriptionCreateManyTypesOfLengthInput>
    skipDuplicates?: boolean
  }

  export type BottomDescriptionUpsertWithWhereUniqueWithoutTypesOfLengthInput = {
    where: BottomDescriptionWhereUniqueInput
    update: XOR<BottomDescriptionUpdateWithoutTypesOfLengthInput, BottomDescriptionUncheckedUpdateWithoutTypesOfLengthInput>
    create: XOR<BottomDescriptionCreateWithoutTypesOfLengthInput, BottomDescriptionUncheckedCreateWithoutTypesOfLengthInput>
  }

  export type BottomDescriptionUpdateWithWhereUniqueWithoutTypesOfLengthInput = {
    where: BottomDescriptionWhereUniqueInput
    data: XOR<BottomDescriptionUpdateWithoutTypesOfLengthInput, BottomDescriptionUncheckedUpdateWithoutTypesOfLengthInput>
  }

  export type BottomDescriptionUpdateManyWithWhereWithoutTypesOfLengthInput = {
    where: BottomDescriptionScalarWhereInput
    data: XOR<BottomDescriptionUpdateManyMutationInput, BottomDescriptionUncheckedUpdateManyWithoutDescriptionInput>
  }

  export type ProductAviableSizesCreateWithoutHistoryInput = {
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    productColor: ProductColorCreateNestedOneWithoutColorSizeInput
    productTypeSize: ProductTypeSizeCreateNestedOneWithoutAviableSizesInput
  }

  export type ProductAviableSizesUncheckedCreateWithoutHistoryInput = {
    id?: number
    quantity: number
    productColorId: number
    productTypeSizeId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ProductAviableSizesCreateOrConnectWithoutHistoryInput = {
    where: ProductAviableSizesWhereUniqueInput
    create: XOR<ProductAviableSizesCreateWithoutHistoryInput, ProductAviableSizesUncheckedCreateWithoutHistoryInput>
  }

  export type ProductAviableSizesUpsertWithoutHistoryInput = {
    update: XOR<ProductAviableSizesUpdateWithoutHistoryInput, ProductAviableSizesUncheckedUpdateWithoutHistoryInput>
    create: XOR<ProductAviableSizesCreateWithoutHistoryInput, ProductAviableSizesUncheckedCreateWithoutHistoryInput>
  }

  export type ProductAviableSizesUpdateWithoutHistoryInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productColor?: ProductColorUpdateOneRequiredWithoutColorSizeNestedInput
    productTypeSize?: ProductTypeSizeUpdateOneRequiredWithoutAviableSizesNestedInput
  }

  export type ProductAviableSizesUncheckedUpdateWithoutHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    productColorId?: IntFieldUpdateOperationsInput | number
    productTypeSizeId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductCreateWithoutOfferInput = {
    syncId: number
    title: string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    isActive?: boolean
    color?: ProductColorCreateNestedManyWithoutProductInput
    seasonalDresses?: SeasonalDressesCreateNestedManyWithoutProductInput
    productType: ProductTypeCreateNestedOneWithoutProductInput
    user?: UserCreateNestedOneWithoutUserProductInput
    priceHistory?: PriceHistoryCreateNestedManyWithoutProductInput
    commonDescription?: CommonDescriptionCreateNestedManyWithoutProductInput
    delivery?: DeleveryPeriodCreateNestedManyWithoutProductInput
    returns?: ReturnedProductCreateNestedManyWithoutProductInput
    cart?: CartCreateNestedManyWithoutProductInput
    wishlistItem?: WishlistItemCreateNestedManyWithoutProductInput
    productReviews?: ProductReviewCreateNestedManyWithoutProductInput
    order?: OrderCreateNestedManyWithoutProductInput
    productOwner?: ProductOwnerCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutOfferInput = {
    id?: number
    syncId: number
    title: string
    price: number
    productTypeId: number
    productOwnerId?: number | null
    userId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    isActive?: boolean
    color?: ProductColorUncheckedCreateNestedManyWithoutProductInput
    seasonalDresses?: SeasonalDressesUncheckedCreateNestedManyWithoutProductInput
    priceHistory?: PriceHistoryUncheckedCreateNestedManyWithoutProductInput
    commonDescription?: CommonDescriptionUncheckedCreateNestedManyWithoutProductInput
    delivery?: DeleveryPeriodUncheckedCreateNestedManyWithoutProductInput
    returns?: ReturnedProductUncheckedCreateNestedManyWithoutProductInput
    cart?: CartUncheckedCreateNestedManyWithoutProductInput
    wishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutProductInput
    productReviews?: ProductReviewUncheckedCreateNestedManyWithoutProductInput
    order?: OrderUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutOfferInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutOfferInput, ProductUncheckedCreateWithoutOfferInput>
  }

  export type OfferValidityCreateWithoutOfferInput = {
    fromDate: Date | string
    toDate: Date | string
    fromTime: Date | string
    toTime: Date | string
    monday: boolean
    tuesday: boolean
    wednesday: boolean
    thursday: boolean
    friday: boolean
    saturday: boolean
    sunday: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    offerPromotionPeriod?: OfferPromotionPeriodsCreateNestedOneWithoutOfferValidityInput
  }

  export type OfferValidityUncheckedCreateWithoutOfferInput = {
    id?: number
    fromDate: Date | string
    toDate: Date | string
    fromTime: Date | string
    toTime: Date | string
    monday: boolean
    tuesday: boolean
    wednesday: boolean
    thursday: boolean
    friday: boolean
    saturday: boolean
    sunday: boolean
    offerPromotionPeriodId?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type OfferValidityCreateOrConnectWithoutOfferInput = {
    where: OfferValidityWhereUniqueInput
    create: XOR<OfferValidityCreateWithoutOfferInput, OfferValidityUncheckedCreateWithoutOfferInput>
  }

  export type OfferValidityCreateManyOfferInputEnvelope = {
    data: Enumerable<OfferValidityCreateManyOfferInput>
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithoutOfferInput = {
    update: XOR<ProductUpdateWithoutOfferInput, ProductUncheckedUpdateWithoutOfferInput>
    create: XOR<ProductCreateWithoutOfferInput, ProductUncheckedCreateWithoutOfferInput>
  }

  export type ProductUpdateWithoutOfferInput = {
    syncId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    color?: ProductColorUpdateManyWithoutProductNestedInput
    seasonalDresses?: SeasonalDressesUpdateManyWithoutProductNestedInput
    productType?: ProductTypeUpdateOneRequiredWithoutProductNestedInput
    user?: UserUpdateOneWithoutUserProductNestedInput
    priceHistory?: PriceHistoryUpdateManyWithoutProductNestedInput
    commonDescription?: CommonDescriptionUpdateManyWithoutProductNestedInput
    delivery?: DeleveryPeriodUpdateManyWithoutProductNestedInput
    returns?: ReturnedProductUpdateManyWithoutProductNestedInput
    cart?: CartUpdateManyWithoutProductNestedInput
    wishlistItem?: WishlistItemUpdateManyWithoutProductNestedInput
    productReviews?: ProductReviewUpdateManyWithoutProductNestedInput
    order?: OrderUpdateManyWithoutProductNestedInput
    productOwner?: ProductOwnerUpdateOneWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutOfferInput = {
    id?: IntFieldUpdateOperationsInput | number
    syncId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    productTypeId?: IntFieldUpdateOperationsInput | number
    productOwnerId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    color?: ProductColorUncheckedUpdateManyWithoutProductNestedInput
    seasonalDresses?: SeasonalDressesUncheckedUpdateManyWithoutProductNestedInput
    priceHistory?: PriceHistoryUncheckedUpdateManyWithoutProductNestedInput
    commonDescription?: CommonDescriptionUncheckedUpdateManyWithoutProductNestedInput
    delivery?: DeleveryPeriodUncheckedUpdateManyWithoutProductNestedInput
    returns?: ReturnedProductUncheckedUpdateManyWithoutProductNestedInput
    cart?: CartUncheckedUpdateManyWithoutProductNestedInput
    wishlistItem?: WishlistItemUncheckedUpdateManyWithoutProductNestedInput
    productReviews?: ProductReviewUncheckedUpdateManyWithoutProductNestedInput
    order?: OrderUncheckedUpdateManyWithoutProductNestedInput
  }

  export type OfferValidityUpsertWithWhereUniqueWithoutOfferInput = {
    where: OfferValidityWhereUniqueInput
    update: XOR<OfferValidityUpdateWithoutOfferInput, OfferValidityUncheckedUpdateWithoutOfferInput>
    create: XOR<OfferValidityCreateWithoutOfferInput, OfferValidityUncheckedCreateWithoutOfferInput>
  }

  export type OfferValidityUpdateWithWhereUniqueWithoutOfferInput = {
    where: OfferValidityWhereUniqueInput
    data: XOR<OfferValidityUpdateWithoutOfferInput, OfferValidityUncheckedUpdateWithoutOfferInput>
  }

  export type OfferValidityUpdateManyWithWhereWithoutOfferInput = {
    where: OfferValidityScalarWhereInput
    data: XOR<OfferValidityUpdateManyMutationInput, OfferValidityUncheckedUpdateManyWithoutOfferValidityInput>
  }

  export type OfferValidityScalarWhereInput = {
    AND?: Enumerable<OfferValidityScalarWhereInput>
    OR?: Enumerable<OfferValidityScalarWhereInput>
    NOT?: Enumerable<OfferValidityScalarWhereInput>
    id?: IntFilter | number
    fromDate?: DateTimeFilter | Date | string
    toDate?: DateTimeFilter | Date | string
    fromTime?: DateTimeFilter | Date | string
    toTime?: DateTimeFilter | Date | string
    monday?: BoolFilter | boolean
    tuesday?: BoolFilter | boolean
    wednesday?: BoolFilter | boolean
    thursday?: BoolFilter | boolean
    friday?: BoolFilter | boolean
    saturday?: BoolFilter | boolean
    sunday?: BoolFilter | boolean
    offerId?: IntFilter | number
    offerPromotionPeriodId?: IntNullableFilter | number | null
    isActive?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type OfferCreateWithoutOfferValidityInput = {
    offerPercntage: number
    offerPrice: number
    currentPrice: number
    offerQuantity: number
    currentQuantity: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    product: ProductCreateNestedOneWithoutOfferInput
  }

  export type OfferUncheckedCreateWithoutOfferValidityInput = {
    id?: number
    productId: number
    offerPercntage: number
    offerPrice: number
    currentPrice: number
    offerQuantity: number
    currentQuantity: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type OfferCreateOrConnectWithoutOfferValidityInput = {
    where: OfferWhereUniqueInput
    create: XOR<OfferCreateWithoutOfferValidityInput, OfferUncheckedCreateWithoutOfferValidityInput>
  }

  export type OfferPromotionPeriodsCreateWithoutOfferValidityInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type OfferPromotionPeriodsUncheckedCreateWithoutOfferValidityInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type OfferPromotionPeriodsCreateOrConnectWithoutOfferValidityInput = {
    where: OfferPromotionPeriodsWhereUniqueInput
    create: XOR<OfferPromotionPeriodsCreateWithoutOfferValidityInput, OfferPromotionPeriodsUncheckedCreateWithoutOfferValidityInput>
  }

  export type OfferUpsertWithoutOfferValidityInput = {
    update: XOR<OfferUpdateWithoutOfferValidityInput, OfferUncheckedUpdateWithoutOfferValidityInput>
    create: XOR<OfferCreateWithoutOfferValidityInput, OfferUncheckedCreateWithoutOfferValidityInput>
  }

  export type OfferUpdateWithoutOfferValidityInput = {
    offerPercntage?: FloatFieldUpdateOperationsInput | number
    offerPrice?: FloatFieldUpdateOperationsInput | number
    currentPrice?: FloatFieldUpdateOperationsInput | number
    offerQuantity?: IntFieldUpdateOperationsInput | number
    currentQuantity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    product?: ProductUpdateOneRequiredWithoutOfferNestedInput
  }

  export type OfferUncheckedUpdateWithoutOfferValidityInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    offerPercntage?: FloatFieldUpdateOperationsInput | number
    offerPrice?: FloatFieldUpdateOperationsInput | number
    currentPrice?: FloatFieldUpdateOperationsInput | number
    offerQuantity?: IntFieldUpdateOperationsInput | number
    currentQuantity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OfferPromotionPeriodsUpsertWithoutOfferValidityInput = {
    update: XOR<OfferPromotionPeriodsUpdateWithoutOfferValidityInput, OfferPromotionPeriodsUncheckedUpdateWithoutOfferValidityInput>
    create: XOR<OfferPromotionPeriodsCreateWithoutOfferValidityInput, OfferPromotionPeriodsUncheckedCreateWithoutOfferValidityInput>
  }

  export type OfferPromotionPeriodsUpdateWithoutOfferValidityInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OfferPromotionPeriodsUncheckedUpdateWithoutOfferValidityInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OfferValidityCreateWithoutOfferPromotionPeriodInput = {
    fromDate: Date | string
    toDate: Date | string
    fromTime: Date | string
    toTime: Date | string
    monday: boolean
    tuesday: boolean
    wednesday: boolean
    thursday: boolean
    friday: boolean
    saturday: boolean
    sunday: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    offer?: OfferCreateNestedOneWithoutOfferValidityInput
  }

  export type OfferValidityUncheckedCreateWithoutOfferPromotionPeriodInput = {
    id?: number
    fromDate: Date | string
    toDate: Date | string
    fromTime: Date | string
    toTime: Date | string
    monday: boolean
    tuesday: boolean
    wednesday: boolean
    thursday: boolean
    friday: boolean
    saturday: boolean
    sunday: boolean
    offerId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type OfferValidityCreateOrConnectWithoutOfferPromotionPeriodInput = {
    where: OfferValidityWhereUniqueInput
    create: XOR<OfferValidityCreateWithoutOfferPromotionPeriodInput, OfferValidityUncheckedCreateWithoutOfferPromotionPeriodInput>
  }

  export type OfferValidityUpsertWithoutOfferPromotionPeriodInput = {
    update: XOR<OfferValidityUpdateWithoutOfferPromotionPeriodInput, OfferValidityUncheckedUpdateWithoutOfferPromotionPeriodInput>
    create: XOR<OfferValidityCreateWithoutOfferPromotionPeriodInput, OfferValidityUncheckedCreateWithoutOfferPromotionPeriodInput>
  }

  export type OfferValidityUpdateWithoutOfferPromotionPeriodInput = {
    fromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    toDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fromTime?: DateTimeFieldUpdateOperationsInput | Date | string
    toTime?: DateTimeFieldUpdateOperationsInput | Date | string
    monday?: BoolFieldUpdateOperationsInput | boolean
    tuesday?: BoolFieldUpdateOperationsInput | boolean
    wednesday?: BoolFieldUpdateOperationsInput | boolean
    thursday?: BoolFieldUpdateOperationsInput | boolean
    friday?: BoolFieldUpdateOperationsInput | boolean
    saturday?: BoolFieldUpdateOperationsInput | boolean
    sunday?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    offer?: OfferUpdateOneWithoutOfferValidityNestedInput
  }

  export type OfferValidityUncheckedUpdateWithoutOfferPromotionPeriodInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    toDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fromTime?: DateTimeFieldUpdateOperationsInput | Date | string
    toTime?: DateTimeFieldUpdateOperationsInput | Date | string
    monday?: BoolFieldUpdateOperationsInput | boolean
    tuesday?: BoolFieldUpdateOperationsInput | boolean
    wednesday?: BoolFieldUpdateOperationsInput | boolean
    thursday?: BoolFieldUpdateOperationsInput | boolean
    friday?: BoolFieldUpdateOperationsInput | boolean
    saturday?: BoolFieldUpdateOperationsInput | boolean
    sunday?: BoolFieldUpdateOperationsInput | boolean
    offerId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCreateWithoutAddCartInput = {
    username: string
    email: string
    mobile: string
    token?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userProduct?: ProductCreateNestedManyWithoutUserInput
    userAddress?: UserAddressCreateNestedManyWithoutUserInput
    wishlist?: WishlistCreateNestedManyWithoutUserInput
    loginRequests?: UserLoginRequestCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewCreateNestedManyWithoutUserInput
    order?: OrderCreateNestedManyWithoutUserInput
    userSearchItems?: SearchItemsCreateNestedManyWithoutUserInput
    password?: UserPasswordCreateNestedManyWithoutUserInput
    roles?: RolesCreateNestedOneWithoutUserInput
    gender: GenderCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAddCartInput = {
    id?: number
    username: string
    email: string
    mobile: string
    token?: string | null
    roleId?: number
    genderId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userProduct?: ProductUncheckedCreateNestedManyWithoutUserInput
    userAddress?: UserAddressUncheckedCreateNestedManyWithoutUserInput
    wishlist?: WishlistUncheckedCreateNestedManyWithoutUserInput
    loginRequests?: UserLoginRequestUncheckedCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewUncheckedCreateNestedManyWithoutUserInput
    order?: OrderUncheckedCreateNestedManyWithoutUserInput
    userSearchItems?: SearchItemsUncheckedCreateNestedManyWithoutUserInput
    password?: UserPasswordUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAddCartInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAddCartInput, UserUncheckedCreateWithoutAddCartInput>
  }

  export type ProductCreateWithoutCartInput = {
    syncId: number
    title: string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    isActive?: boolean
    color?: ProductColorCreateNestedManyWithoutProductInput
    offer?: OfferCreateNestedManyWithoutProductInput
    seasonalDresses?: SeasonalDressesCreateNestedManyWithoutProductInput
    productType: ProductTypeCreateNestedOneWithoutProductInput
    user?: UserCreateNestedOneWithoutUserProductInput
    priceHistory?: PriceHistoryCreateNestedManyWithoutProductInput
    commonDescription?: CommonDescriptionCreateNestedManyWithoutProductInput
    delivery?: DeleveryPeriodCreateNestedManyWithoutProductInput
    returns?: ReturnedProductCreateNestedManyWithoutProductInput
    wishlistItem?: WishlistItemCreateNestedManyWithoutProductInput
    productReviews?: ProductReviewCreateNestedManyWithoutProductInput
    order?: OrderCreateNestedManyWithoutProductInput
    productOwner?: ProductOwnerCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutCartInput = {
    id?: number
    syncId: number
    title: string
    price: number
    productTypeId: number
    productOwnerId?: number | null
    userId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    isActive?: boolean
    color?: ProductColorUncheckedCreateNestedManyWithoutProductInput
    offer?: OfferUncheckedCreateNestedManyWithoutProductInput
    seasonalDresses?: SeasonalDressesUncheckedCreateNestedManyWithoutProductInput
    priceHistory?: PriceHistoryUncheckedCreateNestedManyWithoutProductInput
    commonDescription?: CommonDescriptionUncheckedCreateNestedManyWithoutProductInput
    delivery?: DeleveryPeriodUncheckedCreateNestedManyWithoutProductInput
    returns?: ReturnedProductUncheckedCreateNestedManyWithoutProductInput
    wishlistItem?: WishlistItemUncheckedCreateNestedManyWithoutProductInput
    productReviews?: ProductReviewUncheckedCreateNestedManyWithoutProductInput
    order?: OrderUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCartInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCartInput, ProductUncheckedCreateWithoutCartInput>
  }

  export type UserUpsertWithoutAddCartInput = {
    update: XOR<UserUpdateWithoutAddCartInput, UserUncheckedUpdateWithoutAddCartInput>
    create: XOR<UserCreateWithoutAddCartInput, UserUncheckedCreateWithoutAddCartInput>
  }

  export type UserUpdateWithoutAddCartInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userProduct?: ProductUpdateManyWithoutUserNestedInput
    userAddress?: UserAddressUpdateManyWithoutUserNestedInput
    wishlist?: WishlistUpdateManyWithoutUserNestedInput
    loginRequests?: UserLoginRequestUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUpdateManyWithoutUserNestedInput
    order?: OrderUpdateManyWithoutUserNestedInput
    userSearchItems?: SearchItemsUpdateManyWithoutUserNestedInput
    password?: UserPasswordUpdateManyWithoutUserNestedInput
    roles?: RolesUpdateOneRequiredWithoutUserNestedInput
    gender?: GenderUpdateOneRequiredWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAddCartInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: IntFieldUpdateOperationsInput | number
    genderId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userProduct?: ProductUncheckedUpdateManyWithoutUserNestedInput
    userAddress?: UserAddressUncheckedUpdateManyWithoutUserNestedInput
    wishlist?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    loginRequests?: UserLoginRequestUncheckedUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUncheckedUpdateManyWithoutUserNestedInput
    order?: OrderUncheckedUpdateManyWithoutUserNestedInput
    userSearchItems?: SearchItemsUncheckedUpdateManyWithoutUserNestedInput
    password?: UserPasswordUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProductUpsertWithoutCartInput = {
    update: XOR<ProductUpdateWithoutCartInput, ProductUncheckedUpdateWithoutCartInput>
    create: XOR<ProductCreateWithoutCartInput, ProductUncheckedCreateWithoutCartInput>
  }

  export type ProductUpdateWithoutCartInput = {
    syncId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    color?: ProductColorUpdateManyWithoutProductNestedInput
    offer?: OfferUpdateManyWithoutProductNestedInput
    seasonalDresses?: SeasonalDressesUpdateManyWithoutProductNestedInput
    productType?: ProductTypeUpdateOneRequiredWithoutProductNestedInput
    user?: UserUpdateOneWithoutUserProductNestedInput
    priceHistory?: PriceHistoryUpdateManyWithoutProductNestedInput
    commonDescription?: CommonDescriptionUpdateManyWithoutProductNestedInput
    delivery?: DeleveryPeriodUpdateManyWithoutProductNestedInput
    returns?: ReturnedProductUpdateManyWithoutProductNestedInput
    wishlistItem?: WishlistItemUpdateManyWithoutProductNestedInput
    productReviews?: ProductReviewUpdateManyWithoutProductNestedInput
    order?: OrderUpdateManyWithoutProductNestedInput
    productOwner?: ProductOwnerUpdateOneWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutCartInput = {
    id?: IntFieldUpdateOperationsInput | number
    syncId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    productTypeId?: IntFieldUpdateOperationsInput | number
    productOwnerId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    color?: ProductColorUncheckedUpdateManyWithoutProductNestedInput
    offer?: OfferUncheckedUpdateManyWithoutProductNestedInput
    seasonalDresses?: SeasonalDressesUncheckedUpdateManyWithoutProductNestedInput
    priceHistory?: PriceHistoryUncheckedUpdateManyWithoutProductNestedInput
    commonDescription?: CommonDescriptionUncheckedUpdateManyWithoutProductNestedInput
    delivery?: DeleveryPeriodUncheckedUpdateManyWithoutProductNestedInput
    returns?: ReturnedProductUncheckedUpdateManyWithoutProductNestedInput
    wishlistItem?: WishlistItemUncheckedUpdateManyWithoutProductNestedInput
    productReviews?: ProductReviewUncheckedUpdateManyWithoutProductNestedInput
    order?: OrderUncheckedUpdateManyWithoutProductNestedInput
  }

  export type WishlistItemCreateWithoutWishlistInput = {
    product: ProductCreateNestedOneWithoutWishlistItemInput
  }

  export type WishlistItemUncheckedCreateWithoutWishlistInput = {
    id?: number
    productId: number
  }

  export type WishlistItemCreateOrConnectWithoutWishlistInput = {
    where: WishlistItemWhereUniqueInput
    create: XOR<WishlistItemCreateWithoutWishlistInput, WishlistItemUncheckedCreateWithoutWishlistInput>
  }

  export type WishlistItemCreateManyWishlistInputEnvelope = {
    data: Enumerable<WishlistItemCreateManyWishlistInput>
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutWishlistInput = {
    username: string
    email: string
    mobile: string
    token?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userProduct?: ProductCreateNestedManyWithoutUserInput
    userAddress?: UserAddressCreateNestedManyWithoutUserInput
    addCart?: CartCreateNestedManyWithoutUserInput
    loginRequests?: UserLoginRequestCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewCreateNestedManyWithoutUserInput
    order?: OrderCreateNestedManyWithoutUserInput
    userSearchItems?: SearchItemsCreateNestedManyWithoutUserInput
    password?: UserPasswordCreateNestedManyWithoutUserInput
    roles?: RolesCreateNestedOneWithoutUserInput
    gender: GenderCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWishlistInput = {
    id?: number
    username: string
    email: string
    mobile: string
    token?: string | null
    roleId?: number
    genderId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userProduct?: ProductUncheckedCreateNestedManyWithoutUserInput
    userAddress?: UserAddressUncheckedCreateNestedManyWithoutUserInput
    addCart?: CartUncheckedCreateNestedManyWithoutUserInput
    loginRequests?: UserLoginRequestUncheckedCreateNestedManyWithoutUserInput
    ProductReview?: ProductReviewUncheckedCreateNestedManyWithoutUserInput
    order?: OrderUncheckedCreateNestedManyWithoutUserInput
    userSearchItems?: SearchItemsUncheckedCreateNestedManyWithoutUserInput
    password?: UserPasswordUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWishlistInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWishlistInput, UserUncheckedCreateWithoutWishlistInput>
  }

  export type WishlistItemUpsertWithWhereUniqueWithoutWishlistInput = {
    where: WishlistItemWhereUniqueInput
    update: XOR<WishlistItemUpdateWithoutWishlistInput, WishlistItemUncheckedUpdateWithoutWishlistInput>
    create: XOR<WishlistItemCreateWithoutWishlistInput, WishlistItemUncheckedCreateWithoutWishlistInput>
  }

  export type WishlistItemUpdateWithWhereUniqueWithoutWishlistInput = {
    where: WishlistItemWhereUniqueInput
    data: XOR<WishlistItemUpdateWithoutWishlistInput, WishlistItemUncheckedUpdateWithoutWishlistInput>
  }

  export type WishlistItemUpdateManyWithWhereWithoutWishlistInput = {
    where: WishlistItemScalarWhereInput
    data: XOR<WishlistItemUpdateManyMutationInput, WishlistItemUncheckedUpdateManyWithoutItemsInput>
  }

  export type UserUpsertWithoutWishlistInput = {
    update: XOR<UserUpdateWithoutWishlistInput, UserUncheckedUpdateWithoutWishlistInput>
    create: XOR<UserCreateWithoutWishlistInput, UserUncheckedCreateWithoutWishlistInput>
  }

  export type UserUpdateWithoutWishlistInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userProduct?: ProductUpdateManyWithoutUserNestedInput
    userAddress?: UserAddressUpdateManyWithoutUserNestedInput
    addCart?: CartUpdateManyWithoutUserNestedInput
    loginRequests?: UserLoginRequestUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUpdateManyWithoutUserNestedInput
    order?: OrderUpdateManyWithoutUserNestedInput
    userSearchItems?: SearchItemsUpdateManyWithoutUserNestedInput
    password?: UserPasswordUpdateManyWithoutUserNestedInput
    roles?: RolesUpdateOneRequiredWithoutUserNestedInput
    gender?: GenderUpdateOneRequiredWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWishlistInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: IntFieldUpdateOperationsInput | number
    genderId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userProduct?: ProductUncheckedUpdateManyWithoutUserNestedInput
    userAddress?: UserAddressUncheckedUpdateManyWithoutUserNestedInput
    addCart?: CartUncheckedUpdateManyWithoutUserNestedInput
    loginRequests?: UserLoginRequestUncheckedUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUncheckedUpdateManyWithoutUserNestedInput
    order?: OrderUncheckedUpdateManyWithoutUserNestedInput
    userSearchItems?: SearchItemsUncheckedUpdateManyWithoutUserNestedInput
    password?: UserPasswordUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WishlistCreateWithoutItemsInput = {
    user: UserCreateNestedOneWithoutWishlistInput
  }

  export type WishlistUncheckedCreateWithoutItemsInput = {
    id?: number
    userId: number
  }

  export type WishlistCreateOrConnectWithoutItemsInput = {
    where: WishlistWhereUniqueInput
    create: XOR<WishlistCreateWithoutItemsInput, WishlistUncheckedCreateWithoutItemsInput>
  }

  export type ProductCreateWithoutWishlistItemInput = {
    syncId: number
    title: string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    isActive?: boolean
    color?: ProductColorCreateNestedManyWithoutProductInput
    offer?: OfferCreateNestedManyWithoutProductInput
    seasonalDresses?: SeasonalDressesCreateNestedManyWithoutProductInput
    productType: ProductTypeCreateNestedOneWithoutProductInput
    user?: UserCreateNestedOneWithoutUserProductInput
    priceHistory?: PriceHistoryCreateNestedManyWithoutProductInput
    commonDescription?: CommonDescriptionCreateNestedManyWithoutProductInput
    delivery?: DeleveryPeriodCreateNestedManyWithoutProductInput
    returns?: ReturnedProductCreateNestedManyWithoutProductInput
    cart?: CartCreateNestedManyWithoutProductInput
    productReviews?: ProductReviewCreateNestedManyWithoutProductInput
    order?: OrderCreateNestedManyWithoutProductInput
    productOwner?: ProductOwnerCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutWishlistItemInput = {
    id?: number
    syncId: number
    title: string
    price: number
    productTypeId: number
    productOwnerId?: number | null
    userId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    isActive?: boolean
    color?: ProductColorUncheckedCreateNestedManyWithoutProductInput
    offer?: OfferUncheckedCreateNestedManyWithoutProductInput
    seasonalDresses?: SeasonalDressesUncheckedCreateNestedManyWithoutProductInput
    priceHistory?: PriceHistoryUncheckedCreateNestedManyWithoutProductInput
    commonDescription?: CommonDescriptionUncheckedCreateNestedManyWithoutProductInput
    delivery?: DeleveryPeriodUncheckedCreateNestedManyWithoutProductInput
    returns?: ReturnedProductUncheckedCreateNestedManyWithoutProductInput
    cart?: CartUncheckedCreateNestedManyWithoutProductInput
    productReviews?: ProductReviewUncheckedCreateNestedManyWithoutProductInput
    order?: OrderUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutWishlistItemInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutWishlistItemInput, ProductUncheckedCreateWithoutWishlistItemInput>
  }

  export type WishlistUpsertWithoutItemsInput = {
    update: XOR<WishlistUpdateWithoutItemsInput, WishlistUncheckedUpdateWithoutItemsInput>
    create: XOR<WishlistCreateWithoutItemsInput, WishlistUncheckedCreateWithoutItemsInput>
  }

  export type WishlistUpdateWithoutItemsInput = {
    user?: UserUpdateOneRequiredWithoutWishlistNestedInput
  }

  export type WishlistUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type ProductUpsertWithoutWishlistItemInput = {
    update: XOR<ProductUpdateWithoutWishlistItemInput, ProductUncheckedUpdateWithoutWishlistItemInput>
    create: XOR<ProductCreateWithoutWishlistItemInput, ProductUncheckedCreateWithoutWishlistItemInput>
  }

  export type ProductUpdateWithoutWishlistItemInput = {
    syncId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    color?: ProductColorUpdateManyWithoutProductNestedInput
    offer?: OfferUpdateManyWithoutProductNestedInput
    seasonalDresses?: SeasonalDressesUpdateManyWithoutProductNestedInput
    productType?: ProductTypeUpdateOneRequiredWithoutProductNestedInput
    user?: UserUpdateOneWithoutUserProductNestedInput
    priceHistory?: PriceHistoryUpdateManyWithoutProductNestedInput
    commonDescription?: CommonDescriptionUpdateManyWithoutProductNestedInput
    delivery?: DeleveryPeriodUpdateManyWithoutProductNestedInput
    returns?: ReturnedProductUpdateManyWithoutProductNestedInput
    cart?: CartUpdateManyWithoutProductNestedInput
    productReviews?: ProductReviewUpdateManyWithoutProductNestedInput
    order?: OrderUpdateManyWithoutProductNestedInput
    productOwner?: ProductOwnerUpdateOneWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutWishlistItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    syncId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    productTypeId?: IntFieldUpdateOperationsInput | number
    productOwnerId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    color?: ProductColorUncheckedUpdateManyWithoutProductNestedInput
    offer?: OfferUncheckedUpdateManyWithoutProductNestedInput
    seasonalDresses?: SeasonalDressesUncheckedUpdateManyWithoutProductNestedInput
    priceHistory?: PriceHistoryUncheckedUpdateManyWithoutProductNestedInput
    commonDescription?: CommonDescriptionUncheckedUpdateManyWithoutProductNestedInput
    delivery?: DeleveryPeriodUncheckedUpdateManyWithoutProductNestedInput
    returns?: ReturnedProductUncheckedUpdateManyWithoutProductNestedInput
    cart?: CartUncheckedUpdateManyWithoutProductNestedInput
    productReviews?: ProductReviewUncheckedUpdateManyWithoutProductNestedInput
    order?: OrderUncheckedUpdateManyWithoutProductNestedInput
  }

  export type UserCreateManyRolesInput = {
    id?: number
    username: string
    email: string
    mobile: string
    token?: string | null
    genderId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UserUpdateWithoutRolesInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userProduct?: ProductUpdateManyWithoutUserNestedInput
    userAddress?: UserAddressUpdateManyWithoutUserNestedInput
    addCart?: CartUpdateManyWithoutUserNestedInput
    wishlist?: WishlistUpdateManyWithoutUserNestedInput
    loginRequests?: UserLoginRequestUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUpdateManyWithoutUserNestedInput
    order?: OrderUpdateManyWithoutUserNestedInput
    userSearchItems?: SearchItemsUpdateManyWithoutUserNestedInput
    password?: UserPasswordUpdateManyWithoutUserNestedInput
    gender?: GenderUpdateOneRequiredWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    genderId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userProduct?: ProductUncheckedUpdateManyWithoutUserNestedInput
    userAddress?: UserAddressUncheckedUpdateManyWithoutUserNestedInput
    addCart?: CartUncheckedUpdateManyWithoutUserNestedInput
    wishlist?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    loginRequests?: UserLoginRequestUncheckedUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUncheckedUpdateManyWithoutUserNestedInput
    order?: OrderUncheckedUpdateManyWithoutUserNestedInput
    userSearchItems?: SearchItemsUncheckedUpdateManyWithoutUserNestedInput
    password?: UserPasswordUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    genderId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductTypeCreateManyProductCategoryInput = {
    id?: number
    itemsName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ProductTypeUpdateWithoutProductCategoryInput = {
    itemsName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sizes?: ProductTypeSizeUpdateManyWithoutProductTypeNestedInput
    product?: ProductUpdateManyWithoutProductTypeNestedInput
  }

  export type ProductTypeUncheckedUpdateWithoutProductCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemsName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sizes?: ProductTypeSizeUncheckedUpdateManyWithoutProductTypeNestedInput
    product?: ProductUncheckedUpdateManyWithoutProductTypeNestedInput
  }

  export type ProductTypeUncheckedUpdateManyWithoutProductTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemsName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductTypeSizeCreateManyProductTypeInput = {
    id?: number
    size: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ProductCreateManyProductTypeInput = {
    id?: number
    syncId: number
    title: string
    price: number
    productOwnerId?: number | null
    userId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    isActive?: boolean
  }

  export type ProductTypeSizeUpdateWithoutProductTypeInput = {
    size?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aviableSizes?: ProductAviableSizesUpdateManyWithoutProductTypeSizeNestedInput
  }

  export type ProductTypeSizeUncheckedUpdateWithoutProductTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    size?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aviableSizes?: ProductAviableSizesUncheckedUpdateManyWithoutProductTypeSizeNestedInput
  }

  export type ProductTypeSizeUncheckedUpdateManyWithoutSizesInput = {
    id?: IntFieldUpdateOperationsInput | number
    size?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductUpdateWithoutProductTypeInput = {
    syncId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    color?: ProductColorUpdateManyWithoutProductNestedInput
    offer?: OfferUpdateManyWithoutProductNestedInput
    seasonalDresses?: SeasonalDressesUpdateManyWithoutProductNestedInput
    user?: UserUpdateOneWithoutUserProductNestedInput
    priceHistory?: PriceHistoryUpdateManyWithoutProductNestedInput
    commonDescription?: CommonDescriptionUpdateManyWithoutProductNestedInput
    delivery?: DeleveryPeriodUpdateManyWithoutProductNestedInput
    returns?: ReturnedProductUpdateManyWithoutProductNestedInput
    cart?: CartUpdateManyWithoutProductNestedInput
    wishlistItem?: WishlistItemUpdateManyWithoutProductNestedInput
    productReviews?: ProductReviewUpdateManyWithoutProductNestedInput
    order?: OrderUpdateManyWithoutProductNestedInput
    productOwner?: ProductOwnerUpdateOneWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutProductTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    syncId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    productOwnerId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    color?: ProductColorUncheckedUpdateManyWithoutProductNestedInput
    offer?: OfferUncheckedUpdateManyWithoutProductNestedInput
    seasonalDresses?: SeasonalDressesUncheckedUpdateManyWithoutProductNestedInput
    priceHistory?: PriceHistoryUncheckedUpdateManyWithoutProductNestedInput
    commonDescription?: CommonDescriptionUncheckedUpdateManyWithoutProductNestedInput
    delivery?: DeleveryPeriodUncheckedUpdateManyWithoutProductNestedInput
    returns?: ReturnedProductUncheckedUpdateManyWithoutProductNestedInput
    cart?: CartUncheckedUpdateManyWithoutProductNestedInput
    wishlistItem?: WishlistItemUncheckedUpdateManyWithoutProductNestedInput
    productReviews?: ProductReviewUncheckedUpdateManyWithoutProductNestedInput
    order?: OrderUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    syncId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    productOwnerId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductAviableSizesCreateManyProductTypeSizeInput = {
    id?: number
    quantity: number
    productColorId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ProductAviableSizesUpdateWithoutProductTypeSizeInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    history?: QuantityHistoryUpdateManyWithoutProductAviableSizesNestedInput
    productColor?: ProductColorUpdateOneRequiredWithoutColorSizeNestedInput
  }

  export type ProductAviableSizesUncheckedUpdateWithoutProductTypeSizeInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    productColorId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    history?: QuantityHistoryUncheckedUpdateManyWithoutProductAviableSizesNestedInput
  }

  export type ProductAviableSizesUncheckedUpdateManyWithoutAviableSizesInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    productColorId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductCategoryCreateManyGenderInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UserCreateManyGenderInput = {
    id?: number
    username: string
    email: string
    mobile: string
    token?: string | null
    roleId?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ProductCategoryUpdateWithoutGenderInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productType?: ProductTypeUpdateManyWithoutProductCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateWithoutGenderInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productType?: ProductTypeUncheckedUpdateManyWithoutProductCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateManyWithoutProductCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUpdateWithoutGenderInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userProduct?: ProductUpdateManyWithoutUserNestedInput
    userAddress?: UserAddressUpdateManyWithoutUserNestedInput
    addCart?: CartUpdateManyWithoutUserNestedInput
    wishlist?: WishlistUpdateManyWithoutUserNestedInput
    loginRequests?: UserLoginRequestUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUpdateManyWithoutUserNestedInput
    order?: OrderUpdateManyWithoutUserNestedInput
    userSearchItems?: SearchItemsUpdateManyWithoutUserNestedInput
    password?: UserPasswordUpdateManyWithoutUserNestedInput
    roles?: RolesUpdateOneRequiredWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutGenderInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    mobile?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userProduct?: ProductUncheckedUpdateManyWithoutUserNestedInput
    userAddress?: UserAddressUncheckedUpdateManyWithoutUserNestedInput
    addCart?: CartUncheckedUpdateManyWithoutUserNestedInput
    wishlist?: WishlistUncheckedUpdateManyWithoutUserNestedInput
    loginRequests?: UserLoginRequestUncheckedUpdateManyWithoutUserNestedInput
    ProductReview?: ProductReviewUncheckedUpdateManyWithoutUserNestedInput
    order?: OrderUncheckedUpdateManyWithoutUserNestedInput
    userSearchItems?: SearchItemsUncheckedUpdateManyWithoutUserNestedInput
    password?: UserPasswordUncheckedUpdateManyWithoutUserNestedInput
  }

  export type StateCreateManyCountryInput = {
    id?: number
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type StateUpdateWithoutCountryInput = {
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    district?: AddressUpdateManyWithoutStateNestedInput
  }

  export type StateUncheckedUpdateWithoutCountryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    district?: AddressUncheckedUpdateManyWithoutStateNestedInput
  }

  export type StateUncheckedUpdateManyWithoutStateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AddressCreateManyStateInput = {
    id?: number
    doorNumber: string
    streetName: string
    pinCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AddressUpdateWithoutStateInput = {
    doorNumber?: StringFieldUpdateOperationsInput | string
    streetName?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userAddress?: UserAddressUpdateManyWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateWithoutStateInput = {
    id?: IntFieldUpdateOperationsInput | number
    doorNumber?: StringFieldUpdateOperationsInput | string
    streetName?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userAddress?: UserAddressUncheckedUpdateManyWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateManyWithoutDistrictInput = {
    id?: IntFieldUpdateOperationsInput | number
    doorNumber?: StringFieldUpdateOperationsInput | string
    streetName?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserAddressCreateManyAddressInput = {
    id?: number
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UserAddressUpdateWithoutAddressInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutUserAddressNestedInput
  }

  export type UserAddressUncheckedUpdateWithoutAddressInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserAddressUncheckedUpdateManyWithoutUserAddressInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductCreateManyUserInput = {
    id?: number
    syncId: number
    title: string
    price: number
    productTypeId: number
    productOwnerId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    isActive?: boolean
  }

  export type UserAddressCreateManyUserInput = {
    id?: number
    addressId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type CartCreateManyUserInput = {
    id?: number
    productId: number
    isCheckedOut: boolean
    isRemoved: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type WishlistCreateManyUserInput = {
    id?: number
  }

  export type UserLoginRequestCreateManyUserInput = {
    id?: number
    email: string
    mobile?: string | null
    otp: string
    isUsed?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ProductReviewCreateManyUserInput = {
    id?: number
    productId: number
    review: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type OrderCreateManyUserInput = {
    id?: number
    productId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type SearchItemsCreateManyUserInput = {
    id?: number
    searchName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UserPasswordCreateManyUserInput = {
    id?: number
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ProductUpdateWithoutUserInput = {
    syncId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    color?: ProductColorUpdateManyWithoutProductNestedInput
    offer?: OfferUpdateManyWithoutProductNestedInput
    seasonalDresses?: SeasonalDressesUpdateManyWithoutProductNestedInput
    productType?: ProductTypeUpdateOneRequiredWithoutProductNestedInput
    priceHistory?: PriceHistoryUpdateManyWithoutProductNestedInput
    commonDescription?: CommonDescriptionUpdateManyWithoutProductNestedInput
    delivery?: DeleveryPeriodUpdateManyWithoutProductNestedInput
    returns?: ReturnedProductUpdateManyWithoutProductNestedInput
    cart?: CartUpdateManyWithoutProductNestedInput
    wishlistItem?: WishlistItemUpdateManyWithoutProductNestedInput
    productReviews?: ProductReviewUpdateManyWithoutProductNestedInput
    order?: OrderUpdateManyWithoutProductNestedInput
    productOwner?: ProductOwnerUpdateOneWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    syncId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    productTypeId?: IntFieldUpdateOperationsInput | number
    productOwnerId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    color?: ProductColorUncheckedUpdateManyWithoutProductNestedInput
    offer?: OfferUncheckedUpdateManyWithoutProductNestedInput
    seasonalDresses?: SeasonalDressesUncheckedUpdateManyWithoutProductNestedInput
    priceHistory?: PriceHistoryUncheckedUpdateManyWithoutProductNestedInput
    commonDescription?: CommonDescriptionUncheckedUpdateManyWithoutProductNestedInput
    delivery?: DeleveryPeriodUncheckedUpdateManyWithoutProductNestedInput
    returns?: ReturnedProductUncheckedUpdateManyWithoutProductNestedInput
    cart?: CartUncheckedUpdateManyWithoutProductNestedInput
    wishlistItem?: WishlistItemUncheckedUpdateManyWithoutProductNestedInput
    productReviews?: ProductReviewUncheckedUpdateManyWithoutProductNestedInput
    order?: OrderUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutUserProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    syncId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    productTypeId?: IntFieldUpdateOperationsInput | number
    productOwnerId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserAddressUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: AddressUpdateOneRequiredWithoutUserAddressNestedInput
  }

  export type UserAddressUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    addressId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CartUpdateWithoutUserInput = {
    isCheckedOut?: BoolFieldUpdateOperationsInput | boolean
    isRemoved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    product?: ProductUpdateOneRequiredWithoutCartNestedInput
  }

  export type CartUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    isCheckedOut?: BoolFieldUpdateOperationsInput | boolean
    isRemoved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CartUncheckedUpdateManyWithoutAddCartInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    isCheckedOut?: BoolFieldUpdateOperationsInput | boolean
    isRemoved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WishlistUpdateWithoutUserInput = {
    items?: WishlistItemUpdateManyWithoutWishlistNestedInput
  }

  export type WishlistUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    items?: WishlistItemUncheckedUpdateManyWithoutWishlistNestedInput
  }

  export type WishlistUncheckedUpdateManyWithoutWishlistInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type UserLoginRequestUpdateWithoutUserInput = {
    email?: StringFieldUpdateOperationsInput | string
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserLoginRequestUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserLoginRequestUncheckedUpdateManyWithoutLoginRequestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductReviewUpdateWithoutUserInput = {
    review?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    product?: ProductUpdateOneRequiredWithoutProductReviewsNestedInput
  }

  export type ProductReviewUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    review?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductReviewUncheckedUpdateManyWithoutProductReviewInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    review?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    product?: ProductUpdateOneRequiredWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderUncheckedUpdateManyWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SearchItemsUpdateWithoutUserInput = {
    searchName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SearchItemsUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    searchName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SearchItemsUncheckedUpdateManyWithoutUserSearchItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    searchName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserPasswordUpdateWithoutUserInput = {
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserPasswordUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserPasswordUncheckedUpdateManyWithoutPasswordInput = {
    id?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductCreateManyProductOwnerInput = {
    id?: number
    syncId: number
    title: string
    price: number
    productTypeId: number
    userId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    isActive?: boolean
  }

  export type ProductUpdateWithoutProductOwnerInput = {
    syncId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    color?: ProductColorUpdateManyWithoutProductNestedInput
    offer?: OfferUpdateManyWithoutProductNestedInput
    seasonalDresses?: SeasonalDressesUpdateManyWithoutProductNestedInput
    productType?: ProductTypeUpdateOneRequiredWithoutProductNestedInput
    user?: UserUpdateOneWithoutUserProductNestedInput
    priceHistory?: PriceHistoryUpdateManyWithoutProductNestedInput
    commonDescription?: CommonDescriptionUpdateManyWithoutProductNestedInput
    delivery?: DeleveryPeriodUpdateManyWithoutProductNestedInput
    returns?: ReturnedProductUpdateManyWithoutProductNestedInput
    cart?: CartUpdateManyWithoutProductNestedInput
    wishlistItem?: WishlistItemUpdateManyWithoutProductNestedInput
    productReviews?: ProductReviewUpdateManyWithoutProductNestedInput
    order?: OrderUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutProductOwnerInput = {
    id?: IntFieldUpdateOperationsInput | number
    syncId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    productTypeId?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    color?: ProductColorUncheckedUpdateManyWithoutProductNestedInput
    offer?: OfferUncheckedUpdateManyWithoutProductNestedInput
    seasonalDresses?: SeasonalDressesUncheckedUpdateManyWithoutProductNestedInput
    priceHistory?: PriceHistoryUncheckedUpdateManyWithoutProductNestedInput
    commonDescription?: CommonDescriptionUncheckedUpdateManyWithoutProductNestedInput
    delivery?: DeleveryPeriodUncheckedUpdateManyWithoutProductNestedInput
    returns?: ReturnedProductUncheckedUpdateManyWithoutProductNestedInput
    cart?: CartUncheckedUpdateManyWithoutProductNestedInput
    wishlistItem?: WishlistItemUncheckedUpdateManyWithoutProductNestedInput
    productReviews?: ProductReviewUncheckedUpdateManyWithoutProductNestedInput
    order?: OrderUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductColorCreateManyProductInput = {
    id?: number
    colors: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type OfferCreateManyProductInput = {
    id?: number
    offerPercntage: number
    offerPrice: number
    currentPrice: number
    offerQuantity: number
    currentQuantity: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type SeasonalDressesCreateManyProductInput = {
    id?: number
    seasonal: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PriceHistoryCreateManyProductInput = {
    id?: number
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type CommonDescriptionCreateManyProductInput = {
    id?: number
    fit?: string | null
    materail: string
    care: string
    brandName: string
    origin: string
    occasion: string
    specialFeature?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type DeleveryPeriodCreateManyProductInput = {
    id?: number
    deliveryForMetroCitys: number
    deliveryForOtherCitys: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ReturnedProductCreateManyProductInput = {
    id?: number
    returns: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type CartCreateManyProductInput = {
    id?: number
    userId: number
    isCheckedOut: boolean
    isRemoved: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type WishlistItemCreateManyProductInput = {
    id?: number
    wishlistId: number
  }

  export type ProductReviewCreateManyProductInput = {
    id?: number
    userId: number
    review: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type OrderCreateManyProductInput = {
    id?: number
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ProductColorUpdateWithoutProductInput = {
    colors?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    colorSize?: ProductAviableSizesUpdateManyWithoutProductColorNestedInput
    productImages?: ProductImagesUpdateManyWithoutProductColorNestedInput
  }

  export type ProductColorUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    colors?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    colorSize?: ProductAviableSizesUncheckedUpdateManyWithoutProductColorNestedInput
    productImages?: ProductImagesUncheckedUpdateManyWithoutProductColorNestedInput
  }

  export type ProductColorUncheckedUpdateManyWithoutColorInput = {
    id?: IntFieldUpdateOperationsInput | number
    colors?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OfferUpdateWithoutProductInput = {
    offerPercntage?: FloatFieldUpdateOperationsInput | number
    offerPrice?: FloatFieldUpdateOperationsInput | number
    currentPrice?: FloatFieldUpdateOperationsInput | number
    offerQuantity?: IntFieldUpdateOperationsInput | number
    currentQuantity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    offerValidity?: OfferValidityUpdateManyWithoutOfferNestedInput
  }

  export type OfferUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    offerPercntage?: FloatFieldUpdateOperationsInput | number
    offerPrice?: FloatFieldUpdateOperationsInput | number
    currentPrice?: FloatFieldUpdateOperationsInput | number
    offerQuantity?: IntFieldUpdateOperationsInput | number
    currentQuantity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    offerValidity?: OfferValidityUncheckedUpdateManyWithoutOfferNestedInput
  }

  export type OfferUncheckedUpdateManyWithoutOfferInput = {
    id?: IntFieldUpdateOperationsInput | number
    offerPercntage?: FloatFieldUpdateOperationsInput | number
    offerPrice?: FloatFieldUpdateOperationsInput | number
    currentPrice?: FloatFieldUpdateOperationsInput | number
    offerQuantity?: IntFieldUpdateOperationsInput | number
    currentQuantity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SeasonalDressesUpdateWithoutProductInput = {
    seasonal?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SeasonalDressesUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    seasonal?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SeasonalDressesUncheckedUpdateManyWithoutSeasonalDressesInput = {
    id?: IntFieldUpdateOperationsInput | number
    seasonal?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PriceHistoryUpdateWithoutProductInput = {
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PriceHistoryUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PriceHistoryUncheckedUpdateManyWithoutPriceHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CommonDescriptionUpdateWithoutProductInput = {
    fit?: NullableStringFieldUpdateOperationsInput | string | null
    materail?: StringFieldUpdateOperationsInput | string
    care?: StringFieldUpdateOperationsInput | string
    brandName?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    occasion?: StringFieldUpdateOperationsInput | string
    specialFeature?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    topDescription?: TopDescriptionUpdateManyWithoutCommonDescriptionNestedInput
    pantDescription?: BottomDescriptionUpdateManyWithoutCommonDescriptionNestedInput
    kurtasDescription?: KurtasDescriptionUpdateManyWithoutCommonDescriptionNestedInput
    shoesDescription?: ShoesDescriptionUpdateManyWithoutCommonDescriptionNestedInput
    innerDescription?: InnersDescriptionUpdateManyWithoutCommonDescriptionNestedInput
    watchesDescription?: WatchesDescriptionUpdateManyWithoutCommonDescriptionNestedInput
    perfumesDescription?: PerfumesDescriptionUpdateManyWithoutCommonDescriptionNestedInput
  }

  export type CommonDescriptionUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    fit?: NullableStringFieldUpdateOperationsInput | string | null
    materail?: StringFieldUpdateOperationsInput | string
    care?: StringFieldUpdateOperationsInput | string
    brandName?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    occasion?: StringFieldUpdateOperationsInput | string
    specialFeature?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    topDescription?: TopDescriptionUncheckedUpdateManyWithoutCommonDescriptionNestedInput
    pantDescription?: BottomDescriptionUncheckedUpdateManyWithoutCommonDescriptionNestedInput
    kurtasDescription?: KurtasDescriptionUncheckedUpdateManyWithoutCommonDescriptionNestedInput
    shoesDescription?: ShoesDescriptionUncheckedUpdateManyWithoutCommonDescriptionNestedInput
    innerDescription?: InnersDescriptionUncheckedUpdateManyWithoutCommonDescriptionNestedInput
    watchesDescription?: WatchesDescriptionUncheckedUpdateManyWithoutCommonDescriptionNestedInput
    perfumesDescription?: PerfumesDescriptionUncheckedUpdateManyWithoutCommonDescriptionNestedInput
  }

  export type CommonDescriptionUncheckedUpdateManyWithoutCommonDescriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    fit?: NullableStringFieldUpdateOperationsInput | string | null
    materail?: StringFieldUpdateOperationsInput | string
    care?: StringFieldUpdateOperationsInput | string
    brandName?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    occasion?: StringFieldUpdateOperationsInput | string
    specialFeature?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DeleveryPeriodUpdateWithoutProductInput = {
    deliveryForMetroCitys?: IntFieldUpdateOperationsInput | number
    deliveryForOtherCitys?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DeleveryPeriodUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    deliveryForMetroCitys?: IntFieldUpdateOperationsInput | number
    deliveryForOtherCitys?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DeleveryPeriodUncheckedUpdateManyWithoutDeliveryInput = {
    id?: IntFieldUpdateOperationsInput | number
    deliveryForMetroCitys?: IntFieldUpdateOperationsInput | number
    deliveryForOtherCitys?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReturnedProductUpdateWithoutProductInput = {
    returns?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReturnedProductUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    returns?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReturnedProductUncheckedUpdateManyWithoutReturnsInput = {
    id?: IntFieldUpdateOperationsInput | number
    returns?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CartUpdateWithoutProductInput = {
    isCheckedOut?: BoolFieldUpdateOperationsInput | boolean
    isRemoved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutAddCartNestedInput
  }

  export type CartUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    isCheckedOut?: BoolFieldUpdateOperationsInput | boolean
    isRemoved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CartUncheckedUpdateManyWithoutCartInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    isCheckedOut?: BoolFieldUpdateOperationsInput | boolean
    isRemoved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WishlistItemUpdateWithoutProductInput = {
    wishlist?: WishlistUpdateOneRequiredWithoutItemsNestedInput
  }

  export type WishlistItemUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    wishlistId?: IntFieldUpdateOperationsInput | number
  }

  export type WishlistItemUncheckedUpdateManyWithoutWishlistItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    wishlistId?: IntFieldUpdateOperationsInput | number
  }

  export type ProductReviewUpdateWithoutProductInput = {
    review?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutProductReviewNestedInput
  }

  export type ProductReviewUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    review?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductReviewUncheckedUpdateManyWithoutProductReviewsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    review?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderUpdateWithoutProductInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductAviableSizesCreateManyProductColorInput = {
    id?: number
    quantity: number
    productTypeSizeId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ProductImagesCreateManyProductColorInput = {
    id?: number
    imageUrl: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ProductAviableSizesUpdateWithoutProductColorInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    history?: QuantityHistoryUpdateManyWithoutProductAviableSizesNestedInput
    productTypeSize?: ProductTypeSizeUpdateOneRequiredWithoutAviableSizesNestedInput
  }

  export type ProductAviableSizesUncheckedUpdateWithoutProductColorInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    productTypeSizeId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    history?: QuantityHistoryUncheckedUpdateManyWithoutProductAviableSizesNestedInput
  }

  export type ProductAviableSizesUncheckedUpdateManyWithoutColorSizeInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    productTypeSizeId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductImagesUpdateWithoutProductColorInput = {
    imageUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductImagesUncheckedUpdateWithoutProductColorInput = {
    id?: IntFieldUpdateOperationsInput | number
    imageUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductImagesUncheckedUpdateManyWithoutProductImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    imageUrl?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuantityHistoryCreateManyProductAviableSizesInput = {
    id?: number
    quantity: number
    timestamp?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type QuantityHistoryUpdateWithoutProductAviableSizesInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuantityHistoryUncheckedUpdateWithoutProductAviableSizesInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuantityHistoryUncheckedUpdateManyWithoutHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TopDescriptionCreateManyCommonDescriptionInput = {
    id?: number
    productDescription?: string | null
    sleeveTypeId: number
    weight?: number | null
    chest: number
    shoulder: number
    neckTypeId: number
    type?: string | null
    colorFamily?: string | null
    printAndPattern?: string | null
    length: number
    pocket: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type BottomDescriptionCreateManyCommonDescriptionInput = {
    id?: number
    productDescription?: string | null
    weight?: number | null
    printAndPattern: string
    length: number
    waist: number
    hip: number
    type?: string | null
    colorFamily?: string | null
    pocket?: string | null
    kurtasDescriptionId?: number | null
    topDescriptionId?: number | null
    beltLoop?: boolean
    typeOfPantId: number
    typesOfPleatsId: number
    typesOfLengthId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type KurtasDescriptionCreateManyCommonDescriptionInput = {
    id?: number
    work?: string | null
    productDescription: string
    chest: number
    shoulder: number
    transparencyOfTheFabric?: boolean
    kurtasLengthTypeId: number
    weight?: number | null
    colorFamily?: string | null
    pocket: string
    type: string
    printAndpattern?: string | null
    kurtasNeckTypeId: number
    kurtasSleeveTypeId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ShoesDescriptionCreateManyCommonDescriptionInput = {
    id?: number
    pattern?: string | null
    footLength: string
    type: string
    soleMaterial?: string | null
    printAndPattern?: string | null
    upperMaterial?: string | null
    closure?: string | null
    toeType: string
    weight?: number | null
    colorFamily?: string | null
    productDescription?: string | null
    packageContains?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type InnersDescriptionCreateManyCommonDescriptionInput = {
    id?: number
    type: string
    productDescription: string
    weight?: number | null
    length: number
    waistRise: number
    printAndPattern?: string | null
    packageContains: number
    lookAndFeel: string
    colorFamily?: string | null
    vestsSleeveTypeId?: number | null
    vestsNeckTypeId?: number | null
    multiColors?: boolean
  }

  export type WatchesDescriptionCreateManyCommonDescriptionInput = {
    id?: number
    type?: string | null
    weight: number
    model: string
    dialShape: string
    printAndPattern?: string | null
    dialDiameter: string
    dialColor: string
    strapColor: string
    colorFamily?: string | null
    productDescription?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PerfumesDescriptionCreateManyCommonDescriptionInput = {
    id?: number
    productDescription: string
    type?: string | null
    materialDescription: string
    weight: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type TopDescriptionUpdateWithoutCommonDescriptionInput = {
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    chest?: IntFieldUpdateOperationsInput | number
    shoulder?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    printAndPattern?: NullableStringFieldUpdateOperationsInput | string | null
    length?: IntFieldUpdateOperationsInput | number
    pocket?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sleeveType?: SleeveTypeUpdateOneRequiredWithoutTopDescriptionNestedInput
    neckType?: NeckTypeUpdateOneRequiredWithoutTopDescriptionNestedInput
    bottomDescription?: BottomDescriptionUpdateManyWithoutTopDescriptionNestedInput
  }

  export type TopDescriptionUncheckedUpdateWithoutCommonDescriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    sleeveTypeId?: IntFieldUpdateOperationsInput | number
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    chest?: IntFieldUpdateOperationsInput | number
    shoulder?: IntFieldUpdateOperationsInput | number
    neckTypeId?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    printAndPattern?: NullableStringFieldUpdateOperationsInput | string | null
    length?: IntFieldUpdateOperationsInput | number
    pocket?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bottomDescription?: BottomDescriptionUncheckedUpdateManyWithoutTopDescriptionNestedInput
  }

  export type TopDescriptionUncheckedUpdateManyWithoutTopDescriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    sleeveTypeId?: IntFieldUpdateOperationsInput | number
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    chest?: IntFieldUpdateOperationsInput | number
    shoulder?: IntFieldUpdateOperationsInput | number
    neckTypeId?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    printAndPattern?: NullableStringFieldUpdateOperationsInput | string | null
    length?: IntFieldUpdateOperationsInput | number
    pocket?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BottomDescriptionUpdateWithoutCommonDescriptionInput = {
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    printAndPattern?: StringFieldUpdateOperationsInput | string
    length?: IntFieldUpdateOperationsInput | number
    waist?: IntFieldUpdateOperationsInput | number
    hip?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    pocket?: NullableStringFieldUpdateOperationsInput | string | null
    beltLoop?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    typesOfPants?: TypesOfBottomUpdateOneRequiredWithoutDescriptionNestedInput
    typesOfPleats?: TypesOfPleatsUpdateOneRequiredWithoutDescriptionNestedInput
    typesOfLength?: TypesOfLengthBottomUpdateOneRequiredWithoutDescriptionNestedInput
    kurtasDescription?: KurtasDescriptionUpdateOneWithoutBottomDescriptionNestedInput
    topDescription?: TopDescriptionUpdateOneWithoutBottomDescriptionNestedInput
  }

  export type BottomDescriptionUncheckedUpdateWithoutCommonDescriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    printAndPattern?: StringFieldUpdateOperationsInput | string
    length?: IntFieldUpdateOperationsInput | number
    waist?: IntFieldUpdateOperationsInput | number
    hip?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    pocket?: NullableStringFieldUpdateOperationsInput | string | null
    kurtasDescriptionId?: NullableIntFieldUpdateOperationsInput | number | null
    topDescriptionId?: NullableIntFieldUpdateOperationsInput | number | null
    beltLoop?: BoolFieldUpdateOperationsInput | boolean
    typeOfPantId?: IntFieldUpdateOperationsInput | number
    typesOfPleatsId?: IntFieldUpdateOperationsInput | number
    typesOfLengthId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BottomDescriptionUncheckedUpdateManyWithoutPantDescriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    printAndPattern?: StringFieldUpdateOperationsInput | string
    length?: IntFieldUpdateOperationsInput | number
    waist?: IntFieldUpdateOperationsInput | number
    hip?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    pocket?: NullableStringFieldUpdateOperationsInput | string | null
    kurtasDescriptionId?: NullableIntFieldUpdateOperationsInput | number | null
    topDescriptionId?: NullableIntFieldUpdateOperationsInput | number | null
    beltLoop?: BoolFieldUpdateOperationsInput | boolean
    typeOfPantId?: IntFieldUpdateOperationsInput | number
    typesOfPleatsId?: IntFieldUpdateOperationsInput | number
    typesOfLengthId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type KurtasDescriptionUpdateWithoutCommonDescriptionInput = {
    work?: NullableStringFieldUpdateOperationsInput | string | null
    productDescription?: StringFieldUpdateOperationsInput | string
    chest?: IntFieldUpdateOperationsInput | number
    shoulder?: IntFieldUpdateOperationsInput | number
    transparencyOfTheFabric?: BoolFieldUpdateOperationsInput | boolean
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    pocket?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    printAndpattern?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kurtasLengthType?: KurtasLengthTypeUpdateOneRequiredWithoutKurtasDescriptionNestedInput
    neckType?: NeckTypeUpdateOneRequiredWithoutKurtasDescriptionNestedInput
    sleeveType?: SleeveTypeUpdateOneRequiredWithoutKurtasDescriptionNestedInput
    bottomDescription?: BottomDescriptionUpdateManyWithoutKurtasDescriptionNestedInput
  }

  export type KurtasDescriptionUncheckedUpdateWithoutCommonDescriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    work?: NullableStringFieldUpdateOperationsInput | string | null
    productDescription?: StringFieldUpdateOperationsInput | string
    chest?: IntFieldUpdateOperationsInput | number
    shoulder?: IntFieldUpdateOperationsInput | number
    transparencyOfTheFabric?: BoolFieldUpdateOperationsInput | boolean
    kurtasLengthTypeId?: IntFieldUpdateOperationsInput | number
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    pocket?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    printAndpattern?: NullableStringFieldUpdateOperationsInput | string | null
    kurtasNeckTypeId?: IntFieldUpdateOperationsInput | number
    kurtasSleeveTypeId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bottomDescription?: BottomDescriptionUncheckedUpdateManyWithoutKurtasDescriptionNestedInput
  }

  export type KurtasDescriptionUncheckedUpdateManyWithoutKurtasDescriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    work?: NullableStringFieldUpdateOperationsInput | string | null
    productDescription?: StringFieldUpdateOperationsInput | string
    chest?: IntFieldUpdateOperationsInput | number
    shoulder?: IntFieldUpdateOperationsInput | number
    transparencyOfTheFabric?: BoolFieldUpdateOperationsInput | boolean
    kurtasLengthTypeId?: IntFieldUpdateOperationsInput | number
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    pocket?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    printAndpattern?: NullableStringFieldUpdateOperationsInput | string | null
    kurtasNeckTypeId?: IntFieldUpdateOperationsInput | number
    kurtasSleeveTypeId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ShoesDescriptionUpdateWithoutCommonDescriptionInput = {
    pattern?: NullableStringFieldUpdateOperationsInput | string | null
    footLength?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    soleMaterial?: NullableStringFieldUpdateOperationsInput | string | null
    printAndPattern?: NullableStringFieldUpdateOperationsInput | string | null
    upperMaterial?: NullableStringFieldUpdateOperationsInput | string | null
    closure?: NullableStringFieldUpdateOperationsInput | string | null
    toeType?: StringFieldUpdateOperationsInput | string
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    packageContains?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warranty?: WarrantyUpdateManyWithoutShoesDescriptionNestedInput
  }

  export type ShoesDescriptionUncheckedUpdateWithoutCommonDescriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    pattern?: NullableStringFieldUpdateOperationsInput | string | null
    footLength?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    soleMaterial?: NullableStringFieldUpdateOperationsInput | string | null
    printAndPattern?: NullableStringFieldUpdateOperationsInput | string | null
    upperMaterial?: NullableStringFieldUpdateOperationsInput | string | null
    closure?: NullableStringFieldUpdateOperationsInput | string | null
    toeType?: StringFieldUpdateOperationsInput | string
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    packageContains?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warranty?: WarrantyUncheckedUpdateManyWithoutShoesDescriptionNestedInput
  }

  export type ShoesDescriptionUncheckedUpdateManyWithoutShoesDescriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    pattern?: NullableStringFieldUpdateOperationsInput | string | null
    footLength?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    soleMaterial?: NullableStringFieldUpdateOperationsInput | string | null
    printAndPattern?: NullableStringFieldUpdateOperationsInput | string | null
    upperMaterial?: NullableStringFieldUpdateOperationsInput | string | null
    closure?: NullableStringFieldUpdateOperationsInput | string | null
    toeType?: StringFieldUpdateOperationsInput | string
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    packageContains?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InnersDescriptionUpdateWithoutCommonDescriptionInput = {
    type?: StringFieldUpdateOperationsInput | string
    productDescription?: StringFieldUpdateOperationsInput | string
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    length?: IntFieldUpdateOperationsInput | number
    waistRise?: IntFieldUpdateOperationsInput | number
    printAndPattern?: NullableStringFieldUpdateOperationsInput | string | null
    packageContains?: IntFieldUpdateOperationsInput | number
    lookAndFeel?: StringFieldUpdateOperationsInput | string
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    multiColors?: BoolFieldUpdateOperationsInput | boolean
    sleeveType?: SleeveTypeUpdateOneWithoutInnersDescriptionNestedInput
    neckType?: NeckTypeUpdateOneWithoutInnersDescriptionNestedInput
  }

  export type InnersDescriptionUncheckedUpdateWithoutCommonDescriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    productDescription?: StringFieldUpdateOperationsInput | string
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    length?: IntFieldUpdateOperationsInput | number
    waistRise?: IntFieldUpdateOperationsInput | number
    printAndPattern?: NullableStringFieldUpdateOperationsInput | string | null
    packageContains?: IntFieldUpdateOperationsInput | number
    lookAndFeel?: StringFieldUpdateOperationsInput | string
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    vestsSleeveTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    vestsNeckTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    multiColors?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InnersDescriptionUncheckedUpdateManyWithoutInnerDescriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    productDescription?: StringFieldUpdateOperationsInput | string
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    length?: IntFieldUpdateOperationsInput | number
    waistRise?: IntFieldUpdateOperationsInput | number
    printAndPattern?: NullableStringFieldUpdateOperationsInput | string | null
    packageContains?: IntFieldUpdateOperationsInput | number
    lookAndFeel?: StringFieldUpdateOperationsInput | string
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    vestsSleeveTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    vestsNeckTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    multiColors?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WatchesDescriptionUpdateWithoutCommonDescriptionInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: IntFieldUpdateOperationsInput | number
    model?: StringFieldUpdateOperationsInput | string
    dialShape?: StringFieldUpdateOperationsInput | string
    printAndPattern?: NullableStringFieldUpdateOperationsInput | string | null
    dialDiameter?: StringFieldUpdateOperationsInput | string
    dialColor?: StringFieldUpdateOperationsInput | string
    strapColor?: StringFieldUpdateOperationsInput | string
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warranty?: WarrantyUpdateManyWithoutWatchesNestedInput
  }

  export type WatchesDescriptionUncheckedUpdateWithoutCommonDescriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: IntFieldUpdateOperationsInput | number
    model?: StringFieldUpdateOperationsInput | string
    dialShape?: StringFieldUpdateOperationsInput | string
    printAndPattern?: NullableStringFieldUpdateOperationsInput | string | null
    dialDiameter?: StringFieldUpdateOperationsInput | string
    dialColor?: StringFieldUpdateOperationsInput | string
    strapColor?: StringFieldUpdateOperationsInput | string
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warranty?: WarrantyUncheckedUpdateManyWithoutWatchesNestedInput
  }

  export type WatchesDescriptionUncheckedUpdateManyWithoutWatchesDescriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: IntFieldUpdateOperationsInput | number
    model?: StringFieldUpdateOperationsInput | string
    dialShape?: StringFieldUpdateOperationsInput | string
    printAndPattern?: NullableStringFieldUpdateOperationsInput | string | null
    dialDiameter?: StringFieldUpdateOperationsInput | string
    dialColor?: StringFieldUpdateOperationsInput | string
    strapColor?: StringFieldUpdateOperationsInput | string
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PerfumesDescriptionUpdateWithoutCommonDescriptionInput = {
    productDescription?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    materialDescription?: StringFieldUpdateOperationsInput | string
    weight?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PerfumesDescriptionUncheckedUpdateWithoutCommonDescriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    productDescription?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    materialDescription?: StringFieldUpdateOperationsInput | string
    weight?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PerfumesDescriptionUncheckedUpdateManyWithoutPerfumesDescriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    productDescription?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    materialDescription?: StringFieldUpdateOperationsInput | string
    weight?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BottomDescriptionCreateManyTopDescriptionInput = {
    id?: number
    productDescription?: string | null
    weight?: number | null
    printAndPattern: string
    length: number
    waist: number
    hip: number
    commonDescriptionId: number
    type?: string | null
    colorFamily?: string | null
    pocket?: string | null
    kurtasDescriptionId?: number | null
    beltLoop?: boolean
    typeOfPantId: number
    typesOfPleatsId: number
    typesOfLengthId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type BottomDescriptionUpdateWithoutTopDescriptionInput = {
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    printAndPattern?: StringFieldUpdateOperationsInput | string
    length?: IntFieldUpdateOperationsInput | number
    waist?: IntFieldUpdateOperationsInput | number
    hip?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    pocket?: NullableStringFieldUpdateOperationsInput | string | null
    beltLoop?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    typesOfPants?: TypesOfBottomUpdateOneRequiredWithoutDescriptionNestedInput
    typesOfPleats?: TypesOfPleatsUpdateOneRequiredWithoutDescriptionNestedInput
    typesOfLength?: TypesOfLengthBottomUpdateOneRequiredWithoutDescriptionNestedInput
    commonDescription?: CommonDescriptionUpdateOneRequiredWithoutPantDescriptionNestedInput
    kurtasDescription?: KurtasDescriptionUpdateOneWithoutBottomDescriptionNestedInput
  }

  export type BottomDescriptionUncheckedUpdateWithoutTopDescriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    printAndPattern?: StringFieldUpdateOperationsInput | string
    length?: IntFieldUpdateOperationsInput | number
    waist?: IntFieldUpdateOperationsInput | number
    hip?: IntFieldUpdateOperationsInput | number
    commonDescriptionId?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    pocket?: NullableStringFieldUpdateOperationsInput | string | null
    kurtasDescriptionId?: NullableIntFieldUpdateOperationsInput | number | null
    beltLoop?: BoolFieldUpdateOperationsInput | boolean
    typeOfPantId?: IntFieldUpdateOperationsInput | number
    typesOfPleatsId?: IntFieldUpdateOperationsInput | number
    typesOfLengthId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BottomDescriptionUncheckedUpdateManyWithoutBottomDescriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    printAndPattern?: StringFieldUpdateOperationsInput | string
    length?: IntFieldUpdateOperationsInput | number
    waist?: IntFieldUpdateOperationsInput | number
    hip?: IntFieldUpdateOperationsInput | number
    commonDescriptionId?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    pocket?: NullableStringFieldUpdateOperationsInput | string | null
    kurtasDescriptionId?: NullableIntFieldUpdateOperationsInput | number | null
    beltLoop?: BoolFieldUpdateOperationsInput | boolean
    typeOfPantId?: IntFieldUpdateOperationsInput | number
    typesOfPleatsId?: IntFieldUpdateOperationsInput | number
    typesOfLengthId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BottomDescriptionCreateManyKurtasDescriptionInput = {
    id?: number
    productDescription?: string | null
    weight?: number | null
    printAndPattern: string
    length: number
    waist: number
    hip: number
    commonDescriptionId: number
    type?: string | null
    colorFamily?: string | null
    pocket?: string | null
    topDescriptionId?: number | null
    beltLoop?: boolean
    typeOfPantId: number
    typesOfPleatsId: number
    typesOfLengthId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type BottomDescriptionUpdateWithoutKurtasDescriptionInput = {
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    printAndPattern?: StringFieldUpdateOperationsInput | string
    length?: IntFieldUpdateOperationsInput | number
    waist?: IntFieldUpdateOperationsInput | number
    hip?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    pocket?: NullableStringFieldUpdateOperationsInput | string | null
    beltLoop?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    typesOfPants?: TypesOfBottomUpdateOneRequiredWithoutDescriptionNestedInput
    typesOfPleats?: TypesOfPleatsUpdateOneRequiredWithoutDescriptionNestedInput
    typesOfLength?: TypesOfLengthBottomUpdateOneRequiredWithoutDescriptionNestedInput
    commonDescription?: CommonDescriptionUpdateOneRequiredWithoutPantDescriptionNestedInput
    topDescription?: TopDescriptionUpdateOneWithoutBottomDescriptionNestedInput
  }

  export type BottomDescriptionUncheckedUpdateWithoutKurtasDescriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    printAndPattern?: StringFieldUpdateOperationsInput | string
    length?: IntFieldUpdateOperationsInput | number
    waist?: IntFieldUpdateOperationsInput | number
    hip?: IntFieldUpdateOperationsInput | number
    commonDescriptionId?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    pocket?: NullableStringFieldUpdateOperationsInput | string | null
    topDescriptionId?: NullableIntFieldUpdateOperationsInput | number | null
    beltLoop?: BoolFieldUpdateOperationsInput | boolean
    typeOfPantId?: IntFieldUpdateOperationsInput | number
    typesOfPleatsId?: IntFieldUpdateOperationsInput | number
    typesOfLengthId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WarrantyCreateManyShoesDescriptionInput = {
    id?: number
    watchsId?: number | null
    warrantyPeriod: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type WarrantyUpdateWithoutShoesDescriptionInput = {
    warrantyPeriod?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watches?: WatchesDescriptionUpdateOneWithoutWarrantyNestedInput
  }

  export type WarrantyUncheckedUpdateWithoutShoesDescriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    watchsId?: NullableIntFieldUpdateOperationsInput | number | null
    warrantyPeriod?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WarrantyUncheckedUpdateManyWithoutWarrantyInput = {
    id?: IntFieldUpdateOperationsInput | number
    watchsId?: NullableIntFieldUpdateOperationsInput | number | null
    warrantyPeriod?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WarrantyCreateManyWatchesInput = {
    id?: number
    shoesDescriptionId?: number | null
    warrantyPeriod: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type WarrantyUpdateWithoutWatchesInput = {
    warrantyPeriod?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shoesDescription?: ShoesDescriptionUpdateOneWithoutWarrantyNestedInput
  }

  export type WarrantyUncheckedUpdateWithoutWatchesInput = {
    id?: IntFieldUpdateOperationsInput | number
    shoesDescriptionId?: NullableIntFieldUpdateOperationsInput | number | null
    warrantyPeriod?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type KurtasDescriptionCreateManySleeveTypeInput = {
    id?: number
    work?: string | null
    productDescription: string
    chest: number
    shoulder: number
    transparencyOfTheFabric?: boolean
    kurtasLengthTypeId: number
    weight?: number | null
    colorFamily?: string | null
    pocket: string
    type: string
    printAndpattern?: string | null
    kurtasNeckTypeId: number
    commonDescriptionId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type InnersDescriptionCreateManySleeveTypeInput = {
    id?: number
    type: string
    productDescription: string
    weight?: number | null
    length: number
    waistRise: number
    printAndPattern?: string | null
    packageContains: number
    lookAndFeel: string
    colorFamily?: string | null
    vestsNeckTypeId?: number | null
    commonDescriptionId: number
    multiColors?: boolean
  }

  export type TopDescriptionCreateManySleeveTypeInput = {
    id?: number
    productDescription?: string | null
    weight?: number | null
    chest: number
    shoulder: number
    neckTypeId: number
    type?: string | null
    colorFamily?: string | null
    printAndPattern?: string | null
    length: number
    pocket: string
    commonDescriptionId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type KurtasDescriptionUpdateWithoutSleeveTypeInput = {
    work?: NullableStringFieldUpdateOperationsInput | string | null
    productDescription?: StringFieldUpdateOperationsInput | string
    chest?: IntFieldUpdateOperationsInput | number
    shoulder?: IntFieldUpdateOperationsInput | number
    transparencyOfTheFabric?: BoolFieldUpdateOperationsInput | boolean
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    pocket?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    printAndpattern?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kurtasLengthType?: KurtasLengthTypeUpdateOneRequiredWithoutKurtasDescriptionNestedInput
    neckType?: NeckTypeUpdateOneRequiredWithoutKurtasDescriptionNestedInput
    commonDescription?: CommonDescriptionUpdateOneRequiredWithoutKurtasDescriptionNestedInput
    bottomDescription?: BottomDescriptionUpdateManyWithoutKurtasDescriptionNestedInput
  }

  export type KurtasDescriptionUncheckedUpdateWithoutSleeveTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    work?: NullableStringFieldUpdateOperationsInput | string | null
    productDescription?: StringFieldUpdateOperationsInput | string
    chest?: IntFieldUpdateOperationsInput | number
    shoulder?: IntFieldUpdateOperationsInput | number
    transparencyOfTheFabric?: BoolFieldUpdateOperationsInput | boolean
    kurtasLengthTypeId?: IntFieldUpdateOperationsInput | number
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    pocket?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    printAndpattern?: NullableStringFieldUpdateOperationsInput | string | null
    kurtasNeckTypeId?: IntFieldUpdateOperationsInput | number
    commonDescriptionId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bottomDescription?: BottomDescriptionUncheckedUpdateManyWithoutKurtasDescriptionNestedInput
  }

  export type InnersDescriptionUpdateWithoutSleeveTypeInput = {
    type?: StringFieldUpdateOperationsInput | string
    productDescription?: StringFieldUpdateOperationsInput | string
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    length?: IntFieldUpdateOperationsInput | number
    waistRise?: IntFieldUpdateOperationsInput | number
    printAndPattern?: NullableStringFieldUpdateOperationsInput | string | null
    packageContains?: IntFieldUpdateOperationsInput | number
    lookAndFeel?: StringFieldUpdateOperationsInput | string
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    multiColors?: BoolFieldUpdateOperationsInput | boolean
    neckType?: NeckTypeUpdateOneWithoutInnersDescriptionNestedInput
    commonDescription?: CommonDescriptionUpdateOneRequiredWithoutInnerDescriptionNestedInput
  }

  export type InnersDescriptionUncheckedUpdateWithoutSleeveTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    productDescription?: StringFieldUpdateOperationsInput | string
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    length?: IntFieldUpdateOperationsInput | number
    waistRise?: IntFieldUpdateOperationsInput | number
    printAndPattern?: NullableStringFieldUpdateOperationsInput | string | null
    packageContains?: IntFieldUpdateOperationsInput | number
    lookAndFeel?: StringFieldUpdateOperationsInput | string
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    vestsNeckTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    commonDescriptionId?: IntFieldUpdateOperationsInput | number
    multiColors?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InnersDescriptionUncheckedUpdateManyWithoutInnersDescriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    productDescription?: StringFieldUpdateOperationsInput | string
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    length?: IntFieldUpdateOperationsInput | number
    waistRise?: IntFieldUpdateOperationsInput | number
    printAndPattern?: NullableStringFieldUpdateOperationsInput | string | null
    packageContains?: IntFieldUpdateOperationsInput | number
    lookAndFeel?: StringFieldUpdateOperationsInput | string
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    vestsNeckTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    commonDescriptionId?: IntFieldUpdateOperationsInput | number
    multiColors?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TopDescriptionUpdateWithoutSleeveTypeInput = {
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    chest?: IntFieldUpdateOperationsInput | number
    shoulder?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    printAndPattern?: NullableStringFieldUpdateOperationsInput | string | null
    length?: IntFieldUpdateOperationsInput | number
    pocket?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commonDescription?: CommonDescriptionUpdateOneWithoutTopDescriptionNestedInput
    neckType?: NeckTypeUpdateOneRequiredWithoutTopDescriptionNestedInput
    bottomDescription?: BottomDescriptionUpdateManyWithoutTopDescriptionNestedInput
  }

  export type TopDescriptionUncheckedUpdateWithoutSleeveTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    chest?: IntFieldUpdateOperationsInput | number
    shoulder?: IntFieldUpdateOperationsInput | number
    neckTypeId?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    printAndPattern?: NullableStringFieldUpdateOperationsInput | string | null
    length?: IntFieldUpdateOperationsInput | number
    pocket?: StringFieldUpdateOperationsInput | string
    commonDescriptionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bottomDescription?: BottomDescriptionUncheckedUpdateManyWithoutTopDescriptionNestedInput
  }

  export type KurtasDescriptionCreateManyNeckTypeInput = {
    id?: number
    work?: string | null
    productDescription: string
    chest: number
    shoulder: number
    transparencyOfTheFabric?: boolean
    kurtasLengthTypeId: number
    weight?: number | null
    colorFamily?: string | null
    pocket: string
    type: string
    printAndpattern?: string | null
    kurtasSleeveTypeId: number
    commonDescriptionId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type InnersDescriptionCreateManyNeckTypeInput = {
    id?: number
    type: string
    productDescription: string
    weight?: number | null
    length: number
    waistRise: number
    printAndPattern?: string | null
    packageContains: number
    lookAndFeel: string
    colorFamily?: string | null
    vestsSleeveTypeId?: number | null
    commonDescriptionId: number
    multiColors?: boolean
  }

  export type TopDescriptionCreateManyNeckTypeInput = {
    id?: number
    productDescription?: string | null
    sleeveTypeId: number
    weight?: number | null
    chest: number
    shoulder: number
    type?: string | null
    colorFamily?: string | null
    printAndPattern?: string | null
    length: number
    pocket: string
    commonDescriptionId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type KurtasDescriptionUpdateWithoutNeckTypeInput = {
    work?: NullableStringFieldUpdateOperationsInput | string | null
    productDescription?: StringFieldUpdateOperationsInput | string
    chest?: IntFieldUpdateOperationsInput | number
    shoulder?: IntFieldUpdateOperationsInput | number
    transparencyOfTheFabric?: BoolFieldUpdateOperationsInput | boolean
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    pocket?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    printAndpattern?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kurtasLengthType?: KurtasLengthTypeUpdateOneRequiredWithoutKurtasDescriptionNestedInput
    sleeveType?: SleeveTypeUpdateOneRequiredWithoutKurtasDescriptionNestedInput
    commonDescription?: CommonDescriptionUpdateOneRequiredWithoutKurtasDescriptionNestedInput
    bottomDescription?: BottomDescriptionUpdateManyWithoutKurtasDescriptionNestedInput
  }

  export type KurtasDescriptionUncheckedUpdateWithoutNeckTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    work?: NullableStringFieldUpdateOperationsInput | string | null
    productDescription?: StringFieldUpdateOperationsInput | string
    chest?: IntFieldUpdateOperationsInput | number
    shoulder?: IntFieldUpdateOperationsInput | number
    transparencyOfTheFabric?: BoolFieldUpdateOperationsInput | boolean
    kurtasLengthTypeId?: IntFieldUpdateOperationsInput | number
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    pocket?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    printAndpattern?: NullableStringFieldUpdateOperationsInput | string | null
    kurtasSleeveTypeId?: IntFieldUpdateOperationsInput | number
    commonDescriptionId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bottomDescription?: BottomDescriptionUncheckedUpdateManyWithoutKurtasDescriptionNestedInput
  }

  export type InnersDescriptionUpdateWithoutNeckTypeInput = {
    type?: StringFieldUpdateOperationsInput | string
    productDescription?: StringFieldUpdateOperationsInput | string
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    length?: IntFieldUpdateOperationsInput | number
    waistRise?: IntFieldUpdateOperationsInput | number
    printAndPattern?: NullableStringFieldUpdateOperationsInput | string | null
    packageContains?: IntFieldUpdateOperationsInput | number
    lookAndFeel?: StringFieldUpdateOperationsInput | string
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    multiColors?: BoolFieldUpdateOperationsInput | boolean
    sleeveType?: SleeveTypeUpdateOneWithoutInnersDescriptionNestedInput
    commonDescription?: CommonDescriptionUpdateOneRequiredWithoutInnerDescriptionNestedInput
  }

  export type InnersDescriptionUncheckedUpdateWithoutNeckTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    productDescription?: StringFieldUpdateOperationsInput | string
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    length?: IntFieldUpdateOperationsInput | number
    waistRise?: IntFieldUpdateOperationsInput | number
    printAndPattern?: NullableStringFieldUpdateOperationsInput | string | null
    packageContains?: IntFieldUpdateOperationsInput | number
    lookAndFeel?: StringFieldUpdateOperationsInput | string
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    vestsSleeveTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    commonDescriptionId?: IntFieldUpdateOperationsInput | number
    multiColors?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TopDescriptionUpdateWithoutNeckTypeInput = {
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    chest?: IntFieldUpdateOperationsInput | number
    shoulder?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    printAndPattern?: NullableStringFieldUpdateOperationsInput | string | null
    length?: IntFieldUpdateOperationsInput | number
    pocket?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    commonDescription?: CommonDescriptionUpdateOneWithoutTopDescriptionNestedInput
    sleeveType?: SleeveTypeUpdateOneRequiredWithoutTopDescriptionNestedInput
    bottomDescription?: BottomDescriptionUpdateManyWithoutTopDescriptionNestedInput
  }

  export type TopDescriptionUncheckedUpdateWithoutNeckTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    sleeveTypeId?: IntFieldUpdateOperationsInput | number
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    chest?: IntFieldUpdateOperationsInput | number
    shoulder?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    printAndPattern?: NullableStringFieldUpdateOperationsInput | string | null
    length?: IntFieldUpdateOperationsInput | number
    pocket?: StringFieldUpdateOperationsInput | string
    commonDescriptionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bottomDescription?: BottomDescriptionUncheckedUpdateManyWithoutTopDescriptionNestedInput
  }

  export type KurtasDescriptionCreateManyKurtasLengthTypeInput = {
    id?: number
    work?: string | null
    productDescription: string
    chest: number
    shoulder: number
    transparencyOfTheFabric?: boolean
    weight?: number | null
    colorFamily?: string | null
    pocket: string
    type: string
    printAndpattern?: string | null
    kurtasNeckTypeId: number
    kurtasSleeveTypeId: number
    commonDescriptionId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type KurtasDescriptionUpdateWithoutKurtasLengthTypeInput = {
    work?: NullableStringFieldUpdateOperationsInput | string | null
    productDescription?: StringFieldUpdateOperationsInput | string
    chest?: IntFieldUpdateOperationsInput | number
    shoulder?: IntFieldUpdateOperationsInput | number
    transparencyOfTheFabric?: BoolFieldUpdateOperationsInput | boolean
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    pocket?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    printAndpattern?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    neckType?: NeckTypeUpdateOneRequiredWithoutKurtasDescriptionNestedInput
    sleeveType?: SleeveTypeUpdateOneRequiredWithoutKurtasDescriptionNestedInput
    commonDescription?: CommonDescriptionUpdateOneRequiredWithoutKurtasDescriptionNestedInput
    bottomDescription?: BottomDescriptionUpdateManyWithoutKurtasDescriptionNestedInput
  }

  export type KurtasDescriptionUncheckedUpdateWithoutKurtasLengthTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    work?: NullableStringFieldUpdateOperationsInput | string | null
    productDescription?: StringFieldUpdateOperationsInput | string
    chest?: IntFieldUpdateOperationsInput | number
    shoulder?: IntFieldUpdateOperationsInput | number
    transparencyOfTheFabric?: BoolFieldUpdateOperationsInput | boolean
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    pocket?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    printAndpattern?: NullableStringFieldUpdateOperationsInput | string | null
    kurtasNeckTypeId?: IntFieldUpdateOperationsInput | number
    kurtasSleeveTypeId?: IntFieldUpdateOperationsInput | number
    commonDescriptionId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bottomDescription?: BottomDescriptionUncheckedUpdateManyWithoutKurtasDescriptionNestedInput
  }

  export type BottomDescriptionCreateManyTypesOfPantsInput = {
    id?: number
    productDescription?: string | null
    weight?: number | null
    printAndPattern: string
    length: number
    waist: number
    hip: number
    commonDescriptionId: number
    type?: string | null
    colorFamily?: string | null
    pocket?: string | null
    kurtasDescriptionId?: number | null
    topDescriptionId?: number | null
    beltLoop?: boolean
    typesOfPleatsId: number
    typesOfLengthId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type BottomDescriptionUpdateWithoutTypesOfPantsInput = {
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    printAndPattern?: StringFieldUpdateOperationsInput | string
    length?: IntFieldUpdateOperationsInput | number
    waist?: IntFieldUpdateOperationsInput | number
    hip?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    pocket?: NullableStringFieldUpdateOperationsInput | string | null
    beltLoop?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    typesOfPleats?: TypesOfPleatsUpdateOneRequiredWithoutDescriptionNestedInput
    typesOfLength?: TypesOfLengthBottomUpdateOneRequiredWithoutDescriptionNestedInput
    commonDescription?: CommonDescriptionUpdateOneRequiredWithoutPantDescriptionNestedInput
    kurtasDescription?: KurtasDescriptionUpdateOneWithoutBottomDescriptionNestedInput
    topDescription?: TopDescriptionUpdateOneWithoutBottomDescriptionNestedInput
  }

  export type BottomDescriptionUncheckedUpdateWithoutTypesOfPantsInput = {
    id?: IntFieldUpdateOperationsInput | number
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    printAndPattern?: StringFieldUpdateOperationsInput | string
    length?: IntFieldUpdateOperationsInput | number
    waist?: IntFieldUpdateOperationsInput | number
    hip?: IntFieldUpdateOperationsInput | number
    commonDescriptionId?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    pocket?: NullableStringFieldUpdateOperationsInput | string | null
    kurtasDescriptionId?: NullableIntFieldUpdateOperationsInput | number | null
    topDescriptionId?: NullableIntFieldUpdateOperationsInput | number | null
    beltLoop?: BoolFieldUpdateOperationsInput | boolean
    typesOfPleatsId?: IntFieldUpdateOperationsInput | number
    typesOfLengthId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BottomDescriptionUncheckedUpdateManyWithoutDescriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    printAndPattern?: StringFieldUpdateOperationsInput | string
    length?: IntFieldUpdateOperationsInput | number
    waist?: IntFieldUpdateOperationsInput | number
    hip?: IntFieldUpdateOperationsInput | number
    commonDescriptionId?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    pocket?: NullableStringFieldUpdateOperationsInput | string | null
    kurtasDescriptionId?: NullableIntFieldUpdateOperationsInput | number | null
    topDescriptionId?: NullableIntFieldUpdateOperationsInput | number | null
    beltLoop?: BoolFieldUpdateOperationsInput | boolean
    typesOfPleatsId?: IntFieldUpdateOperationsInput | number
    typesOfLengthId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BottomDescriptionCreateManyTypesOfPleatsInput = {
    id?: number
    productDescription?: string | null
    weight?: number | null
    printAndPattern: string
    length: number
    waist: number
    hip: number
    commonDescriptionId: number
    type?: string | null
    colorFamily?: string | null
    pocket?: string | null
    kurtasDescriptionId?: number | null
    topDescriptionId?: number | null
    beltLoop?: boolean
    typeOfPantId: number
    typesOfLengthId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type BottomDescriptionUpdateWithoutTypesOfPleatsInput = {
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    printAndPattern?: StringFieldUpdateOperationsInput | string
    length?: IntFieldUpdateOperationsInput | number
    waist?: IntFieldUpdateOperationsInput | number
    hip?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    pocket?: NullableStringFieldUpdateOperationsInput | string | null
    beltLoop?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    typesOfPants?: TypesOfBottomUpdateOneRequiredWithoutDescriptionNestedInput
    typesOfLength?: TypesOfLengthBottomUpdateOneRequiredWithoutDescriptionNestedInput
    commonDescription?: CommonDescriptionUpdateOneRequiredWithoutPantDescriptionNestedInput
    kurtasDescription?: KurtasDescriptionUpdateOneWithoutBottomDescriptionNestedInput
    topDescription?: TopDescriptionUpdateOneWithoutBottomDescriptionNestedInput
  }

  export type BottomDescriptionUncheckedUpdateWithoutTypesOfPleatsInput = {
    id?: IntFieldUpdateOperationsInput | number
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    printAndPattern?: StringFieldUpdateOperationsInput | string
    length?: IntFieldUpdateOperationsInput | number
    waist?: IntFieldUpdateOperationsInput | number
    hip?: IntFieldUpdateOperationsInput | number
    commonDescriptionId?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    pocket?: NullableStringFieldUpdateOperationsInput | string | null
    kurtasDescriptionId?: NullableIntFieldUpdateOperationsInput | number | null
    topDescriptionId?: NullableIntFieldUpdateOperationsInput | number | null
    beltLoop?: BoolFieldUpdateOperationsInput | boolean
    typeOfPantId?: IntFieldUpdateOperationsInput | number
    typesOfLengthId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BottomDescriptionCreateManyTypesOfLengthInput = {
    id?: number
    productDescription?: string | null
    weight?: number | null
    printAndPattern: string
    length: number
    waist: number
    hip: number
    commonDescriptionId: number
    type?: string | null
    colorFamily?: string | null
    pocket?: string | null
    kurtasDescriptionId?: number | null
    topDescriptionId?: number | null
    beltLoop?: boolean
    typeOfPantId: number
    typesOfPleatsId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type BottomDescriptionUpdateWithoutTypesOfLengthInput = {
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    printAndPattern?: StringFieldUpdateOperationsInput | string
    length?: IntFieldUpdateOperationsInput | number
    waist?: IntFieldUpdateOperationsInput | number
    hip?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    pocket?: NullableStringFieldUpdateOperationsInput | string | null
    beltLoop?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    typesOfPants?: TypesOfBottomUpdateOneRequiredWithoutDescriptionNestedInput
    typesOfPleats?: TypesOfPleatsUpdateOneRequiredWithoutDescriptionNestedInput
    commonDescription?: CommonDescriptionUpdateOneRequiredWithoutPantDescriptionNestedInput
    kurtasDescription?: KurtasDescriptionUpdateOneWithoutBottomDescriptionNestedInput
    topDescription?: TopDescriptionUpdateOneWithoutBottomDescriptionNestedInput
  }

  export type BottomDescriptionUncheckedUpdateWithoutTypesOfLengthInput = {
    id?: IntFieldUpdateOperationsInput | number
    productDescription?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableIntFieldUpdateOperationsInput | number | null
    printAndPattern?: StringFieldUpdateOperationsInput | string
    length?: IntFieldUpdateOperationsInput | number
    waist?: IntFieldUpdateOperationsInput | number
    hip?: IntFieldUpdateOperationsInput | number
    commonDescriptionId?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    colorFamily?: NullableStringFieldUpdateOperationsInput | string | null
    pocket?: NullableStringFieldUpdateOperationsInput | string | null
    kurtasDescriptionId?: NullableIntFieldUpdateOperationsInput | number | null
    topDescriptionId?: NullableIntFieldUpdateOperationsInput | number | null
    beltLoop?: BoolFieldUpdateOperationsInput | boolean
    typeOfPantId?: IntFieldUpdateOperationsInput | number
    typesOfPleatsId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OfferValidityCreateManyOfferInput = {
    id?: number
    fromDate: Date | string
    toDate: Date | string
    fromTime: Date | string
    toTime: Date | string
    monday: boolean
    tuesday: boolean
    wednesday: boolean
    thursday: boolean
    friday: boolean
    saturday: boolean
    sunday: boolean
    offerPromotionPeriodId?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type OfferValidityUpdateWithoutOfferInput = {
    fromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    toDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fromTime?: DateTimeFieldUpdateOperationsInput | Date | string
    toTime?: DateTimeFieldUpdateOperationsInput | Date | string
    monday?: BoolFieldUpdateOperationsInput | boolean
    tuesday?: BoolFieldUpdateOperationsInput | boolean
    wednesday?: BoolFieldUpdateOperationsInput | boolean
    thursday?: BoolFieldUpdateOperationsInput | boolean
    friday?: BoolFieldUpdateOperationsInput | boolean
    saturday?: BoolFieldUpdateOperationsInput | boolean
    sunday?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    offerPromotionPeriod?: OfferPromotionPeriodsUpdateOneWithoutOfferValidityNestedInput
  }

  export type OfferValidityUncheckedUpdateWithoutOfferInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    toDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fromTime?: DateTimeFieldUpdateOperationsInput | Date | string
    toTime?: DateTimeFieldUpdateOperationsInput | Date | string
    monday?: BoolFieldUpdateOperationsInput | boolean
    tuesday?: BoolFieldUpdateOperationsInput | boolean
    wednesday?: BoolFieldUpdateOperationsInput | boolean
    thursday?: BoolFieldUpdateOperationsInput | boolean
    friday?: BoolFieldUpdateOperationsInput | boolean
    saturday?: BoolFieldUpdateOperationsInput | boolean
    sunday?: BoolFieldUpdateOperationsInput | boolean
    offerPromotionPeriodId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OfferValidityUncheckedUpdateManyWithoutOfferValidityInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    toDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fromTime?: DateTimeFieldUpdateOperationsInput | Date | string
    toTime?: DateTimeFieldUpdateOperationsInput | Date | string
    monday?: BoolFieldUpdateOperationsInput | boolean
    tuesday?: BoolFieldUpdateOperationsInput | boolean
    wednesday?: BoolFieldUpdateOperationsInput | boolean
    thursday?: BoolFieldUpdateOperationsInput | boolean
    friday?: BoolFieldUpdateOperationsInput | boolean
    saturday?: BoolFieldUpdateOperationsInput | boolean
    sunday?: BoolFieldUpdateOperationsInput | boolean
    offerPromotionPeriodId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WishlistItemCreateManyWishlistInput = {
    id?: number
    productId: number
  }

  export type WishlistItemUpdateWithoutWishlistInput = {
    product?: ProductUpdateOneRequiredWithoutWishlistItemNestedInput
  }

  export type WishlistItemUncheckedUpdateWithoutWishlistInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
  }

  export type WishlistItemUncheckedUpdateManyWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}